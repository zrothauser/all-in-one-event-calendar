diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..d15ae9c
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,31 @@
+*.pydevproject
+.project
+.metadata
+bin/**
+tmp/**
+tmp/**/*
+*.tmp
+*.bak
+*.swp
+*~.nib
+local.properties
+.classpath
+.settings/
+.loadpath
+
+# External tool builders
+.externalToolBuilders/
+
+# Locally stored "Eclipse launch configurations"
+*.launch
+
+# CDT-specific
+.cproject
+
+# PDT-specific
+.buildpath
+
+.DS_Store
+
+/app/config/constants-local.php
+/app/public/js/build.txt
\ No newline at end of file
diff --git a/app/controller/javascript.php b/app/controller/javascript.php
new file mode 100644
index 0000000..260d816
--- /dev/null
+++ b/app/controller/javascript.php
@@ -0,0 +1,471 @@
+<?php
+/**
+ * Controller that handles javascript related functions.
+ *
+ * @author     Time.ly Network Inc.
+ * @since      2.0
+ *
+ * @package    AI1EC
+ * @subpackage AI1EC.Controller
+ */
+class Ai1ec_Javascript_Controller {
+
+	// The js handle used when enqueueing
+	const JS_HANDLE = 'ai1ec_requirejs';
+	
+	// The namespace for require.js functions
+	const REQUIRE_NAMESPACE = 'timely';
+	
+	// the name of the configuration module for the frontend
+	const FRONTEND_CONFIG_MODULE = 'ai1ec_calendar';
+	
+	//the name of the get parameter we use for loading js
+	const LOAD_JS_PARAMETER = 'ai1ec_render_js';
+	
+	// just load backend scripts
+	const LOAD_ONLY_BACKEND_SCRIPTS = 'common_backend';
+	
+	// just load backend scripts
+	const LOAD_ONLY_FRONTEND_SCRIPTS = 'common_frontend';
+	
+	// Are we in the backend
+	const IS_BACKEND_PARAMETER = 'is_backend';
+	
+	// Are we on the calendar page
+	const IS_CALENDAR_PAGE = 'is_calendar_page';
+	
+	// this is the value of IS_BACKEND_PARAMETER which triggers loading of backend script
+	const TRUE_PARAM = 'true';
+	
+	// the javascript file for event page
+	const EVENT_PAGE_JS = 'event.js';
+	
+	// the javascript file for calendar page
+	const CALENDAR_PAGE_JS = 'calendar.js';
+
+	private $_registry;
+
+	/**
+	 * Holds an instance of the settings object
+	 *
+	 * @var Ai1ec_Settings
+	 */
+	private $_settings;
+	
+	/**
+	 * The event helper class
+	 *
+	 * @var Ai1ec_Events_Helper
+	 */
+	private $_time_controller;
+	
+	/**
+	 * @var Ai1ec_Locale
+	 */
+	private $_locale;
+	
+	/**
+	 * @var Ai1ec_Scripts
+	 */
+	private $_scripts_helper;
+
+	/**
+	 * @var Ai1ec_Acl_Aco
+	 */
+	private $_aco;
+
+	/**
+	 * @var Ai1ec_Post_Helper
+	 */
+	private $_post_helper;
+
+	/**
+	 * @var Ai1ec_Template_Link_Helper
+	 */
+	private $_template_link_helper;
+
+	/**
+	 * Public constructor.
+	 * 
+	 * @param Ai1ec_Object_Registry $registry
+	 * 
+	 * @return void
+	 */
+	public function __construct( Ai1ec_Object_Registry $registry ) {
+		$this->_registry             = $registry;
+		$this->_settings             = $registry->get( 'settings' );
+		$this->_locale               = $registry->get( 'locale.helper' );
+		$this->_aco                  = $registry->get( 'acl.aco' );
+		$this->_post_helper          = $registry->get( 'post.helper' );
+		$this->_template_link_helper = $registry->get( 'template.link.helper' );
+		// this will need to be modified
+		$this->_time_controller      = $registry->get( 'controller.time' );
+		$this->_scripts_helper       = $registry->get( 'script.helper' );
+	}
+
+	/**
+	 * Load javascript files for frontend pages.
+	 *
+	 * @wp-hook ai1ec_load_frontend_js
+	 *
+	 * @param $is_calendar_page boolean Whether we are displaying the main
+	 *                                  calendar page or not
+	 * 
+	 * @return void
+	 */
+	public function load_frontend_js( $is_calendar_page, $is_shortcode = false ) {
+		$page = null;
+	
+		// ======
+		// = JS =
+		// ======
+		if( $this->_are_we_accessing_the_single_event_page() === true ) {
+			$page = self::EVENT_PAGE_JS;
+		}
+		if( $is_calendar_page === true ) {
+			$page = self::CALENDAR_PAGE_JS;
+		}
+		if( null !== $page ) {
+			$this->_add_link_to_render_js( $page, false );
+		}
+	}
+	/**
+	 * Render the javascript for the appropriate page.
+	 *
+	 * @return void
+	 */
+	public function render_js() {
+		$js_path = AI1EC_ADMIN_THEME_JS_PATH . DIRECTORY_SEPARATOR;
+		$common_js = '';
+		$page_to_load = $_GET[self::LOAD_JS_PARAMETER];
+	
+		if ( $_GET[self::IS_BACKEND_PARAMETER] === self::TRUE_PARAM ) {
+			$common_js = file_get_contents( $js_path . 'pages/common_backend.js' );
+		} else if ( 
+			$page_to_load === self::EVENT_PAGE_JS ||
+			$page_to_load === self::CALENDAR_PAGE_JS ||
+			$page_to_load === self::LOAD_ONLY_FRONTEND_SCRIPTS
+		) {
+			if ( $page_to_load === self::LOAD_ONLY_FRONTEND_SCRIPTS &&
+				true === self::$frontend_scripts_loaded
+			) {
+				return;
+			}
+			if ( false === self::$frontend_scripts_loaded ) {
+				$common_js = file_get_contents( $js_path . 'pages/common_frontend.js' );
+				self::$frontend_scripts_loaded = true;
+			}
+		}
+		// create the config object for require js
+		$require_config = $this->_create_require_js_config_object();
+		// load require
+		$require = file_get_contents( $js_path . 'require.js' );
+	
+		// get jquery
+		$jquery = $this->_get_jquery_version_based_on_browser(
+				$_SERVER['HTTP_USER_AGENT']
+		);
+		// load the script for the page
+	
+		$page_js = '';
+		if ( $page_to_load !== self::LOAD_ONLY_BACKEND_SCRIPTS &&
+			$page_to_load !== self::LOAD_ONLY_FRONTEND_SCRIPTS
+		) {
+			$page_js = file_get_contents( $js_path . 'pages/' . $page_to_load );
+		}
+	
+	
+		$translation = $this->_get_frontend_translation_data();
+		$permalink = $this->_template_link_helper
+			->get_permalink( $this->_settings->calendar_page_id );
+	
+		$translation['calendar_url'] = $permalink;
+	
+		$tranlsation_module = $this->_create_require_js_module(
+				self::FRONTEND_CONFIG_MODULE,
+				$translation
+		);
+		$config = $this->_create_require_js_module(
+				'ai1ec_config',
+				$this->get_translation_data()
+		);
+		// let extensions add their files.
+		$extension_files = array();
+		$extension_files = apply_filters( 'ai1ec_render_js', $extension_files );
+		$ext_js = '';
+		foreach ( $extension_files as $file ) {
+			$ext_js .= file_get_contents( $file );
+		}
+		
+		$javascript = $require . $require_config . $tranlsation_module .
+		$config . $jquery . $page_js . $common_js . $ext_js;
+		$this->_echo_javascript( $javascript );
+	
+	}
+
+	/**
+	 * Check what file needs to be loaded and add the correct link.
+	 *
+	 * @wp-hook init
+	 * 
+	 * @return void
+	 */
+	public function load_admin_js() {
+		// Initialize dashboard view
+		if( is_admin() ) {
+			$script_to_load = FALSE;
+			// Start the scripts for the event category page
+			if( $this->_are_we_editing_event_categories() === TRUE ) {
+				// Load script required when editing categories
+				$script_to_load = 'event_category.js';
+			}
+			// Load the js needed when you edit an event / add a new event
+			if (
+				true === $this->_are_we_creating_a_new_event() ||
+				true === $this->_are_we_editing_an_event()
+			) {
+				// Load script for adding / modifying events
+				$script_to_load = 'add_new_event.js';
+			}
+			if( $this->_are_we_accessing_the_calendar_settings_page() === TRUE ) {
+				$script_to_load = 'admin_settings.js';
+			}
+	
+			if( false === $script_to_load ) {
+				$script_to_load = self::LOAD_ONLY_BACKEND_SCRIPTS;
+			}
+			$this->_add_link_to_render_js( $script_to_load, true );
+		}
+	}
+
+	/**
+	 * Loads version 1.9 or 2.0 of jQuery based on user agent.
+	 *
+	 * @param string $user_agent
+	 * 
+	 * @return string
+	 */
+	private function _get_jquery_version_based_on_browser( $user_agent ) {
+		$js_path = AI1EC_ADMIN_THEME_JS_PATH . DIRECTORY_SEPARATOR;
+		$jquery = 'jquery_timely20.js';
+		preg_match( '/MSIE (.*?);/', $user_agent, $matches );
+		if ( count( $matches ) > 1 ) {
+			//Then we're using IE
+			$version = (int) $matches[1];
+			if ( $version <= 8 ) {
+				//IE 8 or under!
+				$jquery = 'jquery_timely19.js';
+			}
+		}
+		return file_get_contents( $js_path . $jquery );
+	}
+
+	/**
+	 * Echoes the Javascript if not cached.
+	 * 
+	 * Echoes the javascript with the correct content.
+	 * Since the content is dinamic, i use the hash function.
+	 * 
+	 * @param string $javascript
+	 * 
+	 * @return void
+	 */
+	private function _echo_javascript( $javascript ) {
+		$conditional_get = new Ai1ec_HTTP_ConditionalGet( array(
+			'contentHash' => md5( $javascript )
+			)
+		);
+		$conditional_get->sendHeaders();
+		if ( ! $conditional_get->cacheIsValid ) {
+			$http_encoder = new Ai1ec_HTTP_Encoder( array(
+				'content' => $javascript,
+				'type' => 'text/javascript'
+			)
+			);
+			$http_encoder->encode();
+			$http_encoder->sendAll();
+		}
+		Ai1ec_Http_Response::stop( 0 );
+	}
+
+	/**
+	 * Creates a requirejs module that can be used for translations
+	 *
+	 * @param string $object_name
+	 * @param array $data
+	 * 
+	 * @return string
+	 */
+	private function _create_require_js_module( $object_name, array $data ) {
+		foreach ( (array) $data as $key => $value ) {
+			if ( ! is_scalar( $value ) )
+				continue;
+			$data[$key] = html_entity_decode( (string) $value, ENT_QUOTES, 'UTF-8');
+		}
+		$json_data = json_encode( $data );
+		$prefix = self::REQUIRE_NAMESPACE;
+		$script = "$prefix.define( '$object_name', $json_data );";
+	
+		return $script;
+	}
+
+	/**
+	 * Get the array with translated data for the frontend
+	 *
+	 * @return array
+	 */
+	private function _get_frontend_translation_data() {
+		$data = array(
+			'export_url' => AI1EC_EXPORT_URL,
+		);
+
+		// Replace desired CSS selector with calendar, if selector has been set
+		$calendar_selector = $this->_settings->get( 'calendar_css_selector' );
+		if( $calendar_selector ) {
+			$page             = $this->_post_helper->get_post( 
+				$this->_settings->get( 'calendar_post_id ' )
+			);
+			$data['selector'] = $calendar_selector;
+			$data['title']    = $page->post_title;
+		}
+		$data['fonts'] = array();
+		$fonts_dir = AI1EC_DEFAULT_THEME_URL . '/font_css/';
+		$data['fonts'][] = array(
+			'name' => 'League Gothic',
+			'url'  => $fonts_dir . 'font-league-gothic.css',
+		);
+		$data['fonts'][] = array(
+			'name' => 'fontawesome',
+			'url'  => $fonts_dir . 'font-awesome.css',
+		);
+		return $data;
+	}
+
+	/**
+	 * Create the config object for requirejs.
+	 *
+	 * @return string
+	 */
+	private function _create_require_js_config_object() {
+		$js_url    = AI1EC_ADMIN_THEME_JS_URL . '/';
+		$version   = AI1EC_VERSION;
+		$namespace = self::REQUIRE_NAMESPACE;
+		$config    = <<<JSC
+		$namespace.require.config( {
+			waitSeconds : 15,
+			urlArgs     : 'ver=$version',
+			baseUrl     : '$js_url'
+		} );
+JSC;
+		return $config;
+	}
+
+	/**
+	 * Add the link to render the javascript
+	 *
+	 * @param string $page
+	 * @param boolean $backend
+	 * 
+	 * @return void
+	 */
+	private function _add_link_to_render_js( $page, $backend ) {
+		$load_backend_script = 'false';
+		if ( true === $backend ) {
+			$load_backend_script = self::TRUE_PARAM;
+		}
+		$is_calendar_page = false;
+		if( true === $this->_aco->is_page( 
+				$this->_settings->get( 'calendar_page_id' )
+			)
+		) {
+			$is_calendar_page = self::TRUE_PARAM;
+		}
+		$url = $this->_template_link_helper->get_site_url() . '?' .
+				// Add the page to load
+				self::LOAD_JS_PARAMETER . '=' . $page . '&' .
+				// If we are in the backend, we must load the common scripts
+				self::IS_BACKEND_PARAMETER . '=' . $load_backend_script . '&' .
+				// If we are on the calendar page we must load the correct option
+				self::IS_CALENDAR_PAGE . '=' . $is_calendar_page;
+		if ( true === $backend ) {
+			$this->_scripts_helper->enqueue_script(
+					self::JS_HANDLE,
+					$url,
+					array( 'postbox' ),
+					true
+			);
+		} else {
+			$this->_scripts_helper->enqueue_script(
+					self::JS_HANDLE,
+					$url,
+					array(),
+					true
+			);
+		}
+	}
+
+	/**
+	 * check if we are editing an event
+	 *
+	 * @return boolean TRUE if we are editing an event FALSE otherwise
+	 */
+	private function _are_we_editing_an_event() {
+		$path_details = pathinfo( $_SERVER["SCRIPT_NAME"] );
+		$post_id = isset( $_GET['post'] ) ? $_GET['post'] : FALSE;
+		$action = isset( $_GET['action'] ) ? $_GET['action'] : FALSE;
+		if( $post_id === FALSE || $action === FALSE ) {
+			return FALSE;
+		}
+	
+		$editing = $path_details['basename']   === 'post.php' &&
+		$action                                === 'edit' &&
+		$this->_aco->get_post_type( $post_id ) === AI1EC_POST_TYPE;
+		return $editing;
+	}
+
+	/**
+	 * check if we are creating a new event
+	 *
+	 * @return boolean TRUE if we are creating a new event FALSE otherwise
+	 */
+	private function _are_we_creating_a_new_event() {
+		$path_details = pathinfo( $_SERVER["SCRIPT_NAME"] );
+		$post_type = isset( $_GET['post_type'] ) ? $_GET['post_type'] : '';
+		return $path_details['basename'] === 'post-new.php' && 
+				$post_type === AI1EC_POST_TYPE;
+	}
+
+	/**
+	 * Check if we are accessing the settings page
+	 *
+	 * @return boolean TRUE if we are accessing the settings page FALSE otherwise
+	 */
+	private function _are_we_accessing_the_calendar_settings_page() {
+		$path_details = pathinfo( $_SERVER["SCRIPT_NAME"] );
+		$page = isset( $_GET['page'] ) ? $_GET['page'] : '';
+		return $path_details['basename'] === 'edit.php' && 
+				$page === AI1EC_PLUGIN_NAME . '-settings';
+	}
+
+	
+	/**
+	 * Check if we are accessing the events category page
+	 *
+	 * @return boolean TRUE if we are accessing the events category page FALSE otherwise
+	 */
+	private function _are_we_editing_event_categories() {
+		$path_details = pathinfo( $_SERVER["SCRIPT_NAME"] );
+		$post_type = isset( $_GET['post_type'] ) ? $_GET['post_type'] : '';
+		return $path_details['basename'] === 'edit-tags.php' && $post_type === AI1EC_POST_TYPE;
+	}
+
+	/**
+	 * Check if we are accessing a single event page
+	 *
+	 * @return boolean TRUE if we are accessing a single event page FALSE otherwise
+	 */
+	private function _are_we_accessing_the_single_event_page() {
+		return $this->_aco->is_our_post_type();
+	}
+	
+}
\ No newline at end of file
diff --git a/lib/acl/aco.php b/lib/acl/aco.php
new file mode 100644
index 0000000..b3d9bbc
--- /dev/null
+++ b/lib/acl/aco.php
@@ -0,0 +1 @@
+<?php
diff --git a/lib/post/helper.php b/lib/post/helper.php
new file mode 100644
index 0000000..6966295
--- /dev/null
+++ b/lib/post/helper.php
@@ -0,0 +1,42 @@
+<?php
+/**
+ * Helper for post related wp functions.
+ *
+ * @author     Time.ly Network Inc.
+ * @since      2.0
+ *
+ * @package    AI1EC
+ * @subpackage AI1EC.Script
+ */
+class Ai1ec_Post_Helper {
+	
+	/**
+	 * Retrieves post data given a post ID or post object.
+	 *
+	 * See {@link sanitize_post()} for optional $filter values. Also, the parameter
+	 * $post, must be given as a variable, since it is passed by reference.
+	 *
+	 * @since 1.5.1
+	 * @uses $wpdb
+	 * @link http://codex.wordpress.org/Function_Reference/get_post
+	 *
+	 * @param int|object $post Post ID or post object. Optional, default is the current post from the loop.
+	 * @param string $output Optional, default is Object. Either OBJECT, ARRAY_A, or ARRAY_N.
+	 * @param string $filter Optional, default is raw.
+	 * @return WP_Post|null WP_Post on success or null on failure
+	 */
+	public function get_post( $post = null, $output = OBJECT, $filter = 'raw' ) {
+		return get_post( $post, $output, $filter );
+	}
+	 /**
+	  * Retrieve the post type of the current post or of a given post.
+	  *
+	  * @since 2.1.0
+	  *
+	  * @param int|object $post Optional. Post ID or post object. Default is the current post from the loop.
+	  * @return string|bool Post type on success, false on failure.
+	  */
+	function get_post_type( $post = null ) {
+		return get_post_type( $post );
+	 }
+}
\ No newline at end of file
diff --git a/lib/script/helper.php b/lib/script/helper.php
new file mode 100644
index 0000000..488ce2f
--- /dev/null
+++ b/lib/script/helper.php
@@ -0,0 +1,37 @@
+<?php
+/**
+ * Helper for scripts.
+ *
+ * @author     Time.ly Network Inc.
+ * @since      2.0
+ *
+ * @package    AI1EC
+ * @subpackage AI1EC.Script
+ */
+class Ai1ec_Script_Helper {
+
+	/**
+	 *
+	 * @param $name string
+	 *        Unique identifer for the script
+	 *       
+	 * @param $file string
+	 *        Filename of the script
+	 *       
+	 * @param $deps array
+	 *        Dependencies of the script
+	 *       
+	 * @param $in_footer bool
+	 *        Whether to add the script to the footer of the page
+	 *       
+	 *       
+	 * @return void
+	 *
+	 * @see Ai1ec_Scripts::enqueue_admin_script()
+	 *
+	 */
+	public function enqueue_script( $name, $file, $deps = array(), $in_footer = false ) {
+		wp_enqueue_script( $name, $file, $deps, AI1EC_VERSION, $in_footer );
+	}
+
+}
\ No newline at end of file
diff --git a/lib/template/link/helper.php b/lib/template/link/helper.php
new file mode 100644
index 0000000..fe303e4
--- /dev/null
+++ b/lib/template/link/helper.php
@@ -0,0 +1,56 @@
+<?php
+/**
+ * Helper for template links.
+ *
+ * @author     Time.ly Network Inc.
+ * @since      2.0
+ *
+ * @package    AI1EC
+ * @subpackage AI1EC.Template.Link
+ */
+class Ai1ec_Template_Link_Helper {
+	
+	/**
+	 * Retrieve the permalink for current page or page ID.
+	 *
+	 * Respects page_on_front. Use this one.
+	 *
+	 * @param int|object $post Optional. Post ID or object.
+	 * @param bool $leavename Optional, defaults to false.
+	 *                        Whether to keep page name.
+	 * @param bool $sample Optional, defaults to false. Is it a sample permalink.
+	 * 
+	 * @return string
+	 */
+	public function get_page_link( $post = false, $leavename = false, $sample = false ) {
+		return get_page_link( $post, $leavename, $sample );
+	}
+
+	/**
+	 * Get the home url respecting FORCE_SSL_ADMIN
+	 * 
+	 * @return string
+	 */
+	public function get_site_url() {
+		if (
+			is_admin() &&
+			defined( 'FORCE_SSL_ADMIN' ) &&
+			true === FORCE_SSL_ADMIN
+		) {
+			return get_home_url( null, '', 'https' );
+		}
+		return get_home_url();
+	}
+	/**
+	 * Retrieve full permalink for current post or post ID.
+	 *
+	 * @since 1.0.0
+	 *
+	 * @param int $id Optional. Post ID.
+	 * @param bool $leavename Optional, defaults to false. Whether to keep post name or page name.
+	 * @return string
+	 */
+	public function get_permalink( $id = 0, $leavename = false ) {
+		return get_permalink( $id, $leavename );
+	}
+}
\ No newline at end of file
diff --git a/public/js/async.js b/public/js/async.js
new file mode 100644
index 0000000..a03470a
--- /dev/null
+++ b/public/js/async.js
@@ -0,0 +1,8 @@
+/** @license
+ * RequireJS plugin for async dependency load like JSONP and Google Maps
+ * Author: Miller Medeiros
+ * Version: 0.1.1 (2011/11/17)
+ * Released under the MIT license
+ */
+
+timely.define([],function(){function n(e){var t,n;t=document.createElement("script"),t.type="text/javascript",t.async=!0,t.src=e,n=document.getElementsByTagName("script")[0],n.parentNode.insertBefore(t,n)}function r(t,n){var r=/!(.+)/,i=t.replace(r,""),s=r.test(t)?t.replace(/.+!/,""):e;return i+=i.indexOf("?")<0?"?":"&",i+s+"="+n}function i(){return t+=1,"__async_req_"+t+"__"}var e="callback",t=0;return{load:function(e,t,s,o){if(o.isBuild)s(null);else{var u=i();window[u]=s,n(r(e,u))}}}});
\ No newline at end of file
diff --git a/public/js/build.txt b/public/js/build.txt
new file mode 100644
index 0000000..e41772c
--- /dev/null
+++ b/public/js/build.txt
@@ -0,0 +1,333 @@
+
+pages/calendar.js
+----------------
+domReady.js
+scripts/calendar/print.js
+external_libs/jquery.masonry.js
+scripts/calendar/posterboard_view.js
+scripts/calendar/agenda_view.js
+external_libs/modernizr.js
+scripts/calendar/month_view.js
+libs/frontend_utils.js
+external_libs/bootstrap_tab.js
+libs/utils.js
+scripts/common_scripts/frontend/common_event_handlers.js
+external_libs/bootstrap_tooltip.js
+external_libs/bootstrap_popover.js
+external_libs/bootstrap_dropdown.js
+scripts/common_scripts/frontend/common_frontend.js
+external_libs/select2.js
+libs/select2_multiselect_helper.js
+external_libs/jquery_history.js
+external_libs/jquery.tablescroller.js
+external_libs/jquery.scrollTo.js
+external_libs/locales/bootstrap-datepicker.bg.js
+external_libs/locales/bootstrap-datepicker.br.js
+external_libs/locales/bootstrap-datepicker.cs.js
+external_libs/locales/bootstrap-datepicker.da.js
+external_libs/locales/bootstrap-datepicker.de.js
+external_libs/locales/bootstrap-datepicker.es.js
+external_libs/locales/bootstrap-datepicker.fi.js
+external_libs/locales/bootstrap-datepicker.fr.js
+external_libs/locales/bootstrap-datepicker.id.js
+external_libs/locales/bootstrap-datepicker.is.js
+external_libs/locales/bootstrap-datepicker.it.js
+external_libs/locales/bootstrap-datepicker.ja.js
+external_libs/locales/bootstrap-datepicker.kr.js
+external_libs/locales/bootstrap-datepicker.lt.js
+external_libs/locales/bootstrap-datepicker.lv.js
+external_libs/locales/bootstrap-datepicker.ms.js
+external_libs/locales/bootstrap-datepicker.nb.js
+external_libs/locales/bootstrap-datepicker.nl.js
+external_libs/locales/bootstrap-datepicker.pl.js
+external_libs/locales/bootstrap-datepicker.pt-BR.js
+external_libs/locales/bootstrap-datepicker.pt.js
+external_libs/locales/bootstrap-datepicker.ru.js
+external_libs/locales/bootstrap-datepicker.sl.js
+external_libs/locales/bootstrap-datepicker.sv.js
+external_libs/locales/bootstrap-datepicker.th.js
+external_libs/locales/bootstrap-datepicker.tr.js
+external_libs/locales/bootstrap-datepicker.zh-CN.js
+external_libs/locales/bootstrap-datepicker.zh-TW.js
+external_libs/bootstrap_datepicker.js
+external_libs/bootstrap_alert.js
+external_libs/jquery_cookie.js
+scripts/calendar/load_views.js
+libs/recaptcha.js
+external_libs/bootstrap_collapse.js
+libs/collapse_helper.js
+external_libs/Placeholders.js
+scripts/calendar/submit_ics_modal.js
+external_libs/jquery.debouncedresize.js
+external_libs/bootstrap_transition.js
+external_libs/bootstrap_modal.js
+libs/modal_helper.js
+scripts/calendar.js
+pages/calendar.js
+
+pages/event.js
+----------------
+domReady.js
+scripts/event/gmaps_helper.js
+external_libs/bootstrap_tab.js
+libs/utils.js
+external_libs/jquery_cookie.js
+external_libs/bootstrap_modal.js
+external_libs/bootstrap_transition.js
+external_libs/bootstrap_alert.js
+libs/modal_helper.js
+scripts/event.js
+pages/event.js
+
+pages/calendar_feeds.js
+----------------
+domReady.js
+external_libs/bootstrap_tab.js
+scripts/calendar_feeds/facebook/facebook_utility_functions.js
+libs/utils.js
+scripts/calendar_feeds/facebook/facebook_ajax_handlers.js
+external_libs/jquery_cookie.js
+scripts/calendar_feeds/facebook/facebook_event_handlers.js
+scripts/calendar_feeds/ics/ics_utility_functions.js
+scripts/calendar_feeds/ics/ics_ajax_handlers.js
+scripts/calendar_feeds/ics/ics_event_handlers.js
+scripts/calendar_feeds/file_upload/file_upload_event_handlers.js
+external_libs/select2.js
+libs/select2_multiselect_helper.js
+libs/tags_select.js
+external_libs/bootstrap_alert.js
+external_libs/bootstrap_modal.js
+libs/modal_helper.js
+scripts/calendar_feeds.js
+pages/calendar_feeds.js
+
+pages/admin_settings.js
+----------------
+domReady.js
+external_libs/bootstrap_tab.js
+libs/utils.js
+external_libs/bootstrap_collapse.js
+libs/collapse_helper.js
+external_libs/bootstrap_dropdown.js
+external_libs/locales/bootstrap-datepicker.bg.js
+external_libs/locales/bootstrap-datepicker.br.js
+external_libs/locales/bootstrap-datepicker.cs.js
+external_libs/locales/bootstrap-datepicker.da.js
+external_libs/locales/bootstrap-datepicker.de.js
+external_libs/locales/bootstrap-datepicker.es.js
+external_libs/locales/bootstrap-datepicker.fi.js
+external_libs/locales/bootstrap-datepicker.fr.js
+external_libs/locales/bootstrap-datepicker.id.js
+external_libs/locales/bootstrap-datepicker.is.js
+external_libs/locales/bootstrap-datepicker.it.js
+external_libs/locales/bootstrap-datepicker.ja.js
+external_libs/locales/bootstrap-datepicker.kr.js
+external_libs/locales/bootstrap-datepicker.lt.js
+external_libs/locales/bootstrap-datepicker.lv.js
+external_libs/locales/bootstrap-datepicker.ms.js
+external_libs/locales/bootstrap-datepicker.nb.js
+external_libs/locales/bootstrap-datepicker.nl.js
+external_libs/locales/bootstrap-datepicker.pl.js
+external_libs/locales/bootstrap-datepicker.pt-BR.js
+external_libs/locales/bootstrap-datepicker.pt.js
+external_libs/locales/bootstrap-datepicker.ru.js
+external_libs/locales/bootstrap-datepicker.sl.js
+external_libs/locales/bootstrap-datepicker.sv.js
+external_libs/locales/bootstrap-datepicker.th.js
+external_libs/locales/bootstrap-datepicker.tr.js
+external_libs/locales/bootstrap-datepicker.zh-CN.js
+external_libs/locales/bootstrap-datepicker.zh-TW.js
+external_libs/bootstrap_datepicker.js
+external_libs/bootstrap_tooltip.js
+external_libs/jquery_cookie.js
+scripts/admin_settings.js
+pages/admin_settings.js
+
+pages/add_new_event.js
+----------------
+domReady.js
+external_libs/bootstrap_tab.js
+libs/utils.js
+scripts/add_new_event/event_location/input_coordinates_utility_functions.js
+external_libs/jquery.autocomplete_geomod.js
+external_libs/geo_autocomplete.js
+scripts/add_new_event/event_location/gmaps_helper.js
+scripts/add_new_event/event_location/input_coordinates_event_handlers.js
+scripts/add_new_event/event_date_time/date_time_utility_functions.js
+external_libs/jquery.calendrical_timespan.js
+scripts/add_new_event/event_date_time/date_time_event_handlers.js
+external_libs/bootstrap_modal.js
+libs/modal_helper.js
+scripts/add_new_event/facebook_export.js
+scripts/add_new_event/event_cost_helper.js
+external_libs/jquery.inputdate.js
+external_libs/jquery.tools.js
+external_libs/jquery.blockui.js
+external_libs/ai1ec_datepicker.js
+external_libs/bootstrap_collapse.js
+scripts/add_new_event.js
+pages/add_new_event.js
+
+pages/event_category.js
+----------------
+external_libs/colorpicker.js
+domReady.js
+external_libs/tax_meta_class.js
+scripts/event_category.js
+pages/event_category.js
+
+scripts/front_end_create_event_form.js
+----------------
+domReady.js
+external_libs/bootstrap_tab.js
+libs/utils.js
+scripts/add_new_event/event_location/input_coordinates_utility_functions.js
+external_libs/jquery.autocomplete_geomod.js
+external_libs/geo_autocomplete.js
+scripts/add_new_event/event_location/gmaps_helper.js
+external_libs/select2.js
+libs/select2_multiselect_helper.js
+libs/tags_select.js
+libs/ajax_fileupload.js
+external_libs/moment.js
+external_libs/bootstrap_timepicker.js
+libs/timepicker_helper.js
+libs/recaptcha.js
+external_libs/Placeholders.js
+external_libs/locales/bootstrap-datepicker.bg.js
+external_libs/locales/bootstrap-datepicker.br.js
+external_libs/locales/bootstrap-datepicker.cs.js
+external_libs/locales/bootstrap-datepicker.da.js
+external_libs/locales/bootstrap-datepicker.de.js
+external_libs/locales/bootstrap-datepicker.es.js
+external_libs/locales/bootstrap-datepicker.fi.js
+external_libs/locales/bootstrap-datepicker.fr.js
+external_libs/locales/bootstrap-datepicker.id.js
+external_libs/locales/bootstrap-datepicker.is.js
+external_libs/locales/bootstrap-datepicker.it.js
+external_libs/locales/bootstrap-datepicker.ja.js
+external_libs/locales/bootstrap-datepicker.kr.js
+external_libs/locales/bootstrap-datepicker.lt.js
+external_libs/locales/bootstrap-datepicker.lv.js
+external_libs/locales/bootstrap-datepicker.ms.js
+external_libs/locales/bootstrap-datepicker.nb.js
+external_libs/locales/bootstrap-datepicker.nl.js
+external_libs/locales/bootstrap-datepicker.pl.js
+external_libs/locales/bootstrap-datepicker.pt-BR.js
+external_libs/locales/bootstrap-datepicker.pt.js
+external_libs/locales/bootstrap-datepicker.ru.js
+external_libs/locales/bootstrap-datepicker.sl.js
+external_libs/locales/bootstrap-datepicker.sv.js
+external_libs/locales/bootstrap-datepicker.th.js
+external_libs/locales/bootstrap-datepicker.tr.js
+external_libs/locales/bootstrap-datepicker.zh-CN.js
+external_libs/locales/bootstrap-datepicker.zh-TW.js
+external_libs/bootstrap_datepicker.js
+external_libs/bootstrap_collapse.js
+external_libs/bootstrap_alert.js
+external_libs/bootstrap_fileupload.js
+external_libs/jquery.scrollTo.js
+scripts/front_end_create_event_form.js
+
+main_widget.js
+----------------
+domReady.js
+scripts/calendar/print.js
+external_libs/jquery.masonry.js
+scripts/calendar/posterboard_view.js
+scripts/calendar/agenda_view.js
+external_libs/modernizr.js
+scripts/calendar/month_view.js
+libs/frontend_utils.js
+external_libs/bootstrap_tab.js
+libs/utils.js
+scripts/common_scripts/frontend/common_event_handlers.js
+external_libs/bootstrap_tooltip.js
+external_libs/bootstrap_popover.js
+external_libs/bootstrap_dropdown.js
+scripts/common_scripts/frontend/common_frontend.js
+external_libs/select2.js
+libs/select2_multiselect_helper.js
+external_libs/jquery_history.js
+external_libs/jquery.tablescroller.js
+external_libs/jquery.scrollTo.js
+external_libs/locales/bootstrap-datepicker.bg.js
+external_libs/locales/bootstrap-datepicker.br.js
+external_libs/locales/bootstrap-datepicker.cs.js
+external_libs/locales/bootstrap-datepicker.da.js
+external_libs/locales/bootstrap-datepicker.de.js
+external_libs/locales/bootstrap-datepicker.es.js
+external_libs/locales/bootstrap-datepicker.fi.js
+external_libs/locales/bootstrap-datepicker.fr.js
+external_libs/locales/bootstrap-datepicker.id.js
+external_libs/locales/bootstrap-datepicker.is.js
+external_libs/locales/bootstrap-datepicker.it.js
+external_libs/locales/bootstrap-datepicker.ja.js
+external_libs/locales/bootstrap-datepicker.kr.js
+external_libs/locales/bootstrap-datepicker.lt.js
+external_libs/locales/bootstrap-datepicker.lv.js
+external_libs/locales/bootstrap-datepicker.ms.js
+external_libs/locales/bootstrap-datepicker.nb.js
+external_libs/locales/bootstrap-datepicker.nl.js
+external_libs/locales/bootstrap-datepicker.pl.js
+external_libs/locales/bootstrap-datepicker.pt-BR.js
+external_libs/locales/bootstrap-datepicker.pt.js
+external_libs/locales/bootstrap-datepicker.ru.js
+external_libs/locales/bootstrap-datepicker.sl.js
+external_libs/locales/bootstrap-datepicker.sv.js
+external_libs/locales/bootstrap-datepicker.th.js
+external_libs/locales/bootstrap-datepicker.tr.js
+external_libs/locales/bootstrap-datepicker.zh-CN.js
+external_libs/locales/bootstrap-datepicker.zh-TW.js
+external_libs/bootstrap_datepicker.js
+external_libs/bootstrap_alert.js
+external_libs/jquery_cookie.js
+scripts/calendar/load_views.js
+libs/recaptcha.js
+external_libs/bootstrap_collapse.js
+libs/collapse_helper.js
+external_libs/Placeholders.js
+scripts/calendar/submit_ics_modal.js
+external_libs/jquery.debouncedresize.js
+external_libs/bootstrap_transition.js
+external_libs/bootstrap_modal.js
+libs/modal_helper.js
+scripts/calendar.js
+scripts/calendar/event.js
+main_widget.js
+
+pages/less_variables_editing.js
+----------------
+domReady.js
+external_libs/bootstrap_tab.js
+libs/utils.js
+external_libs/bootstrap_colorpicker.js
+external_libs/jquery_cookie.js
+scripts/less_variables_editing.js
+pages/less_variables_editing.js
+
+pages/common_backend.js
+----------------
+domReady.js
+scripts/common_scripts/backend/common_ajax_handlers.js
+scripts/common_scripts/backend/common_event_handlers.js
+external_libs/Placeholders.js
+external_libs/bootstrap_tooltip.js
+external_libs/bootstrap_popover.js
+external_libs/bootstrap_modal.js
+libs/modal_helper.js
+scripts/common_scripts/backend/common_backend.js
+pages/common_backend.js
+
+pages/common_frontend.js
+----------------
+domReady.js
+external_libs/jquery.masonry.js
+scripts/calendar/posterboard_view.js
+scripts/common_scripts/frontend/common_event_handlers.js
+external_libs/modernizr.js
+external_libs/bootstrap_tooltip.js
+external_libs/bootstrap_popover.js
+external_libs/bootstrap_dropdown.js
+scripts/common_scripts/frontend/common_frontend.js
+pages/common_frontend.js
diff --git a/public/js/external_libs/webfont.js b/public/js/external_libs/webfont.js
new file mode 100644
index 0000000..91141d7
--- /dev/null
+++ b/public/js/external_libs/webfont.js
@@ -0,0 +1 @@
+timely.define([],function(){(function(e,t,n){function u(e){return function(){return this[e]}}function f(e,t,n){var r=2<arguments.length?Array.prototype.slice.call(arguments,2):[];return function(){return r.push.apply(r,arguments),t.apply(e,r)}}function l(e){this.L=e,this.ca=r}function c(e,n,r){e=e.L.getElementsByTagName(n)[0],e||(e=t.documentElement),e&&e.lastChild&&e.insertBefore(r,e.lastChild)}function h(e){function n(){t.body?e():setTimeout(n,0)}n()}function p(e,t){return e.createElement("link",{rel:"stylesheet",href:t})}function d(e,t){return e.createElement("script",{src:t})}function v(e,t){for(var n=e.className.split(/\s+/),r=0,i=n.length;r<i;r++)if(n[r]==t)return;n.push(t),e.className=n.join(" ").replace(/^\s+/,"")}function m(e,t){for(var n=e.className.split(/\s+/),r=[],i=0,s=n.length;i<s;i++)n[i]!=t&&r.push(n[i]);e.className=r.join(" ").replace(/^\s+/,"").replace(/\s+$/,"")}function g(e,t){for(var n=e.className.split(/\s+/),r=0,s=n.length;r<s;r++)if(n[r]==t)return i;return o}function y(e){if(e.ca===r){var t=e.L.createElement("p");t.innerHTML='<a style="top:1px;">w</a>',e.ca=/top/.test(t.getElementsByTagName("a")[0].getAttribute("style"))}return e.ca}function b(e,t,n,r,i,s,o,u){this.Ea=e,this.Ka=t,this.ra=n,this.qa=r,this.Ha=i,this.Ga=s,this.pa=o,this.La=u}function w(e,t){this.a=e,this.k=t}function S(e){var t=N(e.a,/(iPod|iPad|iPhone|Android|Windows Phone)/,1);return""!=t?t:(e=N(e.a,/(Linux|Mac_PowerPC|Macintosh|Windows|CrOS)/,1),""!=e?("Mac_PowerPC"==e&&(e="Macintosh"),e):"Unknown")}function x(e){var t=N(e.a,/(OS X|Windows NT|Android|CrOS) ([^;)]+)/,2);return t||(t=N(e.a,/Windows Phone( OS)? ([^;)]+)/,2))?t:(t=N(e.a,/(iPhone )?OS ([\d_]+)/,2))?t:(e=N(e.a,/Linux ([i\d]+)/,1))?e:"Unknown"}function T(e){return e=N(e,/(\d+)/,1),""!=e?parseInt(e,10):-1}function N(e,t,n){return(e=e.match(t))&&e[n]?e[n]:""}function C(e){if(e.documentMode)return e.documentMode}function k(e,t,n){this.c=e,this.g=t,this.da=n,this.m="wf",this.j=new W("-")}function L(e){v(e.g,e.j.e(e.m,"loading")),O(e,"loading")}function A(e){m(e.g,e.j.e(e.m,"loading")),g(e.g,e.j.e(e.m,"active"))||v(e.g,e.j.e(e.m,"inactive")),O(e,"inactive")}function O(e,t,n,r){e.da[t]&&e.da[t](n,r)}function M(){this.ja={}}function _(e,t){var n=[],r;for(r in t)if(t.hasOwnProperty(r)){var i=e.ja[r];i&&n.push(i(t[r]))}return n}function D(e,t,n,r,i,u){this.c=t,this.H=n,this.u=r,this.A=i,this.C=u,this.V=0,"AppleWebKit"===e.W()?(e=this.c.createElement("style",s,"@font-face{font-family:'__webfontloader_test__';src:url(data:application/x-font-woff;base64,) format('woff'),url(data:font/truetype;base64,) format('truetype');}"),t=new I(this.c,this.u,"iii"),c(this.c,"head",e),q(t,"monospace"),R(t),n=t.h().width,q(t,"'__webfontloader_test__', monospace, sans-serif"),n=n!==t.h().width,e.parentNode&&e.parentNode.removeChild(e),t.remove(),e=n):e=o,this.K=e,this.ma=this.ia=o}function P(e){0==--e.V&&e.ia&&(e.ma?(e=e.H,m(e.g,e.j.e(e.m,"loading")),m(e.g,e.j.e(e.m,"inactive")),v(e.g,e.j.e(e.m,"active")),O(e,"active")):A(e.H))}function H(e,t,n,r,i,o,u,a,f,l){this.G=e,this.P=t,this.c=n,this.u=r,this.A=i,this.C=o,this.N=u,this.p=a,this.I=l||"BESbswy",this.K=f,this.S=this.R=s,this.s=new I(this.c,this.u,this.I),R(this.s),q(this.s,"arial,'URW Gothic L',sans-serif",this.p),this.Z=this.s.h(),this.t=new I(this.c,this.u,this.I),R(this.t),q(this.t,"Georgia,'Century Schoolbook L',serif",this.p),this.$=this.t.h()}function B(e,t){return!!e&&!!t&&e.width===t.width&&e.height===t.height}function j(e){e.A(function(e,t){return function(){t.call(e)}}(e,e.U),25)}function F(e,t){e.s.remove(),e.t.remove(),t(e.N,e.p)}function I(e,t,n){this.c=e,this.u=t,this.I=n,this.Da=new X,this.B=new V,this.M=this.c.createElement("span",{},this.I)}function q(e,t,n){var r=e.c,i=e.M,n=e.B.expand(n||""),e="position:absolute;top:-999px;left:-999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;font-family:"+e.Da.quote(t)+";"+n;y(r)?i.setAttribute("style",e):i.style.cssText=e}function R(e){c(e.c,"body",e.M)}function U(e,t,n,r,i){this.c=e,this.ea=t,this.g=n,this.A=r,this.a=i,this.X=this.Y=0}function z(e,t,n){n=_(e.ea,n),e.X=e.Y=n.length;for(var r=new D(e.a,e.c,t,{h:function(e){return{width:e.offsetWidth,height:e.offsetHeight}}},e.A,function(){return(new Date).getTime()}),i=0,s=n.length;i<s;i++){var o=n[i];o.F(e.a,f(e,e.za,o,t,r))}}function W(e){this.Aa=e||"-"}function X(){this.la="'"}function V(){this.Q=$,this.q=J}function K(e,t,n){this.ga=e,this.Ia=t,this.q=n}function G(e,t){this.c=e,this.d=t}function Z(e,t,n){this.o=e,this.c=t,this.d=n,this.f=[],this.w={},this.B=new V}function et(e,t,n,r,i){this.o=e,this.a=t,this.c=n,this.k=r,this.d=i,this.f=[],this.w={}}function tt(e,t,n){this.o=e,this.c=t,this.d=n,this.f=[],this.w={}}function nt(e,t){this.c=e,this.d=t}function rt(e,t,n,r,s,u,a,f,l,c){rt.Ja.call(this,e,t,n,r,s,u,a,f,l,c),e=["Times New Roman","Arial","Times","Sans","Serif"],t=e.length,n={},r=new I(this.c,this.u,this.I),R(r),q(r,e[0],this.p),n[r.h().width]=i;for(s=1;s<t;s++)u=e[s],q(r,u,this.p),n[r.h().width]=i,"4"!=this.p[1]&&(q(r,u,this.p[0]+"4"),n[r.h().width]=i);r.remove(),this.z=n,this.oa=o,this.Ba=this.Z,this.Ca=this.$}function st(t){this.T=t?t:("https:"==e.location.protocol?"https:":"http:")+ot,this.f=[],this.ba=[]}function ut(e){this.f=e,this.ka=[],this.na={},this.O={},this.B=new V}function ht(e,t,n){this.a=e,this.c=t,this.d=n}var r=void 0,i=!0,s=null,o=!1,a;l.prototype.createElement=function(e,t,n){e=this.L.createElement(e);if(t)for(var r in t)if(t.hasOwnProperty(r))if("style"==r){var i=e,s=t[r];y(this)?i.setAttribute("style",s):i.style.cssText=s}else e.setAttribute(r,t[r]);return n&&e.appendChild(this.L.createTextNode(n)),e},a=b.prototype,a.getName=u("Ea"),a.ya=u("Ka"),a.W=u("ra"),a.va=u("qa"),a.wa=u("Ha"),a.xa=u("Ga"),a.ua=u("pa"),a.D=u("La");var E=new b("Unknown","Unknown","Unknown","Unknown","Unknown","Unknown",r,o);w.prototype.parse=function(){var e;if(-1!=this.a.indexOf("MSIE")){e=S(this);var t=x(this),n=N(this.a,/(MSIE [\d\w\.]+)/,1);if(""!=n){var r=n.split(" "),n=r[0],r=r[1],i=T(r),u=T(t);e=new b(n,r,n,r,e,t,C(this.k),"Windows"==e&&6<=i||"Windows Phone"==e&&8<=u)}else e=new b("MSIE","Unknown","MSIE","Unknown",e,t,C(this.k),o)}else if(-1!=this.a.indexOf("Opera"))e:if(t=e="Unknown",n=N(this.a,/(Presto\/[\d\w\.]+)/,1),""!=n?(t=n.split("/"),e=t[0],t=t[1]):(-1!=this.a.indexOf("Gecko")&&(e="Gecko"),n=N(this.a,/rv:([^\)]+)/,1),""!=n&&(t=n)),-1!=this.a.indexOf("Opera Mini/"))n=N(this.a,/Opera Mini\/([\d\.]+)/,1),""==n&&(n="Unknown"),e=new b("OperaMini",n,e,t,S(this),x(this),C(this.k),o);else{if(-1!=this.a.indexOf("Version/")&&(n=N(this.a,/Version\/([\d\.]+)/,1),""!=n)){e=new b("Opera",n,e,t,S(this),x(this),C(this.k),10<=T(n));break e}n=N(this.a,/Opera[\/ ]([\d\.]+)/,1),e=""!=n?new b("Opera",n,e,t,S(this),x(this),C(this.k),10<=T(n)):new b("Opera","Unknown",e,t,S(this),x(this),C(this.k),o)}else-1!=this.a.indexOf("AppleWebKit")?(e=S(this),t=x(this),n=N(this.a,/AppleWebKit\/([\d\.\+]+)/,1),""==n&&(n="Unknown"),r="Unknown",-1!=this.a.indexOf("Chrome")||-1!=this.a.indexOf("CrMo")||-1!=this.a.indexOf("CriOS")?r="Chrome":-1!=this.a.indexOf("Safari")?r="Safari":-1!=this.a.indexOf("AdobeAIR")&&(r="AdobeAIR"),i="Unknown",-1!=this.a.indexOf("Version/")?i=N(this.a,/Version\/([\d\.\w]+)/,1):"Chrome"==r?i=N(this.a,/(Chrome|CrMo|CriOS)\/([\d\.]+)/,2):"AdobeAIR"==r&&(i=N(this.a,/AdobeAIR\/([\d\.]+)/,1)),u=o,"AdobeAIR"==r?(u=N(i,/\d+\.(\d+)/,1),u=2<T(i)||2==T(i)&&5<=parseInt(u,10)):(u=N(n,/\d+\.(\d+)/,1),u=526<=T(n)||525<=T(n)&&13<=parseInt(u,10)),e=new b(r,i,"AppleWebKit",n,e,t,C(this.k),u)):-1!=this.a.indexOf("Gecko")?(t=e="Unknown",r=o,-1!=this.a.indexOf("Firefox")?(e="Firefox",n=N(this.a,/Firefox\/([\d\w\.]+)/,1),""!=n&&(r=N(n,/\d+\.(\d+)/,1),t=n,r=""!=n&&3<=T(n)&&5<=parseInt(r,10))):-1!=this.a.indexOf("Mozilla")&&(e="Mozilla"),n=N(this.a,/rv:([^\)]+)/,1),""==n?n="Unknown":r||(r=T(n),i=parseInt(N(n,/\d+\.(\d+)/,1),10),u=parseInt(N(n,/\d+\.\d+\.(\d+)/,1),10),r=1<r||1==r&&9<i||1==r&&9==i&&2<=u||n.match(/1\.9\.1b[123]/)!=s||n.match(/1\.9\.1\.[\d\.]+/)!=s),e=new b(e,t,"Gecko",n,S(this),x(this),C(this.k),r)):e=E;return e},D.prototype.watch=function(e,t,n,r,i){for(var s=e.length,o=0;o<s;o++){var u=e[o];t[u]||(t[u]=["n4"]),this.V+=t[u].length}i&&(this.ia=i);for(o=0;o<s;o++)for(var u=e[o],i=t[u],a=n[u],l=0,c=i.length;l<c;l++){var h=i[l],p=this.H,d=u,m=h;v(p.g,p.j.e(p.m,d,m,"loading")),O(p,"fontloading",d,m),p=f(this,this.sa),d=f(this,this.ta),(new r(p,d,this.c,this.u,this.A,this.C,u,h,this.K,a)).start()}},D.prototype.sa=function(e,t){var n=this.H;m(n.g,n.j.e(n.m,e,t,"loading")),m(n.g,n.j.e(n.m,e,t,"inactive")),v(n.g,n.j.e(n.m,e,t,"active")),O(n,"fontactive",e,t),this.ma=i,P(this)},D.prototype.ta=function(e,t){var n=this.H;m(n.g,n.j.e(n.m,e,t,"loading")),g(n.g,n.j.e(n.m,e,t,"active"))||v(n.g,n.j.e(n.m,e,t,"inactive")),O(n,"fontinactive",e,t),P(this)},H.prototype.start=function(){this.aa=this.C(),q(this.s,this.N+",arial,'URW Gothic L',sans-serif",this.p),this.K&&(this.R=this.s.h()),q(this.t,this.N+",Georgia,'Century Schoolbook L',serif",this.p),this.K&&(this.S=this.t.h()),this.U()},H.prototype.U=function(){var e=this.s.h(),t=this.t.h();this.K?this.R&&this.S?5e3<=this.C()-this.aa?B(e,this.R)&&B(t,this.S)?F(this,this.G):F(this,this.P):B(e,this.R)&&B(t,this.S)?j(this):B(e,this.Z)&&B(t,this.$)?F(this,this.P):F(this,this.G):j(this):5e3<=this.C()-this.aa?F(this,this.P):B(e,this.Z)&&B(t,this.$)?j(this):F(this,this.G)},I.prototype.h=function(){return this.u.h(this.M)},I.prototype.remove=function(){var e=this.M;e.parentNode&&e.parentNode.removeChild(e)},U.prototype.v=function(e,t){this.ea.ja[e]=t},U.prototype.load=function(e){var t=new k(this.c,this.g,e);this.a.D()?z(this,t,e):A(t)},U.prototype.za=function(e,t,n,r){var i=e.fa?e.fa():H;r?e.load(f(this,this.Fa,t,n,i)):(e=0==--this.Y,this.X--,e&&(0==this.X?A(t):L(t)),n.watch([],{},{},i,e))},U.prototype.Fa=function(e,t,n,r,i,s){var o=0==--this.Y;o&&L(e),this.A(f(this,function(e,t,n,r,i,s){e.watch(t,n||{},r||{},i,s)},t,r,i,s,n,o))},W.prototype.e=function(e){for(var t=[],n=0;n<arguments.length;n++)t.push(arguments[n].replace(/[\W_]+/g,"").toLowerCase());return t.join(this.Aa)},X.prototype.quote=function(e){for(var t=[],e=e.split(/,\s*/),n=0;n<e.length;n++){var r=e[n].replace(/['"]/g,"");-1==r.indexOf(" ")?t.push(r):t.push(this.la+r+this.la)}return t.join(",")};var $=["font-style","font-weight"],J={"font-style":[["n","normal"],["i","italic"],["o","oblique"]],"font-weight":[["1","100"],["2","200"],["3","300"],["4","400"],["5","500"],["6","600"],["7","700"],["8","800"],["9","900"],["4","normal"],["7","bold"]]};K.prototype.compact=function(e,t){for(var n=0;n<this.q.length;n++)if(t==this.q[n][1]){e[this.ga]=this.q[n][0];break}},K.prototype.expand=function(e,t){for(var n=0;n<this.q.length;n++)if(t==this.q[n][0]){e[this.ga]=this.Ia+":"+this.q[n][1];break}},V.prototype.compact=function(e){for(var t=["n","4"],e=e.split(";"),n=0,r=e.length;n<r;n++){var i=e[n].replace(/\s+/g,"").split(":");if(2==i.length){var o=i[1];e:{for(var i=i[0],u=0;u<this.Q.length;u++)if(i==this.Q[u]){i=new K(u,i,this.q[i]);break e}i=s}i&&i.compact(t,o)}}return t.join("")},V.prototype.expand=function(e){if(2!=e.length)return s;for(var t=[s,s],n=0,r=this.Q.length;n<r;n++){var i=this.Q[n];(new K(n,i,this.q[i])).expand(t,e.substr(n,1))}return t[0]&&t[1]?t.join(";")+";":s};var Q=e.WebFont=function(){var e=(new w(navigator.userAgent,t)).parse();return new U(new l(t),new M,t.documentElement,function(e,t){setTimeout(e,t)},e)}();Q.load=Q.load,Q.addModule=Q.v,b.prototype.getName=b.prototype.getName,b.prototype.getVersion=b.prototype.ya,b.prototype.getEngine=b.prototype.W,b.prototype.getEngineVersion=b.prototype.va,b.prototype.getPlatform=b.prototype.wa,b.prototype.getPlatformVersion=b.prototype.xa,b.prototype.getDocumentMode=b.prototype.ua,b.prototype.isSupportingWebFont=b.prototype.D;var Y={regular:"n4",bold:"n7",italic:"i4",bolditalic:"i7",r:"n4",b:"n7",i:"i4",bi:"i7"};G.prototype.F=function(e,t){return t(e.D())},G.prototype.load=function(e){var n,i;c(this.c,"head",p(this.c,("https:"==t.location.protocol?"https:":"http:")+"//webfonts.fontslive.com/css/"+this.d.key+".css"));var s=this.d.families,o,u;o=[],u={};for(var a=0,f=s.length;a<f;a++){i=i=n=r,i=s[a].split(":"),n=i[0];if(i[1]){i=i[1].split(",");for(var l=[],h=0,d=i.length;h<d;h++){var v=i[h];if(v){var m=Y[v];l.push(m?m:v)}}i=l}else i=["n4"];o.push(n),u[n]=i}e(o,u)},Q.v("ascender",function(e){return new G(new l(t),e)}),Z.prototype.J=function(e){return("https:"==this.o.location.protocol?"https:":"http:")+(this.d.api||"//f.fontdeck.com/s/css/js/")+this.o.document.location.hostname+"/"+e+".js"},Z.prototype.F=function(e,t){var n=this.d.id,r=this;n?(this.o.__webfontfontdeckmodule__||(this.o.__webfontfontdeckmodule__={}),this.o.__webfontfontdeckmodule__[n]=function(e,n){for(var i=0,s=n.fonts.length;i<s;++i){var o=n.fonts[i];r.f.push(o.name),r.w[o.name]=[r.B.compact("font-weight:"+o.weight+";font-style:"+o.style)]}t(e)},c(this.c,"head",d(this.c,this.J(n)))):t(i)},Z.prototype.load=function(e){e(this.f,this.w)},Q.v("fontdeck",function(n){return new Z(e,new l(t),n)}),et.prototype.F=function(e,t){var n=this,r=n.d.projectId;if(r){var o=d(n.c,n.J(r));o.id="__MonotypeAPIScript__"+r,o.onreadystatechange=function(e){if("loaded"===o.readyState||"complete"===o.readyState)o.onreadystatechange=s,o.onload(e)},o.onload=function(){if(n.o["__mti_fntLst"+r]){var i=n.o["__mti_fntLst"+r]();if(i&&i.length){var s;for(s=0;s<i.length;s++)n.f.push(i[s].fontfamily)}}t(e.D())},c(this.c,"head",o)}else t(i)},et.prototype.J=function(e){var t=this.protocol(),n=(this.d.api||"fast.fonts.com/jsapi").replace(/^.*http(s?):(\/\/)?/,"");return t+"//"+n+"/"+e+".js"},et.prototype.load=function(e){e(this.f,this.w)},et.prototype.protocol=function(){var e=["http:","https:"],t=e[0];if(this.k&&this.k.location&&this.k.location.protocol)for(var n=0,n=0;n<e.length;n++)if(this.k.location.protocol===e[n])return this.k.location.protocol;return t},Q.v("monotype",function(n){var r=(new w(navigator.userAgent,t)).parse();return new et(e,r,new l(t),t,n)}),tt.prototype.J=function(t){var n="https:"==e.location.protocol?"https:":"http:";return(this.d.api||n+"//use.typekit.com")+"/"+t+".js"},tt.prototype.F=function(e,t){var n=this.d.id,r=this.d,s=this;n?(this.o.__webfonttypekitmodule__||(this.o.__webfonttypekitmodule__={}),this.o.__webfonttypekitmodule__[n]=function(n){n(e,r,function(e,n,r){s.f=n,s.w=r,t(e)})},c(this.c,"head",d(this.c,this.J(n)))):t(i)},tt.prototype.load=function(e){e(this.f,this.w)},Q.v("typekit",function(n){return new tt(e,new l(t),n)}),nt.prototype.load=function(e){for(var t=this.d.urls||[],n=this.d.families||[],r=0,i=t.length;r<i;r++)c(this.c,"head",p(this.c,t[r]));e(n)},nt.prototype.F=function(e,t){return t(e.D())},Q.v("custom",function(e){return new nt(new l(t),e)}),function(e,t){function n(){}n.prototype=e.prototype,t.prototype=new n,t.Ja=e,t.Ma=e.prototype}(H,rt);var it={Arimo:i,Cousine:i,Tinos:i};rt.prototype.U=function(){var e=this.s.h(),t=this.t.h();!this.oa&&e.width==t.width&&this.z[e.width]&&(this.z={},this.oa=this.z[e.width]=i),(this.Ba.width!=e.width||this.Ca.width!=t.width)&&!this.z[e.width]&&!this.z[t.width]?F(this,this.G):5e3<=this.C()-this.aa?this.z[e.width]&&this.z[t.width]&&it[this.N]?F(this,this.G):F(this,this.P):j(this)};var ot="//fonts.googleapis.com/css";st.prototype.e=function(){if(0==this.f.length)throw Error("No fonts to load !");if(-1!=this.T.indexOf("kit="))return this.T;for(var e=this.f.length,t=[],n=0;n<e;n++)t.push(this.f[n].replace(/ /g,"+"));return e=this.T+"?family="+t.join("%7C"),0<this.ba.length&&(e+="&subset="+this.ba.join(",")),e};var at={latin:"BESbswy",cyrillic:"&#1081;&#1103;&#1046;",greek:"&#945;&#946;&#931;",khmer:"&#x1780;&#x1781;&#x1782;",Hanuman:"&#x1780;&#x1781;&#x1782;"},ft={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},lt={i:"i",italic:"i",n:"n",normal:"n"},ct=RegExp("^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$");ut.prototype.parse=function(){for(var e=this.f.length,t=0;t<e;t++){var n=this.f[t].split(":"),i=n[0].replace(/\+/g," "),o=["n4"];if(2<=n.length){var u,a=n[1];u=[];if(a)for(var a=a.split(","),f=a.length,l=0;l<f;l++){var c;c=a[l];if(c.match(/^[\w]+$/))if(c=ct.exec(c.toLowerCase()),c==s)c="";else{var h=r;h=c[1];if(h==s)h="4";else var p=ft[h],h=p?p:isNaN(h)?"4":h.substr(0,1);c=(c=this.B.expand([c[2]==s?"n":lt[c[2]],h].join("")))?this.B.compact(c):s}else c="";c&&u.push(c)}0<u.length&&(o=u),3==n.length&&(n=n[2],u=[],n=n?n.split(","):u,0<n.length&&(n=at[n[0]])&&(this.O[i]=n))}this.O[i]||(n=at[i])&&(this.O[i]=n),this.ka.push(i),this.na[i]=o}},ht.prototype.F=function(e,t){t(e.D())},ht.prototype.fa=function(){return"AppleWebKit"==this.a.W()?rt:H},ht.prototype.load=function(e){"MSIE"==this.a.getName()&&this.d.blocking!=i?h(f(this,this.ha,e)):this.ha(e)},ht.prototype.ha=function(e){for(var t=this.c,n=new st(this.d.api),r=this.d.families,i=r.length,s=0;s<i;s++){var o=r[s].split(":");3==o.length&&n.ba.push(o.pop());var u="";2==o.length&&""!=o[1]&&(u=":"),n.f.push(o.join(u))}r=new ut(r),r.parse(),c(t,"head",p(t,n.e())),e(r.ka,r.na,r.O)},Q.v("google",function(e){var n=(new w(navigator.userAgent,t)).parse();return new ht(n,new l(t),e)}),e.WebFontConfig&&Q.load(e.WebFontConfig)})(this,document)});
\ No newline at end of file
diff --git a/public/js/jquery_timely19.js b/public/js/jquery_timely19.js
new file mode 100644
index 0000000..44ba7c3
--- /dev/null
+++ b/public/js/jquery_timely19.js
@@ -0,0 +1,22 @@
+/*!
+	 * jQuery JavaScript Library v1.9.1
+	 * http://jquery.com/
+	 *
+	 * Includes Sizzle.js
+	 * http://sizzlejs.com/
+	 *
+	 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors
+	 * Released under the MIT license
+	 * http://jquery.org/license
+	 *
+	 * Date: 2013-2-4
+	 */
+
+/*!
+	 * Sizzle CSS Selector Engine
+	 * Copyright 2012 jQuery Foundation and other contributors
+	 * Released under the MIT license
+	 * http://sizzlejs.com/
+	 */
+
+timely.define("jquery_timely",[],function(){return function(e,t){function P(e){var t=e.length,n=b.type(e);return b.isWindow(e)?!1:e.nodeType===1&&t?!0:n==="array"||n!=="function"&&(t===0||typeof t=="number"&&t>0&&t-1 in e)}function B(e){var t=H[e]={};return b.each(e.match(E)||[],function(e,n){t[n]=!0}),t}function I(e,n,r,i){if(!b.acceptData(e))return;var s,o,u=b.expando,a=typeof n=="string",f=e.nodeType,c=f?b.cache:e,h=f?e[u]:e[u]&&u;if((!h||!c[h]||!i&&!c[h].data)&&a&&r===t)return;h||(f?e[u]=h=l.pop()||b.guid++:h=u),c[h]||(c[h]={},f||(c[h].toJSON=b.noop));if(typeof n=="object"||typeof n=="function")i?c[h]=b.extend(c[h],n):c[h].data=b.extend(c[h].data,n);return s=c[h],i||(s.data||(s.data={}),s=s.data),r!==t&&(s[b.camelCase(n)]=r),a?(o=s[n],o==null&&(o=s[b.camelCase(n)])):o=s,o}function q(e,t,n){if(!b.acceptData(e))return;var r,i,s,o=e.nodeType,u=o?b.cache:e,a=o?e[b.expando]:b.expando;if(!u[a])return;if(t){s=n?u[a]:u[a].data;if(s){b.isArray(t)?t=t.concat(b.map(t,b.camelCase)):t in s?t=[t]:(t=b.camelCase(t),t in s?t=[t]:t=t.split(" "));for(r=0,i=t.length;r<i;r++)delete s[t[r]];if(!(n?U:b.isEmptyObject)(s))return}}if(!n){delete u[a].data;if(!U(u[a]))return}o?b.cleanData([e],!0):b.support.deleteExpando||u!=u.window?delete u[a]:u[a]=null}function R(e,n,r){if(r===t&&e.nodeType===1){var i="data-"+n.replace(F,"-$1").toLowerCase();r=e.getAttribute(i);if(typeof r=="string"){try{r=r==="true"?!0:r==="false"?!1:r==="null"?null:+r+""===r?+r:j.test(r)?b.parseJSON(r):r}catch(s){}b.data(e,n,r)}else r=t}return r}function U(e){var t;for(t in e){if(t==="data"&&b.isEmptyObject(e[t]))continue;if(t!=="toJSON")return!1}return!0}function it(){return!0}function st(){return!1}function ct(e,t){do e=e[t];while(e&&e.nodeType!==1);return e}function ht(e,t,n){t=t||0;if(b.isFunction(t))return b.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return b.grep(e,function(e){return e===t===n});if(typeof t=="string"){var r=b.grep(e,function(e){return e.nodeType===1});if(at.test(t))return b.filter(t,r,!n);t=b.filter(t,r)}return b.grep(e,function(e){return b.inArray(e,t)>=0===n})}function pt(e){var t=dt.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}function Mt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function _t(e){var t=e.getAttributeNode("type");return e.type=(t&&t.specified)+"/"+e.type,e}function Dt(e){var t=Ct.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function Pt(e,t){var n,r=0;for(;(n=e[r])!=null;r++)b._data(n,"globalEval",!t||b._data(t[r],"globalEval"))}function Ht(e,t){if(t.nodeType!==1||!b.hasData(e))return;var n,r,i,s=b._data(e),o=b._data(t,s),u=s.events;if(u){delete o.handle,o.events={};for(n in u)for(r=0,i=u[n].length;r<i;r++)b.event.add(t,n,u[n][r])}o.data&&(o.data=b.extend({},o.data))}function Bt(e,t){var n,r,i;if(t.nodeType!==1)return;n=t.nodeName.toLowerCase();if(!b.support.noCloneEvent&&t[b.expando]){i=b._data(t);for(r in i.events)b.removeEvent(t,r,i.handle);t.removeAttribute(b.expando)}if(n==="script"&&t.text!==e.text)_t(t).text=e.text,Dt(t);else if(n==="object")t.parentNode&&(t.outerHTML=e.outerHTML),b.support.html5Clone&&e.innerHTML&&!b.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML);else if(n==="input"&&xt.test(e.type))t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value);else if(n==="option")t.defaultSelected=t.selected=e.defaultSelected;else if(n==="input"||n==="textarea")t.defaultValue=e.defaultValue}function jt(e,n){var r,s,o=0,u=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!u)for(u=[],r=e.childNodes||e;(s=r[o])!=null;o++)!n||b.nodeName(s,n)?u.push(s):b.merge(u,jt(s,n));return n===t||n&&b.nodeName(e,n)?b.merge([e],u):u}function Ft(e){xt.test(e.type)&&(e.defaultChecked=e.checked)}function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--){t=en[i]+n;if(t in e)return t}return r}function nn(e,t){return e=t||e,b.css(e,"display")==="none"||!b.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,s=[],o=0,u=e.length;for(;o<u;o++){r=e[o];if(!r.style)continue;s[o]=b._data(r,"olddisplay"),n=r.style.display,t?(!s[o]&&n==="none"&&(r.style.display=""),r.style.display===""&&nn(r)&&(s[o]=b._data(r,"olddisplay",an(r.nodeName)))):s[o]||(i=nn(r),(n&&n!=="none"||!i)&&b._data(r,"olddisplay",i?n:b.css(r,"display")))}for(o=0;o<u;o++){r=e[o];if(!r.style)continue;if(!t||r.style.display==="none"||r.style.display==="")r.style.display=t?s[o]||"":"none"}return e}function sn(e,t,n){var r=$t.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function on(e,t,n,r,i){var s=n===(r?"border":"content")?4:t==="width"?1:0,o=0;for(;s<4;s+=2)n==="margin"&&(o+=b.css(e,n+Zt[s],!0,i)),r?(n==="content"&&(o-=b.css(e,"padding"+Zt[s],!0,i)),n!=="margin"&&(o-=b.css(e,"border"+Zt[s]+"Width",!0,i))):(o+=b.css(e,"padding"+Zt[s],!0,i),n!=="padding"&&(o+=b.css(e,"border"+Zt[s]+"Width",!0,i)));return o}function un(e,t,n){var r=!0,i=t==="width"?e.offsetWidth:e.offsetHeight,s=qt(e),o=b.support.boxSizing&&b.css(e,"boxSizing",!1,s)==="border-box";if(i<=0||i==null){i=Rt(e,t,s);if(i<0||i==null)i=e.style[t];if(Jt.test(i))return i;r=o&&(b.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+on(e,t,n||(o?"border":"content"),r,s)+"px"}function an(e){var t=s,n=Qt[e];if(!n){n=fn(e,t);if(n==="none"||!n)It=(It||b("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(It[0].contentWindow||It[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=fn(e,t),It.detach();Qt[e]=n}return n}function fn(e,t){var n=b(t.createElement(e)).appendTo(t.body),r=b.css(n[0],"display");return n.remove(),r}function vn(e,t,n,r){var i;if(b.isArray(t))b.each(t,function(t,i){n||cn.test(e)?r(e,i):vn(e+"["+(typeof i=="object"?t:"")+"]",i,n,r)});else if(!n&&b.type(t)==="object")for(i in t)vn(e+"["+i+"]",t[i],n,r);else r(e,t)}function _n(e){return function(t,n){typeof t!="string"&&(n=t,t="*");var r,i=0,s=t.toLowerCase().match(E)||[];if(b.isFunction(n))while(r=s[i++])r[0]==="+"?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function Dn(e,t,n,r){function o(u){var a;return i[u]=!0,b.each(e[u]||[],function(e,u){var f=u(t,n,r);if(typeof f=="string"&&!s&&!i[f])return t.dataTypes.unshift(f),o(f),!1;if(s)return!(a=f)}),a}var i={},s=e===An;return o(t.dataTypes[0])||!i["*"]&&o("*")}function Pn(e,n){var r,i,s=b.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((s[i]?e:r||(r={}))[i]=n[i]);return r&&b.extend(!0,e,r),e}function Hn(e,n,r){var i,s,o,u,a=e.contents,f=e.dataTypes,l=e.responseFields;for(u in l)u in r&&(n[l[u]]=r[u]);while(f[0]==="*")f.shift(),s===t&&(s=e.mimeType||n.getResponseHeader("Content-Type"));if(s)for(u in a)if(a[u]&&a[u].test(s)){f.unshift(u);break}if(f[0]in r)o=f[0];else{for(u in r){if(!f[0]||e.converters[u+" "+f[0]]){o=u;break}i||(i=u)}o=o||i}if(o)return o!==f[0]&&f.unshift(o),r[o]}function Bn(e,t){var n,r,i,s,o={},u=0,a=e.dataTypes.slice(),f=a[0];e.dataFilter&&(t=e.dataFilter(t,e.dataType));if(a[1])for(i in e.converters)o[i.toLowerCase()]=e.converters[i];for(;r=a[++u];)if(r!=="*"){if(f!=="*"&&f!==r){i=o[f+" "+r]||o["* "+r];if(!i)for(n in o){s=n.split(" ");if(s[1]===r){i=o[f+" "+s[0]]||o["* "+s[0]];if(i){i===!0?i=o[n]:o[n]!==!0&&(r=s[0],a.splice(u--,0,r));break}}}if(i!==!0)if(i&&e["throws"])t=i(t);else try{t=i(t)}catch(l){return{state:"parsererror",error:i?l:"No conversion from "+f+" to "+r}}}f=r}return{state:"success",data:t}}function zn(){try{return new e.XMLHttpRequest}catch(t){}}function Wn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}function Yn(){return setTimeout(function(){Xn=t}),Xn=b.now()}function Zn(e,t){b.each(t,function(t,n){var r=(Gn[t]||[]).concat(Gn["*"]),i=0,s=r.length;for(;i<s;i++)if(r[i].call(e,t,n))return})}function er(e,t,n){var r,i,s=0,o=Qn.length,u=b.Deferred().always(function(){delete a.elem}),a=function(){if(i)return!1;var t=Xn||Yn(),n=Math.max(0,f.startTime+f.duration-t),r=n/f.duration||0,s=1-r,o=0,a=f.tweens.length;for(;o<a;o++)f.tweens[o].run(s);return u.notifyWith(e,[f,s,n]),s<1&&a?n:(u.resolveWith(e,[f]),!1)},f=u.promise({elem:e,props:b.extend({},t),opts:b.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Yn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=b.Tween(e,f.opts,t,n,f.opts.specialEasing[t]||f.opts.easing);return f.tweens.push(r),r},stop:function(t){var n=0,r=t?f.tweens.length:0;if(i)return this;i=!0;for(;n<r;n++)f.tweens[n].run(1);return t?u.resolveWith(e,[f,t]):u.rejectWith(e,[f,t]),this}}),l=f.props;tr(l,f.opts.specialEasing);for(;s<o;s++){r=Qn[s].call(f,e,l,f.opts);if(r)return r}return Zn(f,l),b.isFunction(f.opts.start)&&f.opts.start.call(e,f),b.fx.timer(b.extend(a,{elem:e,anim:f,queue:f.opts.queue})),f.progress(f.opts.progress).done(f.opts.done,f.opts.complete).fail(f.opts.fail).always(f.opts.always)}function tr(e,t){var n,r,i,s,o;for(i in e){r=b.camelCase(i),s=t[r],n=e[i],b.isArray(n)&&(s=n[1],n=e[i]=n[0]),i!==r&&(e[r]=n,delete e[i]),o=b.cssHooks[r];if(o&&"expand"in o){n=o.expand(n),delete e[r];for(i in n)i in e||(e[i]=n[i],t[i]=s)}else t[r]=s}}function nr(e,t,n){var r,i,s,o,u,a,f,l,c,h=this,p=e.style,d={},v=[],m=e.nodeType&&nn(e);n.queue||(l=b._queueHooks(e,"fx"),l.unqueued==null&&(l.unqueued=0,c=l.empty.fire,l.empty.fire=function(){l.unqueued||c()}),l.unqueued++,h.always(function(){h.always(function(){l.unqueued--,b.queue(e,"fx").length||l.empty.fire()})})),e.nodeType===1&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],b.css(e,"display")==="inline"&&b.css(e,"float")==="none"&&(!b.support.inlineBlockNeedsLayout||an(e.nodeName)==="inline"?p.display="inline-block":p.zoom=1)),n.overflow&&(p.overflow="hidden",b.support.shrinkWrapBlocks||h.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(i in t){o=t[i];if($n.exec(o)){delete t[i],a=a||o==="toggle";if(o===(m?"hide":"show"))continue;v.push(i)}}s=v.length;if(s){u=b._data(e,"fxshow")||b._data(e,"fxshow",{}),"hidden"in u&&(m=u.hidden),a&&(u.hidden=!m),m?b(e).show():h.done(function(){b(e).hide()}),h.done(function(){var t;b._removeData(e,"fxshow");for(t in d)b.style(e,t,d[t])});for(i=0;i<s;i++)r=v[i],f=h.createTween(r,m?u[r]:0),d[r]=u[r]||b.style(e,r),r in u||(u[r]=f.start,m&&(f.end=f.start,f.start=r==="width"||r==="height"?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}function ir(e,t){var n,r={height:e},i=0;t=t?1:0;for(;i<4;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}function sr(e){return b.isWindow(e)?e:e.nodeType===9?e.defaultView||e.parentWindow:!1}var n,r,i=typeof t,s=e.document,o=e.location,u=e.jQuery,a=e.$,f={},l=[],c="1.9.1-ai1ec",h=l.concat,p=l.push,d=l.slice,v=l.indexOf,m=f.toString,g=f.hasOwnProperty,y=c.trim,b=function(e,t){return new b.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,E=/\S+/g,S=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,x=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,T=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,N=/^[\],:{}\s]*$/,C=/(?:^|:|,)(?:\s*\[)+/g,k=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,L=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,A=/^-ms-/,O=/-([\da-z])/gi,M=function(e,t){return t.toUpperCase()},_=function(e){if(s.addEventListener||e.type==="load"||s.readyState==="complete")D(),b.ready()},D=function(){s.addEventListener?(s.removeEventListener("DOMContentLoaded",_,!1),e.removeEventListener("load",_,!1)):(s.detachEvent("onreadystatechange",_),e.detachEvent("onload",_))};b.fn=b.prototype={jquery:c,constructor:b,init:function(e,n,r){var i,o;if(!e)return this;if(typeof e=="string"){e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3?i=[null,e,null]:i=x.exec(e);if(i&&(i[1]||!n)){if(i[1]){n=n instanceof b?n[0]:n,b.merge(this,b.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:s,!0));if(T.test(i[1])&&b.isPlainObject(n))for(i in n)b.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}o=s.getElementById(i[2]);if(o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=s,this.selector=e,this}return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e)}return e.nodeType?(this.context=this[0]=e,this.length=1,this):b.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),b.makeArray(e,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return d.call(this)},get:function(e){return e==null?this.toArray():e<0?this[this.length+e]:this[e]},pushStack:function(e){var t=b.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return b.each(this,e,t)},ready:function(e){return b.ready.promise().done(e),this},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},map:function(e){return this.pushStack(b.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:p,sort:[].sort,splice:[].splice},b.fn.init.prototype=b.fn,b.extend=b.fn.extend=function(){var e,n,r,i,s,o,u=arguments[0]||{},a=1,f=arguments.length,l=!1;typeof u=="boolean"&&(l=u,u=arguments[1]||{},a=2),typeof u!="object"&&!b.isFunction(u)&&(u={}),f===a&&(u=this,--a);for(;a<f;a++)if((s=arguments[a])!=null)for(i in s){e=u[i],r=s[i];if(u===r)continue;l&&r&&(b.isPlainObject(r)||(n=b.isArray(r)))?(n?(n=!1,o=e&&b.isArray(e)?e:[]):o=e&&b.isPlainObject(e)?e:{},u[i]=b.extend(l,o,r)):r!==t&&(u[i]=r)}return u},b.extend({noConflict:function(t){return e.$===b&&(e.$=a),t&&e.jQuery===b&&(e.jQuery=u),b},isReady:!1,readyWait:1,holdReady:function(e){e?b.readyWait++:b.ready(!0)},ready:function(e){if(e===!0?--b.readyWait:b.isReady)return;if(!s.body)return setTimeout(b.ready);b.isReady=!0;if(e!==!0&&--b.readyWait>0)return;n.resolveWith(s,[b]),b.fn.trigger&&b(s).trigger("ready").off("ready")},isFunction:function(e){return b.type(e)==="function"},isArray:Array.isArray||function(e){return b.type(e)==="array"},isWindow:function(e){return e!=null&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return e==null?String(e):typeof e=="object"||typeof e=="function"?f[m.call(e)]||"object":typeof e},isPlainObject:function(e){if(!e||b.type(e)!=="object"||e.nodeType||b.isWindow(e))return!1;try{if(e.constructor&&!g.call(e,"constructor")&&!g.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||g.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw new Error(e)},parseHTML:function(e,t,n){if(!e||typeof e!="string")return null;typeof t=="boolean"&&(n=t,t=!1),t=t||s;var r=T.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=b.buildFragment([e],t,i),i&&b(i).remove(),b.merge([],r.childNodes))},parseJSON:function(t){if(e.JSON&&e.JSON.parse)return e.JSON.parse(t);if(t===null)return t;if(typeof t=="string"){t=b.trim(t);if(t&&N.test(t.replace(k,"@").replace(L,"]").replace(C,"")))return(new Function("return "+t))()}b.error("Invalid JSON: "+t)},parseXML:function(n){var r,i;if(!n||typeof n!="string")return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(s){r=t}return(!r||!r.documentElement||r.getElementsByTagName("parsererror").length)&&b.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&b.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(A,"ms-").replace(O,M)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,s=e.length,o=P(e);if(n)if(o)for(;i<s;i++){r=t.apply(e[i],n);if(r===!1)break}else for(i in e){r=t.apply(e[i],n);if(r===!1)break}else if(o)for(;i<s;i++){r=t.call(e[i],i,e[i]);if(r===!1)break}else for(i in e){r=t.call(e[i],i,e[i]);if(r===!1)break}return e},trim:y&&!y.call(" ")?function(e){return e==null?"":y.call(e)}:function(e){return e==null?"":(e+"").replace(S,"")},makeArray:function(e,t){var n=t||[];return e!=null&&(P(Object(e))?b.merge(n,typeof e=="string"?[e]:e):p.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(v)return v.call(t,e,n);r=t.length,n=n?n<0?Math.max(0,r+n):n:0;for(;n<r;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,s=0;if(typeof r=="number")for(;s<r;s++)e[i++]=n[s];else while(n[s]!==t)e[i++]=n[s++];return e.length=i,e},grep:function(e,t,n){var r,i=[],s=0,o=e.length;n=!!n;for(;s<o;s++)r=!!t(e[s],s),n!==r&&i.push(e[s]);return i},map:function(e,t,n){var r,i=0,s=e.length,o=P(e),u=[];if(o)for(;i<s;i++)r=t(e[i],i,n),r!=null&&(u[u.length]=r);else for(i in e)r=t(e[i],i,n),r!=null&&(u[u.length]=r);return h.apply([],u)},guid:1,proxy:function(e,n){var r,i,s;return typeof n=="string"&&(s=e[n],n=e,e=s),b.isFunction(e)?(r=d.call(arguments,2),i=function(){return e.apply(n||this,r.concat(d.call(arguments)))},i.guid=e.guid=e.guid||b.guid++,i):t},access:function(e,n,r,i,s,o,u){var a=0,f=e.length,l=r==null;if(b.type(r)==="object"){s=!0;for(a in r)b.access(e,n,a,r[a],!0,o,u)}else if(i!==t){s=!0,b.isFunction(i)||(u=!0),l&&(u?(n.call(e,i),n=null):(l=n,n=function(e,t,n){return l.call(b(e),n)}));if(n)for(;a<f;a++)n(e[a],r,u?i:i.call(e[a],a,n(e[a],r)))}return s?e:l?n.call(e):f?n(e[0],r):o},now:function(){return(new Date).getTime()}}),b.ready.promise=function(t){if(!n){n=b.Deferred();if(s.readyState==="complete")setTimeout(b.ready);else if(s.addEventListener)s.addEventListener("DOMContentLoaded",_,!1),e.addEventListener("load",_,!1);else{s.attachEvent("onreadystatechange",_),e.attachEvent("onload",_);var r=!1;try{r=e.frameElement==null&&s.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!b.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}D(),b.ready()}}()}}return n.promise(t)},b.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){f["[object "+t+"]"]=t.toLowerCase()}),r=b(s);var H={};b.Callbacks=function(e){e=typeof e=="string"?H[e]||B(e):b.extend({},e);var n,r,i,s,o,u,a=[],f=!e.once&&[],l=function(t){r=e.memory&&t,i=!0,o=u||0,u=0,s=a.length,n=!0;for(;a&&o<s;o++)if(a[o].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,a&&(f?f.length&&l(f.shift()):r?a=[]:c.disable())},c={add:function(){if(a){var t=a.length;(function i(t){b.each(t,function(t,n){var r=b.type(n);r==="function"?(!e.unique||!c.has(n))&&a.push(n):n&&n.length&&r!=="string"&&i(n)})})(arguments),n?s=a.length:r&&(u=t,l(r))}return this},remove:function(){return a&&b.each(arguments,function(e,t){var r;while((r=b.inArray(t,a,r))>-1)a.splice(r,1),n&&(r<=s&&s--,r<=o&&o--)}),this},has:function(e){return e?b.inArray(e,a)>-1:!!a&&!!a.length},empty:function(){return a=[],this},disable:function(){return a=f=r=t,this},disabled:function(){return!a},lock:function(){return f=t,r||c.disable(),this},locked:function(){return!f},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],a&&(!i||f)&&(n?f.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!i}};return c},b.extend({Deferred:function(e){var t=[["resolve","done",b.Callbacks("once memory"),"resolved"],["reject","fail",b.Callbacks("once memory"),"rejected"],["notify","progress",b.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return b.Deferred(function(n){b.each(t,function(t,s){var o=s[0],u=b.isFunction(e[t])&&e[t];i[s[1]](function(){var e=u&&u.apply(this,arguments);e&&b.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[o+"With"](this===r?n.promise():this,u?[e]:arguments)})}),e=null}).promise()},promise:function(e){return e!=null?b.extend(e,r):r}},i={};return r.pipe=r.then,b.each(t,function(e,s){var o=s[2],u=s[3];r[s[1]]=o.add,u&&o.add(function(){n=u},t[e^1][2].disable,t[2][2].lock),i[s[0]]=function(){return i[s[0]+"With"](this===i?r:this,arguments),this},i[s[0]+"With"]=o.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=d.call(arguments),r=n.length,i=r!==1||e&&b.isFunction(e.promise)?r:0,s=i===1?e:b.Deferred(),o=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?d.call(arguments):r,n===u?s.notifyWith(t,n):--i||s.resolveWith(t,n)}},u,a,f;if(r>1){u=new Array(r),a=new Array(r),f=new Array(r);for(;t<r;t++)n[t]&&b.isFunction(n[t].promise)?n[t].promise().done(o(t,f,n)).fail(s.reject).progress(o(t,a,u)):--i}return i||s.resolveWith(f,n),s.promise()}}),b.support=function(){var t,n,r,o,u,a,f,l,c,h,p=s.createElement("div");p.setAttribute("className","t"),p.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=p.getElementsByTagName("*"),r=p.getElementsByTagName("a")[0];if(!n||!r||!n.length)return{};u=s.createElement("select"),f=u.appendChild(s.createElement("option")),o=p.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={getSetAttribute:p.className!=="t",leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:r.getAttribute("href")==="/a",opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:!!o.value,optSelected:f.selected,enctype:!!s.createElement("form").enctype,html5Clone:s.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",boxModel:s.compatMode==="CSS1Compat",deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,u.disabled=!0,t.optDisabled=!f.disabled;try{delete p.test}catch(d){t.deleteExpando=!1}o=s.createElement("input"),o.setAttribute("value",""),t.input=o.getAttribute("value")==="",o.value="t",o.setAttribute("type","radio"),t.radioValue=o.value==="t",o.setAttribute("checked","t"),o.setAttribute("name","t"),a=s.createDocumentFragment(),a.appendChild(o),t.appendChecked=o.checked,t.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,p.attachEvent&&(p.attachEvent("onclick",function(){t.noCloneEvent=!1}),p.cloneNode(!0).click());for(h in{submit:!0,change:!0,focusin:!0})p.setAttribute(l="on"+h,"t"),t[h+"Bubbles"]=l in e||p.attributes[l].expando===!1;return p.style.backgroundClip="content-box",p.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle=p.style.backgroundClip==="content-box",b(function(){var n,r,o,u="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",a=s.getElementsByTagName("body")[0];if(!a)return;n=s.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",a.appendChild(n).appendChild(p),p.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=p.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",c=o[0].offsetHeight===0,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=c&&o[0].offsetHeight===0,p.innerHTML="",p.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=p.offsetWidth===4,t.doesNotIncludeMarginInBodyOffset=a.offsetTop!==1,e.getComputedStyle&&(t.pixelPosition=(e.getComputedStyle(p,null)||{}).top!=="1%",t.boxSizingReliable=(e.getComputedStyle(p,null)||{width:"4px"}).width==="4px",r=p.appendChild(s.createElement("div")),r.style.cssText=p.style.cssText=u,r.style.marginRight=r.style.width="0",p.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof p.style.zoom!==i&&(p.innerHTML="",p.style.cssText=u+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=p.offsetWidth===3,p.style.display="block",p.innerHTML="<div></div>",p.firstChild.style.width="5px",t.shrinkWrapBlocks=p.offsetWidth!==3,t.inlineBlockNeedsLayout&&(a.style.zoom=1)),a.removeChild(n),n=p=o=r=null}),n=u=a=f=r=o=null,t}();var j=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,F=/([A-Z])/g;b.extend({cache:{},expando:"jQuery"+(c+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?b.cache[e[b.expando]]:e[b.expando],!!e&&!U(e)},data:function(e,t,n){return I(e,t,n)},removeData:function(e,t){return q(e,t)},_data:function(e,t,n){return I(e,t,n,!0)},_removeData:function(e,t){return q(e,t,!0)},acceptData:function(e){if(e.nodeType&&e.nodeType!==1&&e.nodeType!==9)return!1;var t=e.nodeName&&b.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),b.fn.extend({data:function(e,n){var r,i,s=this[0],o=0,u=null;if(e===t){if(this.length){u=b.data(s);if(s.nodeType===1&&!b._data(s,"parsedAttrs")){r=s.attributes;for(;o<r.length;o++)i=r[o].name,i.indexOf("data-")||(i=b.camelCase(i.slice(5)),R(s,i,u[i]));b._data(s,"parsedAttrs",!0)}}return u}return typeof e=="object"?this.each(function(){b.data(this,e)}):b.access(this,function(n){if(n===t)return s?R(s,e,b.data(s,e)):null;this.each(function(){b.data(this,e,n)})},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){b.removeData(this,e)})}}),b.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=b._data(e,t),n&&(!r||b.isArray(n)?r=b._data(e,t,b.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=b.queue(e,t),r=n.length,i=n.shift(),s=b._queueHooks(e,t),o=function(){b.dequeue(e,t)};i==="inprogress"&&(i=n.shift(),r--),s.cur=i,i&&(t==="fx"&&n.unshift("inprogress"),delete s.stop,i.call(e,o,s)),!r&&s&&s.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return b._data(e,n)||b._data(e,n,{empty:b.Callbacks("once memory").add(function(){b._removeData(e,t+"queue"),b._removeData(e,n)})})}}),b.fn.extend({queue:function(e,n){var r=2;return typeof e!="string"&&(n=e,e="fx",r--),arguments.length<r?b.queue(this[0],e):n===t?this:this.each(function(){var t=b.queue(this,e,n);b._queueHooks(this,e),e==="fx"&&t[0]!=="inprogress"&&b.dequeue(this,e)})},dequeue:function(e){return this.each(function(){b.dequeue(this,e)})},delay:function(e,t){return e=b.fx?b.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,s=b.Deferred(),o=this,u=this.length,a=function(){--i||s.resolveWith(o,[o])};typeof e!="string"&&(n=e,e=t),e=e||"fx";while(u--)r=b._data(o[u],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(a));return a(),s.promise(n)}});var z,W,X=/[\t\r\n]/g,V=/\r/g,$=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,K=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,Q=/^(?:checked|selected)$/i,G=b.support.getSetAttribute,Y=b.support.input;b.fn.extend({attr:function(e,t){return b.access(this,b.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){b.removeAttr(this,e)})},prop:function(e,t){return b.access(this,b.prop,e,t,arguments.length>1)},removeProp:function(e){return e=b.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,s,o=0,u=this.length,a=typeof e=="string"&&e;if(b.isFunction(e))return this.each(function(t){b(this).addClass(e.call(this,t,this.className))});if(a){t=(e||"").match(E)||[];for(;o<u;o++){n=this[o],r=n.nodeType===1&&(n.className?(" "+n.className+" ").replace(X," "):" ");if(r){s=0;while(i=t[s++])r.indexOf(" "+i+" ")<0&&(r+=i+" ");n.className=b.trim(r)}}}return this},removeClass:function(e){var t,n,r,i,s,o=0,u=this.length,a=arguments.length===0||typeof e=="string"&&e;if(b.isFunction(e))return this.each(function(t){b(this).removeClass(e.call(this,t,this.className))});if(a){t=(e||"").match(E)||[];for(;o<u;o++){n=this[o],r=n.nodeType===1&&(n.className?(" "+n.className+" ").replace(X," "):"");if(r){s=0;while(i=t[s++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?b.trim(r):""}}}return this},toggleClass:function(e,t){var n=typeof e,r=typeof t=="boolean";return b.isFunction(e)?this.each(function(n){b(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(n==="string"){var s,o=0,u=b(this),a=t,f=e.match(E)||[];while(s=f[o++])a=r?a:!u.hasClass(s),u[a?"addClass":"removeClass"](s)}else if(n===i||n==="boolean")this.className&&b._data(this,"__className__",this.className),this.className=this.className||e===!1?"":b._data(this,"__className__")||""})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;n<r;n++)if(this[n].nodeType===1&&(" "+this[n].className+" ").replace(X," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,s=this[0];if(!arguments.length){if(s)return r=b.valHooks[s.type]||b.valHooks[s.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(s,"value"))!==t?n:(n=s.value,typeof n=="string"?n.replace(V,""):n==null?"":n);return}return i=b.isFunction(e),this.each(function(n){var s,o=b(this);if(this.nodeType!==1)return;i?s=e.call(this,n,o.val()):s=e,s==null?s="":typeof s=="number"?s+="":b.isArray(s)&&(s=b.map(s,function(e){return e==null?"":e+""})),r=b.valHooks[this.type]||b.valHooks[this.nodeName.toLowerCase()];if(!r||!("set"in r)||r.set(this,s,"value")===t)this.value=s})}}),b.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,s=e.type==="select-one"||i<0,o=s?null:[],u=s?i+1:r.length,a=i<0?u:s?i:0;for(;a<u;a++){n=r[a];if((n.selected||a===i)&&(b.support.optDisabled?!n.disabled:n.getAttribute("disabled")===null)&&(!n.parentNode.disabled||!b.nodeName(n.parentNode,"optgroup"))){t=b(n).val();if(s)return t;o.push(t)}}return o},set:function(e,t){var n=b.makeArray(t);return b(e).find("option").each(function(){this.selected=b.inArray(b(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attr:function(e,n,r){var s,o,u,a=e.nodeType;if(!e||a===3||a===8||a===2)return;if(typeof e.getAttribute===i)return b.prop(e,n,r);o=a!==1||!b.isXMLDoc(e),o&&(n=n.toLowerCase(),s=b.attrHooks[n]||(K.test(n)?W:z));if(r===t)return s&&o&&"get"in s&&(u=s.get(e,n))!==null?u:(typeof e.getAttribute!==i&&(u=e.getAttribute(n)),u==null?t:u);if(r!==null)return s&&o&&"set"in s&&(u=s.set(e,r,n))!==t?u:(e.setAttribute(n,r+""),r);b.removeAttr(e,n)},removeAttr:function(e,t){var n,r,i=0,s=t&&t.match(E);if(s&&e.nodeType===1)while(n=s[i++])r=b.propFix[n]||n,K.test(n)?!G&&Q.test(n)?e[b.camelCase("default-"+n)]=e[r]=!1:e[r]=!1:b.attr(e,n,""),e.removeAttribute(G?n:r)},attrHooks:{type:{set:function(e,t){if(!b.support.radioValue&&t==="radio"&&b.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,s,o,u=e.nodeType;if(!e||u===3||u===8||u===2)return;return o=u!==1||!b.isXMLDoc(e),o&&(n=b.propFix[n]||n,s=b.propHooks[n]),r!==t?s&&"set"in s&&(i=s.set(e,r,n))!==t?i:e[n]=r:s&&"get"in s&&(i=s.get(e,n))!==null?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):$.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:t}}}}),W={get:function(e,n){var r=b.prop(e,n),i=typeof r=="boolean"&&e.getAttribute(n),s=typeof r=="boolean"?Y&&G?i!=null:Q.test(n)?e[b.camelCase("default-"+n)]:!!i:e.getAttributeNode(n);return s&&s.value!==!1?n.toLowerCase():t},set:function(e,t,n){return t===!1?b.removeAttr(e,n):Y&&G||!Q.test(n)?e.setAttribute(!G&&b.propFix[n]||n,n):e[b.camelCase("default-"+n)]=e[n]=!0,n}};if(!Y||!G)b.attrHooks.value={get:function(e,n){var r=e.getAttributeNode(n);return b.nodeName(e,"input")?e.defaultValue:r&&r.specified?r.value:t},set:function(e,t,n){if(!b.nodeName(e,"input"))return z&&z.set(e,t,n);e.defaultValue=t}};G||(z=b.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&(n==="id"||n==="name"||n==="coords"?r.value!=="":r.specified)?r.value:t},set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="",r==="value"||n===e.getAttribute(r)?n:t}},b.attrHooks.contenteditable={get:z.get,set:function(e,t,n){z.set(e,t===""?!1:t,n)}},b.each(["width","height"],function(e,t){b.attrHooks[t]=b.extend(b.attrHooks[t],{set:function(e,n){if(n==="")return e.setAttribute(t,"auto"),n}})})),b.support.hrefNormalized||(b.each(["href","src","width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return r==null?t:r}})}),b.each(["href","src"],function(e,t){b.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}})),b.support.style||(b.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),b.support.optSelected||(b.propHooks.selected=b.extend(b.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),b.support.enctype||(b.propFix.enctype="encoding"),b.support.checkOn||b.each(["radio","checkbox"],function(){b.valHooks[this]={get:function(e){return e.getAttribute("value")===null?"on":e.value}}}),b.each(["radio","checkbox"],function(){b.valHooks[this]=b.extend(b.valHooks[this],{set:function(e,t){if(b.isArray(t))return e.checked=b.inArray(b(e).val(),t)>=0}})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;b.event={global:{},add:function(e,n,r,s,o){var u,a,f,l,c,h,p,d,v,m,g,y=b._data(e);if(!y)return;r.handler&&(l=r,r=l.handler,o=l.selector),r.guid||(r.guid=b.guid++),(a=y.events)||(a=y.events={}),(h=y.handle)||(h=y.handle=function(e){return typeof b===i||!!e&&b.event.triggered===e.type?t:b.event.dispatch.apply(h.elem,arguments)},h.elem=e),n=(n||"").match(E)||[""],f=n.length;while(f--){u=rt.exec(n[f])||[],v=g=u[1],m=(u[2]||"").split(".").sort(),c=b.event.special[v]||{},v=(o?c.delegateType:c.bindType)||v,c=b.event.special[v]||{},p=b.extend({type:v,origType:g,data:s,handler:r,guid:r.guid,selector:o,needsContext:o&&b.expr.match.needsContext.test(o),namespace:m.join(".")},l);if(!(d=a[v])){d=a[v]=[],d.delegateCount=0;if(!c.setup||c.setup.call(e,s,m,h)===!1)e.addEventListener?e.addEventListener(v,h,!1):e.attachEvent&&e.attachEvent("on"+v,h)}c.add&&(c.add.call(e,p),p.handler.guid||(p.handler.guid=r.guid)),o?d.splice(d.delegateCount++,0,p):d.push(p),b.event.global[v]=!0}e=null},remove:function(e,t,n,r,i){var s,o,u,a,f,l,c,h,p,d,v,m=b.hasData(e)&&b._data(e);if(!m||!(l=m.events))return;t=(t||"").match(E)||[""],f=t.length;while(f--){u=rt.exec(t[f])||[],p=v=u[1],d=(u[2]||"").split(".").sort();if(!p){for(p in l)b.event.remove(e,p+t[f],n,r,!0);continue}c=b.event.special[p]||{},p=(r?c.delegateType:c.bindType)||p,h=l[p]||[],u=u[2]&&new RegExp("(^|\\.)"+d.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=s=h.length;while(s--)o=h[s],(i||v===o.origType)&&(!n||n.guid===o.guid)&&(!u||u.test(o.namespace))&&(!r||r===o.selector||r==="**"&&o.selector)&&(h.splice(s,1),o.selector&&h.delegateCount--,c.remove&&c.remove.call(e,o));a&&!h.length&&((!c.teardown||c.teardown.call(e,d,m.handle)===!1)&&b.removeEvent(e,p,m.handle),delete l[p])}b.isEmptyObject(l)&&(delete m.handle,b._removeData(e,"events"))},trigger:function(n,r,i,o){var u,a,f,l,c,h,p,d=[i||s],v=g.call(n,"type")?n.type:n,m=g.call(n,"namespace")?n.namespace.split("."):[];f=h=i=i||s;if(i.nodeType===3||i.nodeType===8)return;if(nt.test(v+b.event.triggered))return;v.indexOf(".")>=0&&(m=v.split("."),v=m.shift(),m.sort()),a=v.indexOf(":")<0&&"on"+v,n=n[b.expando]?n:new b.Event(v,typeof n=="object"&&n),n.isTrigger=!0,n.namespace=m.join("."),n.namespace_re=n.namespace?new RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=r==null?[n]:b.makeArray(r,[n]),c=b.event.special[v]||{};if(!o&&c.trigger&&c.trigger.apply(i,r)===!1)return;if(!o&&!c.noBubble&&!b.isWindow(i)){l=c.delegateType||v,nt.test(l+v)||(f=f.parentNode);for(;f;f=f.parentNode)d.push(f),h=f;h===(i.ownerDocument||s)&&d.push(h.defaultView||h.parentWindow||e)}p=0;while((f=d[p++])&&!n.isPropagationStopped())n.type=p>1?l:c.bindType||v,u=(b._data(f,"events")||{})[n.type]&&b._data(f,"handle"),u&&u.apply(f,r),u=a&&f[a],u&&b.acceptData(f)&&u.apply&&u.apply(f,r)===!1&&n.preventDefault();n.type=v;if(!o&&!n.isDefaultPrevented()&&(!c._default||c._default.apply(i.ownerDocument,r)===!1)&&(v!=="click"||!b.nodeName(i,"a"))&&b.acceptData(i)&&a&&i[v]&&!b.isWindow(i)){h=i[a],h&&(i[a]=null),b.event.triggered=v;try{i[v]()}catch(y){}b.event.triggered=t,h&&(i[a]=h)}return n.result},dispatch:function(e){e=b.event.fix(e);var n,r,i,s,o,u=[],a=d.call(arguments),f=(b._data(this,"events")||{})[e.type]||[],l=b.event.special[e.type]||{};a[0]=e,e.delegateTarget=this;if(l.preDispatch&&l.preDispatch.call(this,e)===!1)return;u=b.event.handlers.call(this,e,f),n=0;while((s=u[n++])&&!e.isPropagationStopped()){e.currentTarget=s.elem,o=0;while((i=s.handlers[o++])&&!e.isImmediatePropagationStopped())if(!e.namespace_re||e.namespace_re.test(i.namespace))e.handleObj=i,e.data=i.data,r=((b.event.special[i.origType]||{}).handle||i.handler).apply(s.elem,a),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation())}return l.postDispatch&&l.postDispatch.call(this,e),e.result},handlers:function(e,n){var r,i,s,o,u=[],a=n.delegateCount,f=e.target;if(a&&f.nodeType&&(!e.button||e.type!=="click"))for(;f!=this;f=f.parentNode||this)if(f.nodeType===1&&(f.disabled!==!0||e.type!=="click")){s=[];for(o=0;o<a;o++)i=n[o],r=i.selector+" ",s[r]===t&&(s[r]=i.needsContext?b(r,this).index(f)>=0:b.find(r,this,null,[f]).length),s[r]&&s.push(i);s.length&&u.push({elem:f,handlers:s})}return a<n.length&&u.push({elem:this,handlers:n.slice(a)}),u},fix:function(e){if(e[b.expando])return e;var t,n,r,i=e.type,o=e,u=this.fixHooks[i];u||(this.fixHooks[i]=u=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=u.props?this.props.concat(u.props):this.props,e=new b.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||s),e.target.nodeType===3&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,u.filter?u.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return e.which==null&&(e.which=t.charCode!=null?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,u=n.button,a=n.fromElement;return e.pageX==null&&n.clientX!=null&&(i=e.target.ownerDocument||s,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&a&&(e.relatedTarget=a===e.target?n.toElement:a),!e.which&&u!==t&&(e.which=u&1?1:u&2?3:u&4?2:0),e}},special:{load:{noBubble:!0},click:{trigger:function(){if(b.nodeName(this,"input")&&this.type==="checkbox"&&this.click)return this.click(),!1}},focus:{trigger:function(){if(this!==s.activeElement&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){if(this===s.activeElement&&this.blur)return this.blur(),!1},delegateType:"focusout"},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=b.extend(new b.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?b.event.trigger(i,null,t):b.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},b.removeEvent=s.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},b.Event=function(e,t){if(!(this instanceof b.Event))return new b.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:st):this.type=e,t&&b.extend(this,t),this.timeStamp=e&&e.timeStamp||b.now(),this[b.expando]=!0},b.Event.prototype={isDefaultPrevented:st,isPropagationStopped:st,isImmediatePropagationStopped:st,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it;if(!e)return;e.preventDefault?e.preventDefault():e.returnValue=!1},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it;if(!e)return;e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},b.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){b.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,s=e.handleObj;if(!i||i!==r&&!b.contains(r,i))e.type=s.origType,n=s.handler.apply(this,arguments),e.type=t;return n}}}),b.support.submitBubbles||(b.event.special.submit={setup:function(){if(b.nodeName(this,"form"))return!1;b.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=b.nodeName(n,"input")||b.nodeName(n,"button")?n.form:t;r&&!b._data(r,"submitBubbles")&&(b.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),b._data(r,"submitBubbles",!0))})},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&b.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){if(b.nodeName(this,"form"))return!1;b.event.remove(this,"._submit")}}),b.support.changeBubbles||(b.event.special.change={setup:function(){if(Z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")b.event.add(this,"propertychange._change",function(e){e.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),b.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),b.event.simulate("change",this,e,!0)});return!1}b.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!b._data(t,"changeBubbles")&&(b.event.add(t,"change._change",function(e){this.parentNode&&!e.isSimulated&&!e.isTrigger&&b.event.simulate("change",this.parentNode,e,!0)}),b._data(t,"changeBubbles",!0))})},handle:function(e){var t=e.target;if(this!==t||e.isSimulated||e.isTrigger||t.type!=="radio"&&t.type!=="checkbox")return e.handleObj.handler.apply(this,arguments)},teardown:function(){return b.event.remove(this,"._change"),!Z.test(this.nodeName)}}),b.support.focusinBubbles||b.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){b.event.simulate(t,e.target,b.event.fix(e),!0)};b.event.special[t]={setup:function(){n++===0&&s.addEventListener(e,r,!0)},teardown:function(){--n===0&&s.removeEventListener(e,r,!0)}}}),b.fn.extend({on:function(e,n,r,i,s){var o,u;if(typeof e=="object"){typeof n!="string"&&(r=r||n,n=t);for(o in e)this.on(o,n,r,e[o],s);return this}r==null&&i==null?(i=n,r=n=t):i==null&&(typeof n=="string"?(i=r,r=t):(i=r,r=n,n=t));if(i===!1)i=st;else if(!i)return this;return s===1&&(u=i,i=function(e){return b().off(e),u.apply(this,arguments)},i.guid=u.guid||(u.guid=b.guid++)),this.each(function(){b.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,s;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,b(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if(typeof e=="object"){for(s in e)this.off(s,n,e[s]);return this}if(n===!1||typeof n=="function")r=n,n=t;return r===!1&&(r=st),this.each(function(){b.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return arguments.length===1?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){b.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return b.event.trigger(e,t,n,!0)}}),function(e,t){function rt(e){return J.test(e+"")}function it(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>i.cacheLength&&delete e[t.shift()],e[n]=r}}function st(e){return e[w]=!0,e}function ot(e){var t=c.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}}function ut(e,t,n,r){var i,s,o,u,a,f,h,v,m,y;(t?t.ownerDocument||t:E)!==c&&l(t),t=t||c,n=n||[];if(!e||typeof e!="string")return n;if((u=t.nodeType)!==1&&u!==9)return[];if(!p&&!r){if(i=K.exec(e))if(o=i[1]){if(u===9){s=t.getElementById(o);if(!s||!s.parentNode)return n;if(s.id===o)return n.push(s),n}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(o))&&g(t,s)&&s.id===o)return n.push(s),n}else{if(i[2])return _.apply(n,D.call(t.getElementsByTagName(e),0)),n;if((o=i[3])&&S.getByClassName&&t.getElementsByClassName)return _.apply(n,D.call(t.getElementsByClassName(o),0)),n}if(S.qsa&&!d.test(e)){h=!0,v=w,m=t,y=u===9&&e;if(u===1&&t.nodeName.toLowerCase()!=="object"){f=ht(e),(h=t.getAttribute("id"))?v=h.replace(Y,"\\$&"):t.setAttribute("id",v),v="[id='"+v+"'] ",a=f.length;while(a--)f[a]=v+pt(f[a]);m=$.test(e)&&t.parentNode||t,y=f.join(",")}if(y)try{return _.apply(n,D.call(m.querySelectorAll(y),0)),n}catch(b){}finally{h||t.removeAttribute("id")}}}return Et(e.replace(R,"$1"),t,n,r)}function at(e,t){var n=t&&e,r=n&&(~t.sourceIndex||A)-(~e.sourceIndex||A);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return n==="input"&&t.type===e}}function lt(e){return function(t){var n=t.nodeName.toLowerCase();return(n==="input"||n==="button")&&t.type===e}}function ct(e){return st(function(t){return t=+t,st(function(n,r){var i,s=e([],n.length,t),o=s.length;while(o--)n[i=s[o]]&&(n[i]=!(r[i]=n[i]))})})}function ht(e,t){var n,r,s,o,u,a,f,l=C[e+" "];if(l)return t?0:l.slice(0);u=e,a=[],f=i.preFilter;while(u){if(!n||(r=U.exec(u)))r&&(u=u.slice(r[0].length)||u),a.push(s=[]);n=!1;if(r=z.exec(u))n=r.shift(),s.push({value:n,type:r[0].replace(R," ")}),u=u.slice(n.length);for(o in i.filter)(r=V[o].exec(u))&&(!f[o]||(r=f[o](r)))&&(n=r.shift(),s.push({value:n,type:o,matches:r}),u=u.slice(n.length));if(!n)break}return t?u.length:u?ut.error(e):C(e,a).slice(0)}function pt(e){var t=0,n=e.length,r="";for(;t<n;t++)r+=e[t].value;return r}function dt(e,t,n){var i=t.dir,s=n&&i==="parentNode",o=T++;return t.first?function(t,n,r){while(t=t[i])if(t.nodeType===1||s)return e(t,n,r)}:function(t,n,u){var a,f,l,c=x+" "+o;if(u){while(t=t[i])if(t.nodeType===1||s)if(e(t,n,u))return!0}else while(t=t[i])if(t.nodeType===1||s){l=t[w]||(t[w]={});if((f=l[i])&&f[0]===c){if((a=f[1])===!0||a===r)return a===!0}else{f=l[i]=[c],f[1]=e(t,n,u)||r;if(f[1]===!0)return!0}}}}function vt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function mt(e,t,n,r,i){var s,o=[],u=0,a=e.length,f=t!=null;for(;u<a;u++)if(s=e[u])if(!n||n(s,r,i))o.push(s),f&&t.push(u);return o}function gt(e,t,n,r,i,s){return r&&!r[w]&&(r=gt(r)),i&&!i[w]&&(i=gt(i,s)),st(function(s,o,u,a){var f,l,c,h=[],p=[],d=o.length,v=s||wt(t||"*",u.nodeType?[u]:u,[]),m=e&&(s||!t)?mt(v,h,e,u,a):v,g=n?i||(s?e:d||r)?[]:o:m;n&&n(m,g,u,a);if(r){f=mt(g,p),r(f,[],u,a),l=f.length;while(l--)if(c=f[l])g[p[l]]=!(m[p[l]]=c)}if(s){if(i||e){if(i){f=[],l=g.length;while(l--)(c=g[l])&&f.push(m[l]=c);i(null,g=[],f,a)}l=g.length;while(l--)(c=g[l])&&(f=i?P.call(s,c):h[l])>-1&&(s[f]=!(o[f]=c))}}else g=mt(g===o?g.splice(d,g.length):g),i?i(null,o,g,a):_.apply(o,g)})}function yt(e){var t,n,r,s=e.length,o=i.relative[e[0].type],u=o||i.relative[" "],a=o?1:0,l=dt(function(e){return e===t},u,!0),c=dt(function(e){return P.call(t,e)>-1},u,!0),h=[function(e,n,r){return!o&&(r||n!==f)||((t=n).nodeType?l(e,n,r):c(e,n,r))}];for(;a<s;a++)if(n=i.relative[e[a].type])h=[dt(vt(h),n)];else{n=i.filter[e[a].type].apply(null,e[a].matches);if(n[w]){r=++a;for(;r<s;r++)if(i.relative[e[r].type])break;return gt(a>1&&vt(h),a>1&&pt(e.slice(0,a-1)).replace(R,"$1"),n,a<r&&yt(e.slice(a,r)),r<s&&yt(e=e.slice(r)),r<s&&pt(e))}h.push(n)}return vt(h)}function bt(e,t){var n=0,s=t.length>0,o=e.length>0,u=function(u,a,l,h,p){var d,v,m,g=[],y=0,b="0",w=u&&[],E=p!=null,S=f,T=u||o&&i.find.TAG("*",p&&a.parentNode||a),N=x+=S==null?1:Math.random()||.1;E&&(f=a!==c&&a,r=n);for(;(d=T[b])!=null;b++){if(o&&d){v=0;while(m=e[v++])if(m(d,a,l)){h.push(d);break}E&&(x=N,r=++n)}s&&((d=!m&&d)&&y--,u&&w.push(d))}y+=b;if(s&&b!==y){v=0;while(m=t[v++])m(w,g,a,l);if(u){if(y>0)while(b--)!w[b]&&!g[b]&&(g[b]=M.call(h));g=mt(g)}_.apply(h,g),E&&!u&&g.length>0&&y+t.length>1&&ut.uniqueSort(h)}return E&&(x=N,f=S),w};return s?st(u):u}function wt(e,t,n){var r=0,i=t.length;for(;r<i;r++)ut(e,t[r],n);return n}function Et(e,t,n,r){var s,o,a,f,l,c=ht(e);if(!r&&c.length===1){o=c[0]=c[0].slice(0);if(o.length>2&&(a=o[0]).type==="ID"&&t.nodeType===9&&!p&&i.relative[o[1].type]){t=i.find.ID(a.matches[0].replace(et,tt),t)[0];if(!t)return n;e=e.slice(o.shift().value.length)}s=V.needsContext.test(e)?0:o.length;while(s--){a=o[s];if(i.relative[f=a.type])break;if(l=i.find[f])if(r=l(a.matches[0].replace(et,tt),$.test(o[0].type)&&t.parentNode||t)){o.splice(s,1),e=r.length&&pt(o);if(!e)return _.apply(n,D.call(r,0)),n;break}}}return u(e,c)(r,t,p,n,$.test(e)),n}function St(){}var n,r,i,s,o,u,a,f,l,c,h,p,d,v,m,g,y,w="sizzle"+ -(new Date),E=e.document,S={},x=0,T=0,N=it(),C=it(),k=it(),L=typeof t,A=1<<31,O=[],M=O.pop,_=O.push,D=O.slice,P=O.indexOf||function(e){var t=0,n=this.length;for(;t<n;t++)if(this[t]===e)return t;return-1},H="[\\x20\\t\\r\\n\\f]",B="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",j=B.replace("w","w#"),F="([*^$|!~]?=)",I="\\["+H+"*("+B+")"+H+"*(?:"+F+H+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+j+")|)|)"+H+"*\\]",q=":("+B+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+I.replace(3,8)+")*)|.*)\\)|)",R=new RegExp("^"+H+"+|((?:^|[^\\\\])(?:\\\\.)*)"+H+"+$","g"),U=new RegExp("^"+H+"*,"+H+"*"),z=new RegExp("^"+H+"*([\\x20\\t\\r\\n\\f>+~])"+H+"*"),W=new RegExp(q),X=new RegExp("^"+j+"$"),V={ID:new RegExp("^#("+B+")"),CLASS:new RegExp("^\\.("+B+")"),NAME:new RegExp("^\\[name=['\"]?("+B+")['\"]?\\]"),TAG:new RegExp("^("+B.replace("w","w*")+")"),ATTR:new RegExp("^"+I),PSEUDO:new RegExp("^"+q),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+H+"*(even|odd|(([+-]|)(\\d*)n|)"+H+"*(?:([+-]|)"+H+"*(\\d+)|))"+H+"*\\)|)","i"),needsContext:new RegExp("^"+H+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+H+"*((?:-\\d)?\\d*)"+H+"*\\)|)(?=[^-]|$)","i")},$=/[\x20\t\r\n\f]*[+~]/,J=/^[^{]+\{\s*\[native code/,K=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,Q=/^(?:input|select|textarea|button)$/i,G=/^h\d$/i,Y=/'|\\/g,Z=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,et=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,tt=function(e,t){var n="0x"+t-65536;return n!==n?t:n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,n&1023|56320)};try{D.call(E.documentElement.childNodes,0)[0].nodeType}catch(nt){D=function(e){var t,n=[];while(t=this[e++])n.push(t);return n}}o=ut.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?t.nodeName!=="HTML":!1},l=ut.setDocument=function(e){var n=e?e.ownerDocument||e:E;if(n===c||n.nodeType!==9||!n.documentElement)return c;c=n,h=n.documentElement,p=o(n),S.tagNameNoComments=ot(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),S.attributes=ot(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return t!=="boolean"&&t!=="string"}),S.getByClassName=ot(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",!e.getElementsByClassName||!e.getElementsByClassName("e").length?!1:(e.lastChild.className="e",e.getElementsByClassName("e").length===2)}),S.getByName=ot(function(e){e.id=w+0,e.innerHTML="<a name='"+w+"'></a><div name='"+w+"'></div>",h.insertBefore(e,h.firstChild);var t=n.getElementsByName&&n.getElementsByName(w).length===2+n.getElementsByName(w+0).length;return S.getIdNotName=!n.getElementById(w),h.removeChild(e),t}),i.attrHandle=ot(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==L&&e.firstChild.getAttribute("href")==="#"})?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},S.getIdNotName?(i.find.ID=function(e,t){if(typeof t.getElementById!==L&&!p){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){return e.getAttribute("id")===t}}):(i.find.ID=function(e,n){if(typeof n.getElementById!==L&&!p){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==L&&r.getAttributeNode("id").value===e?[r]:t:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){var n=typeof e.getAttributeNode!==L&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=S.tagNameNoComments?function(e,t){if(typeof t.getElementsByTagName!==L)return t.getElementsByTagName(e)}:function(e,t){var n,r=[],i=0,s=t.getElementsByTagName(e);if(e==="*"){while(n=s[i++])n.nodeType===1&&r.push(n);return r}return s},i.find.NAME=S.getByName&&function(e,t){if(typeof t.getElementsByName!==L)return t.getElementsByName(name)},i.find.CLASS=S.getByClassName&&function(e,t){if(typeof t.getElementsByClassName!==L&&!p)return t.getElementsByClassName(e)},v=[],d=[":focus"];if(S.qsa=rt(n.querySelectorAll))ot(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||d.push("\\["+H+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||d.push(":checked")}),ot(function(e){e.innerHTML="<input type='hidden' i=''/>",e.querySelectorAll("[i^='']").length&&d.push("[*^$]="+H+"*(?:\"\"|'')"),e.querySelectorAll(":enabled").length||d.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),d.push(",.*:")});return(S.matchesSelector=rt(m=h.matchesSelector||h.mozMatchesSelector||h.webkitMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ot(function(e){S.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),v.push("!=",q)}),d=new RegExp(d.join("|")),v=new RegExp(v.join("|")),g=rt(h.contains)||h.compareDocumentPosition?function(e,t){var n=e.nodeType===9?e.documentElement:e,r=t&&t.parentNode;return e===r||!!r&&r.nodeType===1&&!!(n.contains?n.contains(r):e.compareDocumentPosition&&e.compareDocumentPosition(r)&16)}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},y=h.compareDocumentPosition?function(e,t){var r;if(e===t)return a=!0,0;if(r=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t))return r&1||e.parentNode&&e.parentNode.nodeType===11?e===n||g(E,e)?-1:t===n||g(E,t)?1:0:r&4?-1:1;return e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,s=e.parentNode,o=t.parentNode,u=[e],f=[t];if(e===t)return a=!0,0;if(!s||!o)return e===n?-1:t===n?1:s?-1:o?1:0;if(s===o)return at(e,t);r=e;while(r=r.parentNode)u.unshift(r);r=t;while(r=r.parentNode)f.unshift(r);while(u[i]===f[i])i++;return i?at(u[i],f[i]):u[i]===E?-1:f[i]===E?1:0},a=!1,[0,0].sort(y),S.detectDuplicates=a,c},ut.matches=function(e,t){return ut(e,null,null,t)},ut.matchesSelector=function(e,t){(e.ownerDocument||e)!==c&&l(e),t=t.replace(Z,"='$1']");if(S.matchesSelector&&!p&&(!v||!v.test(t))&&!d.test(t))try{var n=m.call(e,t);if(n||S.disconnectedMatch||e.document&&e.document.nodeType!==11)return n}catch(r){}return ut(t,c,null,[e]).length>0},ut.contains=function(e,t){return(e.ownerDocument||e)!==c&&l(e),g(e,t)},ut.attr=function(e,t){var n;return(e.ownerDocument||e)!==c&&l(e),p||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):p||S.attributes?e.getAttribute(t):((n=e.getAttributeNode(t))||e.getAttribute(t))&&e[t]===!0?t:n&&n.specified?n.value:null},ut.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},ut.uniqueSort=function(e){var t,n=[],r=1,i=0;a=!S.detectDuplicates,e.sort(y);if(a){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e},s=ut.getText=function(e){var t,n="",r=0,i=e.nodeType;if(!i)for(;t=e[r];r++)n+=s(t);else if(i===1||i===9||i===11){if(typeof e.textContent=="string")return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=s(e)}else if(i===3||i===4)return e.nodeValue;return n},i=ut.selectors={cacheLength:50,createPseudo:st,match:V,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(et,tt),e[3]=(e[4]||e[5]||"").replace(et,tt),e[2]==="~="&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),e[1].slice(0,3)==="nth"?(e[3]||ut.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(e[3]==="even"||e[3]==="odd")),e[5]=+(e[7]+e[8]||e[3]==="odd")):e[3]&&ut.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return V.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&W.test(n)&&(t=ht(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){return e==="*"?function(){return!0}:(e=e.replace(et,tt).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=N[e+" "];return t||(t=new RegExp("(^|"+H+")"+e+"("+H+"|$)"))&&N(e,function(e){return t.test(e.className||typeof e.getAttribute!==L&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=ut.attr(r,e);return i==null?t==="!=":t?(i+="",t==="="?i===n:t==="!="?i!==n:t==="^="?n&&i.indexOf(n)===0:t==="*="?n&&i.indexOf(n)>-1:t==="$="?n&&i.slice(-n.length)===n:t==="~="?(" "+i+" ").indexOf(n)>-1:t==="|="?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var s=e.slice(0,3)!=="nth",o=e.slice(-4)!=="last",u=t==="of-type";return r===1&&i===0?function(e){return!!e.parentNode}:function(t,n,a){var f,l,c,h,p,d,v=s!==o?"nextSibling":"previousSibling",m=t.parentNode,g=u&&t.nodeName.toLowerCase(),y=!a&&!u;if(m){if(s){while(v){c=t;while(c=c[v])if(u?c.nodeName.toLowerCase()===g:c.nodeType===1)return!1;d=v=e==="only"&&!d&&"nextSibling"}return!0}d=[o?m.firstChild:m.lastChild];if(o&&y){l=m[w]||(m[w]={}),f=l[e]||[],p=f[0]===x&&f[1],h=f[0]===x&&f[2],c=p&&m.childNodes[p];while(c=++p&&c&&c[v]||(h=p=0)||d.pop())if(c.nodeType===1&&++h&&c===t){l[e]=[x,p,h];break}}else if(y&&(f=(t[w]||(t[w]={}))[e])&&f[0]===x)h=f[1];else while(c=++p&&c&&c[v]||(h=p=0)||d.pop())if((u?c.nodeName.toLowerCase()===g:c.nodeType===1)&&++h){y&&((c[w]||(c[w]={}))[e]=[x,h]);if(c===t)break}return h-=i,h===r||h%r===0&&h/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||ut.error("unsupported pseudo: "+e);return r[w]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?st(function(e,n){var i,s=r(e,t),o=s.length;while(o--)i=P.call(e,s[o]),e[i]=!(n[i]=s[o])}):function(e){return r(e,0,n)}):r}},pseudos:{not:st(function(e){var t=[],n=[],r=u(e.replace(R,"$1"));return r[w]?st(function(e,t,n,i){var s,o=r(e,null,i,[]),u=e.length;while(u--)if(s=o[u])e[u]=!(t[u]=s)}):function(e,i,s){return t[0]=e,r(t,null,s,n),!n.pop()}}),has:st(function(e){return function(t){return ut(e,t).length>0}}),contains:st(function(e){return function(t){return(t.textContent||t.innerText||s(t)).indexOf(e)>-1}}),lang:st(function(e){return X.test(e||"")||ut.error("unsupported lang: "+e),e=e.replace(et,tt).toLowerCase(),function(t){var n;do if(n=p?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return n=n.toLowerCase(),n===e||n.indexOf(e+"-")===0;while((t=t.parentNode)&&t.nodeType===1);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===c.activeElement&&(!c.hasFocus||c.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&!!e.checked||t==="option"&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||e.nodeType===3||e.nodeType===4)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return G.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&e.type==="button"||t==="button"},text:function(e){var t;return e.nodeName.toLowerCase()==="input"&&e.type==="text"&&((t=e.getAttribute("type"))==null||t.toLowerCase()===e.type)},first:ct(function(){return[0]}),last:ct(function(e,t){return[t-1]}),eq:ct(function(e,t,n){return[n<0?n+t:n]}),even:ct(function(e,t){var n=0;for(;n<t;n+=2)e.push(n);return e}),odd:ct(function(e,t){var n=1;for(;n<t;n+=2)e.push(n);return e}),lt:ct(function(e,t,n){var r=n<0?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ct(function(e,t,n){var r=n<0?n+t:n;for(;++r<t;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})i.pseudos[n]=lt(n);u=ut.compile=function(e,t){var n,r=[],i=[],s=k[e+" "];if(!s){t||(t=ht(e)),n=t.length;while(n--)s=yt(t[n]),s[w]?r.push(s):i.push(s);s=k(e,bt(i,r))}return s},i.pseudos.nth=i.pseudos.eq,i.filters=St.prototype=i.pseudos,i.setFilters=new St,l(),ut.attr=b.attr,b.find=ut,b.expr=ut.selectors,b.expr[":"]=b.expr.pseudos,b.unique=ut.uniqueSort,b.text=ut.getText,b.isXMLDoc=ut.isXML,b.contains=ut.contains}(e);var ot=/Until$/,ut=/^(?:parents|prev(?:Until|All))/,at=/^.[^:#\[\.,]*$/,ft=b.expr.match.needsContext,lt={children:!0,contents:!0,next:!0,prev:!0};b.fn.extend({find:function(e){var t,n,r,i=this.length;if(typeof e!="string")return r=this,this.pushStack(b(e).filter(function(){for(t=0;t<i;t++)if(b.contains(r[t],this))return!0}));n=[];for(t=0;t<i;t++)b.find(e,this[t],n);return n=this.pushStack(i>1?b.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t,n=b(e,this),r=n.length;return this.filter(function(){for(t=0;t<r;t++)if(b.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ht(this,e,!1))},filter:function(e){return this.pushStack(ht(this,e,!0))},is:function(e){return!!e&&(typeof e=="string"?ft.test(e)?b(e,this.context).index(this[0])>=0:b.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,s=[],o=ft.test(e)||typeof e!="string"?b(e,t||this.context):0;for(;r<i;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&n.nodeType!==11){if(o?o.index(n)>-1:b.find.matchesSelector(n,e)){s.push(n);break}n=n.parentNode}}return this.pushStack(s.length>1?b.unique(s):s)},index:function(e){return e?typeof e=="string"?b.inArray(this[0],b(e)):b.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n=typeof e=="string"?b(e,t):b.makeArray(e&&e.nodeType?[e]:e),r=b.merge(this.get(),n);return this.pushStack(b.unique(r))},addBack:function(e){return this.add(e==null?this.prevObject:this.prevObject.filter(e))}}),b.fn.andSelf=b.fn.addBack,b.each({parent:function(e){var t=e.parentNode;return t&&t.nodeType!==11?t:null},parents:function(e){return b.dir(e,"parentNode")},parentsUntil:function(e,t,n){return b.dir(e,"parentNode",n)},next:function(e){return ct(e,"nextSibling")},prev:function(e){return ct(e,"previousSibling")},nextAll:function(e){return b.dir(e,"nextSibling")},prevAll:function(e){return b.dir(e,"previousSibling")},nextUntil:function(e,t,n){return b.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return b.dir(e,"previousSibling",n)},siblings:function(e){return b.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return b.sibling(e.firstChild)},contents:function(e){return b.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:b.merge([],e.childNodes)}},function(e,t){b.fn[e]=function(n,r){var i=b.map(this,t,n);return ot.test(e)||(r=n),r&&typeof r=="string"&&(i=b.filter(r,i)),i=this.length>1&&!lt[e]?b.unique(i):i,this.length>1&&ut.test(e)&&(i=i.reverse()),this.pushStack(i)}}),b.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),t.length===1?b.find.matchesSelector(t[0],e)?[t[0]]:[]:b.find.matches(e,t)},dir:function(e,n,r){var i=[],s=e[n];while(s&&s.nodeType!==9&&(r===t||s.nodeType!==1||!b(s).is(r)))s.nodeType===1&&i.push(s),s=s[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)e.nodeType===1&&e!==t&&n.push(e);return n}});var dt="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",vt=/ jQuery\d+="(?:null|\d+)"/g,mt=new RegExp("<(?:"+dt+")[\\s/>]","i"),gt=/^\s+/,yt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,wt=/<tbody/i,Et=/<|&#?\w+;/,St=/<(?:script|style|link)/i,xt=/^(?:checkbox|radio)$/i,Tt=/checked\s*(?:[^=]|=\s*.checked.)/i,Nt=/^$|\/(?:java|ecma)script/i,Ct=/^true\/(.*)/,kt=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Lt={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:b.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},At=pt(s),Ot=At.appendChild(s.createElement("div"));Lt.optgroup=Lt.option,Lt.tbody=Lt.tfoot=Lt.colgroup=Lt.caption=Lt.thead,Lt.th=Lt.td,b.fn.extend({text:function(e){return b.access(this,function(e){return e===t?b.text(this):this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(b.isFunction(e))return this.each(function(t){b(this).wrapAll(e.call(this,t))});if(this[0]){var t=b(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&e.firstChild.nodeType===1)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return b.isFunction(e)?this.each(function(t){b(this).wrapInner(e.call(this,t))}):this.each(function(){var t=b(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=b.isFunction(e);return this.each(function(n){b(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){b.nodeName(this,"body")||b(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11||this.nodeType===9)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11||this.nodeType===9)&&this.insertBefore(e,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=0;for(;(n=this[r])!=null;r++)if(!e||b.filter(e,[n]).length>0)!t&&n.nodeType===1&&b.cleanData(jt(n)),n.parentNode&&(t&&b.contains(n.ownerDocument,n)&&Pt(jt(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;(e=this[t])!=null;t++){e.nodeType===1&&b.cleanData(jt(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&b.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=e==null?!1:e,t=t==null?e:t,this.map(function(){return b.clone(this,e,t)})},html:function(e){return b.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return n.nodeType===1?n.innerHTML.replace(vt,""):t;if(typeof e=="string"&&!St.test(e)&&(b.support.htmlSerialize||!mt.test(e))&&(b.support.leadingWhitespace||!gt.test(e))&&!Lt[(bt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(yt,"<$1></$2>");try{for(;r<i;r++)n=this[r]||{},n.nodeType===1&&(b.cleanData(jt(n,!1)),n.innerHTML=e);n=0}catch(s){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){var t=b.isFunction(e);return!t&&typeof e!="string"&&(e=b(e).not(this).detach()),this.domManip([e],!0,function(e){var t=this.nextSibling,n=this.parentNode;n&&(b(this).remove(),n.insertBefore(e,t))})},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=h.apply([],e);var i,s,o,u,a,f,l=0,c=this.length,p=this,d=c-1,v=e[0],m=b.isFunction(v);if(m||!(c<=1||typeof v!="string"||b.support.checkClone||!Tt.test(v)))return this.each(function(i){var s=p.eq(i);m&&(e[0]=v.call(this,i,n?s.html():t)),s.domManip(e,n,r)});if(c){f=b.buildFragment(e,this[0].ownerDocument,!1,this),i=f.firstChild,f.childNodes.length===1&&(f=i);if(i){n=n&&b.nodeName(i,"tr"),u=b.map(jt(f,"script"),_t),o=u.length;for(;l<c;l++)s=f,l!==d&&(s=b.clone(s,!0,!0),o&&b.merge(u,jt(s,"script"))),r.call(n&&b.nodeName(this[l],"table")?Mt(this[l],"tbody"):this[l],s,l);if(o){a=u[u.length-1].ownerDocument,b.map(u,Dt);for(l=0;l<o;l++)s=u[l],Nt.test(s.type||"")&&!b._data(s,"globalEval")&&b.contains(a,s)&&(s.src?b.ajax({url:s.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):b.globalEval((s.text||s.textContent||s.innerHTML||"").replace(kt,"")))}f=i=null}}return this}}),b.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){b.fn[e]=function(e){var n,r=0,i=[],s=b(e),o=s.length-1;for(;r<=o;r++)n=r===o?this:this.clone(!0),b(s[r])[t](n),p.apply(i,n.get());return this.pushStack(i)}}),b.extend({clone:function(e,t,n){var r,i,s,o,u,a=b.contains(e.ownerDocument,e);b.support.html5Clone||b.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?s=e.cloneNode(!0):(Ot.innerHTML=e.outerHTML,Ot.removeChild(s=Ot.firstChild));if((!b.support.noCloneEvent||!b.support.noCloneChecked)&&(e.nodeType===1||e.nodeType===11)&&!b.isXMLDoc(e)){r=jt(s),u=jt(e);for(o=0;(i=u[o])!=null;++o)r[o]&&Bt(i,r[o])}if(t)if(n){u=u||jt(e),r=r||jt(s);for(o=0;(i=u[o])!=null;o++)Ht(i,r[o])}else Ht(e,s);return r=jt(s,"script"),r.length>0&&Pt(r,!a&&jt(e,"script")),r=u=i=null,s},buildFragment:function(e,t,n,r){var i,s,o,u,a,f,l,c=e.length,h=pt(t),p=[],d=0;for(;d<c;d++){s=e[d];if(s||s===0)if(b.type(s)==="object")b.merge(p,s.nodeType?[s]:s);else if(!Et.test(s))p.push(t.createTextNode(s));else{u=u||h.appendChild(t.createElement("div")),a=(bt.exec(s)||["",""])[1].toLowerCase(),l=Lt[a]||Lt._default,u.innerHTML=l[1]+s.replace(yt,"<$1></$2>")+l[2],i=l[0];while(i--)u=u.lastChild;!b.support.leadingWhitespace&&gt.test(s)&&p.push(t.createTextNode(gt.exec(s)[0]));if(!b.support.tbody){s=a==="table"&&!wt.test(s)?u.firstChild:l[1]==="<table>"&&!wt.test(s)?u:0,i=s&&s.childNodes.length;while(i--)b.nodeName(f=s.childNodes[i],"tbody")&&!f.childNodes.length&&s.removeChild(f)}b.merge(p,u.childNodes),u.textContent="";while(u.firstChild)u.removeChild(u.firstChild);u=h.lastChild}}u&&h.removeChild(u),b.support.appendChecked||b.grep(jt(p,"input"),Ft),d=0;while(s=p[d++]){if(r&&b.inArray(s,r)!==-1)continue;o=b.contains(s.ownerDocument,s),u=jt(h.appendChild(s),"script"),o&&Pt(u);if(n){i=0;while(s=u[i++])Nt.test(s.type||"")&&n.push(s)}}return u=null,h},cleanData:function(e,t){var n,r,s,o,u=0,a=b.expando,f=b.cache,c=b.support.deleteExpando,h=b.event.special;for(;(n=e[u])!=null;u++)if(t||b.acceptData(n)){s=n[a],o=s&&f[s];if(o){if(o.events)for(r in o.events)h[r]?b.event.remove(n,r):b.removeEvent(n,r,o.handle);f[s]&&(delete f[s],c?delete n[a]:typeof n.removeAttribute!==i?n.removeAttribute(a):n[a]=null,l.push(s))}}}});var It,qt,Rt,Ut=/alpha\([^)]*\)/i,zt=/opacity\s*=\s*([^)]*)/,Wt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Vt=/^margin/,$t=new RegExp("^("+w+")(.*)$","i"),Jt=new RegExp("^("+w+")(?!px)[a-z%]+$","i"),Kt=new RegExp("^([+-])=("+w+")","i"),Qt={BODY:"block"},Gt={position:"absolute",visibility:"hidden",display:"block"},Yt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];b.fn.extend({css:function(e,n){return b.access(this,function(e,n,r){var i,s,o={},u=0;if(b.isArray(n)){s=qt(e),i=n.length;for(;u<i;u++)o[n[u]]=b.css(e,n[u],!1,s);return o}return r!==t?b.style(e,n,r):b.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){var t=typeof e=="boolean";return this.each(function(){(t?e:nn(this))?b(this).show():b(this).hide()})}}),b.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Rt(e,"opacity");return n===""?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":b.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(!e||e.nodeType===3||e.nodeType===8||!e.style)return;var s,o,u,a=b.camelCase(n),f=e.style;n=b.cssProps[a]||(b.cssProps[a]=tn(f,a)),u=b.cssHooks[n]||b.cssHooks[a];if(r===t)return u&&"get"in u&&(s=u.get(e,!1,i))!==t?s:f[n];o=typeof r,o==="string"&&(s=Kt.exec(r))&&(r=(s[1]+1)*s[2]+parseFloat(b.css(e,n)),o="number");if(r==null||o==="number"&&isNaN(r))return;o==="number"&&!b.cssNumber[a]&&(r+="px"),!b.support.clearCloneStyle&&r===""&&n.indexOf("background")===0&&(f[n]="inherit");if(!u||!("set"in u)||(r=u.set(e,r,i))!==t)try{f[n]=r}catch(l){}},css:function(e,n,r,i){var s,o,u,a=b.camelCase(n);return n=b.cssProps[a]||(b.cssProps[a]=tn(e.style,a)),u=b.cssHooks[n]||b.cssHooks[a],u&&"get"in u&&(o=u.get(e,!0,r)),o===t&&(o=Rt(e,n,i)),o==="normal"&&n in Yt&&(o=Yt[n]),r===""||r?(s=parseFloat(o),r===!0||b.isNumeric(s)?s||0:o):o},swap:function(e,t,n,r){var i,s,o={};for(s in t)o[s]=e.style[s],e.style[s]=t[s];i=n.apply(e,r||[]);for(s in t)e.style[s]=o[s];return i}}),e.getComputedStyle?(qt=function(t){return e.getComputedStyle(t,null)},Rt=function(e,n,r){var i,s,o,u=r||qt(e),a=u?u.getPropertyValue(n)||u[n]:t,f=e.style;return u&&(a===""&&!b.contains(e.ownerDocument,e)&&(a=b.style(e,n)),Jt.test(a)&&Vt.test(n)&&(i=f.width,s=f.minWidth,o=f.maxWidth,f.minWidth=f.maxWidth=f.width=a,a=u.width,f.width=i,f.minWidth=s,f.maxWidth=o)),a}):s.documentElement.currentStyle&&(qt=function(e){return e.currentStyle},Rt=function(e,n,r){var i,s,o,u=r||qt(e),a=u?u[n]:t,f=e.style;return a==null&&f&&f[n]&&(a=f[n]),Jt.test(a)&&!Wt.test(n)&&(i=f.left,s=e.runtimeStyle,o=s&&s.left,o&&(s.left=e.currentStyle.left),f.left=n==="fontSize"?"1em":a,a=f.pixelLeft+"px",f.left=i,o&&(s.left=o)),a===""?"auto":a}),b.each(["height","width"],function(e,t){b.cssHooks[t]={get:function(e,n,r){if(n)return e.offsetWidth===0&&Xt.test(b.css(e,"display"))?b.swap(e,Gt,function(){return un(e,t,r)}):un(e,t,r)},set:function(e,n,r){var i=r&&qt(e);return sn(e,n,r?on(e,t,r,b.support.boxSizing&&b.css(e,"boxSizing",!1,i)==="border-box",i):0)}}}),b.support.opacity||(b.cssHooks.opacity={get:function(e,t){return zt.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=b.isNumeric(t)?"alpha(opacity="+t*100+")":"",s=r&&r.filter||n.filter||"";n.zoom=1;if((t>=1||t==="")&&b.trim(s.replace(Ut,""))===""&&n.removeAttribute){n.removeAttribute("filter");if(t===""||r&&!r.filter)return}n.filter=Ut.test(s)?s.replace(Ut,i):s+" "+i}}),b(function(){b.support.reliableMarginRight||(b.cssHooks.marginRight={get:function(e,t){if(t)return b.swap(e,{display:"inline-block"},Rt,[e,"marginRight"])}}),!b.support.pixelPosition&&b.fn.position&&b.each(["top","left"],function(e,t){b.cssHooks[t]={get:function(e,n){if(n)return n=Rt(e,t),Jt.test(n)?b(e).position()[t]+"px":n}}})}),b.expr&&b.expr.filters&&(b.expr.filters.hidden=function(e){return e.offsetWidth<=0&&e.offsetHeight<=0||!b.support.reliableHiddenOffsets&&(e.style&&e.style.display||b.css(e,"display"))==="none"},b.expr.filters.visible=function(e){return!b.expr.filters.hidden(e)}),b.each({margin:"",padding:"",border:"Width"},function(e,t){b.cssHooks[e+t]={expand:function(n){var r=0,i={},s=typeof n=="string"?n.split(" "):[n];for(;r<4;r++)i[e+Zt[r]+t]=s[r]||s[r-2]||s[0];return i}},Vt.test(e)||(b.cssHooks[e+t].set=sn)});var ln=/%20/g,cn=/\[\]$/,hn=/\r?\n/g,pn=/^(?:submit|button|image|reset|file)$/i,dn=/^(?:input|select|textarea|keygen)/i;b.fn.extend({serialize:function(){return b.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=b.prop(this,"elements");return e?b.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!b(this).is(":disabled")&&dn.test(this.nodeName)&&!pn.test(e)&&(this.checked||!xt.test(e))}).map(function(e,t){var n=b(this).val();return n==null?null:b.isArray(n)?b.map(n,function(e){return{name:t.name,value:e.replace(hn,"\r\n")}}):{name:t.name,value:n.replace(hn,"\r\n")}}).get()}}),b.param=function(e,n){var r,i=[],s=function(e,t){t=b.isFunction(t)?t():t==null?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};n===t&&(n=b.ajaxSettings&&b.ajaxSettings.traditional);if(b.isArray(e)||e.jquery&&!b.isPlainObject(e))b.each(e,function(){s(this.name,this.value)});else for(r in e)vn(r,e[r],n,s);return i.join("&").replace(ln,"+")},b.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){b.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),b.fn.hover=function(e,t){return this.mouseenter(e).mouseleave(t||e)};var mn,gn,yn=b.now(),bn=/\?/,wn=/#.*$/,En=/([?&])_=[^&]*/,Sn=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,xn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Tn=/^(?:GET|HEAD)$/,Nn=/^\/\//,Cn=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,kn=b.fn.load,Ln={},An={},On="*/".concat("*");try{gn=o.href}catch(Mn){gn=s.createElement("a"),gn.href="",gn=gn.href}mn=Cn.exec(gn.toLowerCase())||[],b.fn.load=function(e,n,r){if(typeof e!="string"&&kn)return kn.apply(this,arguments);var i,s,o,u=this,a=e.indexOf(" ");return a>=0&&(i=e.slice(a,e.length),e=e.slice(0,a)),b.isFunction(n)?(r=n,n=t):n&&typeof n=="object"&&(o="POST"),u.length>0&&b.ajax({url:e,type:o,dataType:"html",data:n}).done(function(e){s=arguments,u.html(i?b("<div>").append(b.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){u.each(r,s||[e.responseText,t,e])}),this},b.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){b.fn[t]=function(e){return this.on(t,e)}}),b.each(["get","post"],function(e,n){b[n]=function(e,r,i,s){return b.isFunction(r)&&(s=s||i,i=r,r=t),b.ajax({url:e,type:n,dataType:s,data:r,success:i})}}),b.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:gn,type:"GET",isLocal:xn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":On,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":b.parseJSON,"text xml":b.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Pn(Pn(e,b.ajaxSettings),t):Pn(b.ajaxSettings,e)},ajaxPrefilter:_n(Ln),ajaxTransport:_n(An),ajax:function(e,n){function N(e,n,r,i){var l,g,y,E,S,T=n;if(w===2)return;w=2,u&&clearTimeout(u),f=t,o=i||"",x.readyState=e>0?4:0,r&&(E=Hn(c,x,r));if(e>=200&&e<300||e===304)c.ifModified&&(S=x.getResponseHeader("Last-Modified"),S&&(b.lastModified[s]=S),S=x.getResponseHeader("etag"),S&&(b.etag[s]=S)),e===204?(l=!0,T="nocontent"):e===304?(l=!0,T="notmodified"):(l=Bn(c,E),T=l.state,g=l.data,y=l.error,l=!y);else{y=T;if(e||!T)T="error",e<0&&(e=0)}x.status=e,x.statusText=(n||T)+"",l?d.resolveWith(h,[g,T,x]):d.rejectWith(h,[x,T,y]),x.statusCode(m),m=t,a&&p.trigger(l?"ajaxSuccess":"ajaxError",[x,c,l?g:y]),v.fireWith(h,[x,T]),a&&(p.trigger("ajaxComplete",[x,c]),--b.active||b.event.trigger("ajaxStop"))}typeof e=="object"&&(n=e,e=t),n=n||{};var r,i,s,o,u,a,f,l,c=b.ajaxSetup({},n),h=c.context||c,p=c.context&&(h.nodeType||h.jquery)?b(h):b.event,d=b.Deferred(),v=b.Callbacks("once memory"),m=c.statusCode||{},g={},y={},w=0,S="canceled",x={readyState:0,getResponseHeader:function(e){var t;if(w===2){if(!l){l={};while(t=Sn.exec(o))l[t[1].toLowerCase()]=t[2]}t=l[e.toLowerCase()]}return t==null?null:t},getAllResponseHeaders:function(){return w===2?o:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return w||(e=y[n]=y[n]||e,g[e]=t),this},overrideMimeType:function(e){return w||(c.mimeType=e),this},statusCode:function(e){var t;if(e)if(w<2)for(t in e)m[t]=[m[t],e[t]];else x.always(e[x.status]);return this},abort:function(e){var t=e||S;return f&&f.abort(t),N(0,t),this}};d.promise(x).complete=v.add,x.success=x.done,x.error=x.fail,c.url=((e||c.url||gn)+"").replace(wn,"").replace(Nn,mn[1]+"//"),c.type=n.method||n.type||c.method||c.type,c.dataTypes=b.trim(c.dataType||"*").toLowerCase().match(E)||[""],c.crossDomain==null&&(r=Cn.exec(c.url.toLowerCase()),c.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||(r[1]==="http:"?80:443))==(mn[3]||(mn[1]==="http:"?80:443)))),c.data&&c.processData&&typeof c.data!="string"&&(c.data=b.param(c.data,c.traditional)),Dn(Ln,c,n,x);if(w===2)return x;a=c.global,a&&b.active++===0&&b.event.trigger("ajaxStart"),c.type=c.type.toUpperCase(),c.hasContent=!Tn.test(c.type),s=c.url,c.hasContent||(c.data&&(s=c.url+=(bn.test(s)?"&":"?")+c.data,delete c.data),c.cache===!1&&(c.url=En.test(s)?s.replace(En,"$1_="+yn++):s+(bn.test(s)?"&":"?")+"_="+yn++)),c.ifModified&&(b.lastModified[s]&&x.setRequestHeader("If-Modified-Since",b.lastModified[s]),b.etag[s]&&x.setRequestHeader("If-None-Match",b.etag[s])),(c.data&&c.hasContent&&c.contentType!==!1||n.contentType)&&x.setRequestHeader("Content-Type",c.contentType),x.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+(c.dataTypes[0]!=="*"?", "+On+"; q=0.01":""):c.accepts["*"]);for(i in c.headers)x.setRequestHeader(i,c.headers[i]);if(!c.beforeSend||c.beforeSend.call(h,x,c)!==!1&&w!==2){S="abort";for(i in{success:1,error:1,complete:1})x[i](c[i]);f=Dn(An,c,n,x);if(!f)N(-1,"No Transport");else{x.readyState=1,a&&p.trigger("ajaxSend",[x,c]),c.async&&c.timeout>0&&(u=setTimeout(function(){x.abort("timeout")},c.timeout));try{w=1,f.send(g,N)}catch(T){if(!(w<2))throw T;N(-1,T)}}return x}return x.abort()},getScript:function(e,n){return b.get(e,t,n,"script")},getJSON:function(e,t,n){return b.get(e,t,n,"json")}}),b.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return b.globalEval(e),e}}}),b.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),b.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=s.head||b("head")[0]||s.documentElement;return{send:function(t,i){n=s.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){if(t||!n.readyState||/loaded|complete/.test(n.readyState))n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success")},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var jn=[],Fn=/(=)\?(?=&|$)|\?\?/;b.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=jn.pop()||b.expando+"_"+yn++;return this[e]=!0,e}}),b.ajaxPrefilter("json jsonp",function(n,r,i){var s,o,u,a=n.jsonp!==!1&&(Fn.test(n.url)?"url":typeof n.data=="string"&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Fn.test(n.data)&&"data");if(a||n.dataTypes[0]==="jsonp")return s=n.jsonpCallback=b.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,a?n[a]=n[a].replace(Fn,"$1"+s):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+s),n.converters["script json"]=function(){return u||b.error(s+" was not called"),u[0]},n.dataTypes[0]="json",o=e[s],e[s]=function(){u=arguments},i.always(function(){e[s]=o,n[s]&&(n.jsonpCallback=r.jsonpCallback,jn.push(s)),u&&b.isFunction(o)&&o(u[0]),u=o=t}),"script"});var In,qn,Rn=0,Un=e.ActiveXObject&&function(){var e;for(e in In)In[e](t,!0)};b.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&zn()||Wn()}:zn,qn=b.ajaxSettings.xhr(),b.support.cors=!!qn&&"withCredentials"in qn,qn=b.support.ajax=!!qn,qn&&b.ajaxTransport(function(n){if(!n.crossDomain||b.support.cors){var r;return{send:function(i,s){var o,u,a=n.xhr();n.username?a.open(n.type,n.url,n.async,n.username,n.password):a.open(n.type,n.url,n.async);if(n.xhrFields)for(u in n.xhrFields)a[u]=n.xhrFields[u];n.mimeType&&a.overrideMimeType&&a.overrideMimeType(n.mimeType),!n.crossDomain&&!i["X-Requested-With"]&&(i["X-Requested-With"]="XMLHttpRequest");try{for(u in i)a.setRequestHeader(u,i[u])}catch(f){}a.send(n.hasContent&&n.data||null),r=function(e,i){var u,f,l,c;try{if(r&&(i||a.readyState===4)){r=t,o&&(a.onreadystatechange=b.noop,Un&&delete In[o]);if(i)a.readyState!==4&&a.abort();else{c={},u=a.status,f=a.getAllResponseHeaders(),typeof a.responseText=="string"&&(c.text=a.responseText);try{l=a.statusText}catch(h){l=""}!u&&n.isLocal&&!n.crossDomain?u=c.text?200:404:u===1223&&(u=204)}}}catch(p){i||s(-1,p)}c&&s(u,l,c,f)},n.async?a.readyState===4?setTimeout(r):(o=++Rn,Un&&(In||(In={},b(e).unload(Un)),In[o]=r),a.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Vn,$n=/^(?:toggle|show|hide)$/,Jn=new RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Kn=/queueHooks$/,Qn=[nr],Gn={"*":[function(e,t){var n,r,i=this.createTween(e,t),s=Jn.exec(t),o=i.cur(),u=+o||0,a=1,f=20;if(s){n=+s[2],r=s[3]||(b.cssNumber[e]?"":"px");if(r!=="px"&&u){u=b.css(i.elem,e,!0)||n||1;do a=a||".5",u/=a,b.style(i.elem,e,u+r);while(a!==(a=i.cur()/o)&&a!==1&&--f)}i.unit=r,i.start=u,i.end=s[1]?u+(s[1]+1)*n:n}return i}]};b.Animation=b.extend(er,{tweener:function(e,t){b.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;r<i;r++)n=e[r],Gn[n]=Gn[n]||[],Gn[n].unshift(t)},prefilter:function(e,t){t?Qn.unshift(e):Qn.push(e)}}),b.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,s){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=s||(b.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.options.duration?this.pos=t=b.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return e.elem[e.prop]==null||!!e.elem.style&&e.elem.style[e.prop]!=null?(t=b.css(e.elem,e.prop,""),!t||t==="auto"?0:t):e.elem[e.prop]},set:function(e){b.fx.step[e.prop]?b.fx.step[e.prop](e):e.elem.style&&(e.elem.style[b.cssProps[e.prop]]!=null||b.cssHooks[e.prop])?b.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},b.each(["toggle","show","hide"],function(e,t){var n=b.fn[t];b.fn[t]=function(e,r,i){return e==null||typeof e=="boolean"?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),b.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=b.isEmptyObject(e),s=b.speed(t,n,r),o=function(){var t=er(this,b.extend({},e),s);o.finish=function(){t.stop(!0)},(i||b._data(this,"finish"))&&t.stop(!0)};return o.finish=o,i||s.queue===!1?this.each(o):this.queue(s.queue,o)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return typeof e!="string"&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=e!=null&&e+"queueHooks",s=b.timers,o=b._data(this);if(n)o[n]&&o[n].stop&&i(o[n]);else for(n in o)o[n]&&o[n].stop&&Kn.test(n)&&i(o[n]);for(n=s.length;n--;)s[n].elem===this&&(e==null||s[n].queue===e)&&(s[n].anim.stop(r),t=!1,s.splice(n,1));(t||!r)&&b.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=b._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],s=b.timers,o=r?r.length:0;n.finish=!0,b.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this);for(t=s.length;t--;)s[t].elem===this&&s[t].queue===e&&(s[t].anim.stop(!0),s.splice(t,1));for(t=0;t<o;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),b.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){b.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),b.speed=function(e,t,n){var r=e&&typeof e=="object"?b.extend({},e):{complete:n||!n&&t||b.isFunction(e)&&e,duration:e,easing:n&&t||t&&!b.isFunction(t)&&t};r.duration=b.fx.off?0:typeof r.duration=="number"?r.duration:r.duration in b.fx.speeds?b.fx.speeds[r.duration]:b.fx.speeds._default;if(r.queue==null||r.queue===!0)r.queue="fx";return r.old=r.complete,r.complete=function(){b.isFunction(r.old)&&r.old.call(this),r.queue&&b.dequeue(this,r.queue)},r},b.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},b.timers=[],b.fx=rr.prototype.init,b.fx.tick=function(){var e,n=b.timers,r=0;Xn=b.now();for(;r<n.length;r++)e=n[r],!e()&&n[r]===e&&n.splice(r--,1);n.length||b.fx.stop(),Xn=t},b.fx.timer=function(e){e()&&b.timers.push(e)&&b.fx.start()},b.fx.interval=13,b.fx.start=function(){Vn||(Vn=setInterval(b.fx.tick,b.fx.interval))},b.fx.stop=function(){clearInterval(Vn),Vn=null},b.fx.speeds={slow:600,fast:200,_default:400},b.fx.step={},b.expr&&b.expr.filters&&(b.expr.filters.animated=function(e){return b.grep(b.timers,function(t){return e===t.elem}).length}),b.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){b.offset.setOffset(this,e,t)});var n,r,s={top:0,left:0},o=this[0],u=o&&o.ownerDocument;if(!u)return;return n=u.documentElement,b.contains(n,o)?(typeof o.getBoundingClientRect!==i&&(s=o.getBoundingClientRect()),r=sr(u),{top:s.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:s.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):s},b.offset={setOffset:function(e,t,n){var r=b.css(e,"position");r==="static"&&(e.style.position="relative");var i=b(e),s=i.offset(),o=b.css(e,"top"),u=b.css(e,"left"),a=(r==="absolute"||r==="fixed")&&b.inArray("auto",[o,u])>-1,f={},l={},c,h;a?(l=i.position(),c=l.top,h=l.left):(c=parseFloat(o)||0,h=parseFloat(u)||0),b.isFunction(t)&&(t=t.call(e,n,s)),t.top!=null&&(f.top=t.top-s.top+c),t.left!=null&&(f.left=t.left-s.left+h),"using"in t?t.using.call(e,f):i.css(f)}},b.fn.extend({position:function(){if(!this[0])return;var e,t,n={top:0,left:0},r=this[0];return b.css(r,"position")==="fixed"?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),b.nodeName(e[0],"html")||(n=e.offset()),n.top+=b.css(e[0],"borderTopWidth",!0),n.left+=b.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-b.css(r,"marginTop",!0),left:t.left-n.left-b.css(r,"marginLeft",!0)}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s.documentElement;while(e&&!b.nodeName(e,"html")&&b.css(e,"position")==="static")e=e.offsetParent;return e||s.documentElement})}}),b.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);b.fn[e]=function(i){return b.access(this,function(e,i,s){var o=sr(e);if(s===t)return o?n in o?o[n]:o.document.documentElement[i]:e[i];o?o.scrollTo(r?b(o).scrollLeft():s,r?s:b(o).scrollTop()):e[i]=s},e,i,arguments.length,null)}}),b.each({Height:"height",Width:"width"},function(e,n){b.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){b.fn[i]=function(i,s){var o=arguments.length&&(r||typeof i!="boolean"),u=r||(i===!0||s===!0?"margin":"border");return b.access(this,function(n,r,i){var s;return b.isWindow(n)?n.document.documentElement["client"+e]:n.nodeType===9?(s=n.documentElement,Math.max(n.body["scroll"+e],s["scroll"+e],n.body["offset"+e],s["offset"+e],s["client"+e])):i===t?b.css(n,r,u):b.style(n,r,i,u)},n,o?i:t,o,null)}})}),e.jQuery=e.$=b}(window),jQuery.noConflict(!0)});
\ No newline at end of file
diff --git a/public/js/jquery_timely20.js b/public/js/jquery_timely20.js
new file mode 100644
index 0000000..ed18186
--- /dev/null
+++ b/public/js/jquery_timely20.js
@@ -0,0 +1,26 @@
+/*!
+	 * jQuery JavaScript Library v2.0.0
+	 * http://jquery.com/
+	 *
+	 * Includes Sizzle.js
+	 * http://sizzlejs.com/
+	 *
+	 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
+	 * Released under the MIT license
+	 * http://jquery.org/license
+	 *
+	 * Date: 2013-04-18
+	 */
+
+/*!
+	 * Sizzle CSS Selector Engine v1.9.2-pre
+	 * http://sizzlejs.com/
+	 *
+	 * Copyright 2013 jQuery Foundation, Inc. and other contributors
+	 * Released under the MIT license
+	 * http://jquery.org/license
+	 *
+	 * Date: 2013-04-16
+	 */
+
+timely.define("jquery_timely",[],function(){return function(window,undefined){function isArraylike(e){var t=e.length,n=jQuery.type(e);return jQuery.isWindow(e)?!1:e.nodeType===1&&t?!0:n==="array"||n!=="function"&&(t===0||typeof t=="number"&&t>0&&t-1 in e)}function createOptions(e){var t=optionsCache[e]={};return jQuery.each(e.match(core_rnotwhite)||[],function(e,n){t[n]=!0}),t}function Data(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=jQuery.expando+Math.random()}function dataAttr(e,t,n){var r;if(n===undefined&&e.nodeType===1){r="data-"+t.replace(rmultiDash,"-$1").toLowerCase(),n=e.getAttribute(r);if(typeof n=="string"){try{n=n==="true"?!0:n==="false"?!1:n==="null"?null:+n+""===n?+n:rbrace.test(n)?JSON.parse(n):n}catch(i){}data_user.set(e,t,n)}else n=undefined}return n}function returnTrue(){return!0}function returnFalse(){return!1}function safeActiveElement(){try{return document.activeElement}catch(e){}}function sibling(e,t){while((e=e[t])&&e.nodeType!==1);return e}function winnow(e,t,n){if(jQuery.isFunction(t))return jQuery.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return jQuery.grep(e,function(e){return e===t!==n});if(typeof t=="string"){if(isSimple.test(t))return jQuery.filter(t,e,n);t=jQuery.filter(t,e)}return jQuery.grep(e,function(e){return core_indexOf.call(t,e)>=0!==n})}function manipulationTarget(e,t){return jQuery.nodeName(e,"table")&&jQuery.nodeName(t.nodeType===1?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function disableScript(e){return e.type=(e.getAttribute("type")!==null)+"/"+e.type,e}function restoreScript(e){var t=rscriptTypeMasked.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function setGlobalEval(e,t){var n=e.length,r=0;for(;r<n;r++)data_priv.set(e[r],"globalEval",!t||data_priv.get(t[r],"globalEval"))}function cloneCopyEvent(e,t){var n,r,i,s,o,u,a,f;if(t.nodeType!==1)return;if(data_priv.hasData(e)){s=data_priv.access(e),o=jQuery.extend({},s),f=s.events,data_priv.set(t,o);if(f){delete o.handle,o.events={};for(i in f)for(n=0,r=f[i].length;n<r;n++)jQuery.event.add(t,i,f[i][n])}}data_user.hasData(e)&&(u=data_user.access(e),a=jQuery.extend({},u),data_user.set(t,a))}function getAll(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return t===undefined||t&&jQuery.nodeName(e,t)?jQuery.merge([e],n):n}function fixInput(e,t){var n=t.nodeName.toLowerCase();if(n==="input"&&manipulation_rcheckableType.test(e.type))t.checked=e.checked;else if(n==="input"||n==="textarea")t.defaultValue=e.defaultValue}function vendorPropName(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=cssPrefixes.length;while(i--){t=cssPrefixes[i]+n;if(t in e)return t}return r}function isHidden(e,t){return e=t||e,jQuery.css(e,"display")==="none"||!jQuery.contains(e.ownerDocument,e)}function getStyles(e){return window.getComputedStyle(e,null)}function showHide(e,t){var n,r,i,s=[],o=0,u=e.length;for(;o<u;o++){r=e[o];if(!r.style)continue;s[o]=data_priv.get(r,"olddisplay"),n=r.style.display,t?(!s[o]&&n==="none"&&(r.style.display=""),r.style.display===""&&isHidden(r)&&(s[o]=data_priv.access(r,"olddisplay",css_defaultDisplay(r.nodeName)))):s[o]||(i=isHidden(r),(n&&n!=="none"||!i)&&data_priv.set(r,"olddisplay",i?n:jQuery.css(r,"display")))}for(o=0;o<u;o++){r=e[o];if(!r.style)continue;if(!t||r.style.display==="none"||r.style.display==="")r.style.display=t?s[o]||"":"none"}return e}function setPositiveNumber(e,t,n){var r=rnumsplit.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function augmentWidthOrHeight(e,t,n,r,i){var s=n===(r?"border":"content")?4:t==="width"?1:0,o=0;for(;s<4;s+=2)n==="margin"&&(o+=jQuery.css(e,n+cssExpand[s],!0,i)),r?(n==="content"&&(o-=jQuery.css(e,"padding"+cssExpand[s],!0,i)),n!=="margin"&&(o-=jQuery.css(e,"border"+cssExpand[s]+"Width",!0,i))):(o+=jQuery.css(e,"padding"+cssExpand[s],!0,i),n!=="padding"&&(o+=jQuery.css(e,"border"+cssExpand[s]+"Width",!0,i)));return o}function getWidthOrHeight(e,t,n){var r=!0,i=t==="width"?e.offsetWidth:e.offsetHeight,s=getStyles(e),o=jQuery.support.boxSizing&&jQuery.css(e,"boxSizing",!1,s)==="border-box";if(i<=0||i==null){i=curCSS(e,t,s);if(i<0||i==null)i=e.style[t];if(rnumnonpx.test(i))return i;r=o&&(jQuery.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+augmentWidthOrHeight(e,t,n||(o?"border":"content"),r,s)+"px"}function css_defaultDisplay(e){var t=document,n=elemdisplay[e];if(!n){n=actualDisplay(e,t);if(n==="none"||!n)iframe=(iframe||jQuery("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(iframe[0].contentWindow||iframe[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=actualDisplay(e,t),iframe.detach();elemdisplay[e]=n}return n}function actualDisplay(e,t){var n=jQuery(t.createElement(e)).appendTo(t.body),r=jQuery.css(n[0],"display");return n.remove(),r}function buildParams(e,t,n,r){var i;if(jQuery.isArray(t))jQuery.each(t,function(t,i){n||rbracket.test(e)?r(e,i):buildParams(e+"["+(typeof i=="object"?t:"")+"]",i,n,r)});else if(!n&&jQuery.type(t)==="object")for(i in t)buildParams(e+"["+i+"]",t[i],n,r);else r(e,t)}function addToPrefiltersOrTransports(e){return function(t,n){typeof t!="string"&&(n=t,t="*");var r,i=0,s=t.toLowerCase().match(core_rnotwhite)||[];if(jQuery.isFunction(n))while(r=s[i++])r[0]==="+"?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function inspectPrefiltersOrTransports(e,t,n,r){function o(u){var a;return i[u]=!0,jQuery.each(e[u]||[],function(e,u){var f=u(t,n,r);if(typeof f=="string"&&!s&&!i[f])return t.dataTypes.unshift(f),o(f),!1;if(s)return!(a=f)}),a}var i={},s=e===transports;return o(t.dataTypes[0])||!i["*"]&&o("*")}function ajaxExtend(e,t){var n,r,i=jQuery.ajaxSettings.flatOptions||{};for(n in t)t[n]!==undefined&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&jQuery.extend(!0,e,r),e}function ajaxHandleResponses(e,t,n){var r,i,s,o,u=e.contents,a=e.dataTypes;while(a[0]==="*")a.shift(),r===undefined&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in u)if(u[i]&&u[i].test(r)){a.unshift(i);break}if(a[0]in n)s=a[0];else{for(i in n){if(!a[0]||e.converters[i+" "+a[0]]){s=i;break}o||(o=i)}s=s||o}if(s)return s!==a[0]&&a.unshift(s),n[s]}function ajaxConvert(e,t,n,r){var i,s,o,u,a,f={},l=e.dataTypes.slice();if(l[1])for(o in e.converters)f[o.toLowerCase()]=e.converters[o];s=l.shift();while(s){e.responseFields[s]&&(n[e.responseFields[s]]=t),!a&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),a=s,s=l.shift();if(s)if(s==="*")s=a;else if(a!=="*"&&a!==s){o=f[a+" "+s]||f["* "+s];if(!o)for(i in f){u=i.split(" ");if(u[1]===s){o=f[a+" "+u[0]]||f["* "+u[0]];if(o){o===!0?o=f[i]:f[i]!==!0&&(s=u[0],l.unshift(u[1]));break}}}if(o!==!0)if(o&&e["throws"])t=o(t);else try{t=o(t)}catch(c){return{state:"parsererror",error:o?c:"No conversion from "+a+" to "+s}}}}return{state:"success",data:t}}function createFxNow(){return setTimeout(function(){fxNow=undefined}),fxNow=jQuery.now()}function createTweens(e,t){jQuery.each(t,function(t,n){var r=(tweeners[t]||[]).concat(tweeners["*"]),i=0,s=r.length;for(;i<s;i++)if(r[i].call(e,t,n))return})}function Animation(e,t,n){var r,i,s=0,o=animationPrefilters.length,u=jQuery.Deferred().always(function(){delete a.elem}),a=function(){if(i)return!1;var t=fxNow||createFxNow(),n=Math.max(0,f.startTime+f.duration-t),r=n/f.duration||0,s=1-r,o=0,a=f.tweens.length;for(;o<a;o++)f.tweens[o].run(s);return u.notifyWith(e,[f,s,n]),s<1&&a?n:(u.resolveWith(e,[f]),!1)},f=u.promise({elem:e,props:jQuery.extend({},t),opts:jQuery.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:fxNow||createFxNow(),duration:n.duration,tweens:[],createTween:function(t,n){var r=jQuery.Tween(e,f.opts,t,n,f.opts.specialEasing[t]||f.opts.easing);return f.tweens.push(r),r},stop:function(t){var n=0,r=t?f.tweens.length:0;if(i)return this;i=!0;for(;n<r;n++)f.tweens[n].run(1);return t?u.resolveWith(e,[f,t]):u.rejectWith(e,[f,t]),this}}),l=f.props;propFilter(l,f.opts.specialEasing);for(;s<o;s++){r=animationPrefilters[s].call(f,e,l,f.opts);if(r)return r}return createTweens(f,l),jQuery.isFunction(f.opts.start)&&f.opts.start.call(e,f),jQuery.fx.timer(jQuery.extend(a,{elem:e,anim:f,queue:f.opts.queue})),f.progress(f.opts.progress).done(f.opts.done,f.opts.complete).fail(f.opts.fail).always(f.opts.always)}function propFilter(e,t){var n,r,i,s,o;for(n in e){r=jQuery.camelCase(n),i=t[r],s=e[n],jQuery.isArray(s)&&(i=s[1],s=e[n]=s[0]),n!==r&&(e[r]=s,delete e[n]),o=jQuery.cssHooks[r];if(o&&"expand"in o){s=o.expand(s),delete e[r];for(n in s)n in e||(e[n]=s[n],t[n]=i)}else t[r]=i}}function defaultPrefilter(e,t,n){var r,i,s,o,u,a,f,l,c,h=this,p=e.style,d={},v=[],m=e.nodeType&&isHidden(e);n.queue||(l=jQuery._queueHooks(e,"fx"),l.unqueued==null&&(l.unqueued=0,c=l.empty.fire,l.empty.fire=function(){l.unqueued||c()}),l.unqueued++,h.always(function(){h.always(function(){l.unqueued--,jQuery.queue(e,"fx").length||l.empty.fire()})})),e.nodeType===1&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],jQuery.css(e,"display")==="inline"&&jQuery.css(e,"float")==="none"&&(p.display="inline-block")),n.overflow&&(p.overflow="hidden",h.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]})),u=data_priv.get(e,"fxshow");for(r in t){s=t[r];if(rfxtypes.exec(s)){delete t[r],a=a||s==="toggle";if(s===(m?"hide":"show")){if(s!=="show"||u===undefined||u[r]===undefined)continue;m=!0}v.push(r)}}o=v.length;if(o){u=data_priv.get(e,"fxshow")||data_priv.access(e,"fxshow",{}),"hidden"in u&&(m=u.hidden),a&&(u.hidden=!m),m?jQuery(e).show():h.done(function(){jQuery(e).hide()}),h.done(function(){var t;data_priv.remove(e,"fxshow");for(t in d)jQuery.style(e,t,d[t])});for(r=0;r<o;r++)i=v[r],f=h.createTween(i,m?u[i]:0),d[i]=u[i]||jQuery.style(e,i),i in u||(u[i]=f.start,m&&(f.end=f.start,f.start=i==="width"||i==="height"?1:0))}}function Tween(e,t,n,r,i){return new Tween.prototype.init(e,t,n,r,i)}function genFx(e,t){var n,r={height:e},i=0;t=t?1:0;for(;i<4;i+=2-t)n=cssExpand[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}function getWindow(e){return jQuery.isWindow(e)?e:e.nodeType===9&&e.defaultView}var rootjQuery,readyList,core_strundefined=typeof undefined,location=window.location,document=window.document,docElem=document.documentElement,_jQuery=window.jQuery,_$=window.$,class2type={},core_deletedIds=[],core_version="2.0.0-ai1ec",core_concat=core_deletedIds.concat,core_push=core_deletedIds.push,core_slice=core_deletedIds.slice,core_indexOf=core_deletedIds.indexOf,core_toString=class2type.toString,core_hasOwn=class2type.hasOwnProperty,core_trim=core_version.trim,jQuery=function(e,t){return new jQuery.fn.init(e,t,rootjQuery)},core_pnum=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,core_rnotwhite=/\S+/g,rquickExpr=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,rsingleTag=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,rmsPrefix=/^-ms-/,rdashAlpha=/-([\da-z])/gi,fcamelCase=function(e,t){return t.toUpperCase()},completed=function(){document.removeEventListener("DOMContentLoaded",completed,!1),window.removeEventListener("load",completed,!1),jQuery.ready()};jQuery.fn=jQuery.prototype={jquery:core_version,constructor:jQuery,init:function(e,t,n){var r,i;if(!e)return this;if(typeof e=="string"){e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3?r=[null,e,null]:r=rquickExpr.exec(e);if(r&&(r[1]||!t)){if(r[1]){t=t instanceof jQuery?t[0]:t,jQuery.merge(this,jQuery.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:document,!0));if(rsingleTag.test(r[1])&&jQuery.isPlainObject(t))for(r in t)jQuery.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=document.getElementById(r[2]),i&&i.parentNode&&(this.length=1,this[0]=i),this.context=document,this.selector=e,this}return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e)}return e.nodeType?(this.context=this[0]=e,this.length=1,this):jQuery.isFunction(e)?n.ready(e):(e.selector!==undefined&&(this.selector=e.selector,this.context=e.context),jQuery.makeArray(e,this))},selector:"",length:0,toArray:function(){return core_slice.call(this)},get:function(e){return e==null?this.toArray():e<0?this[this.length+e]:this[e]},pushStack:function(e){var t=jQuery.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return jQuery.each(this,e,t)},ready:function(e){return jQuery.ready.promise().done(e),this},slice:function(){return this.pushStack(core_slice.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},map:function(e){return this.pushStack(jQuery.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:core_push,sort:[].sort,splice:[].splice},jQuery.fn.init.prototype=jQuery.fn,jQuery.extend=jQuery.fn.extend=function(){var e,t,n,r,i,s,o=arguments[0]||{},u=1,a=arguments.length,f=!1;typeof o=="boolean"&&(f=o,o=arguments[1]||{},u=2),typeof o!="object"&&!jQuery.isFunction(o)&&(o={}),a===u&&(o=this,--u);for(;u<a;u++)if((e=arguments[u])!=null)for(t in e){n=o[t],r=e[t];if(o===r)continue;f&&r&&(jQuery.isPlainObject(r)||(i=jQuery.isArray(r)))?(i?(i=!1,s=n&&jQuery.isArray(n)?n:[]):s=n&&jQuery.isPlainObject(n)?n:{},o[t]=jQuery.extend(f,s,r)):r!==undefined&&(o[t]=r)}return o},jQuery.extend({expando:"jQuery"+(core_version+Math.random()).replace(/\D/g,""),noConflict:function(e){return window.$===jQuery&&(window.$=_$),e&&window.jQuery===jQuery&&(window.jQuery=_jQuery),jQuery},isReady:!1,readyWait:1,holdReady:function(e){e?jQuery.readyWait++:jQuery.ready(!0)},ready:function(e){if(e===!0?--jQuery.readyWait:jQuery.isReady)return;jQuery.isReady=!0;if(e!==!0&&--jQuery.readyWait>0)return;readyList.resolveWith(document,[jQuery]),jQuery.fn.trigger&&jQuery(document).trigger("ready").off("ready")},isFunction:function(e){return jQuery.type(e)==="function"},isArray:Array.isArray,isWindow:function(e){return e!=null&&e===e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return e==null?String(e):typeof e=="object"||typeof e=="function"?class2type[core_toString.call(e)]||"object":typeof e},isPlainObject:function(e){if(jQuery.type(e)!=="object"||e.nodeType||jQuery.isWindow(e))return!1;try{if(e.constructor&&!core_hasOwn.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw new Error(e)},parseHTML:function(e,t,n){if(!e||typeof e!="string")return null;typeof t=="boolean"&&(n=t,t=!1),t=t||document;var r=rsingleTag.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=jQuery.buildFragment([e],t,i),i&&jQuery(i).remove(),jQuery.merge([],r.childNodes))},parseJSON:JSON.parse,parseXML:function(e){var t,n;if(!e||typeof e!="string")return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(r){t=undefined}return(!t||t.getElementsByTagName("parsererror").length)&&jQuery.error("Invalid XML: "+e),t},noop:function(){},globalEval:function(code){var script,indirect=eval;code=jQuery.trim(code),code&&(code.indexOf("use strict")===1?(script=document.createElement("script"),script.text=code,document.head.appendChild(script).parentNode.removeChild(script)):indirect(code))},camelCase:function(e){return e.replace(rmsPrefix,"ms-").replace(rdashAlpha,fcamelCase)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,s=e.length,o=isArraylike(e);if(n)if(o)for(;i<s;i++){r=t.apply(e[i],n);if(r===!1)break}else for(i in e){r=t.apply(e[i],n);if(r===!1)break}else if(o)for(;i<s;i++){r=t.call(e[i],i,e[i]);if(r===!1)break}else for(i in e){r=t.call(e[i],i,e[i]);if(r===!1)break}return e},trim:function(e){return e==null?"":core_trim.call(e)},makeArray:function(e,t){var n=t||[];return e!=null&&(isArraylike(Object(e))?jQuery.merge(n,typeof e=="string"?[e]:e):core_push.call(n,e)),n},inArray:function(e,t,n){return t==null?-1:core_indexOf.call(t,e,n)},merge:function(e,t){var n=t.length,r=e.length,i=0;if(typeof n=="number")for(;i<n;i++)e[r++]=t[i];else while(t[i]!==undefined)e[r++]=t[i++];return e.length=r,e},grep:function(e,t,n){var r,i=[],s=0,o=e.length;n=!!n;for(;s<o;s++)r=!!t(e[s],s),n!==r&&i.push(e[s]);return i},map:function(e,t,n){var r,i=0,s=e.length,o=isArraylike(e),u=[];if(o)for(;i<s;i++)r=t(e[i],i,n),r!=null&&(u[u.length]=r);else for(i in e)r=t(e[i],i,n),r!=null&&(u[u.length]=r);return core_concat.apply([],u)},guid:1,proxy:function(e,t){var n,r,i;return typeof t=="string"&&(n=e[t],t=e,e=n),jQuery.isFunction(e)?(r=core_slice.call(arguments,2),i=function(){return e.apply(t||this,r.concat(core_slice.call(arguments)))},i.guid=e.guid=e.guid||jQuery.guid++,i):undefined},access:function(e,t,n,r,i,s,o){var u=0,a=e.length,f=n==null;if(jQuery.type(n)==="object"){i=!0;for(u in n)jQuery.access(e,t,u,n[u],!0,s,o)}else if(r!==undefined){i=!0,jQuery.isFunction(r)||(o=!0),f&&(o?(t.call(e,r),t=null):(f=t,t=function(e,t,n){return f.call(jQuery(e),n)}));if(t)for(;u<a;u++)t(e[u],n,o?r:r.call(e[u],u,t(e[u],n)))}return i?e:f?t.call(e):a?t(e[0],n):s},now:Date.now,swap:function(e,t,n,r){var i,s,o={};for(s in t)o[s]=e.style[s],e.style[s]=t[s];i=n.apply(e,r||[]);for(s in t)e.style[s]=o[s];return i}}),jQuery.ready.promise=function(e){return readyList||(readyList=jQuery.Deferred(),document.readyState==="complete"?setTimeout(jQuery.ready):(document.addEventListener("DOMContentLoaded",completed,!1),window.addEventListener("load",completed,!1))),readyList.promise(e)},jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){class2type["[object "+t+"]"]=t.toLowerCase()}),rootjQuery=jQuery(document),function(e,t){function it(e){return Q.test(e+"")}function st(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>i.cacheLength&&delete e[t.shift()],e[n]=r}}function ot(e){return e[y]=!0,e}function ut(e){var t=c.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function at(e,t,n,r){var i,s,o,u,a,f,h,v,m,E;(t?t.ownerDocument||t:b)!==c&&l(t),t=t||c,n=n||[];if(!e||typeof e!="string")return n;if((u=t.nodeType)!==1&&u!==9)return[];if(p&&!r){if(i=G.exec(e))if(o=i[1]){if(u===9){s=t.getElementById(o);if(!s||!s.parentNode)return n;if(s.id===o)return n.push(s),n}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(o))&&g(t,s)&&s.id===o)return n.push(s),n}else{if(i[2])return D.apply(n,t.getElementsByTagName(e)),n;if((o=i[3])&&w.getElementsByClassName&&t.getElementsByClassName)return D.apply(n,t.getElementsByClassName(o)),n}if(w.qsa&&(!d||!d.test(e))){v=h=y,m=t,E=u===9&&e;if(u===1&&t.nodeName.toLowerCase()!=="object"){f=vt(e),(h=t.getAttribute("id"))?v=h.replace(et,"\\$&"):t.setAttribute("id",v),v="[id='"+v+"'] ",a=f.length;while(a--)f[a]=v+mt(f[a]);m=X.test(e)&&t.parentNode||t,E=f.join(",")}if(E)try{return D.apply(n,m.querySelectorAll(E)),n}catch(S){}finally{h||t.removeAttribute("id")}}}return Tt(e.replace(U,"$1"),t,n,r)}function ft(e,t){var n=t&&e,r=n&&(~t.sourceIndex||A)-(~e.sourceIndex||A);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function lt(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}function ct(e,n,r){var i;return r?t:i=e.getAttribute(n,n.toLowerCase()==="type"?1:2)}function ht(e){return function(t){var n=t.nodeName.toLowerCase();return n==="input"&&t.type===e}}function pt(e){return function(t){var n=t.nodeName.toLowerCase();return(n==="input"||n==="button")&&t.type===e}}function dt(e){return ot(function(t){return t=+t,ot(function(n,r){var i,s=e([],n.length,t),o=s.length;while(o--)n[i=s[o]]&&(n[i]=!(r[i]=n[i]))})})}function vt(e,t){var n,r,s,o,u,a,f,l=T[e+" "];if(l)return t?0:l.slice(0);u=e,a=[],f=i.preFilter;while(u){if(!n||(r=z.exec(u)))r&&(u=u.slice(r[0].length)||u),a.push(s=[]);n=!1;if(r=W.exec(u))n=r.shift(),s.push({value:n,type:r[0].replace(U," ")}),u=u.slice(n.length);for(o in i.filter)(r=K[o].exec(u))&&(!f[o]||(r=f[o](r)))&&(n=r.shift(),s.push({value:n,type:o,matches:r}),u=u.slice(n.length));if(!n)break}return t?u.length:u?at.error(e):T(e,a).slice(0)}function mt(e){var t=0,n=e.length,r="";for(;t<n;t++)r+=e[t].value;return r}function gt(e,t,n){var i=t.dir,s=n&&i==="parentNode",o=S++;return t.first?function(t,n,r){while(t=t[i])if(t.nodeType===1||s)return e(t,n,r)}:function(t,n,u){var a,f,l,c=E+" "+o;if(u){while(t=t[i])if(t.nodeType===1||s)if(e(t,n,u))return!0}else while(t=t[i])if(t.nodeType===1||s){l=t[y]||(t[y]={});if((f=l[i])&&f[0]===c){if((a=f[1])===!0||a===r)return a===!0}else{f=l[i]=[c],f[1]=e(t,n,u)||r;if(f[1]===!0)return!0}}}}function yt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function bt(e,t,n,r,i){var s,o=[],u=0,a=e.length,f=t!=null;for(;u<a;u++)if(s=e[u])if(!n||n(s,r,i))o.push(s),f&&t.push(u);return o}function wt(e,t,n,r,i,s){return r&&!r[y]&&(r=wt(r)),i&&!i[y]&&(i=wt(i,s)),ot(function(s,o,u,a){var f,l,c,h=[],p=[],d=o.length,v=s||xt(t||"*",u.nodeType?[u]:u,[]),m=e&&(s||!t)?bt(v,h,e,u,a):v,g=n?i||(s?e:d||r)?[]:o:m;n&&n(m,g,u,a);if(r){f=bt(g,p),r(f,[],u,a),l=f.length;while(l--)if(c=f[l])g[p[l]]=!(m[p[l]]=c)}if(s){if(i||e){if(i){f=[],l=g.length;while(l--)(c=g[l])&&f.push(m[l]=c);i(null,g=[],f,a)}l=g.length;while(l--)(c=g[l])&&(f=i?H.call(s,c):h[l])>-1&&(s[f]=!(o[f]=c))}}else g=bt(g===o?g.splice(d,g.length):g),i?i(null,o,g,a):D.apply(o,g)})}function Et(e){var t,n,r,s=e.length,o=i.relative[e[0].type],u=o||i.relative[" "],f=o?1:0,l=gt(function(e){return e===t},u,!0),c=gt(function(e){return H.call(t,e)>-1},u,!0),h=[function(e,n,r){return!o&&(r||n!==a)||((t=n).nodeType?l(e,n,r):c(e,n,r))}];for(;f<s;f++)if(n=i.relative[e[f].type])h=[gt(yt(h),n)];else{n=i.filter[e[f].type].apply(null,e[f].matches);if(n[y]){r=++f;for(;r<s;r++)if(i.relative[e[r].type])break;return wt(f>1&&yt(h),f>1&&mt(e.slice(0,f-1)).replace(U,"$1"),n,f<r&&Et(e.slice(f,r)),r<s&&Et(e=e.slice(r)),r<s&&mt(e))}h.push(n)}return yt(h)}function St(e,t){var n=0,s=t.length>0,o=e.length>0,u=function(u,f,l,h,p){var d,v,m,g=[],y=0,b="0",w=u&&[],S=p!=null,x=a,T=u||o&&i.find.TAG("*",p&&f.parentNode||f),N=E+=x==null?1:Math.random()||.1;S&&(a=f!==c&&f,r=n);for(;(d=T[b])!=null;b++){if(o&&d){v=0;while(m=e[v++])if(m(d,f,l)){h.push(d);break}S&&(E=N,r=++n)}s&&((d=!m&&d)&&y--,u&&w.push(d))}y+=b;if(s&&b!==y){v=0;while(m=t[v++])m(w,g,f,l);if(u){if(y>0)while(b--)!w[b]&&!g[b]&&(g[b]=M.call(h));g=bt(g)}D.apply(h,g),S&&!u&&g.length>0&&y+t.length>1&&at.uniqueSort(h)}return S&&(E=N,a=x),w};return s?ot(u):u}function xt(e,t,n){var r=0,i=t.length;for(;r<i;r++)at(e,t[r],n);return n}function Tt(e,t,n,r){var s,o,a,f,l,c=vt(e);if(!r&&c.length===1){o=c[0]=c[0].slice(0);if(o.length>2&&(a=o[0]).type==="ID"&&t.nodeType===9&&p&&i.relative[o[1].type]){t=(i.find.ID(a.matches[0].replace(tt,nt),t)||[])[0];if(!t)return n;e=e.slice(o.shift().value.length)}s=K.needsContext.test(e)?0:o.length;while(s--){a=o[s];if(i.relative[f=a.type])break;if(l=i.find[f])if(r=l(a.matches[0].replace(tt,nt),X.test(o[0].type)&&t.parentNode||t)){o.splice(s,1),e=r.length&&mt(o);if(!e)return D.apply(n,r),n;break}}}return u(e,c)(r,t,!p,n,X.test(e)),n}function Nt(){}var n,r,i,s,o,u,a,f,l,c,h,p,d,v,m,g,y="sizzle"+ -(new Date),b=e.document,w={},E=0,S=0,x=st(),T=st(),N=st(),C=!1,k=function(){return 0},L=typeof t,A=1<<31,O=[],M=O.pop,_=O.push,D=O.push,P=O.slice,H=O.indexOf||function(e){var t=0,n=this.length;for(;t<n;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",j="[\\x20\\t\\r\\n\\f]",F="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",I=F.replace("w","w#"),q="\\["+j+"*("+F+")"+j+"*(?:([*^$|!~]?=)"+j+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+I+")|)|)"+j+"*\\]",R=":("+F+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+q.replace(3,8)+")*)|.*)\\)|)",U=new RegExp("^"+j+"+|((?:^|[^\\\\])(?:\\\\.)*)"+j+"+$","g"),z=new RegExp("^"+j+"*,"+j+"*"),W=new RegExp("^"+j+"*([>+~]|"+j+")"+j+"*"),X=new RegExp(j+"*[+~]"),V=new RegExp("="+j+"*([^\\]'\"]*)"+j+"*\\]","g"),$=new RegExp(R),J=new RegExp("^"+I+"$"),K={ID:new RegExp("^#("+F+")"),CLASS:new RegExp("^\\.("+F+")"),TAG:new RegExp("^("+F.replace("w","w*")+")"),ATTR:new RegExp("^"+q),PSEUDO:new RegExp("^"+R),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+j+"*(even|odd|(([+-]|)(\\d*)n|)"+j+"*(?:([+-]|)"+j+"*(\\d+)|))"+j+"*\\)|)","i"),"boolean":new RegExp("^(?:"+B+")$","i"),needsContext:new RegExp("^"+j+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+j+"*((?:-\\d)?\\d*)"+j+"*\\)|)(?=[^-]|$)","i")},Q=/^[^{]+\{\s*\[native \w/,G=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,et=/'|\\/g,tt=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,nt=function(e,t){var n="0x"+t-65536;return n!==n?t:n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,n&1023|56320)};try{D.apply(O=P.call(b.childNodes),b.childNodes),O[b.childNodes.length].nodeType}catch(rt){D={apply:O.length?function(e,t){_.apply(e,P.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}o=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?t.nodeName!=="HTML":!1},l=at.setDocument=function(e){var n=e?e.ownerDocument||e:b;if(n===c||n.nodeType!==9||!n.documentElement)return c;c=n,h=n.documentElement,p=!o(n),w.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),w.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),w.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",e.getElementsByClassName("i").length===2}),w.sortDetached=ut(function(e){return e.compareDocumentPosition(c.createElement("div"))&1}),w.getById=ut(function(e){return h.appendChild(e).id=y,!n.getElementsByName||!n.getElementsByName(y).length}),w.getById?(i.find.ID=function(e,t){if(typeof t.getElementById!==L&&p){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(tt,nt);return function(e){return e.getAttribute("id")===t}}):(i.find.ID=function(e,n){if(typeof n.getElementById!==L&&p){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==L&&r.getAttributeNode("id").value===e?[r]:t:[]}},i.filter.ID=function(e){var t=e.replace(tt,nt);return function(e){var n=typeof e.getAttributeNode!==L&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=w.getElementsByTagName?function(e,t){if(typeof t.getElementsByTagName!==L)return t.getElementsByTagName(e)}:function(e,t){var n,r=[],i=0,s=t.getElementsByTagName(e);if(e==="*"){while(n=s[i++])n.nodeType===1&&r.push(n);return r}return s},i.find.CLASS=w.getElementsByClassName&&function(e,t){if(typeof t.getElementsByClassName!==L&&p)return t.getElementsByClassName(e)},v=[],d=[];if(w.qsa=it(n.querySelectorAll))ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||d.push("\\["+j+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||d.push(":checked")}),ut(function(e){var t=c.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&d.push("[*^$]="+j+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||d.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),d.push(",.*:")});return(w.matchesSelector=it(m=h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ut(function(e){w.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),v.push("!=",R)}),d=d.length&&new RegExp(d.join("|")),v=v.length&&new RegExp(v.join("|")),g=it(h.contains)||h.compareDocumentPosition?function(e,t){var n=e.nodeType===9?e.documentElement:e,r=t&&t.parentNode;return e===r||!!r&&r.nodeType===1&&!!(n.contains?n.contains(r):e.compareDocumentPosition&&e.compareDocumentPosition(r)&16)}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},k=h.compareDocumentPosition?function(e,t){if(e===t)return C=!0,0;var r=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);if(r)return r&1||!w.sortDetached&&t.compareDocumentPosition(e)===r?e===n||g(b,e)?-1:t===n||g(b,t)?1:f?H.call(f,e)-H.call(f,t):0:r&4?-1:1;return e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,s=e.parentNode,o=t.parentNode,u=[e],a=[t];if(e===t)return C=!0,0;if(!s||!o)return e===n?-1:t===n?1:s?-1:o?1:f?H.call(f,e)-H.call(f,t):0;if(s===o)return ft(e,t);r=e;while(r=r.parentNode)u.unshift(r);r=t;while(r=r.parentNode)a.unshift(r);while(u[i]===a[i])i++;return i?ft(u[i],a[i]):u[i]===b?-1:a[i]===b?1:0},c},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){(e.ownerDocument||e)!==c&&l(e),t=t.replace(V,"='$1']");if(w.matchesSelector&&p&&(!v||!v.test(t))&&(!d||!d.test(t)))try{var n=m.call(e,t);if(n||w.disconnectedMatch||e.document&&e.document.nodeType!==11)return n}catch(r){}return at(t,c,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==c&&l(e),g(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==c&&l(e);var r=i.attrHandle[n.toLowerCase()],s=r&&r(e,n,!p);return s===t?w.attributes||!p?e.getAttribute(n):(s=e.getAttributeNode(n))&&s.specified?s.value:null:s},at.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],r=0,i=0;C=!w.detectDuplicates,f=!w.sortStable&&e.slice(0),e.sort(k);if(C){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return e},s=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(!i)for(;t=e[r];r++)n+=s(t);else if(i===1||i===9||i===11){if(typeof e.textContent=="string")return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=s(e)}else if(i===3||i===4)return e.nodeValue;return n},i=at.selectors={cacheLength:50,createPseudo:ot,match:K,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(tt,nt),e[3]=(e[4]||e[5]||"").replace(tt,nt),e[2]==="~="&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),e[1].slice(0,3)==="nth"?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(e[3]==="even"||e[3]==="odd")),e[5]=+(e[7]+e[8]||e[3]==="odd")):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return K.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&$.test(n)&&(t=vt(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(tt,nt).toLowerCase();return e==="*"?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=x[e+" "];return t||(t=new RegExp("(^|"+j+")"+e+"("+j+"|$)"))&&x(e,function(e){return t.test(typeof e.className=="string"&&e.className||typeof e.getAttribute!==L&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return i==null?t==="!=":t?(i+="",t==="="?i===n:t==="!="?i!==n:t==="^="?n&&i.indexOf(n)===0:t==="*="?n&&i.indexOf(n)>-1:t==="$="?n&&i.slice(-n.length)===n:t==="~="?(" "+i+" ").indexOf(n)>-1:t==="|="?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var s=e.slice(0,3)!=="nth",o=e.slice(-4)!=="last",u=t==="of-type";return r===1&&i===0?function(e){return!!e.parentNode}:function(t,n,a){var f,l,c,h,p,d,v=s!==o?"nextSibling":"previousSibling",m=t.parentNode,g=u&&t.nodeName.toLowerCase(),b=!a&&!u;if(m){if(s){while(v){c=t;while(c=c[v])if(u?c.nodeName.toLowerCase()===g:c.nodeType===1)return!1;d=v=e==="only"&&!d&&"nextSibling"}return!0}d=[o?m.firstChild:m.lastChild];if(o&&b){l=m[y]||(m[y]={}),f=l[e]||[],p=f[0]===E&&f[1],h=f[0]===E&&f[2],c=p&&m.childNodes[p];while(c=++p&&c&&c[v]||(h=p=0)||d.pop())if(c.nodeType===1&&++h&&c===t){l[e]=[E,p,h];break}}else if(b&&(f=(t[y]||(t[y]={}))[e])&&f[0]===E)h=f[1];else while(c=++p&&c&&c[v]||(h=p=0)||d.pop())if((u?c.nodeName.toLowerCase()===g:c.nodeType===1)&&++h){b&&((c[y]||(c[y]={}))[e]=[E,h]);if(c===t)break}return h-=i,h===r||h%r===0&&h/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[y]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?ot(function(e,n){var i,s=r(e,t),o=s.length;while(o--)i=H.call(e,s[o]),e[i]=!(n[i]=s[o])}):function(e){return r(e,0,n)}):r}},pseudos:{not:ot(function(e){var t=[],n=[],r=u(e.replace(U,"$1"));return r[y]?ot(function(e,t,n,i){var s,o=r(e,null,i,[]),u=e.length;while(u--)if(s=o[u])e[u]=!(t[u]=s)}):function(e,i,s){return t[0]=e,r(t,null,s,n),!n.pop()}}),has:ot(function(e){return function(t){return at(e,t).length>0}}),contains:ot(function(e){return function(t){return(t.textContent||t.innerText||s(t)).indexOf(e)>-1}}),lang:ot(function(e){return J.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(tt,nt).toLowerCase(),function(t){var n;do if(n=p?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||n.indexOf(e+"-")===0;while((t=t.parentNode)&&t.nodeType===1);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===c.activeElement&&(!c.hasFocus||c.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&!!e.checked||t==="option"&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||e.nodeType===3||e.nodeType===4)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return Z.test(e.nodeName)},input:function(e){return Y.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&e.type==="button"||t==="button"},text:function(e){var t;return e.nodeName.toLowerCase()==="input"&&e.type==="text"&&((t=e.getAttribute("type"))==null||t.toLowerCase()===e.type)},first:dt(function(){return[0]}),last:dt(function(e,t){return[t-1]}),eq:dt(function(e,t,n){return[n<0?n+t:n]}),even:dt(function(e,t){var n=0;for(;n<t;n+=2)e.push(n);return e}),odd:dt(function(e,t){var n=1;for(;n<t;n+=2)e.push(n);return e}),lt:dt(function(e,t,n){var r=n<0?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:dt(function(e,t,n){var r=n<0?n+t:n;for(;++r<t;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[n]=ht(n);for(n in{submit:!0,reset:!0})i.pseudos[n]=pt(n);u=at.compile=function(e,t){var n,r=[],i=[],s=N[e+" "];if(!s){t||(t=vt(e)),n=t.length;while(n--)s=Et(t[n]),s[y]?r.push(s):i.push(s);s=N(e,St(i,r))}return s},i.pseudos.nth=i.pseudos.eq,Nt.prototype=i.filters=i.pseudos,i.setFilters=new Nt,w.sortStable=y.split("").sort(k).join("")===y,l(),[0,0].sort(k),w.detectDuplicates=C,ut(function(e){e.innerHTML="<a href='#'></a>";if(e.firstChild.getAttribute("href")!=="#"){var t="type|href|height|width".split("|"),n=t.length;while(n--)i.attrHandle[t[n]]=ct}}),ut(function(e){if(e.getAttribute("disabled")!=null){var t=B.split("|"),n=t.length;while(n--)i.attrHandle[t[n]]=lt}}),jQuery.find=at,jQuery.expr=at.selectors,jQuery.expr[":"]=jQuery.expr.pseudos,jQuery.unique=at.uniqueSort,jQuery.text=at.getText,jQuery.isXMLDoc=at.isXML,jQuery.contains=at.contains}(window);var optionsCache={};jQuery.Callbacks=function(e){e=typeof e=="string"?optionsCache[e]||createOptions(e):jQuery.extend({},e);var t,n,r,i,s,o,u=[],a=!e.once&&[],f=function(c){t=e.memory&&c,n=!0,o=i||0,i=0,s=u.length,r=!0;for(;u&&o<s;o++)if(u[o].apply(c[0],c[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,u&&(a?a.length&&f(a.shift()):t?u=[]:l.disable())},l={add:function(){if(u){var n=u.length;(function o(t){jQuery.each(t,function(t,n){var r=jQuery.type(n);r==="function"?(!e.unique||!l.has(n))&&u.push(n):n&&n.length&&r!=="string"&&o(n)})})(arguments),r?s=u.length:t&&(i=n,f(t))}return this},remove:function(){return u&&jQuery.each(arguments,function(e,t){var n;while((n=jQuery.inArray(t,u,n))>-1)u.splice(n,1),r&&(n<=s&&s--,n<=o&&o--)}),this},has:function(e){return e?jQuery.inArray(e,u)>-1:!!u&&!!u.length},empty:function(){return u=[],s=0,this},disable:function(){return u=a=t=undefined,this},disabled:function(){return!u},lock:function(){return a=undefined,t||l.disable(),this},locked:function(){return!a},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],u&&(!n||a)&&(r?a.push(t):f(t)),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!n}};return l},jQuery.extend({Deferred:function(e){var t=[["resolve","done",jQuery.Callbacks("once memory"),"resolved"],["reject","fail",jQuery.Callbacks("once memory"),"rejected"],["notify","progress",jQuery.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return jQuery.Deferred(function(n){jQuery.each(t,function(t,s){var o=s[0],u=jQuery.isFunction(e[t])&&e[t];i[s[1]](function(){var e=u&&u.apply(this,arguments);e&&jQuery.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[o+"With"](this===r?n.promise():this,u?[e]:arguments)})}),e=null}).promise()},promise:function(e){return e!=null?jQuery.extend(e,r):r}},i={};return r.pipe=r.then,jQuery.each(t,function(e,s){var o=s[2],u=s[3];r[s[1]]=o.add,u&&o.add(function(){n=u},t[e^1][2].disable,t[2][2].lock),i[s[0]]=function(){return i[s[0]+"With"](this===i?r:this,arguments),this},i[s[0]+"With"]=o.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=core_slice.call(arguments),r=n.length,i=r!==1||e&&jQuery.isFunction(e.promise)?r:0,s=i===1?e:jQuery.Deferred(),o=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?core_slice.call(arguments):r,n===u?s.notifyWith(t,n):--i||s.resolveWith(t,n)}},u,a,f;if(r>1){u=new Array(r),a=new Array(r),f=new Array(r);for(;t<r;t++)n[t]&&jQuery.isFunction(n[t].promise)?n[t].promise().done(o(t,f,n)).fail(s.reject).progress(o(t,a,u)):--i}return i||s.resolveWith(f,n),s.promise()}}),jQuery.support=function(e){var t=document.createElement("input"),n=document.createDocumentFragment(),r=document.createElement("div"),i=document.createElement("select"),s=i.appendChild(document.createElement("option"));return t.type?(t.type="checkbox",e.checkOn=t.value!=="",e.optSelected=s.selected,e.reliableMarginRight=!0,e.boxSizingReliable=!0,e.pixelPosition=!1,t.checked=!0,e.noCloneChecked=t.cloneNode(!0).checked,i.disabled=!0,e.optDisabled=!s.disabled,t=document.createElement("input"),t.value="t",t.type="radio",e.radioValue=t.value==="t",t.setAttribute("checked","t"),t.setAttribute("name","t"),n.appendChild(t),e.checkClone=n.cloneNode(!0).cloneNode(!0).lastChild.checked,e.focusinBubbles="onfocusin"in window,r.style.backgroundClip="content-box",r.cloneNode(!0).style.backgroundClip="",e.clearCloneStyle=r.style.backgroundClip==="content-box",jQuery(function(){var t,n,i="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",s=document.getElementsByTagName("body")[0];if(!s)return;t=document.createElement("div"),t.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",s.appendChild(t).appendChild(r),r.innerHTML="",r.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",jQuery.swap(s,s.style.zoom!=null?{zoom:1}:{},function(){e.boxSizing=r.offsetWidth===4}),window.getComputedStyle&&(e.pixelPosition=(window.getComputedStyle(r,null)||{}).top!=="1%",e.boxSizingReliable=(window.getComputedStyle(r,null)||{width:"4px"}).width==="4px",n=r.appendChild(document.createElement("div")),n.style.cssText=r.style.cssText=i,n.style.marginRight=n.style.width="0",r.style.width="1px",e.reliableMarginRight=!parseFloat((window.getComputedStyle(n,null)||{}).marginRight)),s.removeChild(t)}),e):e}({});var data_user,data_priv,rbrace=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,rmultiDash=/([A-Z])/g;Data.uid=1,Data.accepts=function(e){return e.nodeType?e.nodeType===1||e.nodeType===9:!0},Data.prototype={key:function(e){if(!Data.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=Data.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,jQuery.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),s=this.cache[i];if(typeof t=="string")s[t]=n;else if(jQuery.isEmptyObject(s))this.cache[i]=t;else for(r in t)s[r]=t[r]},get:function(e,t){var n=this.cache[this.key(e)];return t===undefined?n:n[t]},access:function(e,t,n){return t===undefined||t&&typeof t=="string"&&n===undefined?this.get(e,t):(this.set(e,t,n),n!==undefined?n:t)},remove:function(e,t){var n,r,i=this.key(e),s=this.cache[i];if(t===undefined)this.cache[i]={};else{jQuery.isArray(t)?r=t.concat(t.map(jQuery.camelCase)):t in s?r=[t]:(r=jQuery.camelCase(t),r=r in s?[r]:r.match(core_rnotwhite)||[]),n=r.length;while(n--)delete s[r[n]]}},hasData:function(e){return!jQuery.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){delete this.cache[this.key(e)]}},data_user=new Data,data_priv=new Data,jQuery.extend({acceptData:Data.accepts,hasData:function(e){return data_user.hasData(e)||data_priv.hasData(e)},data:function(e,t,n){return data_user.access(e,t,n)},removeData:function(e,t){data_user.remove(e,t)},_data:function(e,t,n){return data_priv.access(e,t,n)},_removeData:function(e,t){data_priv.remove(e,t)}}),jQuery.fn.extend({data:function(e,t){var n,r,i=this[0],s=0,o=null;if(e===undefined){if(this.length){o=data_user.get(i);if(i.nodeType===1&&!data_priv.get(i,"hasDataAttrs")){n=i.attributes;for(;s<n.length;s++)r=n[s].name,r.indexOf("data-")===0&&(r=jQuery.camelCase(r.substring(5)),dataAttr(i,r,o[r]));data_priv.set(i,"hasDataAttrs",!0)}}return o}return typeof e=="object"?this.each(function(){data_user.set(this,e)}):jQuery.access(this,function(t){var n,r=jQuery.camelCase(e);if(i&&t===undefined){n=data_user.get(i,e);if(n!==undefined)return n;n=data_user.get(i,r);if(n!==undefined)return n;n=dataAttr(i,r,undefined);if(n!==undefined)return n;return}this.each(function(){var n=data_user.get(this,r);data_user.set(this,r,t),e.indexOf("-")!==-1&&n!==undefined&&data_user.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){data_user.remove(this,e)})}}),jQuery.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=data_priv.get(e,t),n&&(!r||jQuery.isArray(n)?r=data_priv.access(e,t,jQuery.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=jQuery.queue(e,t),r=n.length,i=n.shift(),s=jQuery._queueHooks(e,t),o=function(){jQuery.dequeue(e,t)};i==="inprogress"&&(i=n.shift(),r--),s.cur=i,i&&(t==="fx"&&n.unshift("inprogress"),delete s.stop,i.call(e,o,s)),!r&&s&&s.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return data_priv.get(e,n)||data_priv.access(e,n,{empty:jQuery.Callbacks("once memory").add(function(){data_priv.remove(e,[t+"queue",n])})})}}),jQuery.fn.extend({queue:function(e,t){var n=2;return typeof e!="string"&&(t=e,e="fx",n--),arguments.length<n?jQuery.queue(this[0],e):t===undefined?this:this.each(function(){var n=jQuery.queue(this,e,t);jQuery._queueHooks(this,e),e==="fx"&&n[0]!=="inprogress"&&jQuery.dequeue(this,e)})},dequeue:function(e){return this.each(function(){jQuery.dequeue(this,e)})},delay:function(e,t){return e=jQuery.fx?jQuery.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=jQuery.Deferred(),s=this,o=this.length,u=function(){--r||i.resolveWith(s,[s])};typeof e!="string"&&(t=e,e=undefined),e=e||"fx";while(o--)n=data_priv.get(s[o],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(u));return u(),i.promise(t)}});var nodeHook,boolHook,rclass=/[\t\r\n]/g,rreturn=/\r/g,rfocusable=/^(?:input|select|textarea|button)$/i;jQuery.fn.extend({attr:function(e,t){return jQuery.access(this,jQuery.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){jQuery.removeAttr(this,e)})},prop:function(e,t){return jQuery.access(this,jQuery.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[jQuery.propFix[e]||e]})},addClass:function(e){var t,n,r,i,s,o=0,u=this.length,a=typeof e=="string"&&e;if(jQuery.isFunction(e))return this.each(function(t){jQuery(this).addClass(e.call(this,t,this.className))});if(a){t=(e||"").match(core_rnotwhite)||[];for(;o<u;o++){n=this[o],r=n.nodeType===1&&(n.className?(" "+n.className+" ").replace(rclass," "):" ");if(r){s=0;while(i=t[s++])r.indexOf(" "+i+" ")<0&&(r+=i+" ");n.className=jQuery.trim(r)}}}return this},removeClass:function(e){var t,n,r,i,s,o=0,u=this.length,a=arguments.length===0||typeof e=="string"&&e;if(jQuery.isFunction(e))return this.each(function(t){jQuery(this).removeClass(e.call(this,t,this.className))});if(a){t=(e||"").match(core_rnotwhite)||[];for(;o<u;o++){n=this[o],r=n.nodeType===1&&(n.className?(" "+n.className+" ").replace(rclass," "):"");if(r){s=0;while(i=t[s++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?jQuery.trim(r):""}}}return this},toggleClass:function(e,t){var n=typeof e,r=typeof t=="boolean";return jQuery.isFunction(e)?this.each(function(n){jQuery(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(n==="string"){var i,s=0,o=jQuery(this),u=t,a=e.match(core_rnotwhite)||[];while(i=a[s++])u=r?u:!o.hasClass(i),o[u?"addClass":"removeClass"](i)}else if(n===core_strundefined||n==="boolean")this.className&&data_priv.set(this,"__className__",this.className),this.className=this.className||e===!1?"":data_priv.get(this,"__className__")||""})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;n<r;n++)if(this[n].nodeType===1&&(" "+this[n].className+" ").replace(rclass," ").indexOf(t)>=0)return!0;return!1},val:function(e){var t,n,r,i=this[0];if(!arguments.length){if(i)return t=jQuery.valHooks[i.type]||jQuery.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&(n=t.get(i,"value"))!==undefined?n:(n=i.value,typeof n=="string"?n.replace(rreturn,""):n==null?"":n);return}return r=jQuery.isFunction(e),this.each(function(n){var i,s=jQuery(this);if(this.nodeType!==1)return;r?i=e.call(this,n,s.val()):i=e,i==null?i="":typeof i=="number"?i+="":jQuery.isArray(i)&&(i=jQuery.map(i,function(e){return e==null?"":e+""})),t=jQuery.valHooks[this.type]||jQuery.valHooks[this.nodeName.toLowerCase()];if(!t||!("set"in t)||t.set(this,i,"value")===undefined)this.value=i})}}),jQuery.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,s=e.type==="select-one"||i<0,o=s?null:[],u=s?i+1:r.length,a=i<0?u:s?i:0;for(;a<u;a++){n=r[a];if((n.selected||a===i)&&(jQuery.support.optDisabled?!n.disabled:n.getAttribute("disabled")===null)&&(!n.parentNode.disabled||!jQuery.nodeName(n.parentNode,"optgroup"))){t=jQuery(n).val();if(s)return t;o.push(t)}}return o},set:function(e,t){var n,r,i=e.options,s=jQuery.makeArray(t),o=i.length;while(o--){r=i[o];if(r.selected=jQuery.inArray(jQuery(r).val(),s)>=0)n=!0}return n||(e.selectedIndex=-1),s}}},attr:function(e,t,n){var r,i,s=e.nodeType;if(!e||s===3||s===8||s===2)return;if(typeof e.getAttribute===core_strundefined)return jQuery.prop(e,t,n);if(s!==1||!jQuery.isXMLDoc(e))t=t.toLowerCase(),r=jQuery.attrHooks[t]||(jQuery.expr.match.boolean.test(t)?boolHook:nodeHook);if(n===undefined)return r&&"get"in r&&(i=r.get(e,t))!==null?i:(i=jQuery.find.attr(e,t),i==null?undefined:i);if(n!==null)return r&&"set"in r&&(i=r.set(e,n,t))!==undefined?i:(e.setAttribute(t,n+""),n);jQuery.removeAttr(e,t)},removeAttr:function(e,t){var n,r,i=0,s=t&&t.match(core_rnotwhite);if(s&&e.nodeType===1)while(n=s[i++])r=jQuery.propFix[n]||n,jQuery.expr.match.boolean.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!jQuery.support.radioValue&&t==="radio"&&jQuery.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,t,n){var r,i,s,o=e.nodeType;if(!e||o===3||o===8||o===2)return;return s=o!==1||!jQuery.isXMLDoc(e),s&&(t=jQuery.propFix[t]||t,i=jQuery.propHooks[t]),n!==undefined?i&&"set"in i&&(r=i.set(e,n,t))!==undefined?r:e[t]=n:i&&"get"in i&&(r=i.get(e,t))!==null?r:e[t]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||rfocusable.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),boolHook={set:function(e,t,n){return t===!1?jQuery.removeAttr(e,n):e.setAttribute(n,n),n}},jQuery.each(jQuery.expr.match.boolean.source.match(/\w+/g),function(e,t){var n=jQuery.expr.attrHandle[t]||jQuery.find.attr;jQuery.expr.attrHandle[t]=function(e,t,r){var i=jQuery.expr.attrHandle[t],s=r?undefined:(jQuery.expr.attrHandle[t]=undefined)!=n(e,t,r)?t.toLowerCase():null;return jQuery.expr.attrHandle[t]=i,s}}),jQuery.support.optSelected||(jQuery.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),jQuery.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){jQuery.propFix[this.toLowerCase()]=this}),jQuery.each(["radio","checkbox"],function(){jQuery.valHooks[this]={set:function(e,t){if(jQuery.isArray(t))return e.checked=jQuery.inArray(jQuery(e).val(),t)>=0}},jQuery.support.checkOn||(jQuery.valHooks[this].get=function(e){return e.getAttribute("value")===null?"on":e.value})});var rkeyEvent=/^key/,rmouseEvent=/^(?:mouse|contextmenu)|click/,rfocusMorph=/^(?:focusinfocus|focusoutblur)$/,rtypenamespace=/^([^.]*)(?:\.(.+)|)$/;jQuery.event={global:{},add:function(e,t,n,r,i){var s,o,u,a,f,l,c,h,p,d,v,m=data_priv.get(e);if(!m)return;n.handler&&(s=n,n=s.handler,i=s.selector),n.guid||(n.guid=jQuery.guid++),(a=m.events)||(a=m.events={}),(o=m.handle)||(o=m.handle=function(e){return typeof jQuery===core_strundefined||!!e&&jQuery.event.triggered===e.type?undefined:jQuery.event.dispatch.apply(o.elem,arguments)},o.elem=e),t=(t||"").match(core_rnotwhite)||[""],f=t.length;while(f--){u=rtypenamespace.exec(t[f])||[],p=v=u[1],d=(u[2]||"").split(".").sort();if(!p)continue;c=jQuery.event.special[p]||{},p=(i?c.delegateType:c.bindType)||p,c=jQuery.event.special[p]||{},l=jQuery.extend({type:p,origType:v,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&jQuery.expr.match.needsContext.test(i),namespace:d.join(".")},s),(h=a[p])||(h=a[p]=[],h.delegateCount=0,(!c.setup||c.setup.call(e,r,d,o)===!1)&&e.addEventListener&&e.addEventListener(p,o,!1)),c.add&&(c.add.call(e,l),l.handler.guid||(l.handler.guid=n.guid)),i?h.splice(h.delegateCount++,0,l):h.push(l),jQuery.event.global[p]=!0}e=null},remove:function(e,t,n,r,i){var s,o,u,a,f,l,c,h,p,d,v,m=data_priv.hasData(e)&&data_priv.get(e);if(!m||!(a=m.events))return;t=(t||"").match(core_rnotwhite)||[""],f=t.length;while(f--){u=rtypenamespace.exec(t[f])||[],p=v=u[1],d=(u[2]||"").split(".").sort();if(!p){for(p in a)jQuery.event.remove(e,p+t[f],n,r,!0);continue}c=jQuery.event.special[p]||{},p=(r?c.delegateType:c.bindType)||p,h=a[p]||[],u=u[2]&&new RegExp("(^|\\.)"+d.join("\\.(?:.*\\.|)")+"(\\.|$)"),o=s=h.length;while(s--)l=h[s],(i||v===l.origType)&&(!n||n.guid===l.guid)&&(!u||u.test(l.namespace))&&(!r||r===l.selector||r==="**"&&l.selector)&&(h.splice(s,1),l.selector&&h.delegateCount--,c.remove&&c.remove.call(e,l));o&&!h.length&&((!c.teardown||c.teardown.call(e,d,m.handle)===!1)&&jQuery.removeEvent(e,p,m.handle),delete a[p])}jQuery.isEmptyObject(a)&&(delete m.handle,data_priv.remove(e,"events"))},trigger:function(e,t,n,r){var i,s,o,u,a,f,l,c=[n||document],h=core_hasOwn.call(e,"type")?e.type:e,p=core_hasOwn.call(e,"namespace")?e.namespace.split("."):[];s=o=n=n||document;if(n.nodeType===3||n.nodeType===8)return;if(rfocusMorph.test(h+jQuery.event.triggered))return;h.indexOf(".")>=0&&(p=h.split("."),h=p.shift(),p.sort()),a=h.indexOf(":")<0&&"on"+h,e=e[jQuery.expando]?e:new jQuery.Event(h,typeof e=="object"&&e),e.isTrigger=r?2:3,e.namespace=p.join("."),e.namespace_re=e.namespace?new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=undefined,e.target||(e.target=n),t=t==null?[e]:jQuery.makeArray(t,[e]),l=jQuery.event.special[h]||{};if(!r&&l.trigger&&l.trigger.apply(n,t)===!1)return;if(!r&&!l.noBubble&&!jQuery.isWindow(n)){u=l.delegateType||h,rfocusMorph.test(u+h)||(s=s.parentNode);for(;s;s=s.parentNode)c.push(s),o=s;o===(n.ownerDocument||document)&&c.push(o.defaultView||o.parentWindow||window)}i=0;while((s=c[i++])&&!e.isPropagationStopped())e.type=i>1?u:l.bindType||h,f=(data_priv.get(s,"events")||{})[e.type]&&data_priv.get(s,"handle"),f&&f.apply(s,t),f=a&&s[a],f&&jQuery.acceptData(s)&&f.apply&&f.apply(s,t)===!1&&e.preventDefault();return e.type=h,!r&&!e.isDefaultPrevented()&&(!l._default||l._default.apply(c.pop(),t)===!1)&&jQuery.acceptData(n)&&a&&jQuery.isFunction(n[h])&&!jQuery.isWindow(n)&&(o=n[a],o&&(n[a]=null),jQuery.event.triggered=h,n[h](),jQuery.event.triggered=undefined,o&&(n[a]=o)),e.result},dispatch:function(e){e=jQuery.event.fix(e);var t,n,r,i,s,o=[],u=core_slice.call(arguments),a=(data_priv.get(this,"events")||{})[e.type]||[],f=jQuery.event.special[e.type]||{};u[0]=e,e.delegateTarget=this;if(f.preDispatch&&f.preDispatch.call(this,e)===!1)return;o=jQuery.event.handlers.call(this,e,a),t=0;while((i=o[t++])&&!e.isPropagationStopped()){e.currentTarget=i.elem,n=0;while((s=i.handlers[n++])&&!e.isImmediatePropagationStopped())if(!e.namespace_re||e.namespace_re.test(s.namespace))e.handleObj=s,e.data=s.data,r=((jQuery.event.special[s.origType]||{}).handle||s.handler).apply(i.elem,u),r!==undefined&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation())}return f.postDispatch&&f.postDispatch.call(this,e),e.result},handlers:function(e,t){var n,r,i,s,o=[],u=t.delegateCount,a=e.target;if(u&&a.nodeType&&(!e.button||e.type!=="click"))for(;a!==this;a=a.parentNode||this)if(a.disabled!==!0||e.type!=="click"){r=[];for(n=0;n<u;n++)s=t[n],i=s.selector+" ",r[i]===undefined&&(r[i]=s.needsContext?jQuery(i,this).index(a)>=0:jQuery.find(i,this,null,[a]).length),r[i]&&r.push(s);r.length&&o.push({elem:a,handlers:r})}return u<t.length&&o.push({elem:this,handlers:t.slice(u)}),o},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return e.which==null&&(e.which=t.charCode!=null?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,s=t.button;return e.pageX==null&&t.clientX!=null&&(n=e.target.ownerDocument||document,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),!e.which&&s!==undefined&&(e.which=s&1?1:s&2?3:s&4?2:0),e}},fix:function(e){if(e[jQuery.expando])return e;var t,n,r,i=e.type,s=e,o=this.fixHooks[i];o||(this.fixHooks[i]=o=rmouseEvent.test(i)?this.mouseHooks:rkeyEvent.test(i)?this.keyHooks:{}),r=o.props?this.props.concat(o.props):this.props,e=new jQuery.Event(s),t=r.length;while(t--)n=r[t],e[n]=s[n];return e.target.nodeType===3&&(e.target=e.target.parentNode),o.filter?o.filter(e,s):e},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==safeActiveElement()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===safeActiveElement()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if(this.type==="checkbox"&&this.click&&jQuery.nodeName(this,"input"))return this.click(),!1},_default:function(e){return jQuery.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==undefined&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=jQuery.extend(new jQuery.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?jQuery.event.trigger(i,null,t):jQuery.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},jQuery.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},jQuery.Event=function(e,t){if(!(this instanceof jQuery.Event))return new jQuery.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.getPreventDefault&&e.getPreventDefault()?returnTrue:returnFalse):this.type=e,t&&jQuery.extend(this,t),this.timeStamp=e&&e.timeStamp||jQuery.now(),this[jQuery.expando]=!0},jQuery.Event.prototype={isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=returnTrue,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=returnTrue,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=returnTrue,this.stopPropagation()}},jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){jQuery.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,s=e.handleObj;if(!i||i!==r&&!jQuery.contains(r,i))e.type=s.origType,n=s.handler.apply(this,arguments),e.type=t;return n}}}),jQuery.support.focusinBubbles||jQuery.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){jQuery.event.simulate(t,e.target,jQuery.event.fix(e),!0)};jQuery.event.special[t]={setup:function(){n++===0&&document.addEventListener(e,r,!0)},teardown:function(){--n===0&&document.removeEventListener(e,r,!0)}}}),jQuery.fn.extend({on:function(e,t,n,r,i){var s,o;if(typeof e=="object"){typeof t!="string"&&(n=n||t,t=undefined);for(o in e)this.on(o,t,n,e[o],i);return this}n==null&&r==null?(r=t,n=t=undefined):r==null&&(typeof t=="string"?(r=n,n=undefined):(r=n,n=t,t=undefined));if(r===!1)r=returnFalse;else if(!r)return this;return i===1&&(s=r,r=function(e){return jQuery().off(e),s.apply(this,arguments)},r.guid=s.guid||(s.guid=jQuery.guid++)),this.each(function(){jQuery.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,jQuery(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if(typeof e=="object"){for(i in e)this.off(i,t,e[i]);return this}if(t===!1||typeof t=="function")n=t,t=undefined;return n===!1&&(n=returnFalse),this.each(function(){jQuery.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){jQuery.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return jQuery.event.trigger(e,t,n,!0)}});var isSimple=/^.[^:#\[\.,]*$/,rneedsContext=jQuery.expr.match.needsContext,guaranteedUnique={children:!0,contents:!0,next:!0,prev:!0};jQuery.fn.extend({find:function(e){var t,n,r,i=this.length;if(typeof e!="string")return t=this,this.pushStack(jQuery(e).filter(function(){for(r=0;r<i;r++)if(jQuery.contains(t[r],this))return!0}));n=[];for(r=0;r<i;r++)jQuery.find(e,this[r],n);return n=this.pushStack(i>1?jQuery.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t=jQuery(e,this),n=t.length;return this.filter(function(){var e=0;for(;e<n;e++)if(jQuery.contains(this,t[e]))return!0})},not:function(e){return this.pushStack(winnow(this,e||[],!0))},filter:function(e){return this.pushStack(winnow(this,e||[],!1))},is:function(e){return!!e&&(typeof e=="string"?rneedsContext.test(e)?jQuery(e,this.context).index(this[0])>=0:jQuery.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,s=[],o=rneedsContext.test(e)||typeof e!="string"?jQuery(e,t||this.context):0;for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(o?o.index(n)>-1:n.nodeType===1&&jQuery.find.matchesSelector(n,e))){n=s.push(n);break}return this.pushStack(s.length>1?jQuery.unique(s):s)},index:function(e){return e?typeof e=="string"?core_indexOf.call(jQuery(e),this[0]):core_indexOf.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n=typeof e=="string"?jQuery(e,t):jQuery.makeArray(e&&e.nodeType?[e]:e),r=jQuery.merge(this.get(),n);return this.pushStack(jQuery.unique(r))},addBack:function(e){return this.add(e==null?this.prevObject:this.prevObject.filter(e))}}),jQuery.each({parent:function(e){var t=e.parentNode;return t&&t.nodeType!==11?t:null},parents:function(e){return jQuery.dir(e,"parentNode")},parentsUntil:function(e,t,n){return jQuery.dir(e,"parentNode",n)},next:function(e){return sibling(e,"nextSibling")},prev:function(e){return sibling(e,"previousSibling")},nextAll:function(e){return jQuery.dir(e,"nextSibling")},prevAll:function(e){return jQuery.dir(e,"previousSibling")},nextUntil:function(e,t,n){return jQuery.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return jQuery.dir(e,"previousSibling",n)},siblings:function(e){return jQuery.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return jQuery.sibling(e.firstChild)},contents:function(e){return jQuery.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:jQuery.merge([],e.childNodes)}},function(e,t){jQuery.fn[e]=function(n,r){var i=jQuery.map(this,t,n);return e.slice(-5)!=="Until"&&(r=n),r&&typeof r=="string"&&(i=jQuery.filter(r,i)),this.length>1&&(guaranteedUnique[e]||jQuery.unique(i),e[0]==="p"&&i.reverse()),this.pushStack(i)}}),jQuery.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),t.length===1&&r.nodeType===1?jQuery.find.matchesSelector(r,e)?[r]:[]:jQuery.find.matches(e,jQuery.grep(t,function(e){return e.nodeType===1}))},dir:function(e,t,n){var r=[],i=n!==undefined;while((e=e[t])&&e.nodeType!==9)if(e.nodeType===1){if(i&&jQuery(e).is(n))break;r.push(e)}return r},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)e.nodeType===1&&e!==t&&n.push(e);return n}});var rxhtmlTag=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,rtagName=/<([\w:]+)/,rhtml=/<|&#?\w+;/,rnoInnerhtml=/<(?:script|style|link)/i,manipulation_rcheckableType=/^(?:checkbox|radio)$/i,rchecked=/checked\s*(?:[^=]|=\s*.checked.)/i,rscriptType=/^$|\/(?:java|ecma)script/i,rscriptTypeMasked=/^true\/(.*)/,rcleanScript=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,wrapMap={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};wrapMap.optgroup=wrapMap.option,wrapMap.tbody=wrapMap.tfoot=wrapMap.colgroup=wrapMap.caption=wrapMap.col=wrapMap.thead,wrapMap.th=wrapMap.td,jQuery.fn.extend({text:function(e){return jQuery.access(this,function(e){return e===undefined?jQuery.text(this):this.empty().append((this[0]&&this[0].ownerDocument||document).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var t=manipulationTarget(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var t=manipulationTarget(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?jQuery.filter(e,this):this,i=0;for(;(n=r[i])!=null;i++)!t&&n.nodeType===1&&jQuery.cleanData(getAll(n)),n.parentNode&&(t&&jQuery.contains(n.ownerDocument,n)&&setGlobalEval(getAll(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;(e=this[t])!=null;t++)e.nodeType===1&&(jQuery.cleanData(getAll(e,!1)),e.textContent="");return this},clone:function(e,t){return e=e==null?!1:e,t=t==null?e:t,this.map(function(){return jQuery.clone(this,e,t)})},html:function(e){return jQuery.access(this,function(e){var t=this[0]||{},n=0,r=this.length;if(e===undefined&&t.nodeType===1)return t.innerHTML;if(typeof e=="string"&&!rnoInnerhtml.test(e)&&!wrapMap[(rtagName.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(rxhtmlTag,"<$1></$2>");try{for(;n<r;n++)t=this[n]||{},t.nodeType===1&&(jQuery.cleanData(getAll(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=jQuery.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],s=e[t++];s&&(jQuery(this).remove(),s.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=core_concat.apply([],e);var r,i,s,o,u,a,f=0,l=this.length,c=this,h=l-1,p=e[0],d=jQuery.isFunction(p);if(d||!(l<=1||typeof p!="string"||jQuery.support.checkClone||!rchecked.test(p)))return this.each(function(r){var i=c.eq(r);d&&(e[0]=p.call(this,r,i.html())),i.domManip(e,t,n)});if(l){r=jQuery.buildFragment(e,this[0].ownerDocument,!1,!n&&this),i=r.firstChild,r.childNodes.length===1&&(r=i);if(i){s=jQuery.map(getAll(r,"script"),disableScript),o=s.length;for(;f<l;f++)u=r,f!==h&&(u=jQuery.clone(u,!0,!0),o&&jQuery.merge(s,getAll(u,"script"))),t.call(this[f],u,f);if(o){a=s[s.length-1].ownerDocument,jQuery.map(s,restoreScript);for(f=0;f<o;f++)u=s[f],rscriptType.test(u.type||"")&&!data_priv.access(u,"globalEval")&&jQuery.contains(a,u)&&(u.src?jQuery._evalUrl(u.src):jQuery.globalEval(u.textContent.replace(rcleanScript,"")))}}}return this}}),jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){jQuery.fn[e]=function(e){var n,r=[],i=jQuery(e),s=i.length-1,o=0;for(;o<=s;o++)n=o===s?this:this.clone(!0),jQuery(i[o])[t](n),core_push.apply(r,n.get());return this.pushStack(r)}}),jQuery.extend({clone:function(e,t,n){var r,i,s,o,u=e.cloneNode(!0),a=jQuery.contains(e.ownerDocument,e);if(!jQuery.support.noCloneChecked&&(e.nodeType===1||e.nodeType===11)&&!jQuery.isXMLDoc(e)){o=getAll(u),s=getAll(e);for(r=0,i=s.length;r<i;r++)fixInput(s[r],o[r])}if(t)if(n){s=s||getAll(e),o=o||getAll(u);for(r=0,i=s.length;r<i;r++)cloneCopyEvent(s[r],o[r])}else cloneCopyEvent(e,u);return o=getAll(u,"script"),o.length>0&&setGlobalEval(o,!a&&getAll(e,"script")),u},buildFragment:function(e,t,n,r){var i,s,o,u,a,f,l=0,c=e.length,h=t.createDocumentFragment(),p=[];for(;l<c;l++){i=e[l];if(i||i===0)if(jQuery.type(i)==="object")jQuery.merge(p,i.nodeType?[i]:i);else if(!rhtml.test(i))p.push(t.createTextNode(i));else{s=s||h.appendChild(t.createElement("div")),o=(rtagName.exec(i)||["",""])[1].toLowerCase(),u=wrapMap[o]||wrapMap._default,s.innerHTML=u[1]+i.replace(rxhtmlTag,"<$1></$2>")+u[2],f=u[0];while(f--)s=s.firstChild;jQuery.merge(p,s.childNodes),s=h.firstChild,s.textContent=""}}h.textContent="",l=0;while(i=p[l++]){if(r&&jQuery.inArray(i,r)!==-1)continue;a=jQuery.contains(i.ownerDocument,i),s=getAll(h.appendChild(i),"script"),a&&setGlobalEval(s);if(n){f=0;while(i=s[f++])rscriptType.test(i.type||"")&&n.push(i)}}return h},cleanData:function(e){var t,n,r,i=e.length,s=0,o=jQuery.event.special;for(;s<i;s++){n=e[s];if(jQuery.acceptData(n)){t=data_priv.access(n);if(t)for(r in t.events)o[r]?jQuery.event.remove(n,r):jQuery.removeEvent(n,r,t.handle)}data_user.discard(n),data_priv.discard(n)}},_evalUrl:function(e){return jQuery.ajax({url:e,type:"GET",dataType:"text",async:!1,global:!1,success:jQuery.globalEval})}}),jQuery.fn.extend({wrapAll:function(e){var t;return jQuery.isFunction(e)?this.each(function(t){jQuery(this).wrapAll(e.call(this,t))}):(this[0]&&(t=jQuery(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return jQuery.isFunction(e)?this.each(function(t){jQuery(this).wrapInner(e.call(this,t))}):this.each(function(){var t=jQuery(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=jQuery.isFunction(e);return this.each(function(n){jQuery(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){jQuery.nodeName(this,"body")||jQuery(this).replaceWith(this.childNodes)}).end()}});var curCSS,iframe,rdisplayswap=/^(none|table(?!-c[ea]).+)/,rmargin=/^margin/,rnumsplit=new RegExp("^("+core_pnum+")(.*)$","i"),rnumnonpx=new RegExp("^("+core_pnum+")(?!px)[a-z%]+$","i"),rrelNum=new RegExp("^([+-])=("+core_pnum+")","i"),elemdisplay={BODY:"block"},cssShow={position:"absolute",visibility:"hidden",display:"block"},cssNormalTransform={letterSpacing:0,fontWeight:400},cssExpand=["Top","Right","Bottom","Left"],cssPrefixes=["Webkit","O","Moz","ms"];jQuery.fn.extend({css:function(e,t){return jQuery.access(this,function(e,t,n){var r,i,s={},o=0;if(jQuery.isArray(t)){r=getStyles(e),i=t.length;for(;o<i;o++)s[t[o]]=jQuery.css(e,t[o],!1,r);return s}return n!==undefined?jQuery.style(e,t,n):jQuery.css(e,t)},e,t,arguments.length>1)},show:function(){return showHide(this,!0)},hide:function(){return showHide(this)},toggle:function(e){var t=typeof e=="boolean";return this.each(function(){(t?e:isHidden(this))?jQuery(this).show():jQuery(this).hide()})}}),jQuery.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=curCSS(e,"opacity");return n===""?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(!e||e.nodeType===3||e.nodeType===8||!e.style)return;var i,s,o,u=jQuery.camelCase(t),a=e.style;t=jQuery.cssProps[u]||(jQuery.cssProps[u]=vendorPropName(a,u)),o=jQuery.cssHooks[t]||jQuery.cssHooks[u];if(n===undefined)return o&&"get"in o&&(i=o.get(e,!1,r))!==undefined?i:a[t];s=typeof n,s==="string"&&(i=rrelNum.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(jQuery.css(e,t)),s="number");if(n==null||s==="number"&&isNaN(n))return;s==="number"&&!jQuery.cssNumber[u]&&(n+="px"),!jQuery.support.clearCloneStyle&&n===""&&t.indexOf("background")===0&&(a[t]="inherit");if(!o||!("set"in o)||(n=o.set(e,n,r))!==undefined)a[t]=n},css:function(e,t,n,r){var i,s,o,u=jQuery.camelCase(t);return t=jQuery.cssProps[u]||(jQuery.cssProps[u]=vendorPropName(e.style,u)),o=jQuery.cssHooks[t]||jQuery.cssHooks[u],o&&"get"in o&&(i=o.get(e,!0,n)),i===undefined&&(i=curCSS(e,t,r)),i==="normal"&&t in cssNormalTransform&&(i=cssNormalTransform[t]),n===""||n?(s=parseFloat(i),n===!0||jQuery.isNumeric(s)?s||0:i):i}}),curCSS=function(e,t,n){var r,i,s,o=n||getStyles(e),u=o?o.getPropertyValue(t)||o[t]:undefined,a=e.style;return o&&(u===""&&!jQuery.contains(e.ownerDocument,e)&&(u=jQuery.style(e,t)),rnumnonpx.test(u)&&rmargin.test(t)&&(r=a.width,i=a.minWidth,s=a.maxWidth,a.minWidth=a.maxWidth=a.width=u,u=o.width,a.width=r,a.minWidth=i,a.maxWidth=s)),u},jQuery.each(["height","width"],function(e,t){jQuery.cssHooks[t]={get:function(e,n,r){if(n)return e.offsetWidth===0&&rdisplayswap.test(jQuery.css(e,"display"))?jQuery.swap(e,cssShow,function(){return getWidthOrHeight(e,t,r)}):getWidthOrHeight(e,t,r)},set:function(e,n,r){var i=r&&getStyles(e);return setPositiveNumber(e,n,r?augmentWidthOrHeight(e,t,r,jQuery.support.boxSizing&&jQuery.css(e,"boxSizing",!1,i)==="border-box",i):0)}}}),jQuery(function(){jQuery.support.reliableMarginRight||(jQuery.cssHooks.marginRight={get:function(e,t){if(t)return jQuery.swap(e,{display:"inline-block"},curCSS,[e,"marginRight"])}}),!jQuery.support.pixelPosition&&jQuery.fn.position&&jQuery.each(["top","left"],function(e,t){jQuery.cssHooks[t]={get:function(e,n){if(n)return n=curCSS(e,t),rnumnonpx.test(n)?jQuery(e).position()[t]+"px":n}}})}),jQuery.expr&&jQuery.expr.filters&&(jQuery.expr.filters.hidden=function(e){return e.offsetWidth<=0&&e.offsetHeight<=0},jQuery.expr.filters.visible=function(e){return!jQuery.expr.filters.hidden(e)}),jQuery.each({margin:"",padding:"",border:"Width"},function(e,t){jQuery.cssHooks[e+t]={expand:function(n){var r=0,i={},s=typeof n=="string"?n.split(" "):[n];for(;r<4;r++)i[e+cssExpand[r]+t]=s[r]||s[r-2]||s[0];return i}},rmargin.test(e)||(jQuery.cssHooks[e+t].set=setPositiveNumber)});var r20=/%20/g,rbracket=/\[\]$/,rCRLF=/\r?\n/g,rsubmitterTypes=/^(?:submit|button|image|reset|file)$/i,rsubmittable=/^(?:input|select|textarea|keygen)/i;jQuery.fn.extend({serialize:function(){return jQuery.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=jQuery.prop(this,"elements");return e?jQuery.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!jQuery(this).is(":disabled")&&rsubmittable.test(this.nodeName)&&!rsubmitterTypes.test(e)&&(this.checked||!manipulation_rcheckableType.test(e))}).map(function(e,t){var n=jQuery(this).val();return n==null?null:jQuery.isArray(n)?jQuery.map(n,function(e){return{name:t.name,value:e.replace(rCRLF,"\r\n")}}):{name:t.name,value:n.replace(rCRLF,"\r\n")}}).get()}}),jQuery.param=function(e,t){var n,r=[],i=function(e,t){t=jQuery.isFunction(t)?t():t==null?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};t===undefined&&(t=jQuery.ajaxSettings&&jQuery.ajaxSettings.traditional);if(jQuery.isArray(e)||e.jquery&&!jQuery.isPlainObject(e))jQuery.each(e,function(){i(this.name,this.value)});else for(n in e)buildParams(n,e[n],t,i);return r.join("&").replace(r20,"+")},jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){jQuery.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),jQuery.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return arguments.length===1?this.off(e,"**"):this.off(t,e||"**",n)}});var ajaxLocParts,ajaxLocation,ajax_nonce=jQuery.now(),ajax_rquery=/\?/,rhash=/#.*$/,rts=/([?&])_=[^&]*/,rheaders=/^(.*?):[ \t]*([^\r\n]*)$/mg,rlocalProtocol=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,rnoContent=/^(?:GET|HEAD)$/,rprotocol=/^\/\//,rurl=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,_load=jQuery.fn.load,prefilters={},transports={},allTypes="*/".concat("*");try{ajaxLocation=location.href}catch(e){ajaxLocation=document.createElement("a"),ajaxLocation.href="",ajaxLocation=ajaxLocation.href}ajaxLocParts=rurl.exec(ajaxLocation.toLowerCase())||[],jQuery.fn.load=function(e,t,n){if(typeof e!="string"&&_load)return _load.apply(this,arguments);var r,i,s,o=this,u=e.indexOf(" ");return u>=0&&(r=e.slice(u),e=e.slice(0,u)),jQuery.isFunction(t)?(n=t,t=undefined):t&&typeof t=="object"&&(i="POST"),o.length>0&&jQuery.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){s=arguments,o.html(r?jQuery("<div>").append(jQuery.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){o.each(n,s||[e.responseText,t,e])}),this},jQuery.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){jQuery.fn[t]=function(e){return this.on(t,e)}}),jQuery.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ajaxLocation,type:"GET",isLocal:rlocalProtocol.test(ajaxLocParts[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":allTypes,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":jQuery.parseJSON,"text xml":jQuery.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?ajaxExtend(ajaxExtend(e,jQuery.ajaxSettings),t):ajaxExtend(jQuery.ajaxSettings,e)},ajaxPrefilter:addToPrefiltersOrTransports(prefilters),ajaxTransport:addToPrefiltersOrTransports(transports),ajax:function(e,t){function S(e,t,s,u){var f,m,g,b,E,S=t;if(y===2)return;y=2,o&&clearTimeout(o),n=undefined,i=u||"",w.readyState=e>0?4:0,f=e>=200&&e<300||e===304,s&&(b=ajaxHandleResponses(l,w,s)),b=ajaxConvert(l,b,w,f);if(f)l.ifModified&&(E=w.getResponseHeader("Last-Modified"),E&&(jQuery.lastModified[r]=E),E=w.getResponseHeader("etag"),E&&(jQuery.etag[r]=E)),e===204?S="nocontent":e===304?S="notmodified":(S=b.state,m=b.data,g=b.error,f=!g);else{g=S;if(e||!S)S="error",e<0&&(e=0)}w.status=e,w.statusText=(t||S)+"",f?p.resolveWith(c,[m,S,w]):p.rejectWith(c,[w,S,g]),w.statusCode(v),v=undefined,a&&h.trigger(f?"ajaxSuccess":"ajaxError",[w,l,f?m:g]),d.fireWith(c,[w,S]),a&&(h.trigger("ajaxComplete",[w,l]),--jQuery.active||jQuery.event.trigger("ajaxStop"))}typeof e=="object"&&(t=e,e=undefined),t=t||{};var n,r,i,s,o,u,a,f,l=jQuery.ajaxSetup({},t),c=l.context||l,h=l.context&&(c.nodeType||c.jquery)?jQuery(c):jQuery.event,p=jQuery.Deferred(),d=jQuery.Callbacks("once memory"),v=l.statusCode||{},m={},g={},y=0,b="canceled",w={readyState:0,getResponseHeader:function(e){var t;if(y===2){if(!s){s={};while(t=rheaders.exec(i))s[t[1].toLowerCase()]=t[2]}t=s[e.toLowerCase()]}return t==null?null:t},getAllResponseHeaders:function(){return y===2?i:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return y||(e=g[n]=g[n]||e,m[e]=t),this},overrideMimeType:function(e){return y||(l.mimeType=e),this},statusCode:function(e){var t;if(e)if(y<2)for(t in e)v[t]=[v[t],e[t]];else w.always(e[w.status]);return this},abort:function(e){var t=e||b;return n&&n.abort(t),S(0,t),this}};p.promise(w).complete=d.add,w.success=w.done,w.error=w.fail,l.url=((e||l.url||ajaxLocation)+"").replace(rhash,"").replace(rprotocol,ajaxLocParts[1]+"//"),l.type=t.method||t.type||l.method||l.type,l.dataTypes=jQuery.trim(l.dataType||"*").toLowerCase().match(core_rnotwhite)||[""],l.crossDomain==null&&(u=rurl.exec(l.url.toLowerCase()),l.crossDomain=!(!u||u[1]===ajaxLocParts[1]&&u[2]===ajaxLocParts[2]&&(u[3]||(u[1]==="http:"?"80":"443"))===(ajaxLocParts[3]||(ajaxLocParts[1]==="http:"?"80":"443")))),l.data&&l.processData&&typeof l.data!="string"&&(l.data=jQuery.param(l.data,l.traditional)),inspectPrefiltersOrTransports(prefilters,l,t,w);if(y===2)return w;a=l.global,a&&jQuery.active++===0&&jQuery.event.trigger("ajaxStart"),l.type=l.type.toUpperCase(),l.hasContent=!rnoContent.test(l.type),r=l.url,l.hasContent||(l.data&&(r=l.url+=(ajax_rquery.test(r)?"&":"?")+l.data,delete l.data),l.cache===!1&&(l.url=rts.test(r)?r.replace(rts,"$1_="+ajax_nonce++):r+(ajax_rquery.test(r)?"&":"?")+"_="+ajax_nonce++)),l.ifModified&&(jQuery.lastModified[r]&&w.setRequestHeader("If-Modified-Since",jQuery.lastModified[r]),jQuery.etag[r]&&w.setRequestHeader("If-None-Match",jQuery.etag[r])),(l.data&&l.hasContent&&l.contentType!==!1||t.contentType)&&w.setRequestHeader("Content-Type",l.contentType),w.setRequestHeader("Accept",l.dataTypes[0]&&l.accepts[l.dataTypes[0]]?l.accepts[l.dataTypes[0]]+(l.dataTypes[0]!=="*"?", "+allTypes+"; q=0.01":""):l.accepts["*"]);for(f in l.headers)w.setRequestHeader(f,l.headers[f]);if(!l.beforeSend||l.beforeSend.call(c,w,l)!==!1&&y!==2){b="abort";for(f in{success:1,error:1,complete:1})w[f](l[f]);n=inspectPrefiltersOrTransports(transports,l,t,w);if(!n)S(-1,"No Transport");else{w.readyState=1,a&&h.trigger("ajaxSend",[w,l]),l.async&&l.timeout>0&&(o=setTimeout(function(){w.abort("timeout")},l.timeout));try{y=1,n.send(m,S)}catch(E){if(!(y<2))throw E;S(-1,E)}}return w}return w.abort()},getJSON:function(e,t,n){return jQuery.get(e,t,n,"json")},getScript:function(e,t){return jQuery.get(e,undefined,t,"script")}}),jQuery.each(["get","post"],function(e,t){jQuery[t]=function(e,n,r,i){return jQuery.isFunction(n)&&(i=i||r,r=n,n=undefined),jQuery.ajax({url:e,type:t,dataType:i,data:n,success:r})}}),jQuery.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return jQuery.globalEval(e),e}}}),jQuery.ajaxPrefilter("script",function(e){e.cache===undefined&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),jQuery.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=jQuery("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i(e.type==="error"?404:200,e.type)}),document.head.appendChild(t[0])},abort:function(){n&&n()}}}});var oldCallbacks=[],rjsonp=/(=)\?(?=&|$)|\?\?/;jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=oldCallbacks.pop()||jQuery.expando+"_"+ajax_nonce++;return this[e]=!0,e}}),jQuery.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,s,o=e.jsonp!==!1&&(rjsonp.test(e.url)?"url":typeof e.data=="string"&&!(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&rjsonp.test(e.data)&&"data");if(o||e.dataTypes[0]==="jsonp")return r=e.jsonpCallback=jQuery.isFunction(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,o?e[o]=e[o].replace(rjsonp,"$1"+r):e.jsonp!==!1&&(e.url+=(ajax_rquery.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return s||jQuery.error(r+" was not called"),s[0]},e.dataTypes[0]="json",i=window[r],window[r]=function(){s=arguments},n.always(function(){window[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,oldCallbacks.push(r)),s&&jQuery.isFunction(i)&&i(s[0]),s=i=undefined}),"script"}),jQuery.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var xhrSupported=jQuery.ajaxSettings.xhr(),xhrSuccessStatus={0:200,1223:204},xhrId=0,xhrCallbacks={};window.ActiveXObject&&jQuery(window).on("unload",function(){for(var e in xhrCallbacks)xhrCallbacks[e]();xhrCallbacks=undefined}),jQuery.support.cors=!!xhrSupported&&"withCredentials"in xhrSupported,jQuery.support.ajax=xhrSupported=!!xhrSupported,jQuery.ajaxTransport(function(e){var t;if(jQuery.support.cors||xhrSupported&&!e.crossDomain)return{send:function(n,r){var i,s,o=e.xhr();o.open(e.type,e.url,e.async,e.username,e.password);if(e.xhrFields)for(i in e.xhrFields)o[i]=e.xhrFields[i];e.mimeType&&o.overrideMimeType&&o.overrideMimeType(e.mimeType),!e.crossDomain&&!n["X-Requested-With"]&&(n["X-Requested-With"]="XMLHttpRequest");for(i in n)o.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete xhrCallbacks[s],t=o.onload=o.onerror=null,e==="abort"?o.abort():e==="error"?r(o.status||404,o.statusText):r(xhrSuccessStatus[o.status]||o.status,o.statusText,typeof o.responseText=="string"?{text:o.responseText}:undefined,o.getAllResponseHeaders()))}},o.onload=t(),o.onerror=t("error"),t=xhrCallbacks[s=xhrId++]=t("abort"),o.send(e.hasContent&&e.data||null)},abort:function(){t&&t()}}});var fxNow,timerId,rfxtypes=/^(?:toggle|show|hide)$/,rfxnum=new RegExp("^(?:([+-])=|)("+core_pnum+")([a-z%]*)$","i"),rrun=/queueHooks$/,animationPrefilters=[defaultPrefilter],tweeners={"*":[function(e,t){var n,r,i=this.createTween(e,t),s=rfxnum.exec(t),o=i.cur(),u=+o||0,a=1,f=20;if(s){n=+s[2],r=s[3]||(jQuery.cssNumber[e]?"":"px");if(r!=="px"&&u){u=jQuery.css(i.elem,e,!0)||n||1;do a=a||".5",u/=a,jQuery.style(i.elem,e,u+r);while(a!==(a=i.cur()/o)&&a!==1&&--f)}i.unit=r,i.start=u,i.end=s[1]?u+(s[1]+1)*n:n}return i}]};jQuery.Animation=jQuery.extend(Animation,{tweener:function(e,t){jQuery.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;r<i;r++)n=e[r],tweeners[n]=tweeners[n]||[],tweeners[n].unshift(t)},prefilter:function(e,t){t?animationPrefilters.unshift(e):animationPrefilters.push(e)}}),jQuery.Tween=Tween,Tween.prototype={constructor:Tween,init:function(e,t,n,r,i,s){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=s||(jQuery.cssNumber[n]?"":"px")},cur:function(){var e=Tween.propHooks[this.prop];return e&&e.get?e.get(this):Tween.propHooks._default.get(this)},run:function(e){var t,n=Tween.propHooks[this.prop];return this.options.duration?this.pos=t=jQuery.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Tween.propHooks._default.set(this),this}},Tween.prototype.init.prototype=Tween.prototype,Tween.propHooks={_default:{get:function(e){var t;return e.elem[e.prop]==null||!!e.elem.style&&e.elem.style[e.prop]!=null?(t=jQuery.css(e.elem,e.prop,""),!t||t==="auto"?0:t):e.elem[e.prop]},set:function(e){jQuery.fx.step[e.prop]?jQuery.fx.step[e.prop](e):e.elem.style&&(e.elem.style[jQuery.cssProps[e.prop]]!=null||jQuery.cssHooks[e.prop])?jQuery.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},jQuery.each(["toggle","show","hide"],function(e,t){var n=jQuery.fn[t];jQuery.fn[t]=function(e,r,i){return e==null||typeof e=="boolean"?n.apply(this,arguments):this.animate(genFx(t,!0),e,r,i)}}),jQuery.fn.extend({fadeTo:function(e,t,n,r){return this.filter(isHidden).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=jQuery.isEmptyObject(e),s=jQuery.speed(t,n,r),o=function(){var t=Animation(this,jQuery.extend({},e),s);o.finish=function(){t.stop(!0)},(i||data_priv.get(this,"finish"))&&t.stop(!0)};return o.finish=o,i||s.queue===!1?this.each(o):this.queue(s.queue,o)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return typeof e!="string"&&(n=t,t=e,e=undefined),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=e!=null&&e+"queueHooks",s=jQuery.timers,o=data_priv.get(this);if(i)o[i]&&o[i].stop&&r(o[i]);else for(i in o)o[i]&&o[i].stop&&rrun.test(i)&&r(o[i]);for(i=s.length;i--;)s[i].elem===this&&(e==null||s[i].queue===e)&&(s[i].anim.stop(n),t=!1,s.splice(i,1));(t||!n)&&jQuery.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=data_priv.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],s=jQuery.timers,o=r?r.length:0;n.finish=!0,jQuery.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this);for(t=s.length;t--;)s[t].elem===this&&s[t].queue===e&&(s[t].anim.stop(!0),s.splice(t,1));for(t=0;t<o;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),jQuery.each({slideDown:genFx("show"),slideUp:genFx("hide"),slideToggle:genFx("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){jQuery.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),jQuery.speed=function(e,t,n){var r=e&&typeof e=="object"?jQuery.extend({},e):{complete:n||!n&&t||jQuery.isFunction(e)&&e,duration:e,easing:n&&t||t&&!jQuery.isFunction(t)&&t};r.duration=jQuery.fx.off?0:typeof r.duration=="number"?r.duration:r.duration in jQuery.fx.speeds?jQuery.fx.speeds[r.duration]:jQuery.fx.speeds._default;if(r.queue==null||r.queue===!0)r.queue="fx";return r.old=r.complete,r.complete=function(){jQuery.isFunction(r.old)&&r.old.call(this),r.queue&&jQuery.dequeue(this,r.queue)},r},jQuery.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},jQuery.timers=[],jQuery.fx=Tween.prototype.init,jQuery.fx.tick=function(){var e,t=jQuery.timers,n=0;fxNow=jQuery.now();for(;n<t.length;n++)e=t[n],!e()&&t[n]===e&&t.splice(n--,1);t.length||jQuery.fx.stop(),fxNow=undefined},jQuery.fx.timer=function(e){e()&&jQuery.timers.push(e)&&jQuery.fx.start()},jQuery.fx.interval=13,jQuery.fx.start=function(){timerId||(timerId=setInterval(jQuery.fx.tick,jQuery.fx.interval))},jQuery.fx.stop=function(){clearInterval(timerId),timerId=null},jQuery.fx.speeds={slow:600,fast:200,_default:400},jQuery.fx.step={},jQuery.expr&&jQuery.expr.filters&&(jQuery.expr.filters.animated=function(e){return jQuery.grep(jQuery.timers,function(t){return e===t.elem}).length}),jQuery.fn.offset=function(e){if(arguments.length)return e===undefined?this:this.each(function(t){jQuery.offset.setOffset(this,e,t)});var t,n,r=this[0],i={top:0,left:0},s=r&&r.ownerDocument;if(!s)return;return t=s.documentElement,jQuery.contains(t,r)?(typeof r.getBoundingClientRect!==core_strundefined&&(i=r.getBoundingClientRect()),n=getWindow(s),{top:i.top+n.pageYOffset-t.clientTop,left:i.left+n.pageXOffset-t.clientLeft}):i},jQuery.offset={setOffset:function(e,t,n){var r,i,s,o,u,a,f,l=jQuery.css(e,"position"),c=jQuery(e),h={};l==="static"&&(e.style.position="relative"),u=c.offset(),s=jQuery.css(e,"top"),a=jQuery.css(e,"left"),f=(l==="absolute"||l==="fixed")&&(s+a).indexOf("auto")>-1,f?(r=c.position(),o=r.top,i=r.left):(o=parseFloat(s)||0,i=parseFloat(a)||0),jQuery.isFunction(t)&&(t=t.call(e,n,u)),t.top!=null&&(h.top=t.top-u.top+o),t.left!=null&&(h.left=t.left-u.left+i),"using"in t?t.using.call(e,h):c.css(h)}},jQuery.fn.extend({position:function(){if(!this[0])return;var e,t,n=this[0],r={top:0,left:0};return jQuery.css(n,"position")==="fixed"?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),jQuery.nodeName(e[0],"html")||(r=e.offset()),r.top+=jQuery.css(e[0],"borderTopWidth",!0),r.left+=jQuery.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-jQuery.css(n,"marginTop",!0),left:t.left-r.left-jQuery.css(n,"marginLeft",!0)}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||docElem;while(e&&!jQuery.nodeName(e,"html")&&jQuery.css(e,"position")==="static")e=e.offsetParent;return e||docElem})}}),jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,t){var n="pageYOffset"===t;jQuery.fn[e]=function(r){return jQuery.access(this,function(e,r,i){var s=getWindow(e);if(i===undefined)return s?s[t]:e[r];s?s.scrollTo(n?window.pageXOffset:i,n?i:window.pageYOffset):e[r]=i},e,r,arguments.length,null)}}),jQuery.each({Height:"height",Width:"width"},function(e,t){jQuery.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){jQuery.fn[r]=function(r,i){var s=arguments.length&&(n||typeof r!="boolean"),o=n||(r===!0||i===!0?"margin":"border");return jQuery.access(this,function(t,n,r){var i;return jQuery.isWindow(t)?t.document.documentElement["client"+e]:t.nodeType===9?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):r===undefined?jQuery.css(t,n,o):jQuery.style(t,n,r,o)},t,s?r:undefined,s,null)}})}),jQuery.fn.size=function(){return this.length},jQuery.fn.andSelf=jQuery.fn.addBack,typeof window=="object"&&typeof window.document=="object"&&(window.jQuery=window.$=jQuery)}(window),jQuery.noConflict(!0)});
\ No newline at end of file
diff --git a/public/js/libs/gmaps.js b/public/js/libs/gmaps.js
new file mode 100644
index 0000000..750569b
--- /dev/null
+++ b/public/js/libs/gmaps.js
@@ -0,0 +1 @@
+timely.define(["ai1ec_config"],function(e){var t=e.language,n="async!https://maps.google.com/maps/api/js?sensor=false&language="+t;return function(e){typeof google=="object"&&typeof google.maps=="object"?e():timely.require([n],e)}});
\ No newline at end of file
diff --git a/public/js/main.js b/public/js/main.js
new file mode 100644
index 0000000..1c8a0e7
--- /dev/null
+++ b/public/js/main.js
@@ -0,0 +1 @@
+;
\ No newline at end of file
diff --git a/public/js/pages/add_new_event.js b/public/js/pages/add_new_event.js
new file mode 100644
index 0000000..2b01b16
--- /dev/null
+++ b/public/js/pages/add_new_event.js
@@ -0,0 +1,59 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+
+/* =========================================================
+	 * bootstrap-modal.js v2.2.2
+	 * http://twitter.github.com/bootstrap/javascript.html#modals
+	 * =========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * ========================================================= */
+
+/*!
+			 * jQuery blockUI plugin
+			 * Version 2.59.0-2013.04.05
+			 * @requires jQuery v1.7 or later
+			 *
+			 * Examples at: http://malsup.com/jquery/block/
+			 * Copyright (c) 2007-2013 M. Alsup
+			 * Dual licensed under the MIT and GPL licenses:
+			 * http://www.opensource.org/licenses/mit-license.php
+			 * http://www.gnu.org/licenses/gpl.html
+			 *
+			 * Thanks to Amir-Hossein Sobhi for some excellent contributions!
+			 */
+
+/* =============================================================
+ * bootstrap-collapse.js v2.0.4
+ * http://twitter.github.com/bootstrap/javascript.html#collapse
+ * =============================================================
+ * Copyright 2012 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ============================================================ */
+
+timely.define("domReady",[],function(){function u(e){var t;for(t=0;t<e.length;t++)e[t](n)}function a(){var e=r;t&&e.length&&(r=[],u(e))}function f(){t||(t=!0,o&&clearInterval(o),a())}function c(e){return t?e(n):r.push(e),c}var e=typeof window!="undefined"&&window.document,t=!e,n=e?document:null,r=[],i,s,o;if(e){if(document.addEventListener)document.addEventListener("DOMContentLoaded",f,!1),window.addEventListener("load",f,!1);else if(window.attachEvent){window.attachEvent("onload",f),s=document.createElement("div");try{i=window.frameElement===null}catch(l){}s.doScroll&&i&&window.external&&(o=setInterval(function(){try{s.doScroll(),f()}catch(e){}},30))}(document.readyState==="complete"||document.readyState==="interactive")&&f()}return c.version="2.0.0",c.load=function(e,t,n,r){r.isBuild?n(null):c(n)},c}),timely.define("external_libs/bootstrap_tab",["jquery_timely"],function(e){var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active a").last()[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}},e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e(function(){e("body").on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})})}),timely.define("libs/utils",["jquery_timely","external_libs/bootstrap_tab"],function(e){var t=function(){return{is_float:function(e){return!isNaN(parseFloat(e))},is_valid_coordinate:function(e,t){var n=t?90:180;return this.is_float(e)&&Math.abs(e)<n},convert_comma_to_dot:function(e){return e.replace(",",".")},field_has_value:function(t){var n="#"+t,r=e(n),i=!1;return r.length===1&&(i=e.trim(r.val())!==""),i},make_alert:function(t,n,r){var i="";switch(n){case"error":i="alert alert-error";break;case"success":i="alert alert-success";break;default:i="alert"}var s=e("<div />",{"class":i,html:t});if(!r){var o=e("<a />",{"class":"close","data-dismiss":"alert",href:"#",text:"x"});s.prepend(o)}return s},get_ajax_url:function(){return typeof window.ajaxurl=="undefined"?"http://localhost/wordpress/wp-admin/admin-ajax.php":window.ajaxurl},isUrl:function(e){var t=/(http|https|webcal):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;return t.test(e)},isValidEmail:function(e){var t=/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;return t.test(e)},activate_saved_tab_on_page_load:function(t){null===t||undefined===t?e("ul.nav-tabs a:first").tab("show"):e("ul.nav-tabs a[href="+t+"]").tab("show")}}}();return t}),timely.define("scripts/add_new_event/event_location/input_coordinates_utility_functions",["jquery_timely","ai1ec_config","libs/utils"],function(e,t,n){var r=function(){e("#ai1ec_input_coordinates:checked").length>0&&e("#ai1ec_table_coordinates input.coordinates").each(function(){this.value=n.convert_comma_to_dot(this.value)})},i=function(t,n){var r=e("<div />",{text:n,"class":"ai1ec-error"});e(t).after(r)},s=function(t,n){t.target.id==="post"&&(t.stopImmediatePropagation(),t.preventDefault(),e("#publish").removeClass("button-primary-disabled"),e("#publish").siblings(".spinner").css("visibility","hidden")),e(n).focus()},o=function(){var t=n.field_has_value("ai1ec_address"),r=!0;return e(".coordinates").each(function(){var e=n.field_has_value(this.id);e||(r=!1)}),t||r},u=function(n){var r=!0,o=!1;return e("#ai1ec_input_coordinates:checked").length>0&&(e("div.ai1ec-error").remove(),e("#ai1ec_table_coordinates input.coordinates").each(function(){var n=e(this).hasClass("latitude"),s=n?t.error_message_not_entered_lat:t.error_message_not_entered_long;this.value===""&&(r=!1,o===!1&&(o=this),i(this,s))})),r===!1&&s(n,o),r},a=function(r){if(e("#ai1ec_input_coordinates:checked").length===1){e("div.ai1ec-error").remove();var o=!0,u=!1,a=!1;return e("#ai1ec_table_coordinates input.coordinates").each(function(){if(this.value===""){a=!0;return}var r=e(this).hasClass("latitude"),s=r?t.error_message_not_valid_lat:t.error_message_not_valid_long;n.is_valid_coordinate(this.value,r)||(o=!1,u===!1&&(u=this),i(this,s))}),o===!1&&s(r,u),a===!0&&(o=!1),o}};return{ai1ec_convert_commas_to_dots_for_coordinates:r,ai1ec_show_error_message_after_element:i,check_if_address_or_coordinates_are_set:o,ai1ec_check_lat_long_fields_filled_when_publishing_event:u,ai1ec_check_lat_long_ok_for_search:a}}),timely.define("external_libs/jquery.autocomplete_geomod",["jquery_timely"],function(e){e.fn.extend({autocomplete:function(t,n){var r=typeof t=="string";return n=e.extend({},e.Autocompleter.defaults,{url:r?t:null,data:r?null:t,delay:r?e.Autocompleter.defaults.delay:10,max:n&&!n.scroll?10:150},n),n.highlight=n.highlight||function(e){return e},n.formatMatch=n.formatMatch||n.formatItem,this.each(function(){new e.Autocompleter(this,n)})},result:function(e){return this.bind("result",e)},search:function(e){return this.trigger("search",[e])},flushCache:function(){return this.trigger("flushCache")},setOptions:function(e){return this.trigger("setOptions",[e])},unautocomplete:function(){return this.trigger("unautocomplete")}}),e.Autocompleter=function(t,n){function d(){var r=h.selected();if(!r)return!1;var s=r.result;o=s;if(n.multiple){var u=m(i.val());if(u.length>1){var a=n.multipleSeparator.length,f=e(t).selection().start,l,c=0;e.each(u,function(e,t){c+=t.length;if(f<=c)return l=e,!1;c+=a}),u[l]=s,s=u.join(n.multipleSeparator)}s+=n.multipleSeparator}return i.val(s),w(),i.trigger("result",[r.data,r.value]),!0}function v(e,t){if(f==r.DEL){h.hide();return}var s=i.val();if(!t&&s==o)return;o=s,s=g(s),s.length>=n.minChars?(i.addClass(n.loadingClass),n.matchCase||(s=s.toLowerCase()),S(s,E,w)):(T(),h.hide())}function m(t){return t?n.multiple?e.map(t.split(n.multipleSeparator),function(n){return e.trim(t).length?e.trim(n):null}):[e.trim(t)]:[""]}function g(r){if(!n.multiple)return r;var i=m(r);if(i.length==1)return i[0];var s=e(t).selection().start;return s==r.length?i=m(r):i=m(r.replace(r.substring(s),"")),i[i.length-1]}function y(s,u){n.autoFill&&g(i.val()).toLowerCase()==s.toLowerCase()&&f!=r.BACKSPACE&&(i.val(i.val()+u.substring(g(o).length)),e(t).selection(o.length,o.length+u.length))}function b(){clearTimeout(s),s=setTimeout(w,200)}function w(){var e=h.visible();h.hide(),clearTimeout(s),T(),n.mustMatch&&i.search(function(e){if(!e)if(n.multiple){var t=m(i.val()).slice(0,-1);i.val(t.join(n.multipleSeparator)+(t.length?n.multipleSeparator:""))}else i.val(""),i.trigger("result",null)})}function E(e,t){t&&t.length&&a?(T(),h.display(t,e),y(e,t[0].value),h.show()):w()}function S(r,i,s){n.matchCase||(r=r.toLowerCase());var o=u.load(r);if(o&&o.length)i(r,o);else if(n.geocoder){var a=g(r),f={address:a};n.region&&(f.region=n.region),n.geocoder.geocode(f,function(e,t){var s=n.parse(e,t,a);u.add(r,s),i(r,s)})}else if(typeof n.url=="string"&&n.url.length>0){var l={timestamp:+(new Date)};e.each(n.extraParams,function(e,t){l[e]=typeof t=="function"?t():t}),e.ajax({mode:"abort",port:"autocomplete"+t.name,dataType:n.dataType,url:n.url,data:e.extend({q:g(r),limit:n.max},l),success:function(e){var t=n.parse&&n.parse(e)||x(e);u.add(r,t),i(r,t)}})}else h.emptyList(),s(r)}function x(t){var r=[],i=t.split("\n");for(var s=0;s<i.length;s++){var o=e.trim(i[s]);o&&(o=o.split("|"),r[r.length]={data:o,value:o[0],result:n.formatResult&&n.formatResult(o,o[0])||o[0]})}return r}function T(){i.removeClass(n.loadingClass)}var r={UP:38,DOWN:40,DEL:46,TAB:9,RETURN:13,ESC:27,COMMA:188,PAGEUP:33,PAGEDOWN:34,BACKSPACE:8},i=e(t).attr("autocomplete","off").addClass(n.inputClass),s,o="",u=e.Autocompleter.Cache(n),a=0,f,l=navigator.userAgent.match(/opera/i),c={mouseDownOnSelect:!1},h=e.Autocompleter.Select(n,t,d,c),p;l&&e(t.form).bind("submit.autocomplete",function(){if(p)return p=!1,!1}),i.bind((l?"keypress":"keydown")+".autocomplete",function(t){a=1,f=t.keyCode;switch(t.keyCode){case r.UP:t.preventDefault(),h.visible()?h.prev():v(0,!0);break;case r.DOWN:t.preventDefault(),h.visible()?h.next():v(0,!0);break;case r.PAGEUP:t.preventDefault(),h.visible()?h.pageUp():v(0,!0);break;case r.PAGEDOWN:t.preventDefault(),h.visible()?h.pageDown():v(0,!0);break;case n.multiple&&e.trim(n.multipleSeparator)==","&&r.COMMA:case r.TAB:case r.RETURN:if(d())return t.preventDefault(),p=!0,!1;break;case r.ESC:h.hide();break;default:clearTimeout(s),s=setTimeout(v,n.delay)}}).focus(function(){a++}).blur(function(){a=0,c.mouseDownOnSelect||b()}).click(function(){a++>1&&!h.visible()&&v(0,!0)}).bind("search",function(){function n(e,n){var r;if(n&&n.length)for(var s=0;s<n.length;s++)if(n[s].result.toLowerCase()==e.toLowerCase()){r=n[s];break}typeof t=="function"?t(r):i.trigger("result",r&&[r.data,r.value])}var t=arguments.length>1?arguments[1]:null;e.each(m(i.val()),function(e,t){S(t,n,n)})}).bind("flushCache",function(){u.flush()}).bind("setOptions",function(){e.extend(n,arguments[1]),"data"in arguments[1]&&u.populate()}).bind("unautocomplete",function(){h.unbind(),i.unbind(),e(t.form).unbind(".autocomplete")})},e.Autocompleter.defaults={inputClass:"ac_input",resultsClass:"ac_results",loadingClass:"ac_loading",minChars:1,delay:400,matchCase:!1,matchSubset:!0,matchContains:!1,cacheLength:10,max:100,mustMatch:!1,extraParams:{},selectFirst:!0,formatItem:function(e){return e[0]},formatMatch:null,autoFill:!1,width:0,multiple:!1,multipleSeparator:", ",highlight:function(e,t){return e.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)("+t.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi,"\\$1")+")(?![^<>]*>)(?![^&;]+;)","gi"),"<strong>$1</strong>")},scroll:!0,scrollHeight:180},e.Autocompleter.Cache=function(t){function i(e,n){t.matchCase||(e=e.toLowerCase());var r=e.indexOf(n);return t.matchContains=="word"&&(r=e.toLowerCase().search("\\b"+n.toLowerCase())),r==-1?!1:r==0||t.matchContains}function s(e,i){r>t.cacheLength&&u(),n[e]||r++,n[e]=i}function o(){if(!t.data)return!1;var n={},r=0;t.url||(t.cacheLength=1),n[""]=[];for(var i=0,o=t.data.length;i<o;i++){var u=t.data[i];u=typeof u=="string"?[u]:u;var a=t.formatMatch(u,i+1,t.data.length);if(a===!1)continue;var f=a.charAt(0).toLowerCase();n[f]||(n[f]=[]);var l={value:a,data:u,result:t.formatResult&&t.formatResult(u)||a};n[f].push(l),r++<t.max&&n[""].push(l)}e.each(n,function(e,n){t.cacheLength++,s(e,n)})}function u(){n={},r=0}var n={},r=0;return setTimeout(o,25),{flush:u,add:s,populate:o,load:function(s){if(!t.cacheLength||!r)return null;if(!t.url&&t.matchContains){var o=[];for(var u in n)if(u.length>0){var a=n[u];e.each(a,function(e,t){i(t.value,s)&&o.push(t)})}return o}if(n[s])return n[s];if(t.matchSubset)for(var f=s.length-1;f>=t.minChars;f--){var a=n[s.substr(0,f)];if(a){var o=[];return e.each(a,function(e,t){i(t.value,s)&&(o[o.length]=t)}),o}}return null}}},e.Autocompleter.Select=function(t,n,r,i){function p(){if(!l)return;c=e("<div/>").hide().addClass(t.resultsClass).css("position","absolute").appendTo(document.body),h=e("<ul/>").appendTo(c).mouseover(function(t){d(t).nodeName&&d(t).nodeName.toUpperCase()=="LI"&&(u=e("li",h).removeClass(s.ACTIVE).index(d(t)),e(d(t)).addClass(s.ACTIVE))}).click(function(t){return e(d(t)).addClass(s.ACTIVE),r(),n.focus(),!1}).mousedown(function(){i.mouseDownOnSelect=!0}).mouseup(function(){i.mouseDownOnSelect=!1}),t.width>0&&c.css("width",t.width),l=!1}function d(e){var t=e.target;while(t&&t.tagName!="LI")t=t.parentNode;return t?t:[]}function v(e){o.slice(u,u+1).removeClass(s.ACTIVE),m(e);var n=o.slice(u,u+1).addClass(s.ACTIVE);if(t.scroll){var r=0;o.slice(0,u).each(function(){r+=this.offsetHeight}),r+n[0].offsetHeight-h.scrollTop()>h[0].clientHeight?h.scrollTop(r+n[0].offsetHeight-h.innerHeight()):r<h.scrollTop()&&h.scrollTop(r)}}function m(e){u+=e,u<0?u=o.size()-1:u>=o.size()&&(u=0)}function g(e){return t.max&&t.max<e?t.max:e}function y(){h.empty();var n=g(a.length);for(var r=0;r<n;r++){if(!a[r])continue;var i=t.formatItem(a[r].data,r+1,n,a[r].value,f);if(i===!1)continue;var l=e("<li/>").html(t.highlight(i,f)).addClass(r%2==0?"ac_even":"ac_odd").appendTo(h)[0];e.data(l,"ac_data",a[r])}o=h.find("li"),t.selectFirst&&(o.slice(0,1).addClass(s.ACTIVE),u=0),e.fn.bgiframe&&h.bgiframe()}var s={ACTIVE:"ac_over"},o,u=-1,a,f="",l=!0,c,h;return{display:function(e,t){p(),a=e,f=t,y()},next:function(){v(1)},prev:function(){v(-1)},pageUp:function(){u!=0&&u-8<0?v(-u):v(-8)},pageDown:function(){u!=o.size()-1&&u+8>o.size()?v(o.size()-1-u):v(8)},hide:function(){c&&c.hide(),o&&o.removeClass(s.ACTIVE),u=-1},visible:function(){return c&&c.is(":visible")},current:function(){return this.visible()&&(o.filter("."+s.ACTIVE)[0]||t.selectFirst&&o[0])},show:function(){var r=e(n).offset();c.css({width:typeof t.width=="string"||t.width>0?t.width:e(n).width(),top:r.top+n.offsetHeight,left:r.left}).show();if(t.scroll){h.scrollTop(0),h.css({maxHeight:t.scrollHeight,overflow:"auto"});if(navigator.userAgent.match(/msie/i)&&typeof document.body.style.maxHeight=="undefined"){var i=0;o.each(function(){i+=this.offsetHeight});var s=i>t.scrollHeight;h.css("height",s?t.scrollHeight:i),s||o.width(h.width()-parseInt(o.css("padding-left"))-parseInt(o.css("padding-right")))}}},selected:function(){var t=o&&o.filter("."+s.ACTIVE).removeClass(s.ACTIVE);return t&&t.length&&e.data(t[0],"ac_data")},emptyList:function(){h&&h.empty()},unbind:function(){c&&c.remove()}}},e.fn.selection=function(e,t){if(e!==undefined)return this.each(function(){if(this.createTextRange){var n=this.createTextRange();t===undefined||e==t?(n.move("character",e),n.select()):(n.collapse(!0),n.moveStart("character",e),n.moveEnd("character",t),n.select())}else this.setSelectionRange?this.setSelectionRange(e,t):this.selectionStart&&(this.selectionStart=e,this.selectionEnd=t)});var n=this[0];if(n.createTextRange){var r=document.selection.createRange(),i=n.value,s="<->",o=r.text.length;r.text=s;var u=n.value.indexOf(s);return n.value=i,this.selection(u,u+o),{start:u,end:u+o}}if(n.selectionStart!==undefined)return{start:n.selectionStart,end:n.selectionEnd}}}),timely.define("external_libs/geo_autocomplete",["jquery_timely","external_libs/jquery.autocomplete_geomod"],function(e){e.fn.extend({geo_autocomplete:function(t,n){return options=e.extend({},e.Autocompleter.defaults,{geocoder:t,mapwidth:100,mapheight:100,maptype:"terrain",mapkey:"ABQIAAAAbnvDoAoYOSW2iqoXiGTpYBT2yXp_ZAY8_ufC3CFXhHIE1NvwkxQNumU68AwGqjbSNF9YO8NokKst8w",mapsensor:!1,parse:function(t,n,r){var i=[];return t&&n&&n=="OK"&&e.each(t,function(t,n){if(n.geometry&&n.geometry.viewport){var s=n.formatted_address.split(","),o=s[0];e.each(s,function(t,n){if(n.toLowerCase().indexOf(r.toLowerCase())!=-1)return o=e.trim(n),!1}),i.push({data:n,value:o,result:o})}}),i},formatItem:function(e,t,n,r){var i="https://maps.google.com/maps/api/staticmap?visible="+e.geometry.viewport.getSouthWest().toUrlValue()+"|"+e.geometry.viewport.getNorthEast().toUrlValue()+"&size="+options.mapwidth+"x"+options.mapheight+"&maptype="+options.maptype+"&key="+options.mapkey+"&sensor="+(options.mapsensor?"true":"false"),s=e.formatted_address.replace(/,/gi,",<br/>");return'<img src="'+i+'" width="'+options.mapwidth+'" height="'+options.mapheight+'" /> '+s+'<br clear="both"/>'}},n),options.highlight=options.highlight||function(e){return e},options.formatMatch=options.formatMatch||options.formatItem,options.resultsClass="ai1ec-geo-ac-results-not-ready",this.each(function(){e(this).one("focus",function(){var t=setInterval(function(){var n=e(".ai1ec-geo-ac-results-not-ready");n.length&&(n.removeClass("ai1ec-geo-ac-results-not-ready").addClass("ai1ec-geo-ac-results").wrap('<div class="timely"/>').children("ul").addClass("dropdown-menu"),clearInterval(t))},500)}),new e.Autocompleter(this,options)})}})}),timely.define("scripts/add_new_event/event_location/gmaps_helper",["jquery_timely","domReady","ai1ec_config","scripts/add_new_event/event_location/input_coordinates_utility_functions","external_libs/jquery.autocomplete_geomod","external_libs/geo_autocomplete"],function(e,t,n,r){var i,s,o,u,a,f,l=function(t){e("input.longitude").val(t.latLng.lng()),e("input.latitude").val(t.latLng.lat()),e("#ai1ec_input_coordinates:checked").length===0&&e("#ai1ec_input_coordinates").trigger("click")},c=function(){!navigator.geolocation||navigator.geolocation.getCurrentPosition(function(e){var t=r.check_if_address_or_coordinates_are_set();if(t===!1){var n=e.coords.latitude,i=e.coords.longitude;s=new google.maps.LatLng(n,i),a.setPosition(s),u.setCenter(s),u.setZoom(15),f=e}})},h=function(){n.disable_autocompletion||e("#ai1ec_address").bind("keypress keyup keydown change",function(t){e("#ai1ec_input_coordinates:checked").length&&t.stopImmediatePropagation()}).geo_autocomplete(new google.maps.Geocoder,{selectFirst:!1,minChars:3,cacheLength:50,width:300,scroll:!0,scrollHeight:330,region:n.region}).result(function(e,t){t&&d(t)}).change(function(){if(e(this).val().length>0){var t=e(this).val();i.geocode({address:t,region:n.region},function(e,t){t===google.maps.GeocoderStatus.OK&&d(e[0])})}})},p=function(){i=new google.maps.Geocoder,s=new google.maps.LatLng(9.965,-83.327),o={zoom:0,mapTypeId:google.maps.MapTypeId.ROADMAP,center:s},t(function(){e("#ai1ec_map_canvas").length>0&&(u=new google.maps.Map(e("#ai1ec_map_canvas").get(0),o),a=new google.maps.Marker({map:u,draggable:!0}),google.maps.event.addListener(a,"dragend",l),a.setPosition(s),c(),h(),m())})},d=function(t){u.setCenter(t.geometry.location),u.setZoom(15),a.setPosition(t.geometry.location),e("#ai1ec_address").val(t.formatted_address),e("#ai1ec_latitude").val(t.geometry.location.lat()),e("#ai1ec_longitude").val(t.geometry.location.lng()),e("#ai1ec_input_coordinates").is(":checked")||e("#ai1ec_input_coordinates").click();var n="",r="",i="",s=0,o=0,f="";for(var l=0;l<t.address_components.length;l++)switch(t.address_components[l].types[0]){case"street_number":n=t.address_components[l].long_name;break;case"route":r=t.address_components[l].long_name;break;case"locality":i=t.address_components[l].long_name;break;case"administrative_area_level_1":f=t.address_components[l].long_name;break;case"postal_code":s=t.address_components[l].long_name;break;case"country":o=t.address_components[l].long_name}var c=n.length>0?n+" ":"";c+=r.length>0?r:"",s=s!==0?s:"",e("#ai1ec_city").val(i),e("#ai1ec_province").val(f),e("#ai1ec_postal_code").val(s),e("#ai1ec_country").val(o)},v=function(){var t=parseFloat(e("input.latitude").val()),n=parseFloat(e("input.longitude").val()),r=new google.maps.LatLng(t,n);u.setCenter(r),u.setZoom(15),a.setPosition(r)},m=function(){e("#ai1ec_input_coordinates:checked").length===0?(e("#ai1ec_table_coordinates").css({visibility:"hidden"}),e("#ai1ec_address").change()):v()},g=function(){return a},y=function(){return f};return{init_gmaps:p,ai1ec_update_map_from_coordinates:v,get_marker:g,get_position:y}}),timely.define("scripts/add_new_event/event_location/input_coordinates_event_handlers",["jquery_timely","scripts/add_new_event/event_location/input_coordinates_utility_functions","scripts/add_new_event/event_location/gmaps_helper","ai1ec_config"],function(e,t,n,r){var i=function(t){e(this).is(":checked")?e(".ai1ec_box_map").addClass("ai1ec_box_map_visible").hide().slideDown("fast"):e(".ai1ec_box_map").slideUp("fast")},s=function(t){this.checked===!0?e("#ai1ec_table_coordinates").css({visibility:"visible"}):(e("#ai1ec_table_coordinates").css({visibility:"hidden"}),e("#ai1ec_table_coordinates input").val(""),e("div.ai1ec-error").remove())},o=function(e){t.ai1ec_convert_commas_to_dots_for_coordinates();var r=t.ai1ec_check_lat_long_ok_for_search(e);r===!0&&n.ai1ec_update_map_from_coordinates()};return{toggle_visibility_of_google_map_on_click:i,toggle_visibility_of_coordinate_fields_on_click:s,update_map_from_coordinates_on_blur:o}}),timely.define("scripts/add_new_event/event_date_time/date_time_utility_functions",["jquery_timely","ai1ec_config","libs/utils"],function(e,t,n){var r=n.get_ajax_url(),i=function(){e("#ai1ec_count_holder, #ai1ec_until_holder").hide()},s=function(t,n,r,i,s,o){e(t).val(i),e.unblockUI();var u=e.trim(e(n).text());u.lastIndexOf(":")===-1&&(u=u.substring(0,u.length-3),e(n).text(u+":")),e(s).attr("disabled",!1),e(r).fadeOut("fast",function(){e(this).text(o.message),e(this).fadeIn("fast")})},o=function(t,n,r,i){e.growlUI("Error",r.message),e(i).attr("disabled",!1),e(t).val("");var s=e.trim(e(n).text());s.lastIndexOf("...")===-1&&(s=s.substring(0,s.length-1),e(n).text(s+"...")),e(this).closest("tr").find(".ai1ec_rule_text").text()===""&&e(t).siblings("input:checkbox").removeAttr("checked")},u=function(t,n,r,i,s){e(document).on("click",t,function(){if(!e(n).is(":checked")){e(n).attr("checked",!0);var t=e.trim(e(r).text());t=t.substring(0,t.length-3),e(r).text(t+":")}return c(i,s),!1})},a=function(t,n,r,i,s){e(t).click(function(){if(e(this).is(":checked"))this.id==="ai1ec_repeat"&&e("#ai1ec_exclude").removeAttr("disabled"),c(i,s);else{this.id==="ai1ec_repeat"&&e("#ai1ec_exclude").attr("disabled",!0),e(n).text("");var t=e.trim(e(r).text());t=t.substring(0,t.length-1),e(r).text(t+"...")}})},f=function(t,n,r){if(e.trim(e(t).text())===""){e(n).removeAttr("checked"),e("#ai1ec_repeat").is(":checked")||e("#ai1ec_exclude").attr("disabled",!0);var i=e.trim(e(r).text());i.lastIndexOf("...")===-1&&(i=i.substring(0,i.length-1),e(r).text(i+"..."))}},l=function(){e("#ai1ec_count, #ai1ec_daily_count, #ai1ec_weekly_count, #ai1ec_monthly_count, #ai1ec_yearly_count").rangeinput({css:{input:"ai1ec-range",slider:"ai1ec-slider",progress:"ai1ec-progress",handle:"ai1ec-handle"}});var n={start_date_input:"#ai1ec_until-date-input",start_time:"#ai1ec_until-time",date_format:t.date_format,month_names:t.month_names,day_names:t.day_names,week_start_day:t.week_start_day,twentyfour_hour:t.twentyfour_hour,now:new Date(t.now*1e3)};e.inputdate(n)},c=function(t,n){e.blockUI({message:'<div class="ai1ec-repeat-box-loading"></div>',css:{width:"358px",border:"0",background:"transparent",cursor:"normal"}}),e.post(r,t,function(t){t.error?(window.alert(t.message),e.unblockUI()):(e.blockUI({message:t.message,css:{width:"358px",border:"0",background:"transparent",cursor:"normal"}}),typeof n=="function"&&n())},"json")};return{ai1ec_show_repeat_tabs:c,ai1ec_apply_js_on_repeat_block:l,ai1ec_click_on_modal_cancel:f,ai1ec_click_on_checkbox:a,ai1ec_click_on_ics_rule_text:u,ai1ec_repeat_form_error:o,ai1ec_repeat_form_success:s,hide_all_end_fields:i}}),timely.define("external_libs/jquery.calendrical_timespan",["jquery_timely"],function(e){function o(){var e=new Date;return new Date(e.getFullYear(),e.getMonth(),e.getDate())}function u(e,t){return typeof e=="string"&&(e=new Date(e)),typeof t=="string"&&(t=new Date(t)),e.getUTCDate()===t.getUTCDate()&&e.getUTCMonth()===t.getUTCMonth()&&e.getUTCFullYear()===t.getUTCFullYear()?!0:!1}function a(e,t){if(e instanceof Date)return a(e.getUTCFullYear(),e.getUTCMonth());if(t==1){var n=e%4==0&&(e%100!=0||e%400==0);return n?29:28}return t==3||t==5||t==8||t==10?30:31}function f(e){return new Date(e.getTime()+864e5)}function l(e){return new Date(e.getTime()-864e5)}function c(e,t){return t==11?new Date(e+1,0,1):new Date(e,t+1,1)}function h(t,n,r,i){var s=i.monthNames.split(","),o=e("<thead />"),u=e("<tr />").appendTo(o);e("<th />").addClass("monthCell").append(e('<a href="javascript:;">&laquo;</a>').addClass("prevMonth").mousedown(function(e){p(t,r==0?n-1:n,r==0?11:r-1,i),e.preventDefault()})).appendTo(u),e("<th />").addClass("monthCell").attr("colSpan",5).append(e('<a href="javascript:;">'+s[r]+" "+n+"</a>").addClass("monthName")).appendTo(u),e("<th />").addClass("monthCell").append(e('<a href="javascript:;">&raquo;</a>').addClass("nextMonth").mousedown(function(){p(t,r==11?n+1:n,r==11?0:r+1,i)})).appendTo(u);var a=i.dayNames.split(","),f=parseInt(i.weekStartDay),l=[];for(var c=0,h=a.length;c<h;c++)l[c]=a[(c+f)%h];var d=e("<tr />").appendTo(o);return e.each(l,function(t,n){e("<td />").addClass("dayName").append(n).appendTo(d)}),o}function p(t,n,r,i){i=i||{};var s=parseInt(i.weekStartDay),a=i.today?i.today:o();a.setHours(0),a.setMinutes(0);var p=new Date(n,r,1),d=c(n,r),v=Math.abs(a.getTimezoneOffset());v!=0&&(a.setHours(a.getHours()+v/60),a.setMinutes(a.getMinutes()+v%60),p.setHours(p.getHours()+v/60),p.setMinutes(p.getMinutes()+v%60),d.setHours(d.getHours()+v/60),d.setMinutes(d.getMinutes()+v%60));var m=d.getUTCDay()-s;m<0?m=Math.abs(m)-1:m=6-m;for(var g=0;g<m;g++)d=f(d);var y=e("<table />");h(t,n,r,i).appendTo(y);var b=e("<tbody />").appendTo(y),w=e("<tr />"),E=p.getUTCDay()-s;E<0&&(E=7+E);for(var g=0;g<E;g++)p=l(p);while(p<=d){var S=e("<td />").addClass("day").append(e('<a href="javascript:;">'+p.getUTCDate()+"</a>").click(function(){var e=p;return function(){i&&i.selectDate&&i.selectDate(e)}}())).appendTo(w),x=u(p,a),T=i.selected&&u(i.selected,p);x&&S.addClass("today"),T&&S.addClass("selected"),x&&T&&S.addClass("today_selected"),p.getUTCMonth()!=r&&S.addClass("nonMonth");var N=p.getUTCDay();(N+1)%7==s&&(b.append(w),w=e("<tr />")),p=f(p)}w.children().length?b.append(w):w.remove(),t.empty().append(y)}function d(t,n){var i=n.selection&&s(n.selection);i&&(i.minute=Math.floor(i.minute/15)*15);var o=n.startTime&&n.startTime.hour*60+n.startTime.minute,u,a=e("<ul />");for(var f=0;f<24;f++)for(var l=0;l<60;l+=15){if(o&&o>f*60+l)continue;(function(){var t=r(f,l,n.isoTime),s=t;if(o!=null){var c=f*60+l-o;c<60?s+=" ("+c+" min)":c==60?s+=" (1 hr)":s+=" ("+Math.floor(c/60)+" hr "+c%60+" min)"}var h=e("<li />").append(e('<a href="javascript:;">'+s+"</a>").click(function(){n&&n.selectTime&&n.selectTime(t)}).mousemove(function(){e("li.selected",a).removeClass("selected")})).appendTo(a);!u&&f==n.defaultHour&&(u=h),i&&i.hour==f&&i.minute==l&&(h.addClass("selected"),u=h)})()}u&&setTimeout(function(){t[0].scrollTop=u[0].offsetTop-u.height()*2},0),t.empty().append(a)}function v(e){e.addClass("error").fadeOut("normal",function(){e.val(e.data("timespan.stored")).removeClass("error").fadeIn("fast")})}function m(){e(this).data("timespan.stored",this.value)}function g(t,i,s,o,u,a,f,l,c,h){s.val(s.data("timespan.initial_value")),a.val(a.data("timespan.initial_value")),f.get(0).checked=f.data("timespan.initial_value");var p=parseInt(s.val());isNaN(parseInt(p))?(p=new Date(h),i.val(r(p.getUTCHours(),p.getUTCMinutes()-p.getUTCMinutes()%15,l))):(p=new Date(parseInt(p)*1e3),i.val(r(p.getUTCHours(),p.getUTCMinutes(),l))),t.val(n(p,c));var d=parseInt(a.val());isNaN(parseInt(d))?(d=new Date(p.getTime()+36e5),u.val(r(d.getUTCHours(),d.getUTCMinutes()-d.getUTCMinutes()%15,l))):(d=new Date(parseInt(d)*1e3),u.val(r(d.getUTCHours(),d.getUTCMinutes(),l))),f.get(0).checked&&d.setUTCDate(d.getUTCDate()-1),o.val(n(d,c)),t.each(m),i.each(m),o.each(m),u.each(m),f.trigger("change.timespan"),e("#ai1ec_instant_event").trigger("change.timespan")}var t={us:{pattern:/([\d]{1,2})\/([\d]{1,2})\/([\d]{4}|[\d]{2})/,format:"m/d/y",order:"middleEndian",zeroPad:!1},iso:{pattern:/([\d]{4}|[\d]{2})-([\d]{1,2})-([\d]{1,2})/,format:"y-m-d",order:"bigEndian",zeroPad:!0},dot:{pattern:/([\d]{1,2}).([\d]{1,2}).([\d]{4}|[\d]{2})/,format:"d.m.y",order:"littleEndian",zeroPad:!1},def:{pattern:/([\d]{1,2})\/([\d]{1,2})\/([\d]{4}|[\d]{2})/,format:"d/m/y",order:"littleEndian",zeroPad:!1}},n=function(e,n,r){var i,s,o;typeof t[n]=="undefined"&&(n="def"),typeof r=="undefined"&&(r=!1),!0===r?(i=e.getFullYear().toString(),s=(e.getMonth()+1).toString(),o=e.getDate().toString()):(i=e.getUTCFullYear().toString(),s=(e.getUTCMonth()+1).toString(),o=e.getUTCDate().toString()),t[n].zeroPad&&(s.length==1&&(s="0"+s),o.length==1&&(o="0"+o));var u=t[n].format;return u=u.replace("d",o),u=u.replace("m",s),u=u.replace("y",i),u},r=function(e,t,n){var r=t;t<10&&(r="0"+t);if(n){var i=e;return i<10&&(i="0"+e),i+":"+r}var i=e%12;i==0&&(i=12);var s=e<12?"am":"pm";return i+":"+r+s},i=function(e,n){typeof t[n]=="undefined"&&(n="def");var r=e.match(t[n].pattern);if(!r||r.length!=4)return Date("invalid");switch(t[n].order){case"bigEndian":var i=r[3],s=r[2],o=r[1];break;case"littleEndian":var i=r[1],s=r[2],o=r[3];break;case"middleEndian":var i=r[2],s=r[1],o=r[3];break;default:var i=r[1],s=r[2],o=r[3]}return o.length==2&&(o=(new Date).getUTCFullYear().toString().substr(0,2)+o),new Date(s+"/"+i+"/"+o+" GMT")},s=function(e){var t=t=/(\d+)\s*[:\-\.,]\s*(\d+)\s*(am|pm)?/i.exec(e);if(t&&t.length>=3){var n=Number(t[1]),r=Number(t[2]);return n==12&&t[3]&&(n-=12),t[3]&&t[3].toLowerCase()=="pm"&&(n+=12),{hour:n,minute:r}}return null};e.fn.calendricalDate=function(t){return t=t||{},t.padding=t.padding||4,t.monthNames=t.monthNames||"January,February,March,April,May,June,July,August,September,October,November,December",t.dayNames=t.dayNames||"S,M,T,W,T,F,S",t.weekStartDay=t.weekStartDay||0,this.each(function(){var r=e(this),s,u=!1;r.bind("focus",function(){if(s)return;var a=r.position(),f=r.css("padding-left");s=e("<div />").addClass("calendricalDatePopup").mouseenter(function(){u=!0}).mouseleave(function(){u=!1}).mousedown(function(e){e.preventDefault()}).css({position:"absolute",left:a.left,top:a.top+r.height()+t.padding*2}),r.after(s);var l=i(r.val(),t.dateFormat);l.getUTCFullYear()||(l=t.today?t.today:o()),p(s,l.getUTCFullYear(),l.getUTCMonth(),{today:t.today,selected:l,monthNames:t.monthNames,dayNames:t.dayNames,weekStartDay:t.weekStartDay,selectDate:function(e){u=!1,r.val(n(e,t.dateFormat)),s.remove(),s=null;if(t.endDate){var o=i(t.endDate.val(),t.dateFormat);o>=l&&t.endDate.val(n(new Date(e.getTime()+o.getTime()-l.getTime()),t.dateFormat))}}})}).blur(function(){if(u){s&&r.focus();return}if(!s)return;s.remove(),s=null})})},e.fn.calendricalDateRange=function(t){return this.length>=2&&(e(this[0]).calendricalDate(e.extend({endDate:e(this[1])},t)),e(this[1]).calendricalDate(t)),this},e.fn.calendricalDateRangeSingle=function(t){return this.length==1&&e(this).calendricalDate(t),this},e.fn.calendricalTime=function(t){return t=t||{},t.padding=t.padding||4,this.each(function(){var n=e(this),r,o=!1;n.bind("focus click",function(){if(r)return;var a=t.startTime;a&&t.startDate&&t.endDate&&!u(i(t.startDate.val()),i(t.endDate.val()))&&(a=!1);var f=n.position();r=e("<div />").addClass("calendricalTimePopup").mouseenter(function(){o=!0}).mouseleave(function(){o=!1}).mousedown(function(e){e.preventDefault()}).css({position:"absolute",left:f.left,top:f.top+n.height()+t.padding*2}),a&&r.addClass("calendricalEndTimePopup"),n.after(r);var l={selection:n.val(),selectTime:function(e){o=!1,n.val(e),r.remove(),r=null},isoTime:t.isoTime||!1,defaultHour:t.defaultHour!=null?t.defaultHour:8};a&&(l.startTime=s(t.startTime.val())),d(r,l)}).blur(function(){if(o){r&&n.focus();return}if(!r)return;r.remove(),r=null})})},e.fn.calendricalTimeRange=function(t){return this.length>=2&&(e(this[0]).calendricalTime(t),e(this[1]).calendricalTime(e.extend({startTime:e(this[0])},t))),this},e.fn.calendricalDateTimeRange=function(t){return this.length>=4&&(e(this[0]).calendricalDate(e.extend({endDate:e(this[2])},t)),e(this[1]).calendricalTime(t),e(this[2]).calendricalDate(t),e(this[3]).calendricalTime(e.extend({startTime:e(this[1]),startDate:e(this[0]),endDate:e(this[2])},t))),this};var y={allday:"#allday",start_date_input:"#start-date-input",start_time_input:"#start-time-input",start_time:"#start-time",end_date_input:"#end-date-input",end_time_input:"#end-time-input",end_time:"#end-time",twentyfour_hour:!1,date_format:"def",now:new Date},b={init:function(t){function N(){var e=i(a.val(),o.date_format).getTime()/1e3,t=s(f.val());e+=t.hour*3600+t.minute*60;var n=i(c.val(),o.date_format).getTime()/1e3,r=s(h.val());return n+=r.hour*3600+r.minute*60,n-e}function C(){var e=i(a.data("timespan.stored"),o.date_format),t=s(f.data("timespan.stored")),u=e.getTime()/1e3+t.hour*3600+t.minute*60+a.data("time_diff");return u=new Date(u*1e3),c.val(n(u,o.date_format)),h.val(r(u.getUTCHours(),u.getUTCMinutes(),o.twentyfour_hour)),!0}var o=e.extend({},y,t),u=e(o.allday),a=e(o.start_date_input),f=e(o.start_time_input),l=e(o.start_time),c=e(o.end_date_input),h=e(o.end_time_input),p=e(o.end_time),d=e("#ai1ec_instant_event"),b=c.add(h),w=a.add(o.end_date_input),E=f.add(o.end_time_input),S=a.add(o.start_time_input).add(o.end_date_input).add(o.end_time_input);S.bind("focus.timespan",m),d.bind("change.timespan",function(){this.checked?(b.closest("tr").fadeOut(),u.attr("disabled",!0)):(u.removeAttr("disabled"),b.closest("tr").fadeIn())});var x=new Date(o.now.getFullYear(),o.now.getMonth(),o.now.getDate()),T=!1;return u.bind("change.timespan",function(){this.checked?(E.fadeOut(),d.attr("disabled",!0)):(d.removeAttr("disabled"),E.fadeIn()),T||(T=!0,S.calendricalDateTimeRange({today:x,dateFormat:o.date_format,isoTime:o.twentyfour_hour,monthNames:o.month_names,dayNames:o.day_names,weekStartDay:o.week_start_day}))}).get().checked=!1,w.bind("blur.timespan",function(){var t=i(this.value,o.date_format);isNaN(t)?v(e(this)):(e(this).data("timespan.stored",this.value),e(this).val(n(t,o.date_format)))}),E.bind("blur.timespan",function(){var t=s(this.value);t?(e(this).data("timespan.stored",this.value),e(this).val(r(t.hour,t.minute,o.twentyfour_hour))):v(e(this))}),a.add(o.start_time_input).bind("focus.timespan",function(){a.data("time_diff",N())}).bind("blur.timespan",function(){a.data("time_diff")<0&&a.data("time_diff",900);var e=C()}),c.add(o.start_time_input).bind("blur.timespan",function(){if(N()<0){a.data("time_diff",900);var e=C()}}),a.closest("form").bind("submit.timespan",function(){var e=i(a.val(),o.date_format).getTime()/1e3;if(!isNaN(e)){if(!u.get(0).checked){var t=s(f.val());t?e+=t.hour*3600+t.minute*60:e=""}}else e="";l.val(e);var n=i(c.val(),o.date_format).getTime()/1e3;if(!isNaN(n))if(u.get(0).checked)n+=86400;else{var t=s(h.val());t?n+=t.hour*3600+t.minute*60:n=""}else n="";p.val(n)}),l.data("timespan.initial_value",l.val()),p.data("timespan.initial_value",p.val()),u.data("timespan.initial_value",u.get(0).checked),g(a,f,l,c,h,p,u,o.twentyfour_hour,o.date_format,o.now),this},reset:function(t){var n=e.extend({},y,t);return g(e(n.start_date_input),e(n.start_time_input),e(n.start_time),e(n.end_date_input),e(n.end_time_input),e(n.end_time),e(n.allday),n.twentyfour_hour,n.date_format,n.now),this},destroy:function(t){return t=e.extend({},y,t),e.each(t,function(t,n){e(n).unbind(".timespan")}),e(t.start_date_input).closest("form").unbind(".timespan"),this}};return e.timespan=function(t){if(b[t])return b[t].apply(this,Array.prototype.slice.call(arguments,1));if(typeof t=="object"||!t)return b.init.apply(this,arguments);e.error("Method "+t+" does not exist on jQuery.timespan")},{formatDate:n,parseDate:i}}),timely.define("scripts/add_new_event/event_date_time/date_time_event_handlers",["jquery_timely","ai1ec_config","scripts/add_new_event/event_date_time/date_time_utility_functions","external_libs/jquery.calendrical_timespan","libs/utils"],function(e,t,n,r,i){var s=i.get_ajax_url(),o=function(){var t=e("#ai1ec_end option:selected").val();switch(t){case"0":n.hide_all_end_fields();break;case"1":e("#ai1ec_count_holder").css("display")==="none"&&(n.hide_all_end_fields(),e("#ai1ec_count_holder").fadeIn());break;case"2":e("#ai1ec_until_holder").css("display")==="none"&&(n.hide_all_end_fields(),e("#ai1ec_until_holder").fadeIn())}},u=function(){e("#publish").trigger("click")},a=function(t){if(!e(this).hasClass("ai1ec_active")){var n=e(".ai1ec_repeat_tabs > li > a.ai1ec_active"),r=e(n.attr("href")),i=e(e(this).attr("href"));n.removeClass("ai1ec_active"),r.hide(),e(this).addClass("ai1ec_active"),i.append(e("#ai1ec_repeat_tab_append")),e("#ai1ec_ending_box").show(),i.show()}return!1},f=function(i){var o=e(this),u="",a=e(e(".ai1ec_active").attr("href")),f=a.attr("title");switch(f){case"daily":u+="FREQ=DAILY;";var l=e("#ai1ec_daily_count").val();l>1&&(u+="INTERVAL="+l+";");break;case"weekly":u+="FREQ=WEEKLY;";var c=e("#ai1ec_weekly_count").val();c>1&&(u+="INTERVAL="+c+";");var h=e('input[name="ai1ec_weekly_date_select"]:first').val(),p=e('#ai1ec_weekly_date_select > li:first > input[type="hidden"]:first').val();h.length>0&&(u+="WKST="+p+";BYday="+h+";");break;case"monthly":u+="FREQ=MONTHLY;";var d=e("#ai1ec_monthly_count").val(),v=e('input[name="ai1ec_monthly_type"]:checked').val();d>1&&(u+="INTERVAL="+d+";");var m=e('input[name="ai1ec_montly_date_select"]:first').val();if(m.length>0&&v==="bymonthday")u+="BYMONTHDAY="+m+";";else if(v==="byday"){var g=e("#ai1ec_monthly_byday_num").val(),y=e("#ai1ec_monthly_byday_weekday").val();u+="BYday="+g+y+";"}break;case"yearly":u+="FREQ=YEARLY;";var b=e("#ai1ec_yearly_count").val();b>1&&(u+="INTERVAL="+b+";");var w=e('input[name="ai1ec_yearly_date_select"]:first').val();w.length>0&&(u+="BYMONTH="+w+";")}var E=e("#ai1ec_end").val();E==="1"&&(u+="COUNT="+e("#ai1ec_count").val()+";");if(E==="2"){var S=r.parseDate(e("#ai1ec_until-date-input").val(),t.date_format),x=new Date(r.parseDate(e("#ai1ec_start-time").val(),t.date_format)),T=S.getUTCDate(),N=S.getUTCMonth()+1,C=x.getUTCHours(),k=x.getUTCMinutes();N=N<10?"0"+N:N,T=T<10?"0"+T:T,C=C<10?"0"+C:C,k=k<10?"0"+k:k,S=S.getUTCFullYear()+""+N+T+"T235959Z",u+="UNTIL="+S+";"}var L={action:"ai1ec_rrule_to_text",rrule:u};e(this).attr("disabled",!0),e.post(s,L,function(t){t.error?e("#ai1ec_is_box_repeat").val()==="1"?n.ai1ec_repeat_form_error("#ai1ec_rrule","#ai1ec_repeat_label",t,o):n.ai1ec_repeat_form_error("#ai1ec_exrule","#ai1ec_exclude_label",t,o):e("#ai1ec_is_box_repeat").val()==="1"?n.ai1ec_repeat_form_success("#ai1ec_rrule","#ai1ec_repeat_label","#ai1ec_repeat_text > a",u,o,t):n.ai1ec_repeat_form_success("#ai1ec_exrule","#ai1ec_exclude_label","#ai1ec_exclude_text > a",u,o,t)},"json")},l=function(t){return e("#ai1ec_is_box_repeat").val()==="1"?n.ai1ec_click_on_modal_cancel("#ai1ec_repeat_text > a","#ai1ec_repeat","#ai1ec_repeat_label"):n.ai1ec_click_on_modal_cancel("#ai1ec_exclude_text > a","#ai1ec_exclude","#ai1ec_exclude_label"),e.unblockUI(),!1},c=function(t){e("#ai1c_repeat_monthly_bymonthday").toggle(),e("#ai1c_repeat_monthly_byday").toggle()},h=function(t){var n=e(t.target);n.hasClass("ai1ec_selected")?n.removeClass("ai1ec_selected"):n.addClass("ai1ec_selected");var r=[],i=n.closest("ul");e("li",i).each(function(t,n){if(e(n).hasClass("ai1ec_selected")){var i=e(n).children('input[type="hidden"]:first').val();r.push(i)}}),i.next().val(r.join())},p=function(){n.ai1ec_click_on_ics_rule_text("#ai1ec_repeat_text > a","#ai1ec_repeat","#ai1ec_repeat_label",{action:"ai1ec_get_repeat_box",repeat:1,post_id:e("#post_ID").val()},n.ai1ec_apply_js_on_repeat_block),n.ai1ec_click_on_ics_rule_text("#ai1ec_exclude_text > a","#ai1ec_exclude","#ai1ec_exclude_label",{action:"ai1ec_get_repeat_box",repeat:0,post_id:e("#post_ID").val()},n.ai1ec_apply_js_on_repeat_block),n.ai1ec_click_on_checkbox("#ai1ec_repeat","#ai1ec_repeat_text > a","#ai1ec_repeat_label",{action:"ai1ec_get_repeat_box",repeat:1,post_id:e("#post_ID").val()},n.ai1ec_apply_js_on_repeat_block),n.ai1ec_click_on_checkbox("#ai1ec_exclude","#ai1ec_exclude_text > a","#ai1ec_exclude_label",{action:"ai1ec_get_repeat_box",repeat:0,post_id:e("#post_ID").val()},n.ai1ec_apply_js_on_repeat_block)},d=function(t){var n=e(this).data("state")===undefined?!1:e(this).data("state");return e("#widgetCalendar").stop().animate({height:n?0:e("#widgetCalendar div.datepicker").get(0).offsetHeight},500),e(this).data("state",!n),!1};return{show_end_fields:o,trigger_publish:u,handle_click_on_tab_modal:a,handle_click_on_apply_button:f,handle_click_on_cancel_modal:l,handle_checkbox_monthly_tab_modal:c,execute_pseudo_handlers:p,handle_animation_of_calendar_widget:d,handle_click_on_day_month_in_modal:h}}),timely.define("external_libs/bootstrap_modal",["jquery_timely"],function(e){var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="ai1ec_modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".ai1ec-modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(e){this.$element.hide().trigger("hidden"),this.backdrop()},removeBackdrop:function(){this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="ai1ec-modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,e.proxy(this.removeBackdrop,this)):this.removeBackdrop()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="ai1ec_modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}),timely.define("libs/modal_helper",["jquery_timely","domReady","external_libs/bootstrap_modal"],function(e,t){t(function(){var t=e("body");t.on("shown",".ai1ec-modal",function(){t.addClass("ai1ec-modal-open")}).on("hidden",".ai1ec-modal",function(){t.removeClass("ai1ec-modal-open")})})}),timely.define("scripts/add_new_event/facebook_export",["jquery_timely","libs/modal_helper"],function(e){var t=function(t){!e(this).is(":checked")&&e("#ai1ec-facebook-export-modal").length?e("#ai1ec-facebook-export-modal").modal({show:!0,backdrop:"static"}):e("#ai1ec-remove-event-hidden").remove()},n=function(){e("#ai1ec-facebook-export-modal").modal("hide");if(e(this).hasClass("remove")){var t=e("<input />",{type:"hidden",name:"ai1ec-remove-event",value:1,id:"ai1ec-remove-event-hidden"});e("#ai1ec-facebook-publish").append(t)}},r=function(t){t.preventDefault();var n={action:"ai1ec_refresh_tokens"};e.post(ajaxurl,n,function(n){var r=e(t.target).closest("#ai1ec-facebook-publish"),i=r.find(".ai1ec_export_radios"),s=i.find(".ai1ec_multi_choiches"),o=!0;s.length>0&&(o=s.hasClass("hide")),i.length>0?i.replaceWith(n):r.find(".ai1ec_refresh_tokens").before(n),!1===o&&e("#ai1ec-facebook-publish").find(".ai1ec_multi_choiches").removeClass("hide")},"json")},i=function(t){var n=e(".ai1ec_multi_choiches"),r=e(this);0!==n.length&&(this.checked?n.removeClass("hide"):n.addClass("hide"))};return{open_modal_when_user_chooses_to_unpublish_event:t,add_hidden_field_when_user_click_remove_in_modal:n,show_multi_choices_when_present:i,refresh_page_tokens:r}}),timely.define("scripts/add_new_event/event_cost_helper",["jquery_timely","ai1ec_config"],function(e,t){var n=function(){return e("#ai1ec_is_free").is(":checked")},r=function(){return e("#ai1ec_cost").val()!==""},i=function(r){var i=e(this).parents("table:eq(0)"),s=e("#ai1ec_cost",i),o=t.label_a_buy_tickets_url;n()?(s.attr("value","").addClass("ai1ec-hidden"),o=t.label_a_rsvp_url):s.removeClass("ai1ec-hidden"),e("label[for=ai1ec_ticket_url]",i).text(o)};return{handle_change_is_free:i,check_is_free:n,check_is_price_entered:r}}),timely.define("external_libs/jquery.inputdate",["jquery_timely","external_libs/jquery.calendrical_timespan"],function(e,t){function n(e){e.addClass("error").fadeOut("normal",function(){e.val(e.data("timespan.stored")).removeClass("error").fadeIn("fast")})}function r(){e(this).data("timespan.stored",this.value)}function i(e,n,i,s,o){n.val(n.data("timespan.initial_value"));var u=parseInt(n.val());isNaN(parseInt(u))?u=new Date(o):u=new Date(parseInt(u)*1e3),e.val(t.formatDate(u,s)),e.each(r)}var s={start_date_input:"date-input",start_time:"time",twentyfour_hour:!1,date_format:"def",now:new Date},o={init:function(o){var u=e.extend({},s,o),a=e(u.start_date_input),f=e(u.start_time),l=a,c=a;return c.bind("focus.timespan",r),l.calendricalDate({today:new Date(u.now.getFullYear(),u.now.getMonth(),u.now.getDate()),dateFormat:u.date_format,monthNames:u.month_names,dayNames:u.day_names,weekStartDay:u.week_start_day}),l.bind("blur.timespan",function(){var r=t.parseDate(this.value,u.date_format);isNaN(r)?n(e(this)):(e(this).data("timespan.stored",this.value),e(this).val(t.formatDate(r,u.date_format)))}),a.bind("focus.timespan",function(){var e=t.parseDate(a.val(),u.date_format).getTime()/1e3}).bind("blur.timespan",function(){var e=t.parseDate(a.data("timespan.stored"),u.date_format)}),a.closest("form").bind("submit.timespan",function(){var e=t.parseDate(a.val(),u.date_format).getTime()/1e3;isNaN(e)&&(e=""),f.val(e)}),f.data("timespan.initial_value",f.val()),i(a,f,u.twentyfour_hour,u.date_format,u.now),this},reset:function(t){var n=e.extend({},s,t);return i(e(n.start_date_input),e(n.start_time),n.twentyfour_hour,n.date_format,n.now),this},destroy:function(t){return t=e.extend({},s,t),e.each(t,function(t,n){e(n).unbind(".timespan")}),e(t.start_date_input).closest("form").unbind(".timespan"),this}};e.inputdate=function(t){if(o[t])return o[t].apply(this,Array.prototype.slice.call(arguments,1));if(typeof t=="object"||!t)return o.init.apply(this,arguments);e.error("Method "+t+" does not exist on jQuery.timespan")}}),timely.define("external_libs/jquery.tools",["jquery_timely"],function(e){function i(e,t){var n=Math.pow(10,t);return Math.round(e*n)/n}function s(e,t){var n=parseInt(e.css(t),10);if(n)return n;var r=e[0].currentStyle;return r&&r.width&&parseInt(r.width,10)}function o(e){var t=e.data("events");return t&&t.onSlide}function u(t,n){function x(e,s,o,u){o===undefined?o=s/h*m:u&&(o-=n.min),g&&(o=Math.round(o/g)*g);if(s===undefined||g)s=o*h/m;if(isNaN(o))return r;s=Math.max(0,Math.min(s,h)),o=s/h*m;if(u||!f)o+=n.min;f&&(u?s=h-s:o=n.max-o),o=i(o,y);var a=e.type=="click";if(S&&l!==undefined&&!a){e.type="onSlide",E.trigger(e,[o,s]);if(e.isDefaultPrevented())return r}var c=a?n.speed:0,b=a?function(){e.type="change",E.trigger(e,[o])}:null;return f?(d.animate({top:s},c,b),n.progress&&v.animate({height:h-s+d.height()/2},c)):(d.animate({left:s},c,b),n.progress&&v.animate({width:s+d.width()/2},c)),l=o,p=s,t.val(o),r}function T(){f=n.vertical||s(a,"height")>s(a,"width"),f?(h=s(a,"height")-s(d,"height"),c=a.offset().top+h):(h=s(a,"width")-s(d,"width"),c=a.offset().left)}function N(){T(),r.setValue(n.value!==undefined?n.value:n.min)}var r=this,u=n.css,a=e("<div><div/><a href='#'/></div>").data("rangeinput",r),f,l,c,h,p;t.before(a);var d=a.addClass(u.slider).find("a").addClass(u.handle),v=a.find("div").addClass(u.progress);e.each("min,max,step,value".split(","),function(e,r){var i=t.attr(r);parseFloat(i)&&(n[r]=parseFloat(i,10))});var m=n.max-n.min,g=n.step=="any"?0:n.step,y=n.precision;y===undefined&&(y=g.toString().split("."),y=y.length===2?y[1].length:0);if(t.attr("type")=="range"){var b=t.clone().wrap("<div/>").parent().html(),w=e(b.replace(/type/i,"type=text data-orig-type"));w.val(n.value),t.replaceWith(w),t=w}t.addClass(u.input);var E=e(r).add(t),S=!0;e.extend(r,{getValue:function(){return l},setValue:function(t,n){return T(),x(n||e.Event("api"),undefined,t,!0)},getConf:function(){return n},getProgress:function(){return v},getHandle:function(){return d},getInput:function(){return t},step:function(t,i){i=i||e.Event();var s=n.step=="any"?1:n.step;r.setValue(l+s*(t||1),i)},stepUp:function(e){return r.step(e||1)},stepDown:function(e){return r.step(-e||-1)}}),e.each("onSlide,change".split(","),function(t,i){e.isFunction(n[i])&&e(r).on(i,n[i]),r[i]=function(t){return t&&e(r).on(i,t),r}}),d.drag({drag:!1}).on("dragStart",function(){T(),S=o(e(r))||o(t)}).on("drag",function(e,n,r){if(t.is(":disabled"))return!1;x(e,f?n:r)}).on("dragEnd",function(e){e.isDefaultPrevented()||(e.type="change",E.trigger(e,[l]))}).click(function(e){return e.preventDefault()}),a.click(function(e){if(t.is(":disabled")||e.target==d[0])return e.preventDefault();T();var n=f?d.height()/2:d.width()/2;x(e,f?h-c-n+e.pageY:e.pageX-c-n)}),n.keyboard&&t.keydown(function(n){if(t.attr("readonly"))return;var i=n.keyCode,s=e([75,76,38,33,39]).index(i)!=-1,o=e([74,72,40,34,37]).index(i)!=-1;if((s||o)&&!(n.shiftKey||n.altKey||n.ctrlKey))return s?r.step(i==33?10:1,n):o&&r.step(i==34?-10:-1,n),n.preventDefault()}),t.blur(function(t){var n=e(this).val();n!==l&&r.setValue(n,t)}),e.extend(t[0],{stepUp:r.stepUp,stepDown:r.stepDown}),N(),h||e(window).load(N)}e.tools=e.tools||{version:"1.2.7"};var t;t=e.tools.rangeinput={conf:{min:0,max:100,step:"any",steps:0,value:0,precision:undefined,vertical:0,keyboard:!0,progress:!1,speed:100,css:{input:"range",slider:"slider",progress:"progress",handle:"handle"}}};var n,r;e.fn.drag=function(t){return document.ondragstart=function(){return!1},t=e.extend({x:!0,y:!0,drag:!0},t),n=n||e(document).on("mousedown mouseup",function(i){var s=e(i.target);if(i.type=="mousedown"&&s.data("drag")){var o=s.position(),u=i.pageX-o.left,a=i.pageY-o.top,f=!0;n.on("mousemove.drag",function(e){var n=e.pageX-u,i=e.pageY-a,o={};t.x&&(o.left=n),t.y&&(o.top=i),f&&(s.trigger("dragStart"),f=!1),t.drag&&s.css(o),s.trigger("drag",[i,n]),r=s}),i.preventDefault()}else try{r&&r.trigger("dragEnd")}finally{n.off("mousemove.drag"),r=null}}),this.data("drag",!0)},e.expr[":"].range=function(t){var n=t.getAttribute("type");return n&&n=="range"||!!e(t).filter("input").data("rangeinput")},e.fn.rangeinput=function(n){if(this.data("rangeinput"))return this;n=e.extend(!0,{},t.conf,n);var r;return this.each(function(){var t=new u(e(this),e.extend(!0,{},n)),i=t.getInput().data("rangeinput",t);r=r?r.add(i):i}),r?r:this}}),timely.define("external_libs/jquery.blockui",["jquery_timely"],function(e){(function(){function t(e){function a(i,a){var l,h,m=i==window,g=a&&a.message!==undefined?a.message:undefined;a=e.extend({},e.blockUI.defaults,a||{});if(a.ignoreIfBlocked&&e(i).data("blockUI.isBlocked"))return;a.overlayCSS=e.extend({},e.blockUI.defaults.overlayCSS,a.overlayCSS||{}),l=e.extend({},e.blockUI.defaults.css,a.css||{}),a.onOverlayClick&&(a.overlayCSS.cursor="pointer"),h=e.extend({},e.blockUI.defaults.themedCSS,a.themedCSS||{}),g=g===undefined?a.message:g,m&&o&&f(window,{fadeOut:0});if(g&&typeof g!="string"&&(g.parentNode||g.jquery)){var y=g.jquery?g[0]:g,b={};e(i).data("blockUI.history",b),b.el=y,b.parent=y.parentNode,b.display=y.style.display,b.position=y.style.position,b.parent&&b.parent.removeChild(y)}e(i).data("blockUI.onUnblock",a.onUnblock);var w=a.baseZ,E,S,x,T;n||a.forceIframe?E=e('<iframe class="blockUI" style="z-index:'+w++ +';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="'+a.iframeSrc+'"></iframe>'):E=e('<div class="blockUI" style="display:none"></div>'),a.theme?S=e('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:'+w++ +';display:none"></div>'):S=e('<div class="blockUI blockOverlay" style="z-index:'+w++ +';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>'),a.theme&&m?(T='<div class="blockUI '+a.blockMsgClass+' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:'+(w+10)+';display:none;position:fixed">',a.title&&(T+='<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(a.title||"&nbsp;")+"</div>"),T+='<div class="ui-widget-content ui-dialog-content"></div>',T+="</div>"):a.theme?(T='<div class="blockUI '+a.blockMsgClass+' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:'+(w+10)+';display:none;position:absolute">',a.title&&(T+='<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(a.title||"&nbsp;")+"</div>"),T+='<div class="ui-widget-content ui-dialog-content"></div>',T+="</div>"):m?T='<div class="blockUI '+a.blockMsgClass+' blockPage" style="z-index:'+(w+10)+';display:none;position:fixed"></div>':T='<div class="blockUI '+a.blockMsgClass+' blockElement" style="z-index:'+(w+10)+';display:none;position:absolute"></div>',x=e(T),g&&(a.theme?(x.css(h),x.addClass("ui-widget-content")):x.css(l)),a.theme||S.css(a.overlayCSS),S.css("position",m?"fixed":"absolute"),(n||a.forceIframe)&&E.css("opacity",0);var N=[E,S,x],C=m?e("body"):e(i);e.each(N,function(){this.appendTo(C)}),a.theme&&a.draggable&&e.fn.draggable&&x.draggable({handle:".ui-dialog-titlebar",cancel:"li"});var k=s&&(!e.support.boxModel||e("object,embed",m?null:i).length>0);if(r||k){m&&a.allowBodyStretch&&e.support.boxModel&&e("html,body").css("height","100%");if((r||!e.support.boxModel)&&!m)var L=v(i,"borderTopWidth"),A=v(i,"borderLeftWidth"),O=L?"(0 - "+L+")":0,M=A?"(0 - "+A+")":0;e.each(N,function(e,t){var n=t[0].style;n.position="absolute";if(e<2)m?n.setExpression("height","Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:"+a.quirksmodeOffsetHack+') + "px"'):n.setExpression("height",'this.parentNode.offsetHeight + "px"'),m?n.setExpression("width",'jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"'):n.setExpression("width",'this.parentNode.offsetWidth + "px"'),M&&n.setExpression("left",M),O&&n.setExpression("top",O);else if(a.centerY)m&&n.setExpression("top",'(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"'),n.marginTop=0;else if(!a.centerY&&m){var r=a.css&&a.css.top?parseInt(a.css.top,10):0,i="((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "+r+') + "px"';n.setExpression("top",i)}})}g&&(a.theme?x.find(".ui-widget-content").append(g):x.append(g),(g.jquery||g.nodeType)&&e(g).show()),(n||a.forceIframe)&&a.showOverlay&&E.show();if(a.fadeIn){var _=a.onBlock?a.onBlock:t,D=a.showOverlay&&!g?_:t,P=g?_:t;a.showOverlay&&S._fadeIn(a.fadeIn,D),g&&x._fadeIn(a.fadeIn,P)}else a.showOverlay&&S.show(),g&&x.show(),a.onBlock&&a.onBlock();c(1,i,a),m?(o=x[0],u=e(":input:enabled:visible",o),a.focusInput&&setTimeout(p,20)):d(x[0],a.centerX,a.centerY);if(a.timeout){var H=setTimeout(function(){m?e.unblockUI(a):e(i).unblock(a)},a.timeout);e(i).data("blockUI.timeout",H)}}function f(t,n){var r,i=t==window,s=e(t),a=s.data("blockUI.history"),f=s.data("blockUI.timeout");f&&(clearTimeout(f),s.removeData("blockUI.timeout")),n=e.extend({},e.blockUI.defaults,n||{}),c(0,t,n),n.onUnblock===null&&(n.onUnblock=s.data("blockUI.onUnblock"),s.removeData("blockUI.onUnblock"));var h;i?h=e("body").children().filter(".blockUI").add("body > .blockUI"):h=s.find(">.blockUI"),n.cursorReset&&(h.length>1&&(h[1].style.cursor=n.cursorReset),h.length>2&&(h[2].style.cursor=n.cursorReset)),i&&(o=u=null),n.fadeOut?(r=h.length,h.fadeOut(n.fadeOut,function(){--r===0&&l(h,a,n,t)})):l(h,a,n,t)}function l(t,n,r,i){var s=e(i);t.each(function(e,t){this.parentNode&&this.parentNode.removeChild(this)}),n&&n.el&&(n.el.style.display=n.display,n.el.style.position=n.position,n.parent&&n.parent.appendChild(n.el),s.removeData("blockUI.history")),s.data("blockUI.static")&&s.css("position","static"),typeof r.onUnblock=="function"&&r.onUnblock(i,r);var o=e(document.body),u=o.width(),a=o[0].style.width;o.width(u-1).width(u),o[0].style.width=a}function c(t,n,r){var i=n==window,s=e(n);if(!t&&(i&&!o||!i&&!s.data("blockUI.isBlocked")))return;s.data("blockUI.isBlocked",t);if(!i||!r.bindEvents||t&&!r.showOverlay)return;var u="mousedown mouseup keydown keypress keyup touchstart touchend touchmove";t?e(document).bind(u,r,h):e(document).unbind(u,h)}function h(t){if(t.keyCode&&t.keyCode==9&&o&&t.data.constrainTabKey){var n=u,r=!t.shiftKey&&t.target===n[n.length-1],i=t.shiftKey&&t.target===n[0];if(r||i)return setTimeout(function(){p(i)},10),!1}var s=t.data,a=e(t.target);return a.hasClass("blockOverlay")&&s.onOverlayClick&&s.onOverlayClick(),a.parents("div."+s.blockMsgClass).length>0?!0:a.parents().children().filter("div.blockUI").length===0}function p(e){if(!u)return;var t=u[e===!0?u.length-1:0];t&&t.focus()}function d(e,t,n){var r=e.parentNode,i=e.style,s=(r.offsetWidth-e.offsetWidth)/2-v(r,"borderLeftWidth"),o=(r.offsetHeight-e.offsetHeight)/2-v(r,"borderTopWidth");t&&(i.left=s>0?s+"px":"0"),n&&(i.top=o>0?o+"px":"0")}function v(t,n){return parseInt(e.css(t,n),10)||0}e.fn._fadeIn=e.fn.fadeIn;var t=e.noop||function(){},n=/MSIE/.test(navigator.userAgent),r=/MSIE 6.0/.test(navigator.userAgent)&&!/MSIE 8.0/.test(navigator.userAgent),i=document.documentMode||0,s=e.isFunction(document.createElement("div").style.setExpression);e.blockUI=function(e){a(window,e)},e.unblockUI=function(e){f(window,e)},e.growlUI=function(t,n,r,i){var s=e('<div class="growlUI"></div>');t&&s.append("<h1>"+t+"</h1>"),n&&s.append("<h2>"+n+"</h2>"),r===undefined&&(r=3e3),e.blockUI({message:s,fadeIn:700,fadeOut:1e3,centerY:!1,timeout:r,showOverlay:!1,onUnblock:i,css:e.blockUI.defaults.growlCSS})},e.fn.block=function(t){if(this[0]===window)return e.blockUI(t),this;var n=e.extend({},e.blockUI.defaults,t||{});return this.each(function(){var t=e(this);if(n.ignoreIfBlocked&&t.data("blockUI.isBlocked"))return;t.unblock({fadeOut:0})}),this.each(function(){e.css(this,"position")=="static"&&(this.style.position="relative",e(this).data("blockUI.static",!0)),this.style.zoom=1,a(this,t)})},e.fn.unblock=function(t){return this[0]===window?(e.unblockUI(t),this):this.each(function(){f(this,t)})},e.blockUI.version=2.59,e.blockUI.defaults={message:"<h1>Please wait...</h1>",title:null,draggable:!0,theme:!1,css:{padding:0,margin:0,width:"30%",top:"40%",left:"35%",textAlign:"center",color:"#000",border:"3px solid #aaa",backgroundColor:"#fff",cursor:"wait"},themedCSS:{width:"30%",top:"40%",left:"35%"},overlayCSS:{backgroundColor:"#000",opacity:.6,cursor:"wait"},cursorReset:"default",growlCSS:{width:"350px",top:"10px",left:"",right:"10px",border:"none",padding:"5px",opacity:.6,cursor:"default",color:"#fff",backgroundColor:"#000","-webkit-border-radius":"10px","-moz-border-radius":"10px","border-radius":"10px"},iframeSrc:/^https/i.test(window.location.href||"")?"javascript:false":"about:blank",forceIframe:!1,baseZ:1e3,centerX:!0,centerY:!0,allowBodyStretch:!0,bindEvents:!0,constrainTabKey:!0,fadeIn:200,fadeOut:400,timeout:0,showOverlay:!0,focusInput:!0,onBlock:null,onUnblock:null,onOverlayClick:null,quirksmodeOffsetHack:4,blockMsgClass:"blockMsg",ignoreIfBlocked:!1};var o=null,u=[]}t(e)})()}),timely.define("external_libs/ai1ec_datepicker",["jquery_timely"],function(e){var t=function(){var t={},n={years:"datepickerViewYears",moths:"datepickerViewMonths",days:"datepickerViewDays"},i={wrapper:'<div class="datepicker"><div class="datepickerBorderT" /><div class="datepickerBorderB" /><div class="datepickerBorderL" /><div class="datepickerBorderR" /><div class="datepickerBorderTL" /><div class="datepickerBorderTR" /><div class="datepickerBorderBL" /><div class="datepickerBorderBR" /><div class="datepickerContainer"><table cellspacing="0" cellpadding="0"><tbody><tr></tr></tbody></table></div></div>',head:["<td>",'<table cellspacing="0" cellpadding="0">',"<thead>","<tr>",'<th class="datepickerGoPrev"><a href="#"><span><%=prev%></span></a></th>','<th colspan="6" class="datepickerMonth"><a href="#"><span></span></a></th>','<th class="datepickerGoNext"><a href="#"><span><%=next%></span></a></th>',"</tr>",'<tr class="datepickerDoW">',"<th><span><%=week%></span></th>","<th><span><%=day1%></span></th>","<th><span><%=day2%></span></th>","<th><span><%=day3%></span></th>","<th><span><%=day4%></span></th>","<th><span><%=day5%></span></th>","<th><span><%=day6%></span></th>","<th><span><%=day7%></span></th>","</tr>","</thead>","</table></td>"],space:'<td class="datepickerSpace"><div></div></td>',days:['<tbody class="datepickerDays">',"<tr>",'<th class="datepickerWeek"><a href="#"><span><%=weeks[0].week%></span></a></th>','<td class="<%=weeks[0].days[0].classname%>"><a href="#"><span><%=weeks[0].days[0].text%></span></a></td>','<td class="<%=weeks[0].days[1].classname%>"><a href="#"><span><%=weeks[0].days[1].text%></span></a></td>','<td class="<%=weeks[0].days[2].classname%>"><a href="#"><span><%=weeks[0].days[2].text%></span></a></td>','<td class="<%=weeks[0].days[3].classname%>"><a href="#"><span><%=weeks[0].days[3].text%></span></a></td>','<td class="<%=weeks[0].days[4].classname%>"><a href="#"><span><%=weeks[0].days[4].text%></span></a></td>','<td class="<%=weeks[0].days[5].classname%>"><a href="#"><span><%=weeks[0].days[5].text%></span></a></td>','<td class="<%=weeks[0].days[6].classname%>"><a href="#"><span><%=weeks[0].days[6].text%></span></a></td>',"</tr>","<tr>",'<th class="datepickerWeek"><a href="#"><span><%=weeks[1].week%></span></a></th>','<td class="<%=weeks[1].days[0].classname%>"><a href="#"><span><%=weeks[1].days[0].text%></span></a></td>','<td class="<%=weeks[1].days[1].classname%>"><a href="#"><span><%=weeks[1].days[1].text%></span></a></td>','<td class="<%=weeks[1].days[2].classname%>"><a href="#"><span><%=weeks[1].days[2].text%></span></a></td>','<td class="<%=weeks[1].days[3].classname%>"><a href="#"><span><%=weeks[1].days[3].text%></span></a></td>','<td class="<%=weeks[1].days[4].classname%>"><a href="#"><span><%=weeks[1].days[4].text%></span></a></td>','<td class="<%=weeks[1].days[5].classname%>"><a href="#"><span><%=weeks[1].days[5].text%></span></a></td>','<td class="<%=weeks[1].days[6].classname%>"><a href="#"><span><%=weeks[1].days[6].text%></span></a></td>',"</tr>","<tr>",'<th class="datepickerWeek"><a href="#"><span><%=weeks[2].week%></span></a></th>','<td class="<%=weeks[2].days[0].classname%>"><a href="#"><span><%=weeks[2].days[0].text%></span></a></td>','<td class="<%=weeks[2].days[1].classname%>"><a href="#"><span><%=weeks[2].days[1].text%></span></a></td>','<td class="<%=weeks[2].days[2].classname%>"><a href="#"><span><%=weeks[2].days[2].text%></span></a></td>','<td class="<%=weeks[2].days[3].classname%>"><a href="#"><span><%=weeks[2].days[3].text%></span></a></td>','<td class="<%=weeks[2].days[4].classname%>"><a href="#"><span><%=weeks[2].days[4].text%></span></a></td>','<td class="<%=weeks[2].days[5].classname%>"><a href="#"><span><%=weeks[2].days[5].text%></span></a></td>','<td class="<%=weeks[2].days[6].classname%>"><a href="#"><span><%=weeks[2].days[6].text%></span></a></td>',"</tr>","<tr>",'<th class="datepickerWeek"><a href="#"><span><%=weeks[3].week%></span></a></th>','<td class="<%=weeks[3].days[0].classname%>"><a href="#"><span><%=weeks[3].days[0].text%></span></a></td>','<td class="<%=weeks[3].days[1].classname%>"><a href="#"><span><%=weeks[3].days[1].text%></span></a></td>','<td class="<%=weeks[3].days[2].classname%>"><a href="#"><span><%=weeks[3].days[2].text%></span></a></td>','<td class="<%=weeks[3].days[3].classname%>"><a href="#"><span><%=weeks[3].days[3].text%></span></a></td>','<td class="<%=weeks[3].days[4].classname%>"><a href="#"><span><%=weeks[3].days[4].text%></span></a></td>','<td class="<%=weeks[3].days[5].classname%>"><a href="#"><span><%=weeks[3].days[5].text%></span></a></td>','<td class="<%=weeks[3].days[6].classname%>"><a href="#"><span><%=weeks[3].days[6].text%></span></a></td>',"</tr>","<tr>",'<th class="datepickerWeek"><a href="#"><span><%=weeks[4].week%></span></a></th>','<td class="<%=weeks[4].days[0].classname%>"><a href="#"><span><%=weeks[4].days[0].text%></span></a></td>','<td class="<%=weeks[4].days[1].classname%>"><a href="#"><span><%=weeks[4].days[1].text%></span></a></td>','<td class="<%=weeks[4].days[2].classname%>"><a href="#"><span><%=weeks[4].days[2].text%></span></a></td>','<td class="<%=weeks[4].days[3].classname%>"><a href="#"><span><%=weeks[4].days[3].text%></span></a></td>','<td class="<%=weeks[4].days[4].classname%>"><a href="#"><span><%=weeks[4].days[4].text%></span></a></td>','<td class="<%=weeks[4].days[5].classname%>"><a href="#"><span><%=weeks[4].days[5].text%></span></a></td>','<td class="<%=weeks[4].days[6].classname%>"><a href="#"><span><%=weeks[4].days[6].text%></span></a></td>',"</tr>","<tr>",'<th class="datepickerWeek"><a href="#"><span><%=weeks[5].week%></span></a></th>','<td class="<%=weeks[5].days[0].classname%>"><a href="#"><span><%=weeks[5].days[0].text%></span></a></td>','<td class="<%=weeks[5].days[1].classname%>"><a href="#"><span><%=weeks[5].days[1].text%></span></a></td>','<td class="<%=weeks[5].days[2].classname%>"><a href="#"><span><%=weeks[5].days[2].text%></span></a></td>','<td class="<%=weeks[5].days[3].classname%>"><a href="#"><span><%=weeks[5].days[3].text%></span></a></td>','<td class="<%=weeks[5].days[4].classname%>"><a href="#"><span><%=weeks[5].days[4].text%></span></a></td>','<td class="<%=weeks[5].days[5].classname%>"><a href="#"><span><%=weeks[5].days[5].text%></span></a></td>','<td class="<%=weeks[5].days[6].classname%>"><a href="#"><span><%=weeks[5].days[6].text%></span></a></td>',"</tr>","</tbody>"],months:['<tbody class="<%=className%>">',"<tr>",'<td colspan="2"><a href="#"><span><%=data[0]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[1]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[2]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[3]%></span></a></td>',"</tr>","<tr>",'<td colspan="2"><a href="#"><span><%=data[4]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[5]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[6]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[7]%></span></a></td>',"</tr>","<tr>",'<td colspan="2"><a href="#"><span><%=data[8]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[9]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[10]%></span></a></td>','<td colspan="2"><a href="#"><span><%=data[11]%></span></a></td>',"</tr>","</tbody>"]},s={flat:!1,starts:1,prev:"&#9664;",next:"&#9654;",lastSel:!1,mode:"single",view:"days",calendars:1,format:"Y-m-d",position:"bottom",eventName:"click",onRender:function(){return{}},onChange:function(){return!0},onShow:function(){return!0},onBeforeShow:function(){return!0},onHide:function(){return!0},locale:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sun"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa","Su"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],weekMin:"wk"}},o=function(t){var n=e(t).data("datepicker"),s=e(t),o=Math.floor(n.calendars/2),u,f,l,c,h=0,p,d,v,m,g,y;s.find("td>table tbody").remove();for(var b=0;b<n.calendars;b++){u=new Date(n.current),u.addMonths(-o+b),y=s.find("table").eq(b+1);switch(y[0].className){case"datepickerViewDays":l=a(u,"B, Y");break;case"datepickerViewMonths":l=u.getFullYear();break;case"datepickerViewYears":l=u.getFullYear()-6+" - "+(u.getFullYear()+5)}y.find("thead tr:first th:eq(1) span").text(l),l=u.getFullYear()-6,f={data:[],className:"datepickerYears"};for(var w=0;w<12;w++)f.data.push(l+w);g=r(i.months.join(""),f),u.setDate(1),f={weeks:[],test:10},c=u.getMonth();var l=(u.getDay()-n.starts)%7;u.addDays(-(l+(l<0?7:0))),p=-1,h=0;while(h<42){v=parseInt(h/7,10),m=h%7,f.weeks[v]||(p=u.getWeekNumber(),f.weeks[v]={week:p,days:[]}),f.weeks[v].days[m]={text:u.getDate(),classname:[]},c!=u.getMonth()&&f.weeks[v].days[m].classname.push("datepickerNotInMonth"),u.getDay()==0&&f.weeks[v].days[m].classname.push("datepickerSunday"),u.getDay()==6&&f.weeks[v].days[m].classname.push("datepickerSaturday");var E=n.onRender(u),S=u.valueOf();(E.selected||n.date==S||e.inArray(S,n.date)>-1||n.mode=="range"&&S>=n.date[0]&&S<=n.date[1])&&f.weeks[v].days[m].classname.push("datepickerSelected"),E.disabled&&f.weeks[v].days[m].classname.push("datepickerDisabled"),E.className&&f.weeks[v].days[m].classname.push(E.className),f.weeks[v].days[m].classname=f.weeks[v].days[m].classname.join(" "),h++,u.addDays(1)}g=r(i.days.join(""),f)+g,f={data:n.locale.monthsShort,className:"datepickerMonths"},g=r(i.months.join(""),f)+g,y.append(g)}},u=function(e,t){if(e.constructor==Date)return new Date(e);var n=e.split(/\W+/),r=t.split(/\W+/),i,s,o,u,a,f=new Date;for(var l=0;l<n.length;l++)switch(r[l]){case"d":case"e":i=parseInt(n[l],10);break;case"m":s=parseInt(n[l],10)-1;break;case"Y":case"y":o=parseInt(n[l],10),o+=o>100?0:o<29?2e3:1900;break;case"H":case"I":case"k":case"l":u=parseInt(n[l],10);break;case"P":case"p":/pm/i.test(n[l])&&u<12?u+=12:/am/i.test(n[l])&&u>=12&&(u-=12);break;case"M":a=parseInt(n[l],10)}return new Date(o===undefined?f.getFullYear():o,s===undefined?f.getMonth():s,i===undefined?f.getDate():i,u===undefined?f.getHours():u,a===undefined?f.getMinutes():a,0)},a=function(e,t){var n=e.getMonth(),r=e.getDate(),i=e.getFullYear(),s=e.getWeekNumber(),o=e.getDay(),u={},a=e.getHours(),f=a>=12,l=f?a-12:a,c=e.getDayOfYear();l==0&&(l=12);var h=e.getMinutes(),p=e.getSeconds(),d=t.split(""),v;for(var m=0;m<d.length;m++){v=d[m];switch(d[m]){case"a":v=e.getDayName();break;case"A":v=e.getDayName(!0);break;case"b":v=e.getMonthName();break;case"B":v=e.getMonthName(!0);break;case"C":v=1+Math.floor(i/100);break;case"d":v=r<10?"0"+r:r;break;case"e":v=r;break;case"H":v=a<10?"0"+a:a;break;case"I":v=l<10?"0"+l:l;break;case"j":v=c<100?c<10?"00"+c:"0"+c:c;break;case"k":v=a;break;case"l":v=l;break;case"m":v=n<9?"0"+(1+n):1+n;break;case"M":v=h<10?"0"+h:h;break;case"p":case"P":v=f?"PM":"AM";break;case"s":v=Math.floor(e.getTime()/1e3);break;case"S":v=p<10?"0"+p:p;break;case"u":v=o+1;break;case"w":v=o;break;case"y":v=(""+i).substr(2,2);break;case"Y":v=i}d[m]=v}return d.join("")},f=function(e){if(Date.prototype.tempDate)return;Date.prototype.tempDate=null,Date.prototype.months=e.months,Date.prototype.monthsShort=e.monthsShort,Date.prototype.days=e.days,Date.prototype.daysShort=e.daysShort,Date.prototype.getMonthName=function(e){return this[e?"months":"monthsShort"][this.getMonth()]},Date.prototype.getDayName=function(e){return this[e?"days":"daysShort"][this.getDay()]},Date.prototype.addDays=function(e){this.setDate(this.getDate()+e),this.tempDate=this.getDate()},Date.prototype.addMonths=function(e){this.tempDate==null&&(this.tempDate=this.getDate()),this.setDate(1),this.setMonth(this.getMonth()+e),this.setDate(Math.min(this.tempDate,this.getMaxDays()))},Date.prototype.addYears=function(e){this.tempDate==null&&(this.tempDate=this.getDate()),this.setDate(1),this.setFullYear(this.getFullYear()+e),this.setDate(Math.min(this.tempDate,this.getMaxDays()))},Date.prototype.getMaxDays=function(){var e=new Date(Date.parse(this)),t=28,n;n=e.getMonth(),t=28;while(e.getMonth()==n)t++,e.setDate(t);return t-1},Date.prototype.getFirstDay=function(){var e=new Date(Date.parse(this));return e.setDate(1),e.getDay()},Date.prototype.getWeekNumber=function(){var e=new Date(this);e.setDate(e.getDate()-(e.getDay()+6)%7+3);var t=e.valueOf();return e.setMonth(0),e.setDate(4),Math.round((t-e.valueOf())/6048e5)+1},Date.prototype.getDayOfYear=function(){var e=new Date(this.getFullYear(),this.getMonth(),this.getDate(),0,0,0),t=new Date(this.getFullYear(),0,0,0,0,0),n=e-t;return Math.floor(n/24*60*60*1e3)}},l=function(t){var n=e(t).data("datepicker"),r=e("#"+n.id);if(!n.extraHeight){var i=e(t).find("div");n.extraHeight=i.get(0).offsetHeight+i.get(1).offsetHeight,n.extraWidth=i.get(2).offsetWidth+i.get(3).offsetWidth}var s=r.find("table:first").get(0),o=s.offsetWidth,u=s.offsetHeight;r.css({width:o+n.extraWidth+"px",height:u+n.extraHeight+"px"}).find("div.datepickerContainer").css({width:o+"px",height:u+"px"})},c=function(t){e(t.target).is("span")&&(t.target=t.target.parentNode);var n=e(t.target);if(n.is("a")){t.target.blur();if(n.hasClass("datepickerDisabled"))return!1;var r=e(this).data("datepicker"),i=n.parent(),s=i.parent().parent().parent(),u=e("table",this).index(s.get(0))-1,f=new Date(r.current),l=!1,c=!1;if(i.is("th")){if(i.hasClass("datepickerWeek")&&r.mode=="range"&&!i.next().hasClass("datepickerDisabled")){var p=parseInt(i.next().text(),10);f.addMonths(u-Math.floor(r.calendars/2)),i.next().hasClass("datepickerNotInMonth")&&f.addMonths(p>15?-1:1),f.setDate(p),r.date[0]=f.setHours(0,0,0,0).valueOf(),f.setHours(23,59,59,0),f.addDays(6),r.date[1]=f.valueOf(),c=!0,l=!0,r.lastSel=!1}else if(i.hasClass("datepickerMonth")){f.addMonths(u-Math.floor(r.calendars/2));switch(s.get(0).className){case"datepickerViewDays":s.get(0).className="datepickerViewMonths",n.find("span").text(f.getFullYear());break;case"datepickerViewMonths":s.get(0).className="datepickerViewYears",n.find("span").text(f.getFullYear()-6+" - "+(f.getFullYear()+5));break;case"datepickerViewYears":s.get(0).className="datepickerViewDays",n.find("span").text(a(f,"B, Y"))}}else if(i.parent().parent().is("thead")){switch(s.get(0).className){case"datepickerViewDays":r.current.addMonths(i.hasClass("datepickerGoPrev")?-1:1);break;case"datepickerViewMonths":r.current.addYears(i.hasClass("datepickerGoPrev")?-1:1);break;case"datepickerViewYears":r.current.addYears(i.hasClass("datepickerGoPrev")?-12:12)}c=!0}}else if(i.is("td")&&!i.hasClass("datepickerDisabled")){switch(s.get(0).className){case"datepickerViewMonths":r.current.setMonth(s.find("tbody.datepickerMonths td").index(i)),r.current.setFullYear(parseInt(s.find("thead th.datepickerMonth span").text(),10)),r.current.addMonths(Math.floor(r.calendars/2)-u),s.get(0).className="datepickerViewDays";break;case"datepickerViewYears":r.current.setFullYear(parseInt(n.text(),10)),s.get(0).className="datepickerViewMonths";break;default:var p=parseInt(n.text(),10);f.addMonths(u-Math.floor(r.calendars/2)),i.hasClass("datepickerNotInMonth")&&f.addMonths(p>15?-1:1),f.setDate(p);switch(r.mode){case"multiple":p=f.setHours(0,0,0,0).valueOf(),e.inArray(p,r.date)>-1?e.each(r.date,function(e,t){if(t==p)return r.date.splice(e,1),!1}):r.date.push(p);break;case"range":r.lastSel||(r.date[0]=f.setHours(0,0,0,0).valueOf()),p=f.setHours(23,59,59,0).valueOf(),p<r.date[0]?(r.date[1]=r.date[0]+86399e3,r.date[0]=p-86399e3):r.date[1]=p,r.lastSel=!r.lastSel;break;default:r.date=f.valueOf()}}c=!0,l=!0}c&&o(this),l&&r.onChange.apply(this,h(r))}return!1},h=function(t){var n;return t.mode=="single"?(n=new Date(t.date),[a(n,t.format),n,t.el]):(n=[[],[],t.el],e.each(t.date,function(e,r){var i=new Date(r);n[0].push(a(i,t.format)),n[1].push(i)}),n)},p=function(){var e=document.compatMode=="CSS1Compat";return{l:window.pageXOffset||(e?document.documentElement.scrollLeft:document.body.scrollLeft),t:window.pageYOffset||(e?document.documentElement.scrollTop:document.body.scrollTop),w:window.innerWidth||(e?document.documentElement.clientWidth:document.body.clientWidth),h:window.innerHeight||(e?document.documentElement.clientHeight:document.body.clientHeight)}},d=function(e,t,n){if(e==t)return!0;if(e.contains)return e.contains(t);if(e.compareDocumentPosition)return!!(e.compareDocumentPosition(t)&16);var r=t.parentNode;while(r&&r!=n){if(r==e)return!0;r=r.parentNode}return!1},v=function(t){var n=e("#"+e(this).data("datepickerId"));if(!n.is(":visible")){var r=n.get(0);o(r);var i=n.data("datepicker");i.onBeforeShow.apply(this,[n.get(0)]);var s=e(this).offset(),u=p(),a=s.top,f=s.left,c=e.curCSS(r,"display");n.css({visibility:"hidden",display:"block"}),l(r);switch(i.position){case"top":a-=r.offsetHeight;break;case"left":f-=r.offsetWidth;break;case"right":f+=this.offsetWidth;break;case"bottom":a+=this.offsetHeight}a+r.offsetHeight>u.t+u.h&&(a=s.top-r.offsetHeight),a<u.t&&(a=s.top+this.offsetHeight+r.offsetHeight),f+r.offsetWidth>u.l+u.w&&(f=s.left-r.offsetWidth),f<u.l&&(f=s.left+this.offsetWidth),n.css({visibility:"visible",display:"block",top:a+"px",left:f+"px"}),i.onShow.apply(this,[n.get(0)])!=0&&n.show(),e(document).bind("mousedown",{cal:n,trigger:this},m)}return!1},m=function(t){t.target!=t.data.trigger&&!d(t.data.cal.get(0),t.target,t.data.cal.get(0))&&(t.data.cal.data("datepicker").onHide.apply(this,[t.data.cal.get(0)])!=0&&t.data.cal.hide(),e(document).unbind("mousedown",m))};return{init:function(t){return t=e.extend({},s,t||{}),f(t.locale),t.calendars=Math.max(1,parseInt(t.calendars,10)||1),t.mode=/single|multiple|range/.test(t.mode)?t.mode:"single",this.each(function(){if(!e(this).data("datepicker")){t.el=this,t.date.constructor==String&&(t.date=u(t.date,t.format),t.date.setHours(0,0,0,0));if(t.mode!="single")if(t.date.constructor!=Array)t.date=[t.date.valueOf()],t.mode=="range"&&t.date.push((new Date(t.date[0])).setHours(23,59,59,0).valueOf());else{for(var s=0;s<t.date.length;s++)t.date[s]=u(t.date[s],t.format).setHours(0,0,0,0).valueOf();t.mode=="range"&&(t.date[1]=(new Date(t.date[1])).setHours(23,59,59,0).valueOf())}else t.date=t.date.valueOf();t.current?t.current=u(t.current,t.format):t.current=new Date,t.current.setDate(1),t.current.setHours(0,0,0,0);var a="datepicker_"+parseInt(Math.random()*1e3),f;t.id=a,e(this).data("datepickerId",t.id);var h=e(i.wrapper).attr("id",a).bind("click",c).data("datepicker",t);t.className&&h.addClass(t.className);var p="";for(var s=0;s<t.calendars;s++)f=t.starts,s>0&&(p+=i.space),p+=r(i.head.join(""),{week:t.locale.weekMin,prev:t.prev,next:t.next,day1:t.locale.daysMin[f++%7],day2:t.locale.daysMin[f++%7],day3:t.locale.daysMin[f++%7],day4:t.locale.daysMin[f++%7],day5:t.locale.daysMin[f++%7],day6:t.locale.daysMin[f++%7],day7:t.locale.daysMin[f++%7]});h.find("tr:first").append(p).find("table").addClass(n[t.view]),o(h.get(0)),t.flat?(h.appendTo(this).show().css("position","relative"),l(h.get(0))):(h.appendTo(document.body),e(this).bind(t.eventName,v))}})},showPicker:function(){return this.each(function(){e(this).data("datepickerId")&&v.apply(this)})},hidePicker:function(){return this.each(function(){e(this).data("datepickerId")&&e("#"+e(this).data("datepickerId")).hide()})},setDate:function(t,n){return this.each(function(){if(e(this).data("datepickerId")){var r=e("#"+e(this).data("datepickerId")),i=r.data("datepicker");i.date=t,i.date.constructor==String&&(i.date=u(i.date,i.format),i.date.setHours(0,0,0,0));if(i.mode!="single")if(i.date.constructor!=Array)i.date=[i.date.valueOf()],i.mode=="range"&&i.date.push((new Date(i.date[0])).setHours(23,59,59,0).valueOf());else{for(var s=0;s<i.date.length;s++)i.date[s]=u(i.date[s],i.format).setHours(0,0,0,0).valueOf();i.mode=="range"&&(i.date[1]=(new Date(i.date[1])).setHours(23,59,59,0).valueOf())}else i.date=i.date.valueOf();n&&(i.current=new Date(i.mode!="single"?i.date[0]:i.date)),o(r.get(0))}})},getDate:function(t){if(this.size()>0)return h(e("#"+e(this).data("datepickerId")).data("datepicker"))[t?0:1]},clear:function(){return this.each(function(){if(e(this).data("datepickerId")){var t=e("#"+e(this).data("datepickerId")),n=t.data("datepicker");n.mode!="single"&&(n.date=[],o(t.get(0)))}})},fixLayout:function(){return this.each(function(){if(e(this).data("datepickerId")){var t=e("#"+e(this).data("datepickerId")),n=t.data("datepicker");n.flat&&l(t.get(0))}})}}}();e.fn.extend({DatePicker:t.init,DatePickerHide:t.hidePicker,DatePickerShow:t.showPicker,DatePickerSetDate:t.setDate,DatePickerGetDate:t.getDate,DatePickerClear:t.clear,DatePickerLayout:t.fixLayout});var n={},r=function(e,t){var i=/\W/.test(e)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+e.replace(/[\r\t\n]/g," ").split("<%").join("	").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("	").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):n[e]=n[e]||r(document.getElementById(e).innerHTML);return t?i(t):i}}),timely.define("external_libs/bootstrap_collapse",["jquery_timely"],function(e){var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning)return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning)return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}},e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=typeof n=="object"&&n;i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e(function(){e("body").on("click.collapse.data-api","[data-toggle=ai1ec_collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();e(i).collapse(s)})})}),timely.define("scripts/add_new_event",["jquery_timely","domReady","ai1ec_config","scripts/add_new_event/event_location/gmaps_helper","scripts/add_new_event/event_location/input_coordinates_event_handlers","scripts/add_new_event/event_location/input_coordinates_utility_functions","scripts/add_new_event/event_date_time/date_time_event_handlers","scripts/add_new_event/facebook_export","scripts/add_new_event/event_cost_helper","external_libs/jquery.calendrical_timespan","external_libs/jquery.inputdate","external_libs/jquery.tools","external_libs/jquery.blockui","external_libs/ai1ec_datepicker","external_libs/bootstrap_collapse"],function(e,t,n,r,i,s,o,u,a,f){var l=function(){var t=new Date(n.now*1e3),r={allday:"#ai1ec_all_day_event",start_date_input:"#ai1ec_start-date-input",start_time_input:"#ai1ec_start-time-input",start_time:"#ai1ec_start-time",end_date_input:"#ai1ec_end-date-input",end_time_input:"#ai1ec_end-time-input",end_time:"#ai1ec_end-time",date_format:n.date_format,month_names:n.month_names,day_names:n.day_names,week_start_day:n.week_start_day,twentyfour_hour:n.twentyfour_hour,now:t};e.timespan(r);var i=e("#ai1ec_exdate").val(),s=null,o=!1,u;if(i.length>=8){s=[];var a=[];e.each(i.split(","),function(e,t){var r=t.slice(0,8),i=r.substr(0,4),o=r.substr(4,2);u=r.substr(6,2),o=o.charAt(0)==="0"?"0"+(parseInt(o.charAt(1),10)-1):parseInt(o,10)-1,s.push(new Date(i,o,u)),a.push(f.formatDate(new Date(i,o,u),n.date_format,!0))}),e("#widgetField span:first").html(a.join(", "))}else s=new Date(n.now*1e3),o=!0;e("#widgetCalendar").DatePicker({flat:!0,calendars:3,mode:"multiple",start:1,date:s,onChange:function(t){t=t.toString();if(t.length>=8){var r="",i=[];e.each(t.split(","),function(e,t){i.push(f.formatDate(new Date(t),n.date_format)),r+=t.replace(/-/g,"")+"T000000Z,"}),e("#widgetField span").html(i.join(", ")),r=r.slice(0,r.length-1),e("#ai1ec_exdate").val(r)}else e("#ai1ec_exdate").val("")}}),o&&e("#widgetCalendar").DatePickerClear(),e("#widgetCalendar div.datepicker").css("position","absolute")},c=function(){e(".accordion-body").on("hide",function(){e(this).removeClass("ai1ec-overflow-visible")}),e(".accordion-body").on("shown",function(){var t=e(this);window.setTimeout(function(){t.addClass("ai1ec-overflow-visible")},350)})},h=function(){l(),timely.require(["libs/gmaps"],function(e){e(r.init_gmaps)})},p=function(t,n){window.alert(n),t.preventDefault(),e("#publish, #ai1ec_bottom_publish").removeClass("button-primary-disabled"),e("#publish, #ai1ec_bottom_publish").siblings("#ajax-loading, .spinner").css("visibility","hidden")},d=function(t){s.ai1ec_check_lat_long_fields_filled_when_publishing_event(t)===!0&&(s.ai1ec_convert_commas_to_dots_for_coordinates(),s.ai1ec_check_lat_long_ok_for_search(t)),e("#ai1ec_ticket_url, #ai1ec_contact_url").each(function(){var e=this.value;if(""!==e){var r=/(http|https):\/\//;r.test(e)||p(t,n.url_not_valid)}})},v=function(){e("#ai1ec_google_map").click(i.toggle_visibility_of_google_map_on_click),e("#ai1ec_input_coordinates").change(i.toggle_visibility_of_coordinate_fields_on_click),e("#post").submit(d),e("input.coordinates").blur(i.update_map_from_coordinates_on_blur),e(document).on("change","#ai1ec_end",o.show_end_fields),e("#ai1ec_bottom_publish").on("click",o.trigger_publish),e(document).on("click",".ai1ec_tab",o.handle_click_on_tab_modal),e(document).on("click",".ai1ec_repeat_apply",o.handle_click_on_apply_button),e(document).on("click","a.ai1ec_repeat_cancel",o.handle_click_on_cancel_modal),e(document).on("click","#ai1ec_monthly_type_bymonthday, #ai1ec_monthly_type_byday",o.handle_checkbox_monthly_tab_modal),e("#widgetField > a, #widgetField > span, #ai1ec_exclude_date_label").on("click",o.handle_animation_of_calendar_widget),e(document).on("click","#ai1ec_weekly_date_select > li,#ai1ec_montly_date_select > li,#ai1ec_yearly_date_select > li",o.handle_click_on_day_month_in_modal),e("#ai1ec_facebook_export").click(u.open_modal_when_user_chooses_to_unpublish_event),e("#ai1ec_facebook_export").click(u.show_multi_choices_when_present),e(document).on("click","#ai1ec_refresh_tokens",u.refresh_page_tokens),e("body").on("click",".remove, .keep",u.add_hidden_field_when_user_click_remove_in_modal),e(document).on("change","#ai1ec_is_free",a.handle_change_is_free),o.execute_pseudo_handlers()},m=function(){e("#ai1ec_event").insertAfter("#titlediv"),e("#post").addClass("ai1ec-visible")},g=function(){h(),t(function(){c(),m(),v()})};return{start:g}}),timely.require(["scripts/add_new_event"],function(e){e.start()}),timely.define("pages/add_new_event",function(){});
\ No newline at end of file
diff --git a/public/js/pages/admin_settings.js b/public/js/pages/admin_settings.js
new file mode 100644
index 0000000..da04393
--- /dev/null
+++ b/public/js/pages/admin_settings.js
@@ -0,0 +1,89 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+
+/* =============================================================
+ * bootstrap-collapse.js v2.0.4
+ * http://twitter.github.com/bootstrap/javascript.html#collapse
+ * =============================================================
+ * Copyright 2012 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ============================================================ */
+
+/* ============================================================
+			 * bootstrap-dropdown.js v2.0.3
+			 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
+			 * ============================================================
+			 * Copyright 2012 Twitter, Inc.
+			 *
+			 * Licensed under the Apache License, Version 2.0 (the "License");
+			 * you may not use this file except in compliance with the License.
+			 * You may obtain a copy of the License at
+			 *
+			 * http://www.apache.org/licenses/LICENSE-2.0
+			 *
+			 * Unless required by applicable law or agreed to in writing, software
+			 * distributed under the License is distributed on an "AS IS" BASIS,
+			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+			 * See the License for the specific language governing permissions and
+			 * limitations under the License.
+			 * ============================================================ */
+
+/* =========================================================
+ * bootstrap-datepicker.js
+ * http://www.eyecon.ro/bootstrap-datepicker
+ * =========================================================
+ * Copyright 2012 Stefan Petre
+ * Improvements by Andrew Rowls
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ========================================================= */
+
+/* ===========================================================
+   * bootstrap-tooltip.js v2.0.4
+   * http://twitter.github.com/bootstrap/javascript.html#tooltips
+   * Inspired by the original jQuery.tipsy by Jason Frame
+   * ===========================================================
+   * Copyright 2012 Twitter, Inc.
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   * http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   * ========================================================== */
+
+/**
+	 * Initialize the license status indicator with API call.
+	 */
+
+timely.define("domReady",[],function(){function u(e){var t;for(t=0;t<e.length;t++)e[t](n)}function a(){var e=r;t&&e.length&&(r=[],u(e))}function f(){t||(t=!0,o&&clearInterval(o),a())}function c(e){return t?e(n):r.push(e),c}var e=typeof window!="undefined"&&window.document,t=!e,n=e?document:null,r=[],i,s,o;if(e){if(document.addEventListener)document.addEventListener("DOMContentLoaded",f,!1),window.addEventListener("load",f,!1);else if(window.attachEvent){window.attachEvent("onload",f),s=document.createElement("div");try{i=window.frameElement===null}catch(l){}s.doScroll&&i&&window.external&&(o=setInterval(function(){try{s.doScroll(),f()}catch(e){}},30))}(document.readyState==="complete"||document.readyState==="interactive")&&f()}return c.version="2.0.0",c.load=function(e,t,n,r){r.isBuild?n(null):c(n)},c}),timely.define("external_libs/bootstrap_tab",["jquery_timely"],function(e){var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active a").last()[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}},e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e(function(){e("body").on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})})}),timely.define("libs/utils",["jquery_timely","external_libs/bootstrap_tab"],function(e){var t=function(){return{is_float:function(e){return!isNaN(parseFloat(e))},is_valid_coordinate:function(e,t){var n=t?90:180;return this.is_float(e)&&Math.abs(e)<n},convert_comma_to_dot:function(e){return e.replace(",",".")},field_has_value:function(t){var n="#"+t,r=e(n),i=!1;return r.length===1&&(i=e.trim(r.val())!==""),i},make_alert:function(t,n,r){var i="";switch(n){case"error":i="alert alert-error";break;case"success":i="alert alert-success";break;default:i="alert"}var s=e("<div />",{"class":i,html:t});if(!r){var o=e("<a />",{"class":"close","data-dismiss":"alert",href:"#",text:"x"});s.prepend(o)}return s},get_ajax_url:function(){return typeof window.ajaxurl=="undefined"?"http://localhost/wordpress/wp-admin/admin-ajax.php":window.ajaxurl},isUrl:function(e){var t=/(http|https|webcal):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;return t.test(e)},isValidEmail:function(e){var t=/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;return t.test(e)},activate_saved_tab_on_page_load:function(t){null===t||undefined===t?e("ul.nav-tabs a:first").tab("show"):e("ul.nav-tabs a[href="+t+"]").tab("show")}}}();return t}),timely.define("external_libs/bootstrap_collapse",["jquery_timely"],function(e){var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning)return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning)return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}},e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=typeof n=="object"&&n;i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e(function(){e("body").on("click.collapse.data-api","[data-toggle=ai1ec_collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();e(i).collapse(s)})})}),timely.define("libs/collapse_helper",["jquery_timely","domReady","external_libs/bootstrap_collapse"],function(e,t){t(function(){e(document).on("click",'[data-toggle="ai1ec_collapse"]',function(){e(this).toggleClass("active"),e(".icon-caret-down, .icon-caret-up, .icon-chevron-down, .icon-chevron-up, .icon-arrow-down, .icon-arrow-up",this).toggleClass("hide")})})}),timely.define("external_libs/bootstrap_dropdown",["jquery_timely","domReady"],function(e,t){if(!e.fn.dropdown){var n='[data-toggle="dropdown"]',r=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};r.prototype={constructor:r,toggle:function(t){var n=e(this),r,s,o;if(n.is(".disabled, :disabled"))return;return s=n.attr("data-target"),s||(s=n.attr("href"),s=s&&s.replace(/.*(?=#[^\s]*$)/,"")),r=e(s),r.length||(r=n.parent()),o=r.hasClass("open"),i(),o||r.toggleClass("open"),!1}};function i(){e(n).parent().removeClass("open")}e.fn.dropdown=function(t){return this.each(function(){var n=e(this),i=n.data("dropdown");i||n.data("dropdown",i=new r(this)),typeof t=="string"&&i[t].call(n)})},e.fn.dropdown.Constructor=r,t(function(){e(document).on("click.dropdown.data-api",i),e(document).on("click.dropdown",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown.data-api",n,r.prototype.toggle)})}}),timely.define("external_libs/locales/bootstrap-datepicker.bg",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.bg={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.br",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.br={days:["Domingo","Segunda","Tera","Quarta","Quinta","Sexta","Sbado","Domingo"],daysShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sb","Dom"],daysMin:["Do","Se","Te","Qu","Qu","Se","Sa","Do"],months:["Janeiro","Fevereiro","Maro","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthsShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.cs",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.cs={days:["Nedle","Pondl","ter","Steda","tvrtek","Ptek","Sobota","Nedle"],daysShort:["Ne","Po","t","St","t","P","So","Ne"],daysMin:["N","P","","St","","P","So","N"],months:["Leden","nor","Bezen","Duben","Kvten","erven","ervenec","Srpen","Z","jen","Listopad","Prosinec"],monthsShort:["Led","no","Be","Dub","Kv","er","nc","Srp","Z","j","Lis","Pro"],today:"Dnes"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.da",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.da={days:["Sndag","Mandag","Tirsdag","Onsdag","Torsdag","Fredag","Lrdag","Sndag"],daysShort:["Sn","Man","Tir","Ons","Tor","Fre","Lr","Sn"],daysMin:["S","Ma","Ti","On","To","Fr","L","S"],months:["Januar","Februar","Marts","April","Maj","Juni","Juli","August","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],today:"I Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.de",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.de={days:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag","Sonntag"],daysShort:["Son","Mon","Die","Mit","Don","Fre","Sam","Son"],daysMin:["So","Mo","Di","Mi","Do","Fr","Sa","So"],months:["Januar","Februar","Mrz","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],monthsShort:["Jan","Feb","Mr","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],today:"Heute"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.es",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.es={days:["Domingo","Lunes","Martes","Mircoles","Jueves","Viernes","Sbado","Domingo"],daysShort:["Dom","Lun","Mar","Mi","Jue","Vie","Sb","Dom"],daysMin:["Do","Lu","Ma","Mi","Ju","Vi","Sa","Do"],months:["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"],monthsShort:["Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic"],today:"Hoy"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.fi",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.fi={days:["sunnuntai","maanantai","tiistai","keskiviikko","torstai","perjantai","lauantai","sunnuntai"],daysShort:["sun","maa","tii","kes","tor","per","lau","sun"],daysMin:["su","ma","ti","ke","to","pe","la","su"],months:["tammikuu","helmikuu","maaliskuu","huhtikuu","toukokuu","keskuu","heinkuu","elokuu","syyskuu","lokakuu","marraskuu","joulukuu"],monthsShort:["tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mar","jou"],today:"tnn"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.fr",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.fr={days:["Dimanche","Lundi","Mardi","Mercredi","Jeudi","Vendredi","Samedi","Dimanche"],daysShort:["Dim","Lun","Mar","Mer","Jeu","Ven","Sam","Dim"],daysMin:["D","L","Ma","Me","J","V","S","D"],months:["Janvier","Fvrier","Mars","Avril","Mai","Juin","Juillet","Aot","Septembre","Octobre","Novembre","Dcembre"],monthsShort:["Jan","Fev","Mar","Avr","Mai","Jui","Jul","Aou","Sep","Oct","Nov","Dec"],today:"Aujourd'hui"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.id",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.id={days:["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu","Minggu"],daysShort:["Mgu","Sen","Sel","Rab","Kam","Jum","Sab","Mgu"],daysMin:["Mg","Sn","Sl","Ra","Ka","Ju","Sa","Mg"],months:["Januari","Februari","Maret","April","Mei","Juni","Juli","Agustus","September","Oktober","November","Desember"],monthsShort:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Ags","Sep","Okt","Nov","Des"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.is",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.is={days:["Sunnudagur","Mnudagur","rijudagur","Mivikudagur","Fimmtudagur","Fstudagur","Laugardagur","Sunnudagur"],daysShort:["Sun","Mn","ri","Mi","Fim","Fs","Lau","Sun"],daysMin:["Su","M","r","Mi","Fi","F","La","Su"],months:["Janar","Febrar","Mars","Aprl","Ma","Jn","Jl","gst","September","Oktber","Nvember","Desember"],monthsShort:["Jan","Feb","Mar","Apr","Ma","Jn","Jl","g","Sep","Okt","Nv","Des"],today:" Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.it",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.it={days:["Domenica","Lunedi","Martedi","Mercoledi","Giovedi","Venerdi","Sabato","Domenica"],daysShort:["Dom","Lun","Mar","Mer","Gio","Ven","Sab","Dom"],daysMin:["Do","Lu","Ma","Me","Gi","Ve","Sa","Do"],months:["Gennaio","Febbraio","Marzo","Aprile","Maggio","Giugno","Luglio","Agosto","Settembre","Ottobre","Novembre","Dicembre"],monthsShort:["Gen","Feb","Mar","Apr","Mag","Giu","Lug","Ago","Set","Ott","Nov","Dic"],today:"Oggi"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.ja",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.ja={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["1","2","3","4","5","6","7","8","9","10","11","12"],monthsShort:["1","2","3","4","5","6","7","8","9","10","11","12"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.kr",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.kr={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["1","2","3","4","5","6","7","8","9","10","11","12"],monthsShort:["1","2","3","4","5","6","7","8","9","10","11","12"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.lt",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.lt={days:["Sekmadienis","Pirmadienis","Antradienis","Treiadienis","Ketvirtadienis","Penktadienis","etadienis","Sekmadienis"],daysShort:["S","Pr","A","T","K","Pn","","S"],daysMin:["Sk","Pr","An","Tr","Ke","Pn","t","Sk"],months:["Sausis","Vasaris","Kovas","Balandis","Gegu","Birelis","Liepa","Rugpjtis","Rugsjis","Spalis","Lapkritis","Gruodis"],monthsShort:["Sau","Vas","Kov","Bal","Geg","Bir","Lie","Rugp","Rugs","Spa","Lap","Gru"],weekStart:1}}}}),timely.define("external_libs/locales/bootstrap-datepicker.lv",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.lv={days:["Svtdiena","Pirmdiena","Otrdiena","Trediena","Ceturtdiena","Piektdiena","Sestdiena","Svtdiena"],daysShort:["Sv","P","O","T","C","Pk","S","Sv"],daysMin:["Sv","Pr","Ot","Tr","Ce","Pk","St","Sv"],months:["Janvris","Februris","Marts","Aprlis","Maijs","Jnijs","Jlijs","Augusts","Septembris","Oktobris","Novembris","Decembris"],monthsShort:["Jan","Feb","Mar","Apr","Mai","Jn","Jl","Aug","Sep","Okt","Nov","Dec."],today:"odien",weekStart:1}}}}),timely.define("external_libs/locales/bootstrap-datepicker.ms",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.ms={days:["Ahad","Isnin","Selasa","Rabu","Khamis","Jumaat","Sabtu","Ahad"],daysShort:["Aha","Isn","Sel","Rab","Kha","Jum","Sab","Aha"],daysMin:["Ah","Is","Se","Ra","Kh","Ju","Sa","Ah"],months:["Januari","Februari","Mac","April","Mei","Jun","Julai","Ogos","September","Oktober","November","Disember"],monthsShort:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Ogo","Sep","Okt","Nov","Dis"],today:"Hari Ini"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.nb",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.nb={days:["Sndag","Mandag","Tirsdag","Onsdag","Torsdag","Fredag","Lrdag","Sndag"],daysShort:["Sn","Man","Tir","Ons","Tor","Fre","Lr","Sn"],daysMin:["S","Ma","Ti","On","To","Fr","L","S"],months:["Januar","Februar","Mars","April","Mai","Juni","Juli","August","September","Oktober","November","Desember"],monthsShort:["Jan","Feb","Mar","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Des"],today:"I Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.nl",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.nl={days:["Zondag","Maandag","Dinsdag","Woensdag","Donderdag","Vrijdag","Zaterdag","Zondag"],daysShort:["Zo","Ma","Di","Wo","Do","Vr","Za","Zo"],daysMin:["Zo","Ma","Di","Wo","Do","Vr","Za","Zo"],months:["Januari","Februari","Maart","April","Mei","Juni","Juli","Augustus","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mrt","Apr","Mei","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],today:"Vandaag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.pl",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.pl={days:["Niedziela","Poniedziaek","Wtorek","roda","Czwartek","Pitek","Sobota","Niedziela"],daysShort:["Nie","Pn","Wt","r","Czw","Pt","So","Nie"],daysMin:["N","Pn","Wt","r","Cz","Pt","So","N"],months:["Stycze","Luty","Marzec","Kwiecie","Maj","Czerwiec","Lipiec","Sierpie","Wrzesie","Padziernik","Listopad","Grudzie"],monthsShort:["Sty","Lu","Mar","Kw","Maj","Cze","Lip","Sie","Wrz","Pa","Lis","Gru"],today:"Dzisiaj"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.pt-BR",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates["pt-BR"]={days:["Domingo","Segunda","Tera","Quarta","Quinta","Sexta","Sbado","Domingo"],daysShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sb","Dom"],daysMin:["Do","Se","Te","Qu","Qu","Se","Sa","Do"],months:["Janeiro","Fevereiro","Maro","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthsShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],today:"Hoje"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.pt",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.pt={days:["Domingo","Segunda","Tera","Quarta","Quinta","Sexta","Sbado","Domingo"],daysShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sb","Dom"],daysMin:["Do","Se","Te","Qu","Qu","Se","Sa","Do"],months:["Janeiro","Fevereiro","Maro","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthsShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.ru",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.ru={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.sl",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.sl={days:["Nedelja","Ponedeljek","Torek","Sreda","etrtek","Petek","Sobota","Nedelja"],daysShort:["Ned","Pon","Tor","Sre","et","Pet","Sob","Ned"],daysMin:["Ne","Po","To","Sr","e","Pe","So","Ne"],months:["Januar","Februar","Marec","April","Maj","Junij","Julij","Avgust","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Avg","Sep","Okt","Nov","Dec"],today:"Danes"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.sv",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.sv={days:["Sndag","Mndag","Tisdag","Onsdag","Torsdag","Fredag","Lrdag","Sndag"],daysShort:["Sn","Mn","Tis","Ons","Tor","Fre","Lr","Sn"],daysMin:["S","M","Ti","On","To","Fr","L","S"],months:["Januari","Februari","Mars","April","Maj","Juni","Juli","Augusti","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],today:"I Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.th",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.th={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["..","..","..","..","..","..","..","..","..","..","..",".."],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.tr",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.tr={days:["Pazar","Pazartesi","Sal","aramba","Perembe","Cuma","Cumartesi","Pazar"],daysShort:["Pz","Pzt","Sal","r","Pr","Cu","Cts","Pz"],daysMin:["Pz","Pzt","Sa","r","Pr","Cu","Ct","Pz"],months:["Ocak","ubat","Mart","Nisan","Mays","Haziran","Temmuz","Austos","Eyll","Ekim","Kasm","Aralk"],monthsShort:["Oca","ub","Mar","Nis","May","Haz","Tem","Au","Eyl","Eki","Kas","Ara"],today:"Bugn"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.zh-CN",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates["zh-CN"]={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.zh-TW",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates["zh-TW"]={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""]}}}}),timely.define("external_libs/bootstrap_datepicker",["jquery_timely","ai1ec_config","external_libs/locales/bootstrap-datepicker.bg","external_libs/locales/bootstrap-datepicker.br","external_libs/locales/bootstrap-datepicker.cs","external_libs/locales/bootstrap-datepicker.da","external_libs/locales/bootstrap-datepicker.de","external_libs/locales/bootstrap-datepicker.es","external_libs/locales/bootstrap-datepicker.fi","external_libs/locales/bootstrap-datepicker.fr","external_libs/locales/bootstrap-datepicker.id","external_libs/locales/bootstrap-datepicker.is","external_libs/locales/bootstrap-datepicker.it","external_libs/locales/bootstrap-datepicker.ja","external_libs/locales/bootstrap-datepicker.kr","external_libs/locales/bootstrap-datepicker.lt","external_libs/locales/bootstrap-datepicker.lv","external_libs/locales/bootstrap-datepicker.ms","external_libs/locales/bootstrap-datepicker.nb","external_libs/locales/bootstrap-datepicker.nl","external_libs/locales/bootstrap-datepicker.pl","external_libs/locales/bootstrap-datepicker.pt-BR","external_libs/locales/bootstrap-datepicker.pt","external_libs/locales/bootstrap-datepicker.ru","external_libs/locales/bootstrap-datepicker.sl","external_libs/locales/bootstrap-datepicker.sv","external_libs/locales/bootstrap-datepicker.th","external_libs/locales/bootstrap-datepicker.tr","external_libs/locales/bootstrap-datepicker.zh-CN","external_libs/locales/bootstrap-datepicker.zh-TW"],function(e,t){function n(){return new Date(Date.UTC.apply(Date,arguments))}function r(){var e=new Date;return n(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate())}var i=function(n,r){var i=this;this.element=e(n),this.language=r.language||this.element.data("date-language")||t.language||"en",this.language=this.language in s?this.language:"en",this.format=o.parseFormat(r.format||this.element.data("date-format")||"mm/dd/yyyy"),this.picker=e(o.template).appendTo("body").on({click:e.proxy(this.click,this)}),this.isInput=this.element.is("input"),this.component=this.element.is(".date")?this.element.find(".add-on"):!1,this.hasInput=this.component&&this.element.find("input").length,this.component&&this.component.length===0&&(this.component=!1),this.isInput?this.element.on({focus:e.proxy(this.show,this),keyup:e.proxy(this.update,this),keydown:e.proxy(this.keydown,this)}):this.component&&this.hasInput?(this.element.find("input").on({focus:e.proxy(this.show,this),keyup:e.proxy(this.update,this),keydown:e.proxy(this.keydown,this)}),this.component.on("click",e.proxy(this.show,this))):this.element.on("click",e.proxy(this.show,this)),e(document).on("mousedown",function(t){e(t.target).closest(".datepicker").length==0&&i.hide()}),this.autoclose=!1,"autoclose"in r?this.autoclose=r.autoclose:"dateAutoclose"in this.element.data()&&(this.autoclose=this.element.data("date-autoclose")),this.keyboardNavigation=!0,"keyboardNavigation"in r?this.keyboardNavigation=r.keyboardNavigation:"dateKeyboardNavigation"in this.element.data()&&(this.keyboardNavigation=this.element.data("date-keyboard-navigation"));switch(r.startView||this.element.data("date-start-view")){case 2:case"decade":this.viewMode=this.startViewMode=2;break;case 1:case"year":this.viewMode=this.startViewMode=1;break;case 0:case"month":default:this.viewMode=this.startViewMode=0}this.todayBtn=r.todayBtn||this.element.data("date-today-btn")||!1,this.todayHighlight=r.todayHighlight||this.element.data("date-today-highlight")||!1,this.weekStart=(r.weekStart||this.element.data("date-weekstart")||s[this.language].weekStart||0)%7,this.weekEnd=(this.weekStart+6)%7,this.startDate=-Infinity,this.endDate=Infinity,this.setStartDate(r.startDate||this.element.data("date-startdate")),this.setEndDate(r.endDate||this.element.data("date-enddate")),this.fillDow(),this.fillMonths(),this.update(),this.showMode()};i.prototype={constructor:i,show:function(t){this.picker.show(),this.height=this.component?this.component.outerHeight():this.element.outerHeight(),this.update(),this.place(),e(window).on("resize",e.proxy(this.place,this)),t&&(t.stopPropagation(),t.preventDefault()),this.element.trigger({type:"show",date:this.date})},hide:function(t){this.picker.hide(),e(window).off("resize",this.place),this.viewMode=this.startViewMode,this.showMode(),this.isInput||e(document).off("mousedown",this.hide),t&&t.currentTarget.value&&this.setValue(),this.element.trigger({type:"hide",date:this.date})},getDate:function(){var e=this.getUTCDate();return new Date(e.getTime()+e.getTimezoneOffset()*6e4)},getUTCDate:function(){return this.date},setDate:function(e){this.setUTCDate(new Date(e.getTime()-e.getTimezoneOffset()*6e4))},setUTCDate:function(e){this.date=e,this.setValue()},setValue:function(){var e=o.formatDate(this.date,this.format,this.language);this.isInput?this.element.prop("value",e):(this.component&&this.element.find("input").prop("value",e),this.element.data("date",e))},setStartDate:function(e){this.startDate=e||-Infinity,this.startDate!==-Infinity&&(this.startDate=o.parseDate(this.startDate,this.format,this.language)),this.update(),this.updateNavArrows()},setEndDate:function(e){this.endDate=e||Infinity,this.endDate!==Infinity&&(this.endDate=o.parseDate(this.endDate,this.format,this.language)),this.update(),this.updateNavArrows()},place:function(){var t=parseInt(this.element.parents().filter(function(){return e(this).css("z-index")!="auto"}).first().css("z-index"))+10,n=this.component?this.component.offset():this.element.offset();this.picker.css({top:n.top+this.height,left:n.left,zIndex:t})},update:function(){this.date=o.parseDate(this.isInput?this.element.prop("value"):this.element.data("date")||this.element.find("input").prop("value"),this.format,this.language),this.date<this.startDate?this.viewDate=new Date(this.startDate):this.date>this.endDate?this.viewDate=new Date(this.endDate):this.viewDate=new Date(this.date),this.fill()},fillDow:function(){var e=this.weekStart,t="<tr>";while(e<this.weekStart+7)t+='<th class="dow">'+s[this.language].daysMin[e++%7]+"</th>";t+="</tr>",this.picker.find(".datepicker-days thead").append(t)},fillMonths:function(){var e="",t=0;while(t<12)e+='<span class="month">'+s[this.language].monthsShort[t++]+"</span>";this.picker.find(".datepicker-months td").html(e)},fill:function(){var e=new Date(this.viewDate),t=e.getUTCFullYear(),r=e.getUTCMonth(),i=this.startDate!==-Infinity?this.startDate.getUTCFullYear():-Infinity,u=this.startDate!==-Infinity?this.startDate.getUTCMonth():-Infinity,a=this.endDate!==Infinity?this.endDate.getUTCFullYear():Infinity,f=this.endDate!==Infinity?this.endDate.getUTCMonth():Infinity,l=this.date.valueOf(),c=new Date;this.picker.find(".datepicker-days thead th:eq(1)").text(s[this.language].months[r]+" "+t),this.picker.find("tfoot th.today").text(s[this.language].today).toggle(this.todayBtn),this.updateNavArrows(),this.fillMonths();var h=n(t,r-1,28,0,0,0,0),p=o.getDaysInMonth(h.getUTCFullYear(),h.getUTCMonth());h.setUTCDate(p),h.setUTCDate(p-(h.getUTCDay()-this.weekStart+7)%7);var d=new Date(h);d.setUTCDate(d.getUTCDate()+42),d=d.valueOf();var v=[],m;while(h.valueOf()<d){h.getUTCDay()==this.weekStart&&v.push("<tr>"),m="";if(h.getUTCFullYear()<t||h.getUTCFullYear()==t&&h.getUTCMonth()<r)m+=" old";else if(h.getUTCFullYear()>t||h.getUTCFullYear()==t&&h.getUTCMonth()>r)m+=" new";this.todayHighlight&&h.getUTCFullYear()==c.getFullYear()&&h.getUTCMonth()==c.getMonth()&&h.getUTCDate()==c.getDate()&&(m+=" today"),h.valueOf()==l&&(m+=" active");if(h.valueOf()<this.startDate||h.valueOf()>this.endDate)m+=" disabled";v.push('<td class="day'+m+'">'+h.getUTCDate()+"</td>"),h.getUTCDay()==this.weekEnd&&v.push("</tr>"),h.setUTCDate(h.getUTCDate()+1)}this.picker.find(".datepicker-days tbody").empty().append(v.join(""));var g=this.date.getUTCFullYear(),y=this.picker.find(".datepicker-months").find("th:eq(1)").text(t).end().find("span").removeClass("active");g==t&&y.eq(this.date.getUTCMonth()).addClass("active"),(t<i||t>a)&&y.addClass("disabled"),t==i&&y.slice(0,u).addClass("disabled"),t==a&&y.slice(f+1).addClass("disabled"),v="",t=parseInt(t/10,10)*10;var b=this.picker.find(".datepicker-years").find("th:eq(1)").text(t+"-"+(t+9)).end().find("td");t-=1;for(var w=-1;w<11;w++)v+='<span class="year'+(w==-1||w==10?" old":"")+(g==t?" active":"")+(t<i||t>a?" disabled":"")+'">'+t+"</span>",t+=1;b.html(v)},updateNavArrows:function(){var e=new Date(this.viewDate),t=e.getUTCFullYear(),n=e.getUTCMonth();switch(this.viewMode){case 0:this.startDate!==-Infinity&&t<=this.startDate.getUTCFullYear()&&n<=this.startDate.getUTCMonth()?this.picker.find(".prev").css({visibility:"hidden"}):this.picker.find(".prev").css({visibility:"visible"}),this.endDate!==Infinity&&t>=this.endDate.getUTCFullYear()&&n>=this.endDate.getUTCMonth()?this.picker.find(".next").css({visibility:"hidden"}):this.picker.find(".next").css({visibility:"visible"});break;case 1:case 2:this.startDate!==-Infinity&&t<=this.startDate.getUTCFullYear()?this.picker.find(".prev").css({visibility:"hidden"}):this.picker.find(".prev").css({visibility:"visible"}),this.endDate!==Infinity&&t>=this.endDate.getUTCFullYear()?this.picker.find(".next").css({visibility:"hidden"}):this.picker.find(".next").css({visibility:"visible"})}},click:function(t){t.stopPropagation(),t.preventDefault();var r=e(t.target).closest("span, td, th");if(r.length==1)switch(r[0].nodeName.toLowerCase()){case"th":switch(r[0].className){case"switch":this.showMode(1);break;case"prev":case"next":var i=o.modes[this.viewMode].navStep*(r[0].className=="prev"?-1:1);switch(this.viewMode){case 0:this.viewDate=this.moveMonth(this.viewDate,i);break;case 1:case 2:this.viewDate=this.moveYear(this.viewDate,i)}this.fill();break;case"today":var s=new Date;s.setUTCHours(0),s.setUTCMinutes(0),s.setUTCSeconds(0),s.setUTCMilliseconds(0),this.showMode(-2);var u=this.todayBtn=="linked"?null:"view";this._setDate(s,u)}break;case"span":if(!r.is(".disabled")){this.viewDate.setUTCDate(1);if(r.is(".month")){var a=r.parent().find("span").index(r);this.viewDate.setUTCMonth(a),this.element.trigger({type:"changeMonth",date:this.viewDate})}else{var f=parseInt(r.text(),10)||0;this.viewDate.setUTCFullYear(f),this.element.trigger({type:"changeYear",date:this.viewDate})}this.showMode(-1),this.fill()}break;case"td":if(r.is(".day")&&!r.is(".disabled")){var l=parseInt(r.text(),10)||1,f=this.viewDate.getUTCFullYear(),a=this.viewDate.getUTCMonth();r.is(".old")?a==0?(a=11,f-=1):a-=1:r.is(".new")&&(a==11?(a=0,f+=1):a+=1),this._setDate(n(f,a,l,0,0,0,0))}}},_setDate:function(e,t){if(!t||t=="date")this.date=e;if(!t||t=="view")this.viewDate=e;this.fill(),this.setValue(),this.element.trigger({type:"changeDate",date:this.date});var n;this.isInput?n=this.element:this.component&&(n=this.element.find("input")),n&&(n.change(),this.autoclose&&this.hide())},moveMonth:function(e,t){if(!t)return e;var n=new Date(e.valueOf()),r=n.getUTCDate(),i=n.getUTCMonth(),s=Math.abs(t),o,u;t=t>0?1:-1;if(s==1){u=t==-1?function(){return n.getUTCMonth()==i}:function(){return n.getUTCMonth()!=o},o=i+t,n.setUTCMonth(o);if(o<0||o>11)o=(o+12)%12}else{for(var a=0;a<s;a++)n=this.moveMonth(n,t);o=n.getUTCMonth(),n.setUTCDate(r),u=function(){return o!=n.getUTCMonth()}}while(u())n.setUTCDate(--r),n.setUTCMonth(o);return n},moveYear:function(e,t){return this.moveMonth(e,t*12)},dateWithinRange:function(e){return e>=this.startDate&&e<=this.endDate},keydown:function(e){if(this.picker.is(":not(:visible)")){e.keyCode==27&&this.show();return}var t=!1,n,r,i,s,o;switch(e.keyCode){case 27:this.hide(),e.preventDefault();break;case 37:case 39:if(!this.keyboardNavigation)break;n=e.keyCode==37?-1:1,e.ctrlKey?(s=this.moveYear(this.date,n),o=this.moveYear(this.viewDate,n)):e.shiftKey?(s=this.moveMonth(this.date,n),o=this.moveMonth(this.viewDate,n)):(s=new Date(this.date),s.setUTCDate(this.date.getUTCDate()+n),o=new Date(this.viewDate),o.setUTCDate(this.viewDate.getUTCDate()+n)),this.dateWithinRange(s)&&(this.date=s,this.viewDate=o,this.setValue(),this.update(),e.preventDefault(),t=!0);break;case 38:case 40:if(!this.keyboardNavigation)break;n=e.keyCode==38?-1:1,e.ctrlKey?(s=this.moveYear(this.date,n),o=this.moveYear(this.viewDate,n)):e.shiftKey?(s=this.moveMonth(this.date,n),o=this.moveMonth(this.viewDate,n)):(s=new Date(this.date),s.setUTCDate(this.date.getUTCDate()+n*7),o=new Date(this.viewDate),o.setUTCDate(this.viewDate.getUTCDate()+n*7)),this.dateWithinRange(s)&&(this.date=s,this.viewDate=o,this.setValue(),this.update(),e.preventDefault(),t=!0);break;case 13:this.hide(),e.preventDefault();break;case 9:this.hide()}if(t){this.element.trigger({type:"changeDate",date:this.date});var u;this.isInput?u=this.element:this.component&&(u=this.element.find("input")),u&&u.change()}},showMode:function(e){e&&(this.viewMode=Math.max(0,Math.min(2,this.viewMode+e))),this.picker.find(">div").hide().filter(".datepicker-"+o.modes[this.viewMode].clsName).show(),this.updateNavArrows()}},e.fn.datepicker=function(t){var n=Array.apply(null,arguments);return n.shift(),this.each(function(){var r=e(this),s=r.data("datepicker"),o=typeof t=="object"&&t;s||r.data("datepicker",s=new i(this,e.extend({},e.fn.datepicker.defaults,o))),typeof t=="string"&&typeof s[t]=="function"&&s[t].apply(s,n)})},e.fn.datepicker.defaults={},e.fn.datepicker.Constructor=i;var s=e.fn.datepicker.dates={en:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sun"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa","Su"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],today:"Today"}},o={modes:[{clsName:"days",navFnc:"Month",navStep:1},{clsName:"months",navFnc:"FullYear",navStep:1},{clsName:"years",navFnc:"FullYear",navStep:10}],isLeapYear:function(e){return e%4===0&&e%100!==0||e%400===0},getDaysInMonth:function(e,t){return[31,o.isLeapYear(e)?29:28,31,30,31,30,31,31,30,31,30,31][t]},validParts:/dd?|mm?|MM?|yy(?:yy)?/g,nonpunctuation:/[^ -\/:-@\[-`{-~\t\n\r]+/g,parseFormat:function(e){var t=e.replace(this.validParts,"\0").split("\0"),n=e.match(this.validParts);if(!t||!t.length||!n||n.length==0)throw new Error("Invalid date format.");return{separators:t,parts:n}},parseDate:function(t,r,o){if(t instanceof Date)return t;if(/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(t)){var u=/([-+]\d+)([dmwy])/,a=t.match(/([-+]\d+)([dmwy])/g),f,l;t=new Date;for(var c=0;c<a.length;c++){f=u.exec(a[c]),l=parseInt(f[1]);switch(f[2]){case"d":t.setUTCDate(t.getUTCDate()+l);break;case"m":t=i.prototype.moveMonth.call(i.prototype,t,l);break;case"w":t.setUTCDate(t.getUTCDate()+l*7);break;case"y":t=i.prototype.moveYear.call(i.prototype,t,l)}}return n(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate(),0,0,0)}var a=t&&t.match(this.nonpunctuation)||[],t=new Date,h={},p=["yyyy","yy","M","MM","m","mm","d","dd"],d={yyyy:function(e,t){return e.setUTCFullYear(t)},yy:function(e,t){return e.setUTCFullYear(2e3+t)},m:function(e,t){t-=1;while(t<0)t+=12;t%=12,e.setUTCMonth(t);while(e.getUTCMonth()!=t)e.setUTCDate(e.getUTCDate()-1);return e},d:function(e,t){return e.setUTCDate(t)}},v,m,f;d.M=d.MM=d.mm=d.m,d.dd=d.d,t=n(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate(),0,0,0);if(a.length==r.parts.length){for(var c=0,g=r.parts.length;c<g;c++){v=parseInt(a[c],10),f=r.parts[c];if(isNaN(v))switch(f){case"MM":m=e(s[o].months).filter(function(){var e=this.slice(0,a[c].length),t=a[c].slice(0,e.length);return e==t}),v=e.inArray(m[0],s[o].months)+1;break;case"M":m=e(s[o].monthsShort).filter(function(){var e=this.slice(0,a[c].length),t=a[c].slice(0,e.length);return e==t}),v=e.inArray(m[0],s[o].monthsShort)+1}h[f]=v}for(var c=0,y;c<p.length;c++)y=p[c],y in h&&d[y](t,h[y])}return t},formatDate:function(t,n,r){var i={d:t.getUTCDate(),m:t.getUTCMonth()+1,M:s[r].monthsShort[t.getUTCMonth()],MM:s[r].months[t.getUTCMonth()],yy:t.getUTCFullYear().toString().substring(2),yyyy:t.getUTCFullYear()};i.dd=(i.d<10?"0":"")+i.d,i.mm=(i.m<10?"0":"")+i.m;var t=[],o=e.extend([],n.separators);for(var u=0,a=n.parts.length;u<a;u++)o.length&&t.push(o.shift()),t.push(i[n.parts[u]]);return t.join("")},headTemplate:'<thead><tr><th class="prev"><i class="icon-arrow-left"/></th><th colspan="5" class="switch"></th><th class="next"><i class="icon-arrow-right"/></th></tr></thead>',contTemplate:'<tbody><tr><td colspan="7"></td></tr></tbody>',footTemplate:'<tfoot><tr><th colspan="7" class="today"></th></tr></tfoot>'};o.template='<div class="datepicker dropdown-menu"><div class="datepicker-days"><table class=" table-condensed">'+o.headTemplate+"<tbody></tbody>"+o.footTemplate+"</table>"+"</div>"+'<div class="datepicker-months">'+'<table class="table-condensed">'+o.headTemplate+o.contTemplate+o.footTemplate+"</table>"+"</div>"+'<div class="datepicker-years">'+'<table class="table-condensed">'+o.headTemplate+o.contTemplate+o.footTemplate+"</table>"+"</div>"+"</div>";for(var u=2,a=arguments.length;u<a;u++)arguments[u].localize()}),timely.define("external_libs/bootstrap_tooltip",["jquery_timely"],function(e){if(!e.fn.tooltip){var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,this.options.trigger!="manual"&&(i=this.options.trigger=="hover"?"mouseenter":"focus",s=this.options.trigger=="hover"?"mouseleave":"blur",this.$element.on(i,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s,this.options.selector,e.proxy(this.leave,this))),this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,t,this.$element.data()),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);if(!n.options.delay||!n.options.delay.show)return n.show();clearTimeout(this.timeout),n.hoverState="in",this.timeout=setTimeout(function(){n.hoverState=="in"&&n.show()},n.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var e,t,n,r,i,s,o;if(this.hasContent()&&this.enabled){e=this.tip(),this.setContent(),this.options.animation&&e.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,t=/in/.test(s),e.remove().css({top:0,left:0,display:"block"}).appendTo(t?this.$element:document.body),n=this.getPosition(t),r=e[0].offsetWidth,i=e[0].offsetHeight;switch(t?s.split(" ")[1]:s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}e.css(o).addClass(s).addClass("in")}},isHTML:function(e){return typeof e!="string"||e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3||/^(?:[^<]*<[\w\W]+>[^>]*$)/.exec(e)},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.isHTML(t)?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function r(){var t=setTimeout(function(){n.off(e.support.transition.end).remove()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.remove()})}var t=this,n=this.tip();n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?r():n.remove()},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").removeAttr("title")},hasContent:function(){return this.getTitle()},getPosition:function(t){return e.extend({},t?{top:0,left:0}:this.$element.offset(),{width:this.$element[0].offsetWidth,height:this.$element[0].offsetHeight})},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(){this[this.tip().hasClass("in")?"hide":"show"]()}},e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover",title:"",delay:0}}}),timely.define("external_libs/jquery_cookie",["jquery_timely"],function(e){function n(e){return e}function r(e){return decodeURIComponent(e.replace(t," "))}function i(e){e.indexOf('"')===0&&(e=e.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,"\\"));try{return s.json?JSON.parse(e):e}catch(t){}}var t=/\+/g,s=e.cookie=function(t,o,u){if(o!==undefined){u=e.extend({},s.defaults,u);if(typeof u.expires=="number"){var a=u.expires,f=u.expires=new Date;f.setDate(f.getDate()+a)}return o=s.json?JSON.stringify(o):String(o),document.cookie=[s.raw?t:encodeURIComponent(t),"=",s.raw?o:encodeURIComponent(o),u.expires?"; expires="+u.expires.toUTCString():"",u.path?"; path="+u.path:"",u.domain?"; domain="+u.domain:"",u.secure?"; secure":""].join("")}var l=s.raw?n:r,c=document.cookie.split("; "),h=t?undefined:{};for(var p=0,d=c.length;p<d;p++){var v=c[p].split("="),m=l(v.shift()),g=l(v.join("="));if(t&&t===m){h=i(g);break}t||(h[m]=i(g))}return h};s.defaults={},e.removeCookie=function(t,n){return e.cookie(t)!==undefined?(e.cookie(t,"",e.extend({},n,{expires:-1})),!0):!1}}),timely.define("scripts/admin_settings",["jquery_timely","domReady","ai1ec_config","libs/utils","libs/collapse_helper","external_libs/bootstrap_tab","external_libs/bootstrap_dropdown","external_libs/bootstrap_datepicker","external_libs/bootstrap_tooltip","external_libs/jquery_cookie"],function(e,t,n,r){var i=function(){var t=!0;e("#ai1ec-plugins-settings input:text").each(function(){this.value!==""&&(t=!1)}),t===!0&&e("#ai1ec-plugins-settings").remove()},s=function(e,t){var n=!1;e.val()!==""&&(n=e.data("datepicker").date);var r=e.data("datepicker");r!==undefined&&(r.hide(),r.picker.remove(),e.removeData("datepicker")),e.data(t).datepicker(),r=e.data("datepicker"),n!==!1&&(r.date=n,r.setValue())},o=function(t){var n=e(this).attr("href");e.cookie("ai1ec_general_settings_active_tab",n)},u=function(){var t=e("#show_create_event_button")[0].checked,n=e("#show_front_end_create_form"),r=n[0].checked,i=e("#allow_anonymous_submissions"),s=i[0].checked;n.attr("disabled",!t),i.attr("disabled",!t||!r),e("#allow_anonymous_uploads").attr("disabled",!(t&&r&&s))},a=function(){var t=e("#week_view_starts_at"),r=e("#week_view_ends_at"),i=parseInt(t.val(),10),s=parseInt(r.val(),10);if(s<i)return window.alert(n.end_must_be_after_start),r.focus(),!1;var o=s-i;if(o<6)return window.alert(n.show_at_least_six_hours),r.focus(),!1},f=function(){},l=function(){e(".ai1ec-gzip-causes-js-failure").remove()},c=function(){e("#ai1ec_save_settings").on("click",function(t){var r=e("#require_disclaimer").is(":checked"),i=e("#disclaimer").val();!0===r&&""===i&&(alert(n.require_desclaimer),e('#ai1ec-general-settings ul.nav-tabs a[href="#ai1ec-advanced"]').tab("show"),e("#disclaimer").focus(),t.preventDefault())})},h=function(){t(function(){f(),c(),l(),r.activate_saved_tab_on_page_load(e.cookie("ai1ec_general_settings_active_tab")),e(document).on("click",'#ai1ec-general-settings .nav-tabs a[data-toggle="tab"]',o),e(document).on("click","#disable_standard_filter_menu_toggler",function(e){e.preventDefault()});var t=e("#exact_date");t.datepicker(),e(document).on("change","#input_date_format",function(){var n=e("option:selected",this).data("pattern");s(t,{dateFormat:n})}),e(document).on("change","#week_start_day",function(){var n=e(this).val();s(t,{dateWeekstart:n})}),i(),e(document).on("click",".ai1ec-admin-view-settings .ai1ec-toggle-view",function(){var t=e(this),n=t.closest("tr"),r=e(".ai1ec-admin-view-settings .ai1ec-toggle-view:checked").length===0,i=n.find(".ai1ec-toggle-default-view:checked").length===1;if(r===!0||i===!0)return!1}),e(document).on("click",".ai1ec-admin-view-settings .ai1ec-toggle-default-view",function(){e(this).closest("tr").find(".ai1ec-toggle-view:first").prop("checked",!0)}),e(document).on("click ready","#show_create_event_button, #show_front_end_create_form, #allow_anonymous_submissions",u),e("#ai1ec_save_settings").on("click",a),e("#show_create_event_button").trigger("ready")})};return{start:h,reset_datepicker:s}}),timely.require(["scripts/admin_settings"],function(e){e.start()}),timely.define("pages/admin_settings",function(){});
\ No newline at end of file
diff --git a/public/js/pages/calendar.js b/public/js/pages/calendar.js
new file mode 100644
index 0000000..82efcd7
--- /dev/null
+++ b/public/js/pages/calendar.js
@@ -0,0 +1,324 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+
+/**
+ * jQuery Masonry v2.1.05
+ * A dynamic layout plugin for jQuery
+ * The flip-side of CSS Floats
+ * http://masonry.desandro.com
+ *
+ * Licensed under the MIT license.
+ * Copyright 2012 David DeSandro
+ */
+
+/*
+   * smartresize: debounced resize event for jQuery
+   *
+   * latest version and complete README available on Github:
+   * https://github.com/louisremi/jquery.smartresize.js
+   *
+   * Copyright 2011 @louis_remi
+   * Licensed under the MIT license.
+   */
+
+/*!
+   * jQuery imagesLoaded plugin v1.1.0
+   * http://github.com/desandro/imagesloaded
+   *
+   * MIT License. by Paul Irish et al.
+   */
+
+/* ===========================================================
+   * bootstrap-tooltip.js v2.0.4
+   * http://twitter.github.com/bootstrap/javascript.html#tooltips
+   * Inspired by the original jQuery.tipsy by Jason Frame
+   * ===========================================================
+   * Copyright 2012 Twitter, Inc.
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   * http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   * ========================================================== */
+
+/* ===========================================================
+	 * bootstrap-popover.js v2.0.4
+	 * http://twitter.github.com/bootstrap/javascript.html#popovers
+	 * ===========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * =========================================================== */
+
+/* ============================================================
+			 * bootstrap-dropdown.js v2.0.3
+			 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
+			 * ============================================================
+			 * Copyright 2012 Twitter, Inc.
+			 *
+			 * Licensed under the Apache License, Version 2.0 (the "License");
+			 * you may not use this file except in compliance with the License.
+			 * You may obtain a copy of the License at
+			 *
+			 * http://www.apache.org/licenses/LICENSE-2.0
+			 *
+			 * Unless required by applicable law or agreed to in writing, software
+			 * distributed under the License is distributed on an "AS IS" BASIS,
+			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+			 * See the License for the specific language governing permissions and
+			 * limitations under the License.
+			 * ============================================================ */
+
+/*
+Copyright 2012 Igor Vaynberg
+
+Version: 3.3.1 Timestamp: Wed Feb 20 09:57:22 PST 2013
+
+This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
+General Public License version 2 (the "GPL License"). You may choose either license to govern your
+use of this software only upon the condition that you accept all of the terms of either the Apache
+License or the GPL License.
+
+You may obtain a copy of the Apache License and the GPL License at:
+
+    http://www.apache.org/licenses/LICENSE-2.0
+    http://www.gnu.org/licenses/gpl-2.0.html
+
+Unless required by applicable law or agreed to in writing, software distributed under the
+Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
+the specific language governing permissions and limitations under the Apache License and the GPL License.
+*/
+
+/**
+				 * History.js jQuery Adapter
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
+				 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
+				 */
+
+/**
+				 * History.js HTML4 Support
+				 * Depends on the HTML5 Support
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
+				 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
+				 */
+
+/**
+		 * History.js Core
+		 * @author Benjamin Arthur Lupton <contact@balupton.com>
+		 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
+		 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
+		 */
+
+/**
+				 * History.getInternetExplorerMajorVersion()
+				 * Get's the major version of Internet Explorer
+				 * @return {integer}
+				 * @license Public Domain
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 * @author James Padolsey <https://gist.github.com/527683>
+				 */
+
+/**
+				 * History.isInternetExplorer()
+				 * Are we using Internet Explorer?
+				 * @return {boolean}
+				 * @license Public Domain
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 */
+
+/*
+
+Copyright (c) 2009 Dimas Begunoff, http://www.farinspace.com
+
+Licensed under the MIT license
+http://en.wikipedia.org/wiki/MIT_License
+
+Permission is hereby granted, free of charge, to any person
+obtaining a copy of this software and associated documentation
+files (the "Software"), to deal in the Software without
+restriction, including without limitation the rights to use,
+copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+*/
+
+/*!
+ * jQuery.ScrollTo
+ * Copyright (c) 2007-2012 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
+ * Dual licensed under MIT and GPL.
+ * Date: 12/14/2012
+ *
+ * @projectDescription Easy element scrolling using jQuery.
+ * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
+ * @author Ariel Flesler
+ * @version 1.4.5 BETA
+ *
+ * @id jQuery.scrollTo
+ * @id jQuery.fn.scrollTo
+ * @param {String, Number, DOMElement, jQuery, Object} target Where to scroll the matched elements.
+ *	  The different options for target are:
+ *		- A number position (will be applied to all axes).
+ *		- A string position ('44', '100px', '+=90', etc ) will be applied to all axes
+ *		- A jQuery/DOM element ( logically, child of the element to scroll )
+ *		- A string selector, that will be relative to the element to scroll ( 'li:eq(2)', etc )
+ *		- A hash { top:x, left:y }, x and y can be any kind of number/string like above.
+ *		- A percentage of the container's dimension/s, for example: 50% to go to the middle.
+ *		- The string 'max' for go-to-end.
+ * @param {Number, Function} duration The OVERALL length of the animation, this argument can be the settings object instead.
+ * @param {Object,Function} settings Optional set of settings or the onAfter callback.
+ *	 @option {String} axis Which axis must be scrolled, use 'x', 'y', 'xy' or 'yx'.
+ *	 @option {Number, Function} duration The OVERALL length of the animation.
+ *	 @option {String} easing The easing method for the animation.
+ *	 @option {Boolean} margin If true, the margin of the target element will be deducted from the final position.
+ *	 @option {Object, Number} offset Add/deduct from the end position. One number for both axes or { top:x, left:y }.
+ *	 @option {Object, Number} over Add/deduct the height/width multiplied by 'over', can be { top:x, left:y } when using both axes.
+ *	 @option {Boolean} queue If true, and both axis are given, the 2nd axis will only be animated after the first one ends.
+ *	 @option {Function} onAfter Function to be called after the scrolling ends.
+ *	 @option {Function} onAfterFirst If queuing is activated, this function will be called after the first scrolling ends.
+ * @return {jQuery} Returns the same jQuery object, for chaining.
+ *
+ * @desc Scroll to a fixed position
+ * @example $('div').scrollTo( 340 );
+ *
+ * @desc Scroll relatively to the actual position
+ * @example $('div').scrollTo( '+=340px', { axis:'y' } );
+ *
+ * @desc Scroll using a selector (relative to the scrolled element)
+ * @example $('div').scrollTo( 'p.paragraph:eq(2)', 500, { easing:'swing', queue:true, axis:'xy' } );
+ *
+ * @desc Scroll to a DOM element (same for jQuery object)
+ * @example var second_child = document.getElementById('container').firstChild.nextSibling;
+ *			$('#container').scrollTo( second_child, { duration:500, axis:'x', onAfter:function(){
+ *				alert('scrolled!!');
+ *			}});
+ *
+ * @desc Scroll on both axes, to different values
+ * @example $('div').scrollTo( { top: 300, left:'+=200' }, { axis:'xy', offset:-20 } );
+ */
+
+/* =========================================================
+ * bootstrap-datepicker.js
+ * http://www.eyecon.ro/bootstrap-datepicker
+ * =========================================================
+ * Copyright 2012 Stefan Petre
+ * Improvements by Andrew Rowls
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ========================================================= */
+
+/* =============================================================
+ * bootstrap-collapse.js v2.0.4
+ * http://twitter.github.com/bootstrap/javascript.html#collapse
+ * =============================================================
+ * Copyright 2012 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ============================================================ */
+
+/*
+ * The MIT License
+ *
+ * Copyright (c) 2012 James Allardice
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/*
+	 * debouncedresize: special jQuery event that happens once after a window resize
+	 *
+	 * latest version and complete README available on Github:
+	 * https://github.com/louisremi/jquery-smartresize
+	 *
+	 * Copyright 2012 @louis_remi
+	 * Licensed under the MIT license.
+	 *
+	 * This saved you an hour of work?
+	 * Send me music http://www.amazon.co.uk/wishlist/HNTU0468LQON
+	 */
+
+/* =========================================================
+	 * bootstrap-modal.js v2.2.2
+	 * http://twitter.github.com/bootstrap/javascript.html#modals
+	 * =========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * ========================================================= */
+
+timely.define("domReady",[],function(){function u(e){var t;for(t=0;t<e.length;t++)e[t](n)}function a(){var e=r;t&&e.length&&(r=[],u(e))}function f(){t||(t=!0,o&&clearInterval(o),a())}function c(e){return t?e(n):r.push(e),c}var e=typeof window!="undefined"&&window.document,t=!e,n=e?document:null,r=[],i,s,o;if(e){if(document.addEventListener)document.addEventListener("DOMContentLoaded",f,!1),window.addEventListener("load",f,!1);else if(window.attachEvent){window.attachEvent("onload",f),s=document.createElement("div");try{i=window.frameElement===null}catch(l){}s.doScroll&&i&&window.external&&(o=setInterval(function(){try{s.doScroll(),f()}catch(e){}},30))}(document.readyState==="complete"||document.readyState==="interactive")&&f()}return c.version="2.0.0",c.load=function(e,t,n,r){r.isBuild?n(null):c(n)},c}),timely.define("scripts/calendar/print",["jquery_timely"],function(e){var t=function(t){t.preventDefault();var n=e("body"),r=e("html"),i=e("#ai1ec-container").html(),s=n.html();s=s.replace(/<script.*?>([\s\S]*?)<\/script>/gmi,""),n.empty(),n.addClass("timely"),r.addClass("ai1ec-print"),n.html(i),e("span").click(function(){return!1}),window.print(),n.removeClass("timely"),r.removeClass("ai1ec-print"),n.html(s)};return{handle_click_on_print_button:t}}),timely.define("external_libs/jquery.masonry",["jquery_timely"],function(e){(function(e,t,n){var r=t.event,i;r.special.smartresize={setup:function(){t(this).bind("resize",r.special.smartresize.handler)},teardown:function(){t(this).unbind("resize",r.special.smartresize.handler)},handler:function(e,n){var r=this,s=arguments;e.type="smartresize",i&&clearTimeout(i),i=setTimeout(function(){t.event.handle.apply(r,s)},n==="execAsap"?0:100)}},t.fn.smartresize=function(e){return e?this.bind("smartresize",e):this.trigger("smartresize",["execAsap"])},t.Mason=function(e,n){this.element=t(n),this._create(e),this._init()},t.Mason.settings={isResizable:!0,isAnimated:!1,animationOptions:{queue:!1,duration:500},gutterWidth:0,isRTL:!1,isFitWidth:!1,containerStyle:{position:"relative"}},t.Mason.prototype={_filterFindBricks:function(e){var t=this.options.itemSelector;return t?e.filter(t).add(e.find(t)):e},_getBricks:function(e){var t=this._filterFindBricks(e).css({position:"absolute"}).addClass("masonry-brick");return t},_create:function(n){this.options=t.extend(!0,{},t.Mason.settings,n),this.styleQueue=[];var r=this.element[0].style;this.originalStyle={height:r.height||""};var i=this.options.containerStyle;for(var s in i)this.originalStyle[s]=r[s]||"";this.element.css(i),this.horizontalDirection=this.options.isRTL?"right":"left",this.offset={x:parseInt(this.element.css("padding-"+this.horizontalDirection),10),y:parseInt(this.element.css("padding-top"),10)},this.isFluid=this.options.columnWidth&&typeof this.options.columnWidth=="function";var o=this;setTimeout(function(){o.element.addClass("masonry")},0),this.options.isResizable&&t(e).bind("smartresize.masonry",function(){o.resize()}),this.reloadItems()},_init:function(e){this._getColumns(),this._reLayout(e)},option:function(e,n){t.isPlainObject(e)&&(this.options=t.extend(!0,this.options,e))},layout:function(e,t){for(var n=0,r=e.length;n<r;n++)this._placeBrick(e[n]);var i={};i.height=Math.max.apply(Math,this.colYs);if(this.options.isFitWidth){var s=0;n=this.cols;while(--n){if(this.colYs[n]!==0)break;s++}i.width=(this.cols-s)*this.columnWidth-this.options.gutterWidth}this.styleQueue.push({$el:this.element,style:i});var o=this.isLaidOut?this.options.isAnimated?"animate":"css":"css",u=this.options.animationOptions,a;for(n=0,r=this.styleQueue.length;n<r;n++)a=this.styleQueue[n],a.$el[o](a.style,u);this.styleQueue=[],t&&t.call(e),this.isLaidOut=!0},_getColumns:function(){var e=this.options.isFitWidth?this.element.parent():this.element,t=e.width();this.columnWidth=this.isFluid?this.options.columnWidth(t):this.options.columnWidth||this.$bricks.outerWidth(!0)||t,this.columnWidth+=this.options.gutterWidth,this.cols=Math.floor((t+this.options.gutterWidth)/this.columnWidth),this.cols=Math.max(this.cols,1)},_placeBrick:function(e){var n=t(e),r,i,s,o,u;r=Math.ceil(n.outerWidth(!0)/this.columnWidth),r=Math.min(r,this.cols);if(r===1)s=this.colYs;else{i=this.cols+1-r,s=[];for(u=0;u<i;u++)o=this.colYs.slice(u,u+r),s[u]=Math.max.apply(Math,o)}var a=Math.min.apply(Math,s),f=0;for(var l=0,c=s.length;l<c;l++)if(s[l]===a){f=l;break}var h={top:a+this.offset.y};h[this.horizontalDirection]=this.columnWidth*f+this.offset.x,this.styleQueue.push({$el:n,style:h});var p=a+n.outerHeight(!0),d=this.cols+1-c;for(l=0;l<d;l++)this.colYs[f+l]=p},resize:function(){var e=this.cols;this._getColumns(),(this.isFluid||this.cols!==e)&&this._reLayout()},_reLayout:function(e){var t=this.cols;this.colYs=[];while(t--)this.colYs.push(0);this.layout(this.$bricks,e)},reloadItems:function(){this.$bricks=this._getBricks(this.element.children())},reload:function(e){this.reloadItems(),this._init(e)},appended:function(e,t,n){if(t){this._filterFindBricks(e).css({top:this.element.height()});var r=this;setTimeout(function(){r._appended(e,n)},1)}else this._appended(e,n)},_appended:function(e,t){var n=this._getBricks(e);this.$bricks=this.$bricks.add(n),this.layout(n,t)},remove:function(e){this.$bricks=this.$bricks.not(e),e.remove()},destroy:function(){this.$bricks.removeClass("masonry-brick").each(function(){this.style.position="",this.style.top="",this.style.left=""});var n=this.element[0].style;for(var r in this.originalStyle)n[r]=this.originalStyle[r];this.element.unbind(".masonry").removeClass("masonry").removeData("masonry"),t(e).unbind(".masonry")}},t.fn.imagesLoaded=function(e){function u(){e.call(n,r)}function a(e){var n=e.target;n.src!==s&&t.inArray(n,o)===-1&&(o.push(n),--i<=0&&(setTimeout(u),r.unbind(".imagesLoaded",a)))}var n=this,r=n.find("img").add(n.filter("img")),i=r.length,s="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",o=[];return i||u(),r.bind("load.imagesLoaded error.imagesLoaded",a).each(function(){var e=this.src;this.src=s,this.src=e}),n};var s=function(t){e.console&&e.console.error(t)};t.fn.masonry=function(e){if(typeof e=="string"){var n=Array.prototype.slice.call(arguments,1);this.each(function(){var r=t.data(this,"masonry");if(!r){s("cannot call methods on masonry prior to initialization; attempted to call method '"+e+"'");return}if(!t.isFunction(r[e])||e.charAt(0)==="_"){s("no such method '"+e+"' for masonry instance");return}r[e].apply(r,n)})}else this.each(function(){var n=t.data(this,"masonry");n?(n.option(e||{}),n._init()):t.data(this,"masonry",new t.Mason(e,this))});return this}})(window,e)}),timely.define("scripts/calendar/posterboard_view",["jquery_timely","external_libs/jquery.masonry"],function(e,t){var n=function(){var t=e(".ai1ec-posterboard-view"),n=e("> .ai1ec-event",t),r,i,s;if(t.length===0)return;r=t.parent().width(),i=t.data("ai1ecTileMinWidth"),s=Math.floor(r/i),s=Math.min(s,n.length),i=Math.floor(r/s),t.css("width","auto"),n.width(i),t.imagesLoaded(function(){var n=e("#ai1ec-calendar-view-loading");t.masonry({itemSelector:".ai1ec-event",isFitWidth:!0,isResizable:!1,isAnimated:!0,columnWidth:i,animationOptions:{easing:"swing"}})}),t.imagesLoaded(function(){t.masonry("reload")})},r=function(){e(".ai1ec-posterboard-view").masonry("reload")};return{resize_masonry:n,reload_masonry:r}}),timely.define("scripts/calendar/agenda_view",["jquery_timely"],function(e){var t=function(){e(this).closest(".ai1ec-event").toggleClass("ai1ec-expanded").find(".ai1ec-event-summary").slideToggle(300)},n=function(){e(".ai1ec-expanded .ai1ec-event-toggle").click()},r=function(){e(".ai1ec-event:not(.ai1ec-expanded) .ai1ec-event-toggle").click()};return{toggle_event:t,collapse_all:n,expand_all:r}}),timely.define("external_libs/modernizr",[],function(){var e=function(e,t,n){function S(e){f.cssText=e}function x(e,t){return S(h.join(e+";")+(t||""))}function T(e,t){return typeof e===t}function N(e,t){return!!~(""+e).indexOf(t)}function C(e,t,r){for(var i in e){var s=t[e[i]];if(s!==n)return r===!1?e[i]:T(s,"function")?s.bind(r||t):s}return!1}var r="2.5.3",i={},s=!0,o=t.documentElement,u="modernizr",a=t.createElement(u),f=a.style,l,c={}.toString,h=" -webkit- -moz- -o- -ms- ".split(" "),p={},d={},v={},m=[],g=m.slice,y,b=function(e,n,r,i){var s,a,f,l=t.createElement("div"),c=t.body,h=c?c:t.createElement("body");if(parseInt(r,10))while(r--)f=t.createElement("div"),f.id=i?i[r]:u+(r+1),l.appendChild(f);return s=["&#173;","<style>",e,"</style>"].join(""),l.id=u,(c?l:h).innerHTML+=s,h.appendChild(l),c||(h.style.background="",o.appendChild(h)),a=n(l,e),c?l.parentNode.removeChild(l):h.parentNode.removeChild(h),!!a},w={}.hasOwnProperty,E;!T(w,"undefined")&&!T(w.call,"undefined")?E=function(e,t){return w.call(e,t)}:E=function(e,t){return t in e&&T(e.constructor.prototype[t],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(t){var n=this;if(typeof n!="function")throw new TypeError;var r=g.call(arguments,1),i=function(){if(this instanceof i){var e=function(){};e.prototype=n.prototype;var s=new e,o=n.apply(s,r.concat(g.call(arguments)));return Object(o)===o?o:s}return n.apply(t,r.concat(g.call(arguments)))};return i});var k=function(n,r){var s=n.join(""),o=r.length;b(s,function(n,r){var s=t.styleSheets[t.styleSheets.length-1],u=s?s.cssRules&&s.cssRules[0]?s.cssRules[0].cssText:s.cssText||"":"",a=n.childNodes,f={};while(o--)f[a[o].id]=a[o];i.touch="ontouchstart"in e||e.DocumentTouch&&t instanceof DocumentTouch||(f.touch&&f.touch.offsetTop)===9},o,r)}([,["@media (",h.join("touch-enabled),("),u,")","{#touch{top:9px;position:absolute}}"].join("")],[,"touch"]);p.touch=function(){return i.touch};for(var L in p)E(p,L)&&(y=L.toLowerCase(),i[y]=p[L](),m.push((i[y]?"":"no-")+y));return S(""),a=l=null,i._version=r,i._prefixes=h,i.testStyles=b,o.className=o.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(s?" js "+m.join(" "):""),i}(window,window.document);return e}),timely.define("scripts/calendar/month_view",["jquery_timely","external_libs/modernizr"],function(e,t){var n=navigator.userAgent.match(/opera/i),r=navigator.userAgent.match(/webkit/i),i=function(){var t=e(".ai1ec-day"),n=e(".ai1ec-week:first .ai1ec-day").length;e(".ai1ec-month-view .ai1ec-multiday").each(function(){var n=this.parentNode,r=e(this).outerHeight(!0),i=parseInt(e(this).data("endDay"),10),u=e(".ai1ec-date",n),a=parseInt(u.text(),10),f=e(this).data("endTruncated");f&&(i=parseInt(e(t[t.length-1]).text(),10));var l=e(this),c=e(".ai1ec-event",l)[0].style.backgroundColor,h=0,p=i-a+1,d=p,v,m=0;t.each(function(t){var n=e(".ai1ec-date",this),r=e(this.parentNode),u=r.index(),f=parseInt(n.text(),10);if(f>=a&&f<=i){f===a&&(v=parseInt(n.css("marginBottom"),10)+16),h===0&&m++;if(u===0&&f>a&&d!==0){var p=l.next(".ai1ec-popup").andSelf().clone(!1);n.parent().append(p);var g=p.first();g.addClass("ai1ec-multiday-bar ai1ec-multiday-clone"),g.css({position:"absolute",left:"1px",top:parseInt(n.css("marginBottom"),10)+13,backgroundColor:c});var y=d>7?7:d;g.css("width",s(y)),d>7&&g.append(o(1,c)),g.append(o(2,c))}h===0?n.css({marginBottom:v+"px"}):n.css({marginBottom:"+=16px"}),d--,d>0&&u===6&&h++}});if(f){var g=e("."+l[0].className.replace(/\s+/igm,".")).last();g.append(o(1,c))}e(this).css({position:"absolute",top:u.outerHeight(!0)-r-1+"px",left:"1px",width:s(m)}),h>0&&e(this).append(o(1,c)),e(this).data("startTruncated")&&e(this).append(o(2,c)).addClass("ai1ec-multiday-bar")})},s=function(e){var t;switch(e){case 1:t=97.5;break;case 2:t=198.7;break;case 3:t=300;break;case 4:t=401;break;case 5:r||n?t=507:t=503.4;break;case 6:r||n?t=608:t=603.5;break;case 7:r||n?t=709:t=705}return t+"%"},o=function(t,n){var r=e('<div class="ai1ec-multiday-arrow'+t+'"></div>');return t===1?r.css({borderLeftColor:n}):r.css({borderTopColor:n,borderRightColor:n,borderBottomColor:n}),r};return{extend_multiday_events:i}}),timely.define("libs/frontend_utils",[],function(){var e=function(e){var t,n;t=function(e){if(/&[^;]+;/.test(e)){var t=document.createElement("div");return t.innerHTML=e,t.firstChild?t.firstChild.nodeValue:e}return e};if(typeof e=="string")return t(e);if(typeof e=="object")for(n in e)typeof e[n]=="string"&&(e[n]=t(e[n]));return e},t=function(e,t,n){var r,i,s,o,u;if("#"===e.charAt(0)||"?"===e.charAt(0))e=e.substring(1);r={},e=e.split(t);for(i=0;i<e.length;i++)o=e[i].trim(),-1!==(u=o.indexOf(n))?(s=o.substring(0,u).trim(),o=o.substring(u+1).trim()):(s=o,o=!0),r[s]=o;return r},n=function(e){var n,r,i,s,o;e=t(e,"&","="),i=Object.keys(e),n={ai1ec:{},action:"posterboard"};for(r=0;r<i.length;r++)if("ai1ec"===i[r]){var u=t(e[i[r]],"|",":");for(s in u)if(""!==u[s]){if("action"===s||"view"===s)n.action=u[s];n.ai1ec[s]=u[s]}}else"ai1ec_"===i[r].substring(0,6)?n.ai1ec[i[r].substring(6)]=e[i[r]]:n[i[r]]=e[i[r]];"ai1ec_"!==n.action.substring(0,6)&&(n.action="ai1ec_"+n.action),o="action="+n.action+"&ai1ec=";for(s in n.ai1ec)n.ai1ec.hasOwnProperty(s)&&(o+=escape(s)+":"+escape(n.ai1ec[s])+"|");o=o.substring(0,o.length-1);for(s in n)"ai1ec"!==s&&"action"!==s&&(o+="&"+s+"="+escape(n[s]));return o};return{ai1ec_convert_entities:e,ai1ec_map_internal_query:n,ai1ec_tokenize_uri:t}}),timely.define("external_libs/bootstrap_tab",["jquery_timely"],function(e){var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active a").last()[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}},e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e(function(){e("body").on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})})}),timely.define("libs/utils",["jquery_timely","external_libs/bootstrap_tab"],function(e){var t=function(){return{is_float:function(e){return!isNaN(parseFloat(e))},is_valid_coordinate:function(e,t){var n=t?90:180;return this.is_float(e)&&Math.abs(e)<n},convert_comma_to_dot:function(e){return e.replace(",",".")},field_has_value:function(t){var n="#"+t,r=e(n),i=!1;return r.length===1&&(i=e.trim(r.val())!==""),i},make_alert:function(t,n,r){var i="";switch(n){case"error":i="alert alert-error";break;case"success":i="alert alert-success";break;default:i="alert"}var s=e("<div />",{"class":i,html:t});if(!r){var o=e("<a />",{"class":"close","data-dismiss":"alert",href:"#",text:"x"});s.prepend(o)}return s},get_ajax_url:function(){return typeof window.ajaxurl=="undefined"?"http://localhost/wordpress/wp-admin/admin-ajax.php":window.ajaxurl},isUrl:function(e){var t=/(http|https|webcal):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;return t.test(e)},isValidEmail:function(e){var t=/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;return t.test(e)},activate_saved_tab_on_page_load:function(t){null===t||undefined===t?e("ul.nav-tabs a:first").tab("show"):e("ul.nav-tabs a[href="+t+"]").tab("show")}}}();return t}),timely.define("scripts/common_scripts/frontend/common_event_handlers",["jquery_timely","scripts/calendar/posterboard_view"],function(e,t){var n=function(t){var n=e(this),r=n.next(".ai1ec-popup"),i,s,o;if(r.length===0)return;i=r.html(),s=r.attr("class");var u=n.closest("#ai1ec-calendar-view");u.length===0&&(u=e("body")),n.offset().left-u.offset().left>182?o="left":o="right",n.constrained_popover({content:i,title:"",placement:o,trigger:"manual",html:!0,template:'<div class="timely popover '+s+'"><div class="arrow"></div><div class="popover-inner">'+'<div class="popover-content"><div></div></div></div></div></div>',container:n.closest(".ai1ec-popover-boundary")}).constrained_popover("show")},r=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".ai1ec-popup").length===0&&e(this).constrained_popover("hide")},i=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".tooltip").length===0&&(e(this).remove(),e("body > .tooltip").remove())},s=function(t){var n=e(this),r={template:'<div class="timely tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"manual"};if(n.is(".ai1ec-category .ai1ec-color-swatch"))return;n.tooltip(r),n.tooltip("show")},o=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".tooltip").length===0&&e(this).tooltip("hide")},u=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".ai1ec-tooltip-trigger").length===0&&e(this).remove(),n.closest(".ai1ec-popup").length===0&&e("body > .ai1ec-popup").remove()},a=function(n){t.resize_masonry(),e("html").is("#ie8")};return{handle_popover_over:n,handle_popover_out:r,handle_popover_self_out:i,handle_tooltip_over:s,handle_tooltip_out:o,handle_tooltip_self_out:u,handle_fonts_loaded:a}}),timely.define("external_libs/bootstrap_tooltip",["jquery_timely"],function(e){if(!e.fn.tooltip){var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,this.options.trigger!="manual"&&(i=this.options.trigger=="hover"?"mouseenter":"focus",s=this.options.trigger=="hover"?"mouseleave":"blur",this.$element.on(i,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s,this.options.selector,e.proxy(this.leave,this))),this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,t,this.$element.data()),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);if(!n.options.delay||!n.options.delay.show)return n.show();clearTimeout(this.timeout),n.hoverState="in",this.timeout=setTimeout(function(){n.hoverState=="in"&&n.show()},n.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var e,t,n,r,i,s,o;if(this.hasContent()&&this.enabled){e=this.tip(),this.setContent(),this.options.animation&&e.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,t=/in/.test(s),e.remove().css({top:0,left:0,display:"block"}).appendTo(t?this.$element:document.body),n=this.getPosition(t),r=e[0].offsetWidth,i=e[0].offsetHeight;switch(t?s.split(" ")[1]:s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}e.css(o).addClass(s).addClass("in")}},isHTML:function(e){return typeof e!="string"||e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3||/^(?:[^<]*<[\w\W]+>[^>]*$)/.exec(e)},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.isHTML(t)?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function r(){var t=setTimeout(function(){n.off(e.support.transition.end).remove()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.remove()})}var t=this,n=this.tip();n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?r():n.remove()},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").removeAttr("title")},hasContent:function(){return this.getTitle()},getPosition:function(t){return e.extend({},t?{top:0,left:0}:this.$element.offset(),{width:this.$element[0].offsetWidth,height:this.$element[0].offsetHeight})},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(){this[this.tip().hasClass("in")?"hide":"show"]()}},e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover",title:"",delay:0}}}),timely.define("external_libs/bootstrap_popover",["jquery_timely","external_libs/bootstrap_tooltip"],function(e,t){if(!e.fn.popover){var n=function(e,t){this.init("popover",e,t)};n.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:n,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.isHTML(t)?"html":"text"](t),e.find(".popover-content > *")[this.isHTML(n)?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-content")||(typeof n.content=="function"?n.content.call(t[0]):n.content),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip}}),e.fn.popover=function(t){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof t=="object"&&t;i||r.data("popover",i=new n(this,s)),typeof t=="string"&&i[t]()})},e.fn.popover.Constructor=n,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",content:"",template:'<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'})}if(!e.fn.constrained_popover){var r=function(e,t){this.init("constrained_popover",e,t)};r.prototype=e.extend({},e.fn.popover.Constructor.prototype,{constructor:r,show:function(){var e,t,n,r,i,s,o,u,a={};if(this.hasContent()&&this.enabled){e=this.tip(),this.setContent(),this.options.animation&&e.addClass("fade"),o=typeof this.options.placement=="function"?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,t=/in/.test(o),e.remove().css({top:0,left:0,display:"block"}).appendTo(t?this.$element:document.body),n=this.getPosition(t),i=e[0].offsetWidth,s=e[0].offsetHeight;switch(t?o.split(" ")[1]:o){case"left":r=this.defineBounds(n),typeof r.top=="undefined"?a.top=n.top+n.height/2-s/2:a.top=r.top-s/2,typeof r.left=="undefined"?a.left=n.left-i:a.left=r.left-i,u={top:a.top,left:a.left};break;case"right":r=this.defineBounds(n),typeof r.top=="undefined"?a.top=n.top+n.height/2-s/2:a.top=r.top-s/2,typeof r.left=="undefined"?a.left=n.left+n.width:a.left=r.left+n.width,u={top:a.top,left:a.left}}e.css(u).addClass(o).addClass("in")}},defineBounds:function(t){var n,r,i,s,o,u,a={},f=e(this.options.container);return f.length?(r=f.offset(),i=r.top,s=r.left,o=i+f.height(),u=s+f.width(),t.top+t.height/2<i&&(a.top=i),t.top+t.height/2>o&&(a.top=o),t.left-t.width/2<s&&(a.left=s),t.left-t.width/2>u&&(a.left=u),a):!1}}),e.fn.constrained_popover=function(t){return this.each(function(){var n=e(this),i=n.data("constrained_popover"),s=typeof t=="object"&&t;i||n.data("constrained_popover",i=new r(this,s)),typeof t=="string"&&i[t]()})},e.fn.constrained_popover.Constructor=r,e.fn.constrained_popover.defaults=e.extend({},e.fn.popover.defaults,{container:"",content:this.options})}}),timely.define("external_libs/bootstrap_dropdown",["jquery_timely","domReady"],function(e,t){if(!e.fn.dropdown){var n='[data-toggle="dropdown"]',r=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};r.prototype={constructor:r,toggle:function(t){var n=e(this),r,s,o;if(n.is(".disabled, :disabled"))return;return s=n.attr("data-target"),s||(s=n.attr("href"),s=s&&s.replace(/.*(?=#[^\s]*$)/,"")),r=e(s),r.length||(r=n.parent()),o=r.hasClass("open"),i(),o||r.toggleClass("open"),!1}};function i(){e(n).parent().removeClass("open")}e.fn.dropdown=function(t){return this.each(function(){var n=e(this),i=n.data("dropdown");i||n.data("dropdown",i=new r(this)),typeof t=="string"&&i[t].call(n)})},e.fn.dropdown.Constructor=r,t(function(){e(document).on("click.dropdown.data-api",i),e(document).on("click.dropdown",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown.data-api",n,r.prototype.toggle)})}}),timely.define("scripts/common_scripts/frontend/common_frontend",["jquery_timely","domReady","scripts/common_scripts/frontend/common_event_handlers","ai1ec_calendar","external_libs/modernizr","external_libs/bootstrap_tooltip","external_libs/bootstrap_popover","external_libs/bootstrap_dropdown"],function(e,t,n,r,i){var s=!1,o=function(){s=!0,e(document).on("mouseenter",".ai1ec-popup-trigger",n.handle_popover_over),e(document).on("mouseleave",".ai1ec-popup-trigger",n.handle_popover_out),e(document).on("mouseleave",".ai1ec-popup",n.handle_popover_self_out),e(document).on("mouseenter",".ai1ec-tooltip-trigger",n.handle_tooltip_over),e(document).on("mouseleave",".ai1ec-tooltip-trigger",n.handle_tooltip_out),e(document).on("mouseleave",".tooltip",n.handle_tooltip_self_out)},u=function(){var t=[],i=[];e.each(r.fonts,function(){t.push(this.name),i.push(this.url)});var s={active:n.handle_fonts_loaded,custom:{families:t,urls:i}};timely.require(["external_libs/webfont"],function(){WebFont.load(s)})},a=function(){u(),t(function(){o()})},f=function(){return s};return{start:a,are_event_listeners_attached:f}}),timely.define("external_libs/select2",["jquery_timely"],function(e){(function(e){typeof e.fn.each2=="undefined"&&e.fn.extend({each2:function(t){var n=e([0]),r=-1,i=this.length;while(++r<i&&(n.context=n[0]=this[r])&&t.call(n[0],r,n)!==!1);return this}})})(e),function(e,t){function l(e,t){var n=0,r=t.length;for(;n<r;n+=1)if(c(e,t[n]))return n;return-1}function c(e,n){return e===n?!0:e===t||n===t?!1:e===null||n===null?!1:e.constructor===String?e===n+"":n.constructor===String?n===e+"":!1}function h(t,n){var r,i,s;if(t===null||t.length<1)return[];r=t.split(n);for(i=0,s=r.length;i<s;i+=1)r[i]=e.trim(r[i]);return r}function p(e){return e.outerWidth(!1)-e.width()}function d(n){var r="keyup-change-value";n.bind("keydown",function(){e.data(n,r)===t&&e.data(n,r,n.val())}),n.bind("keyup",function(){var i=e.data(n,r);i!==t&&n.val()!==i&&(e.removeData(n,r),n.trigger("keyup-change"))})}function v(n){n.bind("mousemove",function(n){var r=a;(r===t||r.x!==n.pageX||r.y!==n.pageY)&&e(n.target).trigger("mousemove-filtered",n)})}function m(e,n,r){r=r||t;var i;return function(){var t=arguments;window.clearTimeout(i),i=window.setTimeout(function(){n.apply(r,t)},e)}}function g(e){var t=!1,n;return function(){return t===!1&&(n=e(),t=!0),n}}function y(e,t){var n=m(e,function(e){t.trigger("scroll-debounced",e)});t.bind("scroll",function(e){l(e.target,t.get())>=0&&n(e)})}function b(e){if(e[0]===document.activeElement)return;window.setTimeout(function(){var t=e[0],n=e.val().length,r;e.focus(),t.setSelectionRange?t.setSelectionRange(n,n):t.createTextRange&&(r=t.createTextRange(),r.collapse(!0),r.moveEnd("character",n),r.moveStart("character",n),r.select())},0)}function w(e){e.preventDefault(),e.stopPropagation()}function E(e){e.preventDefault(),e.stopImmediatePropagation()}function S(t){if(!u){var n=t[0].currentStyle||window.getComputedStyle(t[0],null);u=e(document.createElement("div")).css({position:"absolute",left:"-10000px",top:"-10000px",display:"none",fontSize:n.fontSize,fontFamily:n.fontFamily,fontStyle:n.fontStyle,fontWeight:n.fontWeight,letterSpacing:n.letterSpacing,textTransform:n.textTransform,whiteSpace:"nowrap"}),u.attr("class","select2-sizer"),e("body").append(u)}return u.text(t.val()),u.width()}function x(t,n,r){var i,s=[],o;i=t.attr("class"),typeof i=="string"&&e(i.split(" ")).each2(function(){this.indexOf("select2-")===0&&s.push(this)}),i=n.attr("class"),typeof i=="string"&&e(i.split(" ")).each2(function(){this.indexOf("select2-")!==0&&(o=r(this),typeof o=="string"&&o.length>0&&s.push(this))}),t.attr("class",s.join(" "))}function T(e,t,n,r){var i=e.toUpperCase().indexOf(t.toUpperCase()),s=t.length;if(i<0){n.push(r(e));return}n.push(r(e.substring(0,i))),n.push("<span class='select2-match'>"),n.push(r(e.substring(i,i+s))),n.push("</span>"),n.push(r(e.substring(i+s,e.length)))}function N(t){var n,r=0,i=null,s=t.quietMillis||100,o=t.url,u=this;return function(a){window.clearTimeout(n),n=window.setTimeout(function(){r+=1;var n=r,s=t.data,f=o,l=t.transport||e.ajax,c=t.type||"GET",h={};s=s?s.call(u,a.term,a.page,a.context):null,f=typeof f=="function"?f.call(u,a.term,a.page,a.context):f,null!==i&&i.abort(),t.params&&(e.isFunction(t.params)?e.extend(h,t.params.call(u)):e.extend(h,t.params)),e.extend(h,{url:f,dataType:t.dataType,data:s,type:c,cache:!1,success:function(e){if(n<r)return;var i=t.results(e,a.page);a.callback(i)}}),i=l.call(u,h)},s)}}function C(t){var n=t,r,i,s=function(e){return""+e.text};e.isArray(n)&&(i=n,n={results:i}),e.isFunction(n)===!1&&(i=n,n=function(){return i});var o=n();return o.text&&(s=o.text,e.isFunction(s)||(r=n.text,s=function(e){return e[r]})),function(t){var r=t.term,i={results:[]},o;if(r===""){t.callback(n());return}o=function(n,i){var u,a;n=n[0];if(n.children){u={};for(a in n)n.hasOwnProperty(a)&&(u[a]=n[a]);u.children=[],e(n.children).each2(function(e,t){o(t,u.children)}),(u.children.length||t.matcher(r,s(u),n))&&i.push(u)}else t.matcher(r,s(n),n)&&i.push(n)},e(n().results).each2(function(e,t){o(t,i.results)}),t.callback(i)}}function k(n){var r=e.isFunction(n);return function(i){var s=i.term,o={results:[]};e(r?n():n).each(function(){var e=this.text!==t,n=e?this.text:this;(s===""||i.matcher(s,n))&&o.results.push(e?this:{id:this,text:this})}),i.callback(o)}}function L(t,n){if(e.isFunction(t))return!0;if(!t)return!1;throw new Error("formatterName must be a function or a falsy value")}function A(t){return e.isFunction(t)?t():t}function O(t){var n=0;return e.each(t,function(e,t){t.children?n+=O(t.children):n++}),n}function M(e,n,r,i){var s=e,o=!1,u,a,f,l,h;if(!i.createSearchChoice||!i.tokenSeparators||i.tokenSeparators.length<1)return t;for(;;){a=-1;for(f=0,l=i.tokenSeparators.length;f<l;f++){h=i.tokenSeparators[f],a=e.indexOf(h);if(a>=0)break}if(a<0)break;u=e.substring(0,a),e=e.substring(a+h.length);if(u.length>0){u=i.createSearchChoice(u,n);if(u!==t&&u!==null&&i.id(u)!==t&&i.id(u)!==null){o=!1;for(f=0,l=n.length;f<l;f++)if(c(i.id(u),i.id(n[f]))){o=!0;break}o||r(u)}}}if(s!==e)return e}function _(t,n){var r=function(){};return r.prototype=new t,r.prototype.constructor=r,r.prototype.parent=t.prototype,r.prototype=e.extend(r.prototype,n),r}var n,r,i,s,o,u,a,f;n={TAB:9,ENTER:13,ESC:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40,SHIFT:16,CTRL:17,ALT:18,PAGE_UP:33,PAGE_DOWN:34,HOME:36,END:35,BACKSPACE:8,DELETE:46,isArrow:function(e){e=e.which?e.which:e;switch(e){case n.LEFT:case n.RIGHT:case n.UP:case n.DOWN:return!0}return!1},isControl:function(e){var t=e.which;switch(t){case n.SHIFT:case n.CTRL:case n.ALT:return!0}return e.metaKey?!0:!1},isFunctionKey:function(e){return e=e.which?e.which:e,e>=112&&e<=123}},f=e(document),o=function(){var e=1;return function(){return e++}}(),f.bind("mousemove",function(e){a={x:e.pageX,y:e.pageY}}),r=_(Object,{bind:function(e){var t=this;return function(){e.apply(t,arguments)}},init:function(n){var r,i,s=".select2-results",u;this.opts=n=this.prepareOpts(n),this.id=n.id,n.element.data("select2")!==t&&n.element.data("select2")!==null&&this.destroy(),this.enabled=!0,this.container=this.createContainer(),this.containerId="s2id_"+(n.element.attr("id")||"autogen"+o()),this.containerSelector="#"+this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g,"\\$1"),this.container.attr("id",this.containerId),this.body=g(function(){return n.element.closest("body")}),x(this.container,this.opts.element,this.opts.adaptContainerCssClass),this.container.css(A(n.containerCss)),this.container.addClass(A(n.containerCssClass)),this.elementTabIndex=this.opts.element.attr("tabIndex"),this.opts.element.data("select2",this).addClass("select2-offscreen").bind("focus.select2",function(){e(this).select2("focus")}).attr("tabIndex","-1").before(this.container),this.container.data("select2",this),this.dropdown=this.container.find(".select2-drop"),this.dropdown.addClass(A(n.dropdownCssClass)),this.dropdown.data("select2",this),this.results=r=this.container.find(s),this.search=i=this.container.find("input.select2-input"),i.attr("tabIndex",this.elementTabIndex),this.resultsPage=0,this.context=null,this.initContainer(),v(this.results),this.dropdown.delegate(s,"mousemove-filtered touchstart touchmove touchend",this.bind(this.highlightUnderEvent)),y(80,this.results),this.dropdown.delegate(s,"scroll-debounced",this.bind(this.loadMoreIfNeeded)),e.fn.mousewheel&&r.mousewheel(function(e,t,n,i){var s=r.scrollTop(),o;i>0&&s-i<=0?(r.scrollTop(0),w(e)):i<0&&r.get(0).scrollHeight-r.scrollTop()+i<=r.height()&&(r.scrollTop(r.get(0).scrollHeight-r.height()),w(e))}),d(i),i.bind("keyup-change input paste",this.bind(this.updateResults)),i.bind("focus",function(){i.addClass("select2-focused")}),i.bind("blur",function(){i.removeClass("select2-focused")}),this.dropdown.delegate(s,"mouseup",this.bind(function(t){e(t.target).closest(".select2-result-selectable").length>0&&(this.highlightUnderEvent(t),this.selectHighlighted(t))})),this.dropdown.bind("click mouseup mousedown",function(e){e.stopPropagation()}),e.isFunction(this.opts.initSelection)&&(this.initSelection(),this.monitorSource()),(n.element.is(":disabled")||n.element.is("[readonly='readonly']"))&&this.disable()},destroy:function(){var e=this.opts.element.data("select2");this.propertyObserver&&(delete this.propertyObserver,this.propertyObserver=null),e!==t&&(e.container.remove(),e.dropdown.remove(),e.opts.element.removeClass("select2-offscreen").removeData("select2").unbind(".select2").attr({tabIndex:this.elementTabIndex}).show())},prepareOpts:function(n){var r,i,s,o;r=n.element,r.get(0).tagName.toLowerCase()==="select"&&(this.select=i=n.element),i&&e.each(["id","multiple","ajax","query","createSearchChoice","initSelection","data","tags"],function(){if(this in n)throw new Error("Option '"+this+"' is not allowed for Select2 when attached to a <select> element.")}),n=e.extend({},{populateResults:function(r,i,s){var o,u,a,f,l=this.opts.id,c=this;o=function(r,i,u){var a,f,h,p,d,v,m,g,y,b;r=n.sortResults(r,i,s);for(a=0,f=r.length;a<f;a+=1)h=r[a],d=h.disabled===!0,p=!d&&l(h)!==t,v=h.children&&h.children.length>0,m=e("<li></li>"),m.addClass("select2-results-dept-"+u),m.addClass("select2-result"),m.addClass(p?"select2-result-selectable":"select2-result-unselectable"),d&&m.addClass("select2-disabled"),v&&m.addClass("select2-result-with-children"),m.addClass(c.opts.formatResultCssClass(h)),g=e(document.createElement("div")),g.addClass("select2-result-label"),b=n.formatResult(h,g,s,c.opts.escapeMarkup),b!==t&&g.html(b),m.append(g),v&&(y=e("<ul></ul>"),y.addClass("select2-result-sub"),o(h.children,y,u+1),m.append(y)),m.data("select2-data",h),i.append(m)},o(i,r,0)}},e.fn.select2.defaults,n),typeof n.id!="function"&&(s=n.id,n.id=function(e){return e[s]});if(e.isArray(n.element.data("select2Tags"))){if("tags"in n)throw"tags specified as both an attribute 'data-select2-tags' and in options of Select2 "+n.element.attr("id");n.tags=n.element.attr("data-select2-tags")}i?(n.query=this.bind(function(n){var i={results:[],more:!1},s=n.term,o,u,a;a=function(e,t){var r;e.is("option")?n.matcher(s,e.text(),e)&&t.push({id:e.attr("value"),text:e.text(),element:e.get(),css:e.attr("class"),disabled:c(e.attr("disabled"),"disabled")}):e.is("optgroup")&&(r={text:e.attr("label"),children:[],element:e.get(),css:e.attr("class")},e.children().each2(function(e,t){a(t,r.children)}),r.children.length>0&&t.push(r))},o=r.children(),this.getPlaceholder()!==t&&o.length>0&&(u=o[0],e(u).text()===""&&(o=o.not(u))),o.each2(function(e,t){a(t,i.results)}),n.callback(i)}),n.id=function(e){return e.id},n.formatResultCssClass=function(e){return e.css}):"query"in n||("ajax"in n?(o=n.element.data("ajax-url"),o&&o.length>0&&(n.ajax.url=o),n.query=N.call(n.element,n.ajax)):"data"in n?n.query=C(n.data):"tags"in n&&(n.query=k(n.tags),n.createSearchChoice===t&&(n.createSearchChoice=function(e){return{id:e,text:e}}),n.initSelection===t&&(n.initSelection=function(t,r){var i=[];e(h(t.val(),n.separator)).each(function(){var t=this,r=this,s=n.tags;e.isFunction(s)&&(s=s()),e(s).each(function(){if(c(this.id,t))return r=this.text,!1}),i.push({id:t,text:r})}),r(i)})));if(typeof n.query!="function")throw"query function not defined for Select2 "+n.element.attr("id");return n},monitorSource:function(){var e=this.opts.element,t;e.bind("change.select2",this.bind(function(e){this.opts.element.data("select2-change-triggered")!==!0&&this.initSelection()})),t=this.bind(function(){var e,t,n=this;e=this.opts.element.attr("disabled")!=="disabled",t=this.opts.element.attr("readonly")==="readonly",e=e&&!t,this.enabled!==e&&(e?this.enable():this.disable()),x(this.container,this.opts.element,this.opts.adaptContainerCssClass),this.container.addClass(A(this.opts.containerCssClass)),x(this.dropdown,this.opts.element,this.opts.adaptDropdownCssClass),this.dropdown.addClass(A(this.opts.dropdownCssClass))}),e.bind("propertychange.select2 DOMAttrModified.select2",t),typeof WebKitMutationObserver!="undefined"&&(this.propertyObserver&&(delete this.propertyObserver,this.propertyObserver=null),this.propertyObserver=new WebKitMutationObserver(function(e){e.forEach(t)}),this.propertyObserver.observe(e.get(0),{attributes:!0,subtree:!1}))},triggerChange:function(t){t=t||{},t=e.extend({},t,{type:"change",val:this.val()}),this.opts.element.data("select2-change-triggered",!0),this.opts.element.trigger(t),this.opts.element.data("select2-change-triggered",!1),this.opts.element.click(),this.opts.blurOnChange&&this.opts.element.blur()},enable:function(){if(this.enabled)return;this.enabled=!0,this.container.removeClass("select2-container-disabled"),this.opts.element.removeAttr("disabled")},disable:function(){if(!this.enabled)return;this.close(),this.enabled=!1,this.container.addClass("select2-container-disabled"),this.opts.element.attr("disabled","disabled")},opened:function(){return this.container.hasClass("select2-dropdown-open")},positionDropdown:function(){var t=this.container.offset(),n=this.container.outerHeight(!1),r=this.container.outerWidth(!1),i=this.dropdown.outerHeight(!1),s=e(window).scrollLeft()+e(window).width(),o=e(window).scrollTop()+e(window).height(),u=t.top+n,a=t.left,f=u+i<=o,l=t.top-i>=this.body().scrollTop(),c=this.dropdown.outerWidth(!1),h=a+c<=s,p=this.dropdown.hasClass("select2-drop-above"),d,v,m;this.body().css("position")!=="static"&&(d=this.body().offset(),u-=d.top,a-=d.left),p?(v=!0,!l&&f&&(v=!1)):(v=!1,!f&&l&&(v=!0)),h||(a=t.left+r-c),v?(u=t.top-i,this.container.addClass("select2-drop-above"),this.dropdown.addClass("select2-drop-above")):(this.container.removeClass("select2-drop-above"),this.dropdown.removeClass("select2-drop-above")),m=e.extend({top:u,left:a,width:r},A(this.opts.dropdownCss)),this.dropdown.css(m)},shouldOpen:function(){var t;return this.opened()?!1:(t=e.Event("opening"),this.opts.element.trigger(t),!t.isDefaultPrevented())},clearDropdownAlignmentPreference:function(){this.container.removeClass("select2-drop-above"),this.dropdown.removeClass("select2-drop-above")},open:function(){return this.shouldOpen()?(window.setTimeout(this.bind(this.opening),1),!0):!1},opening:function(){var t=this.containerId,n="scroll."+t,r="resize."+t,i="orientationchange."+t,s;this.clearDropdownAlignmentPreference(),this.container.addClass("select2-dropdown-open").addClass("select2-container-active"),this.dropdown[0]!==this.body().children().last()[0]&&this.dropdown.detach().appendTo(this.body()),this.updateResults(!0),s=e("#select2-drop-mask"),s.length==0&&(s=e(document.createElement("div")),s.attr("id","select2-drop-mask").attr("class","select2-drop-mask"),s.hide(),s.appendTo(this.body()),s.bind("mousedown touchstart",function(t){var n=e("#select2-drop"),r;n.length>0&&(r=n.data("select2"),r.opts.selectOnBlur&&r.selectHighlighted({noFocus:!0}),r.close())})),this.dropdown.prev()[0]!==s[0]&&this.dropdown.before(s),e("#select2-drop").removeAttr("id"),this.dropdown.attr("id","select2-drop"),s.css({width:document.documentElement.scrollWidth,height:document.documentElement.scrollHeight}),s.show(),this.dropdown.show(),this.positionDropdown(),this.dropdown.addClass("select2-drop-active"),this.ensureHighlightVisible();var o=this;this.container.parents().add(window).each(function(){e(this).bind(r+" "+n+" "+i,function(t){e("#select2-drop-mask").css({width:document.documentElement.scrollWidth,height:document.documentElement.scrollHeight}),o.positionDropdown()})}),this.focusSearch()},close:function(){if(!this.opened())return;var t=this.containerId,n="scroll."+t,r="resize."+t,i="orientationchange."+t;this.container.parents().add(window).each(function(){e(this).unbind(n).unbind(r).unbind(i)}),this.clearDropdownAlignmentPreference(),e("#select2-drop-mask").hide(),this.dropdown.removeAttr("id"),this.dropdown.hide(),this.container.removeClass("select2-dropdown-open"),this.results.empty(),this.clearSearch(),this.opts.element.trigger(e.Event("close"))},clearSearch:function(){},getMaximumSelectionSize:function(){return A(this.opts.maximumSelectionSize)},ensureHighlightVisible:function(){var t=this.results,n,r,i,s,o,u,a;r=this.highlight();if(r<0)return;if(r==0){t.scrollTop(0);return}n=this.findHighlightableChoices(),i=e(n[r]),s=i.offset().top+i.outerHeight(!0),r===n.length-1&&(a=t.find("li.select2-more-results"),a.length>0&&(s=a.offset().top+a.outerHeight(!0))),o=t.offset().top+t.outerHeight(!0),s>o&&t.scrollTop(t.scrollTop()+(s-o)),u=i.offset().top-t.offset().top,u<0&&i.css("display")!="none"&&t.scrollTop(t.scrollTop()+u)},findHighlightableChoices:function(){var e=this.results.find(".select2-result-selectable:not(.select2-selected):not(.select2-disabled)");return this.results.find(".select2-result-selectable:not(.select2-selected):not(.select2-disabled)")},moveHighlight:function(t){var n=this.findHighlightableChoices(),r=this.highlight();while(r>-1&&r<n.length){r+=t;var i=e(n[r]);if(i.hasClass("select2-result-selectable")&&!i.hasClass("select2-disabled")&&!i.hasClass("select2-selected")){this.highlight(r);break}}},highlight:function(t){var n=this.findHighlightableChoices(),r,i;if(arguments.length===0)return l(n.filter(".select2-highlighted")[0],n.get());t>=n.length&&(t=n.length-1),t<0&&(t=0),this.results.find(".select2-highlighted").removeClass("select2-highlighted"),r=e(n[t]),r.addClass("select2-highlighted"),this.ensureHighlightVisible(),i=r.data("select2-data"),i&&this.opts.element.trigger({type:"highlight",val:this.id(i),choice:i})},countSelectableResults:function(){return this.findHighlightableChoices().length},highlightUnderEvent:function(t){var n=e(t.target).closest(".select2-result-selectable");if(n.length>0&&!n.is(".select2-highlighted")){var r=this.findHighlightableChoices();this.highlight(r.index(n))}else n.length==0&&this.results.find(".select2-highlighted").removeClass("select2-highlighted")},loadMoreIfNeeded:function(){var e=this.results,t=e.find("li.select2-more-results"),n,r=-1,i=this.resultsPage+1,s=this,o=this.search.val(),u=this.context;if(t.length===0)return;n=t.offset().top-e.offset().top-e.height(),n<=this.opts.loadMorePadding&&(t.addClass("select2-active"),this.opts.query({element:this.opts.element,term:o,page:i,context:u,matcher:this.opts.matcher,callback:this.bind(function(n){if(!s.opened())return;s.opts.populateResults.call(this,e,n.results,{term:o,page:i,context:u}),n.more===!0?(t.detach().appendTo(e).text(s.opts.formatLoadMore(i+1)),window.setTimeout(function(){s.loadMoreIfNeeded()},10)):t.remove(),s.positionDropdown(),s.resultsPage=i,s.context=n.context})}))},tokenize:function(){},updateResults:function(n){function f(){i.scrollTop(0),r.removeClass("select2-active"),u.positionDropdown()}function l(e){i.html(e),f()}var r=this.search,i=this.results,s=this.opts,o,u=this,a;if(n!==!0&&(this.showSearchInput===!1||!this.opened()))return;r.addClass("select2-active");var h=this.getMaximumSelectionSize();if(h>=1){o=this.data();if(e.isArray(o)&&o.length>=h&&L(s.formatSelectionTooBig,"formatSelectionTooBig")){l("<li class='select2-selection-limit'>"+s.formatSelectionTooBig(h)+"</li>");return}}if(r.val().length<s.minimumInputLength){L(s.formatInputTooShort,"formatInputTooShort")?l("<li class='select2-no-results'>"+s.formatInputTooShort(r.val(),s.minimumInputLength)+"</li>"):l("");return}s.formatSearching()&&n===!0&&l("<li class='select2-searching'>"+s.formatSearching()+"</li>");if(s.maximumInputLength&&r.val().length>s.maximumInputLength){L(s.formatInputTooLong,"formatInputTooLong")?l("<li class='select2-no-results'>"+s.formatInputTooLong(r.val(),s.maximumInputLength)+"</li>"):l("");return}a=this.tokenize(),a!=t&&a!=null&&r.val(a),this.resultsPage=1,s.query({element:s.element,term:r.val(),page:this.resultsPage,context:null,matcher:s.matcher,callback:this.bind(function(o){var a;if(!this.opened())return;this.context=o.context===t?null:o.context,this.opts.createSearchChoice&&r.val()!==""&&(a=this.opts.createSearchChoice.call(null,r.val(),o.results),a!==t&&a!==null&&u.id(a)!==t&&u.id(a)!==null&&e(o.results).filter(function(){return c(u.id(this),u.id(a))}).length===0&&o.results.unshift(a));if(o.results.length===0&&L(s.formatNoMatches,"formatNoMatches")){l("<li class='select2-no-results'>"+s.formatNoMatches(r.val())+"</li>");return}i.empty(),u.opts.populateResults.call(this,i,o.results,{term:r.val(),page:this.resultsPage,context:null}),o.more===!0&&L(s.formatLoadMore,"formatLoadMore")&&(i.append("<li class='select2-more-results'>"+u.opts.escapeMarkup(s.formatLoadMore(this.resultsPage))+"</li>"),window.setTimeout(function(){u.loadMoreIfNeeded()},10)),this.postprocessResults(o,n),f()})})},cancel:function(){this.close()},blur:function(){this.opts.selectOnBlur&&this.selectHighlighted({noFocus:!0}),this.close(),this.container.removeClass("select2-container-active"),this.search[0]===document.activeElement&&this.search.blur(),this.clearSearch(),this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus")},focusSearch:function(){b(this.search)},selectHighlighted:function(e){var t=this.highlight(),n=this.results.find(".select2-highlighted"),r=n.closest(".select2-result").data("select2-data");r&&(this.highlight(t),this.onSelect(r,e))},getPlaceholder:function(){return this.opts.element.attr("placeholder")||this.opts.element.attr("data-placeholder")||this.opts.element.data("placeholder")||this.opts.placeholder},initContainerWidth:function(){function n(){var n,r,i,s,o;if(this.opts.width==="off")return null;if(this.opts.width==="element")return this.opts.element.outerWidth(!1)===0?"auto":this.opts.element.outerWidth(!1)+"px";if(this.opts.width==="copy"||this.opts.width==="resolve"){n=this.opts.element.attr("style");if(n!==t){r=n.split(";");for(s=0,o=r.length;s<o;s+=1){i=r[s].replace(/\s/g,"").match(/width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/);if(i!==null&&i.length>=1)return i[1]}}return this.opts.width==="resolve"?(n=this.opts.element.css("width"),n.indexOf("%")>0?n:this.opts.element.outerWidth(!1)===0?"auto":this.opts.element.outerWidth(!1)+"px"):null}return e.isFunction(this.opts.width)?this.opts.width():this.opts.width}var r=n.call(this);r!==null&&this.container.css("width",r)}}),i=_(r,{createContainer:function(){var t=e(document.createElement("div")).attr({"class":"select2-container"}).html(["<a href='javascript:void(0)' onclick='return false;' class='select2-choice' tabindex='-1'>","   <span></span><abbr class='select2-search-choice-close' style='display:none;'></abbr>","   <div><b></b></div>","</a>","<input class='select2-focusser select2-offscreen' type='text'/>","<div class='select2-drop' style='display:none'>","   <div class='select2-search'>","       <input type='text' autocomplete='off' class='select2-input'/>","   </div>","   <ul class='select2-results'>","   </ul>","</div>"].join(""));return t},disable:function(){if(!this.enabled)return;this.parent.disable.apply(this,arguments),this.focusser.attr("disabled","disabled")},enable:function(){if(this.enabled)return;this.parent.enable.apply(this,arguments),this.focusser.removeAttr("disabled")},opening:function(){this.parent.opening.apply(this,arguments),this.focusser.attr("disabled","disabled"),this.opts.element.trigger(e.Event("open"))},close:function(){if(!this.opened())return;this.parent.close.apply(this,arguments),this.focusser.removeAttr("disabled"),b(this.focusser)},focus:function(){this.opened()?this.close():(this.focusser.removeAttr("disabled"),this.focusser.focus())},isFocused:function(){return this.container.hasClass("select2-container-active")},cancel:function(){this.parent.cancel.apply(this,arguments),this.focusser.removeAttr("disabled"),this.focusser.focus()},initContainer:function(){var e,t=this.container,r=this.dropdown,i=!1;this.showSearch(this.opts.minimumResultsForSearch>=0),this.selection=e=t.find(".select2-choice"),this.focusser=t.find(".select2-focusser"),this.search.bind("keydown",this.bind(function(e){if(!this.enabled)return;if(e.which===n.PAGE_UP||e.which===n.PAGE_DOWN){w(e);return}switch(e.which){case n.UP:case n.DOWN:this.moveHighlight(e.which===n.UP?-1:1),w(e);return;case n.TAB:case n.ENTER:this.selectHighlighted(),w(e);return;case n.ESC:this.cancel(e),w(e);return}})),this.focusser.bind("keydown",this.bind(function(e){if(!this.enabled)return;if(e.which===n.TAB||n.isControl(e)||n.isFunctionKey(e)||e.which===n.ESC)return;if(this.opts.openOnEnter===!1&&e.which===n.ENTER){w(e);return}if(e.which==n.DOWN||e.which==n.UP||e.which==n.ENTER&&this.opts.openOnEnter){this.open(),w(e);return}if(e.which==n.DELETE||e.which==n.BACKSPACE){this.opts.allowClear&&this.clear(),w(e);return}})),d(this.focusser),this.focusser.bind("keyup-change input",this.bind(function(e){if(this.opened())return;this.open(),this.showSearchInput!==!1&&this.search.val(this.focusser.val()),this.focusser.val(""),w(e)})),e.delegate("abbr","mousedown",this.bind(function(e){if(!this.enabled)return;this.clear(),E(e),this.close(),this.selection.focus()})),e.bind("mousedown",this.bind(function(e){i=!0,this.opened()?this.close():this.enabled&&this.open(),w(e),i=!1})),r.bind("mousedown",this.bind(function(){this.search.focus()})),e.bind("focus",this.bind(function(e){w(e)})),this.focusser.bind("focus",this.bind(function(){this.container.addClass("select2-container-active")})).bind("blur",this.bind(function(){this.opened()||this.container.removeClass("select2-container-active")})),this.search.bind("focus",this.bind(function(){this.container.addClass("select2-container-active")})),this.initContainerWidth(),this.setPlaceholder()},clear:function(){var e=this.selection.data("select2-data");this.opts.element.val(""),this.selection.find("span").empty(),this.selection.removeData("select2-data"),this.setPlaceholder(),this.opts.element.trigger({type:"removed",val:this.id(e),choice:e}),this.triggerChange({removed:e})},initSelection:function(){var e;if(this.opts.element.val()===""&&this.opts.element.text()==="")this.close(),this.setPlaceholder();else{var n=this;this.opts.initSelection.call(null,this.opts.element,function(e){e!==t&&e!==null&&(n.updateSelection(e),n.close(),n.setPlaceholder())})}},prepareOpts:function(){var t=this.parent.prepareOpts.apply(this,arguments);return t.element.get(0).tagName.toLowerCase()==="select"?t.initSelection=function(t,n){var r=t.find(":selected");e.isFunction(n)&&n({id:r.attr("value"),text:r.text(),element:r})}:"data"in t&&(t.initSelection=t.initSelection||function(n,r){var i=n.val();t.query({matcher:function(e,n,r){return c(i,t.id(r))},callback:e.isFunction(r)?function(e){r(e.results.length?e.results[0]:null)}:e.noop})}),t},getPlaceholder:function(){return this.select&&this.select.find("option").first().text()!==""?t:this.parent.getPlaceholder.apply(this,arguments)},setPlaceholder:function(){var e=this.getPlaceholder();if(this.opts.element.val()===""&&e!==t){if(this.select&&this.select.find("option:first").text()!=="")return;this.selection.find("span").html(this.opts.escapeMarkup(e)),this.selection.addClass("select2-default"),this.selection.find("abbr").hide()}},postprocessResults:function(e,t){var n=0,r=this,i=!0;this.findHighlightableChoices().each2(function(e,t){if(c(r.id(t.data("select2-data")),r.opts.element.val()))return n=e,!1}),this.highlight(n);if(t===!0){var s=this.opts.minimumResultsForSearch;i=s<0?!1:O(e.results)>=s,this.showSearch(i)}},showSearch:function(t){this.showSearchInput=t,this.dropdown.find(".select2-search")[t?"removeClass":"addClass"]("select2-search-hidden"),e(this.dropdown,this.container)[t?"addClass":"removeClass"]("select2-with-searchbox")},onSelect:function(e,t){var n=this.opts.element.val();this.opts.element.val(this.id(e)),this.updateSelection(e),this.opts.element.trigger({type:"selected",val:this.id(e),choice:e}),this.close(),(!t||!t.noFocus)&&this.selection.focus(),c(n,this.id(e))||this.triggerChange()},updateSelection:function(e){var n=this.selection.find("span"),r;this.selection.data("select2-data",e),n.empty(),r=this.opts.formatSelection(e,n),r!==t&&n.append(this.opts.escapeMarkup(r)),this.selection.removeClass("select2-default"),this.opts.allowClear&&this.getPlaceholder()!==t&&this.selection.find("abbr").show()},val:function(){var e,n=!1,r=null,i=this;if(arguments.length===0)return this.opts.element.val();e=arguments[0],arguments.length>1&&(n=arguments[1]);if(this.select)this.select.val(e).find(":selected").each2(function(e,t){return r={id:t.attr("value"),text:t.text()},!1}),this.updateSelection(r),this.setPlaceholder(),n&&this.triggerChange();else{if(this.opts.initSelection===t)throw new Error("cannot call val() if initSelection() is not defined");if(!e&&e!==0){this.clear(),n&&this.triggerChange();return}this.opts.element.val(e),this.opts.initSelection(this.opts.element,function(e){i.opts.element.val(e?i.id(e):""),i.updateSelection(e),i.setPlaceholder(),n&&i.triggerChange()})}},clearSearch:function(){this.search.val(""),this.focusser.val("")},data:function(e){var n;if(arguments.length===0)return n=this.selection.data("select2-data"),n==t&&(n=null),n;!e||e===""?this.clear():(this.opts.element.val(e?this.id(e):""),this.updateSelection(e))}}),s=_(r,{createContainer:function(){var t=e(document.createElement("div")).attr({"class":"select2-container select2-container-multi"}).html(["    <ul class='select2-choices'>","  <li class='select2-search-field'>","    <input type='text' autocomplete='off' class='select2-input'>","  </li>","</ul>","<div class='select2-drop select2-drop-multi' style='display:none;'>","   <ul class='select2-results'>","   </ul>","</div>"].join(""));return t},prepareOpts:function(){var t=this.parent.prepareOpts.apply(this,arguments);return t.element.get(0).tagName.toLowerCase()==="select"?t.initSelection=function(e,t){var n=[];e.find(":selected").each2(function(e,t){n.push({id:t.attr("value"),text:t.text(),element:t[0]})}),t(n)}:"data"in t&&(t.initSelection=t.initSelection||function(n,r){var i=h(n.val(),t.separator);t.query({matcher:function(n,r,s){return e.grep(i,function(e){return c(e,t.id(s))}).length},callback:e.isFunction(r)?function(e){r(e.results)}:e.noop})}),t},initContainer:function(){var t=".select2-choices",r;this.searchContainer=this.container.find(".select2-search-field"),this.selection=r=this.container.find(t),this.search.bind("input paste",this.bind(function(){if(!this.enabled)return;this.opened()||this.open()})),this.search.bind("keydown",this.bind(function(e){if(!this.enabled)return;if(e.which===n.BACKSPACE&&this.search.val()===""){this.close();var t,i=r.find(".select2-search-choice-focus");if(i.length>0){this.unselect(i.first()),this.search.width(10),w(e);return}t=r.find(".select2-search-choice:not(.select2-locked)"),t.length>0&&t.last().addClass("select2-search-choice-focus")}else r.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");if(this.opened())switch(e.which){case n.UP:case n.DOWN:this.moveHighlight(e.which===n.UP?-1:1),w(e);return;case n.ENTER:case n.TAB:this.selectHighlighted(),w(e);return;case n.ESC:this.cancel(e),w(e);return}if(e.which===n.TAB||n.isControl(e)||n.isFunctionKey(e)||e.which===n.BACKSPACE||e.which===n.ESC)return;if(e.which===n.ENTER){if(this.opts.openOnEnter===!1)return;if(e.altKey||e.ctrlKey||e.shiftKey||e.metaKey)return}this.open(),(e.which===n.PAGE_UP||e.which===n.PAGE_DOWN)&&w(e)})),this.search.bind("keyup",this.bind(this.resizeSearch)),this.search.bind("blur",this.bind(function(e){this.container.removeClass("select2-container-active"),this.search.removeClass("select2-focused"),this.opened()||this.clearSearch(),e.stopImmediatePropagation()})),this.container.delegate(t,"mousedown",this.bind(function(t){if(!this.enabled)return;if(e(t.target).closest(".select2-search-choice").length>0)return;this.clearPlaceholder(),this.open(),this.focusSearch(),t.preventDefault()})),this.container.delegate(t,"focus",this.bind(function(){if(!this.enabled)return;this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active"),this.clearPlaceholder()})),this.initContainerWidth(),this.clearSearch()},enable:function(){if(this.enabled)return;this.parent.enable.apply(this,arguments),this.search.removeAttr("disabled")},disable:function(){if(!this.enabled)return;this.parent.disable.apply(this,arguments),this.search.attr("disabled",!0)},initSelection:function(){var e;this.opts.element.val()===""&&this.opts.element.text()===""&&(this.updateSelection([]),this.close(),this.clearSearch());if(this.select||this.opts.element.val()!==""){var n=this;this.opts.initSelection.call(null,this.opts.element,function(e){e!==t&&e!==null&&(n.updateSelection(e),n.close(),n.clearSearch())})}},clearSearch:function(){var e=this.getPlaceholder();e!==t&&this.getVal().length===0&&this.search.hasClass("select2-focused")===!1?(this.search.val(e).addClass("select2-default"),this.resizeSearch()):this.search.val("").width(10)},clearPlaceholder:function(){this.search.hasClass("select2-default")&&this.search.val("").removeClass("select2-default")},opening:function(){this.parent.opening.apply(this,arguments),this.clearPlaceholder(),this.resizeSearch(),this.focusSearch(),this.opts.element.trigger(e.Event("open"))},close:function(){if(!this.opened())return;this.parent.close.apply(this,arguments)},focus:function(){this.close(),this.search.focus(),this.opts.element.triggerHandler("focus")},isFocused:function(){return this.search.hasClass("select2-focused")},updateSelection:function(t){var n=[],r=[],i=this;e(t).each(function(){l(i.id(this),n)<0&&(n.push(i.id(this)),r.push(this))}),t=r,this.selection.find(".select2-search-choice").remove(),e(t).each(function(){i.addSelectedChoice(this)}),i.postprocessResults()},tokenize:function(){var e=this.search.val();e=this.opts.tokenizer(e,this.data(),this.bind(this.onSelect),this.opts),e!=null&&e!=t&&(this.search.val(e),e.length>0&&this.open())},onSelect:function(e,t){this.addSelectedChoice(e),this.opts.element.trigger({type:"selected",val:this.id(e),choice:e}),(this.select||!this.opts.closeOnSelect)&&this.postprocessResults(),this.opts.closeOnSelect?(this.close(),this.search.width(10)):this.countSelectableResults()>0?(this.search.width(10),this.resizeSearch(),this.val().length>=this.getMaximumSelectionSize()&&this.updateResults(!0),this.positionDropdown()):(this.close(),this.search.width(10)),this.triggerChange({added:e}),(!t||!t.noFocus)&&this.focusSearch()},cancel:function(){this.close(),this.focusSearch()},addSelectedChoice:function(n){var r=!n.locked,i=e("<li class='select2-search-choice'>    <div></div>    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a></li>"),s=e("<li class='select2-search-choice select2-locked'><div></div></li>"),o=r?i:s,u=this.id(n),a=this.getVal(),f;f=this.opts.formatSelection(n,o.find("div")),f!=t&&o.find("div").replaceWith("<div>"+this.opts.escapeMarkup(f)+"</div>"),r&&o.find(".select2-search-choice-close").bind("mousedown",w).bind("click dblclick",this.bind(function(t){if(!this.enabled)return;e(t.target).closest(".select2-search-choice").fadeOut("fast",this.bind(function(){this.unselect(e(t.target)),this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus"),this.close(),this.focusSearch()})).dequeue(),w(t)})).bind("focus",this.bind(function(){if(!this.enabled)return;this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active")})),o.data("select2-data",n),o.insertBefore(this.searchContainer),a.push(u),this.setVal(a)},unselect:function(e){var t=this.getVal(),n,r;e=e.closest(".select2-search-choice");if(e.length===0)throw"Invalid argument: "+e+". Must be .select2-search-choice";n=e.data("select2-data");if(!n)return;r=l(this.id(n),t),r>=0&&(t.splice(r,1),this.setVal(t),this.select&&this.postprocessResults()),e.remove(),this.opts.element.trigger({type:"removed",val:this.id(n),choice:n}),this.triggerChange({removed:n})},postprocessResults:function(){var e=this.getVal(),t=this.results.find(".select2-result"),n=this.results.find(".select2-result-with-children"),r=this;t.each2(function(t,n){var i=r.id(n.data("select2-data"));l(i,e)>=0&&(n.addClass("select2-selected"),n.find(".select2-result-selectable").addClass("select2-selected"))}),n.each2(function(e,t){!t.is(".select2-result-selectable")&&t.find(".select2-result-selectable:not(.select2-selected)").length===0&&t.addClass("select2-selected")}),this.highlight()==-1&&r.highlight(0)},resizeSearch:function(){var e,t,n,r,i,s=p(this.search);e=S(this.search)+10,t=this.search.offset().left,n=this.selection.width(),r=this.selection.offset().left,i=n-(t-r)-s,i<e&&(i=n-s),i<40&&(i=n-s),i<=0&&(i=e),this.search.width(i)},getVal:function(){var e;return this.select?(e=this.select.val(),e===null?[]:e):(e=this.opts.element.val(),h(e,this.opts.separator))},setVal:function(t){var n;this.select?this.select.val(t):(n=[],e(t).each(function(){l(this,n)<0&&n.push(this)}),this.opts.element.val(n.length===0?"":n.join(this.opts.separator)))},val:function(){var n,r=!1,i=[],s=this;if(arguments.length===0)return this.getVal();n=arguments[0],arguments.length>1&&(r=arguments[1]);if(!n&&n!==0){this.opts.element.val(""),this.updateSelection([]),this.clearSearch(),r&&this.triggerChange();return}this.setVal(n);if(this.select)this.opts.initSelection(this.select,this.bind(this.updateSelection)),r&&this.triggerChange();else{if(this.opts.initSelection===t)throw new Error("val() cannot be called if initSelection() is not defined");this.opts.initSelection(this.opts.element,function(t){var n=e(t).map(s.id);s.setVal(n),s.updateSelection(t),s.clearSearch(),r&&s.triggerChange()})}this.clearSearch()},onSortStart:function(){if(this.select)throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");this.search.width(0),this.searchContainer.hide()},onSortEnd:function(){var t=[],n=this;this.searchContainer.show(),this.searchContainer.appendTo(this.searchContainer.parent()),this.resizeSearch(),this.selection.find(".select2-search-choice").each(function(){t.push(n.opts.id(e(this).data("select2-data")))}),this.setVal(t),this.triggerChange()},data:function(t){var n=this,r;if(arguments.length===0)return this.selection.find(".select2-search-choice").map(function(){return e(this).data("select2-data")}).get();t||(t=[]),r=e.map(t,function(e){return n.opts.id(e)}),this.setVal(r),this.updateSelection(t),this.clearSearch()}}),e.fn.select2=function(){var n=Array.prototype.slice.call(arguments,0),r,o,u,a,f=["val","destroy","opened","open","close","focus","isFocused","container","onSortStart","onSortEnd","enable","disable","positionDropdown","data"];return this.each(function(){if(n.length===0||typeof n[0]=="object")r=n.length===0?{}:e.extend({},n[0]),r.element=e(this),r.element.get(0).tagName.toLowerCase()==="select"?a=r.element.attr("multiple"):(a=r.multiple||!1,"tags"in r&&(r.multiple=a=!0)),o=a?new s:new i,o.init(r);else{if(typeof n[0]!="string")throw"Invalid arguments to select2 plugin: "+n;if(l(n[0],f)<0)throw"Unknown method: "+n[0];u=t,o=e(this).data("select2");if(o===t)return;n[0]==="container"?u=o.container:u=o[n[0]].apply(o,n.slice(1));if(u!==t)return!1}}),u===t?this:u},e.fn.select2.defaults={width:"copy",loadMorePadding:0,closeOnSelect:!0,openOnEnter:!0,containerCss:{},dropdownCss:{},containerCssClass:"",dropdownCssClass:"",formatResult:function(e,t,n,r){var i=[];return T(e.text,n.term,i,r),i.join("")},formatSelection:function(e,n){return e?e.text:t},sortResults:function(e,t,n){return e},formatResultCssClass:function(e){return t},formatNoMatches:function(){return"No matches found"},formatInputTooShort:function(e,t){var n=t-e.length;return"Please enter "+n+" more character"+(n==1?"":"s")},formatInputTooLong:function(e,t){var n=e.length-t;return"Please enter "+n+" less character"+(n==1?"":"s")},formatSelectionTooBig:function(e){return"You can only select "+e+" item"+(e==1?"":"s")},formatLoadMore:function(e){return"Loading more results..."},formatSearching:function(){return"Searching..."},minimumResultsForSearch:0,minimumInputLength:0,maximumInputLength:null,maximumSelectionSize:0,id:function(e){return e.id},matcher:function(e,t){return t.toUpperCase().indexOf(e.toUpperCase())>=0},separator:",",tokenSeparators:[],tokenizer:M,escapeMarkup:function(e){var t={"\\":"&#92;","&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&apos;","/":"&#47;"};return String(e).replace(/[&<>"'/\\]/g,function(e){return t[e[0]]})},blurOnChange:!1,selectOnBlur:!1,adaptContainerCssClass:function(e){return e},adaptDropdownCssClass:function(e){return null}}}(e)}),timely.define("libs/select2_multiselect_helper",["jquery_timely","external_libs/select2"],function(e){var t=function(t){var n=e(t.element),r=n.data("color"),i=n.data("description"),s="";return typeof r!="undefined"&&r!==""&&(s+='<span class="ai1ec-color-swatch" style="background: '+n.data("color")+'"></span> '),s+=t.text,s='<span title="'+i+'">'+s+"</span>",s},n=function(t){var n=e(t.element),r=n.data("color"),i=n.data("description"),s="";return typeof r!="undefined"&&r!==""?s+='<span class="ai1ec-color-swatch" style="background: '+n.data("color")+'"></span> ':s+='<span class="ai1ec-color-swatch-empty"></span> ',s+=t.text,s='<span title="'+i+'">'+s+"</span>",s},r=function(r){typeof r=="undefined"&&(r=e(document)),e(".ai1ec-select2-multiselect-selector",r).select2({allowClear:!0,formatResult:n,formatSelection:t,escapeMarkup:function(e){return e}})},i=function(t){e(".ai1ec-select2-multiselect-selector.select2-container",t).each(function(){e(this).data("select2").resizeSearch()})};return{init:r,refresh:i}}),timely.define("external_libs/jquery_history",["jquery_timely"],function(e){try{(function(t,n){var r=t.History=t.History||{};if(typeof r.Adapter!="undefined")throw new Error("History.js Adapter has already been loaded...");r.Adapter={bind:function(t,n,r){e(t).bind(n,r)},trigger:function(t,n,r){e(t).trigger(n,r)},extractEventData:function(e,t,r){var i=t&&t.originalEvent&&t.originalEvent[e]||r&&r[e]||n;return i},onDomLoad:function(t){e(t)}},typeof r.init!="undefined"&&r.init()})(window),function(e,t){var n=e.document,r=e.setTimeout||r,i=e.clearTimeout||i,s=e.setInterval||s,o=e.History=e.History||{};if(typeof o.initHtml4!="undefined")throw new Error("History.js HTML4 Support has already been loaded...");o.initHtml4=function(){if(typeof o.initHtml4.initialized!="undefined")return!1;o.initHtml4.initialized=!0,o.enabled=!0,o.savedHashes=[],o.isLastHash=function(e){var t=o.getHashByIndex(),n;return n=e===t,n},o.saveHash=function(e){return o.isLastHash(e)?!1:(o.savedHashes.push(e),!0)},o.getHashByIndex=function(e){var t=null;return typeof e=="undefined"?t=o.savedHashes[o.savedHashes.length-1]:e<0?t=o.savedHashes[o.savedHashes.length+e]:t=o.savedHashes[e],t},o.discardedHashes={},o.discardedStates={},o.discardState=function(e,t,n){var r=o.getHashByState(e),i;return i={discardedState:e,backState:n,forwardState:t},o.discardedStates[r]=i,!0},o.discardHash=function(e,t,n){var r={discardedHash:e,backState:n,forwardState:t};return o.discardedHashes[e]=r,!0},o.discardedState=function(e){var t=o.getHashByState(e),n;return n=o.discardedStates[t]||!1,n},o.discardedHash=function(e){var t=o.discardedHashes[e]||!1;return t},o.recycleState=function(e){var t=o.getHashByState(e);return o.discardedState(e)&&delete o.discardedStates[t],!0},o.emulated.hashChange&&(o.hashChangeInit=function(){o.checkerFunction=null;var t="",r,i,u,a;return o.isInternetExplorer()?(r="historyjs-iframe",i=n.createElement("iframe"),i.setAttribute("id",r),i.style.display="none",n.body.appendChild(i),i.contentWindow.document.open(),i.contentWindow.document.close(),u="",a=!1,o.checkerFunction=function(){if(a)return!1;a=!0;var n=o.getHash()||"",r=o.unescapeHash(i.contentWindow.document.location.hash)||"";return n!==t?(t=n,r!==n&&(u=r=n,i.contentWindow.document.open(),i.contentWindow.document.close(),i.contentWindow.document.location.hash=o.escapeHash(n)),o.Adapter.trigger(e,"hashchange")):r!==u&&(u=r,o.setHash(r,!1)),a=!1,!0}):o.checkerFunction=function(){var n=o.getHash();return n!==t&&(t=n,o.Adapter.trigger(e,"hashchange")),!0},o.intervalList.push(s(o.checkerFunction,o.options.hashChangeInterval)),!0},o.Adapter.onDomLoad(o.hashChangeInit)),o.emulated.pushState&&(o.onHashChange=function(t){var r=t&&t.newURL||n.location.href,i=o.getHashByUrl(r),s=null,u=null,a=null,f;return o.isLastHash(i)?(o.busy(!1),!1):(o.doubleCheckComplete(),o.saveHash(i),i&&o.isTraditionalAnchor(i)?(o.Adapter.trigger(e,"anchorchange"),o.busy(!1),!1):(s=o.extractState(o.getFullUrl(i||n.location.href,!1),!0),o.isLastSavedState(s)?(o.busy(!1),!1):(u=o.getHashByState(s),f=o.discardedState(s),f?(o.getHashByIndex(-2)===o.getHashByState(f.forwardState)?o.back(!1):o.forward(!1),!1):(o.pushState(s.data,s.title,s.url,!1),!0))))},o.Adapter.bind(e,"hashchange",o.onHashChange),o.pushState=function(t,r,i,s){if(o.getHashByUrl(i))throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(s!==!1&&o.busy())return o.pushQueue({scope:o,callback:o.pushState,args:arguments,queue:s}),!1;o.busy(!0);var u=o.createStateObject(t,r,i),a=o.getHashByState(u),f=o.getState(!1),l=o.getHashByState(f),c=o.getHash();return o.storeState(u),o.expectedStateId=u.id,o.recycleState(u),o.setTitle(u),a===l?(o.busy(!1),!1):a!==c&&a!==o.getShortUrl(n.location.href)?(o.setHash(a,!1),!1):(o.saveState(u),o.Adapter.trigger(e,"statechange"),o.busy(!1),!0)},o.replaceState=function(e,t,n,r){if(o.getHashByUrl(n))throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(r!==!1&&o.busy())return o.pushQueue({scope:o,callback:o.replaceState,args:arguments,queue:r}),!1;o.busy(!0);var i=o.createStateObject(e,t,n),s=o.getState(!1),u=o.getStateByIndex(-2);return o.discardState(s,i,u),o.pushState(i.data,i.title,i.url,!1),!0}),o.emulated.pushState&&o.getHash()&&!o.emulated.hashChange&&o.Adapter.onDomLoad(function(){o.Adapter.trigger(e,"hashchange")})},typeof o.init!="undefined"&&o.init()}(window),function(e,t){var n=e.console||t,r=e.document,i=e.navigator,s=e.sessionStorage||!1,o=e.setTimeout,u=e.clearTimeout,a=e.setInterval,f=e.clearInterval,l=e.JSON,c=e.alert,h=e.History=e.History||{},p=e.history;l.stringify=l.stringify||l.encode,l.parse=l.parse||l.decode;if(typeof h.init!="undefined")throw new Error("History.js Core has already been loaded...");h.init=function(){return typeof h.Adapter=="undefined"?!1:(typeof h.initCore!="undefined"&&h.initCore(),typeof h.initHtml4!="undefined"&&h.initHtml4(),!0)},h.initCore=function(){if(typeof h.initCore.initialized!="undefined")return!1;h.initCore.initialized=!0,h.options=h.options||{},h.options.hashChangeInterval=h.options.hashChangeInterval||100,h.options.safariPollInterval=h.options.safariPollInterval||500,h.options.doubleCheckInterval=h.options.doubleCheckInterval||500,h.options.storeInterval=h.options.storeInterval||1e3,h.options.busyDelay=h.options.busyDelay||250,h.options.debug=h.options.debug||!1,h.options.initialTitle=h.options.initialTitle||r.title,h.intervalList=[],h.clearAllIntervals=function(){var e,t=h.intervalList;if(typeof t!="undefined"&&t!==null){for(e=0;e<t.length;e++)f(t[e]);h.intervalList=null}},h.debug=function(){(h.options.debug||!1)&&h.log.apply(h,arguments)},h.log=function(){var e=typeof n!="undefined"&&typeof n.log!="undefined"&&typeof n.log.apply!="undefined",t=r.getElementById("log"),i,s,o,u,a;e?(u=Array.prototype.slice.call(arguments),i=u.shift(),typeof n.debug!="undefined"?n.debug.apply(n,[i,u]):n.log.apply(n,[i,u])):i="\n"+arguments[0]+"\n";for(s=1,o=arguments.length;s<o;++s){a=arguments[s];if(typeof a=="object"&&typeof l!="undefined")try{a=l.stringify(a)}catch(f){}i+="\n"+a+"\n"}return t?(t.value+=i+"\n-----\n",t.scrollTop=t.scrollHeight-t.clientHeight):e||c(i),!0},h.getInternetExplorerMajorVersion=function(){var e=h.getInternetExplorerMajorVersion.cached=typeof h.getInternetExplorerMajorVersion.cached!="undefined"?h.getInternetExplorerMajorVersion.cached:function(){var e=3,t=r.createElement("div"),n=t.getElementsByTagName("i");while((t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&n[0]);return e>4?e:!1}();return e},h.isInternetExplorer=function(){var e=h.isInternetExplorer.cached=typeof h.isInternetExplorer.cached!="undefined"?h.isInternetExplorer.cached:Boolean(h.getInternetExplorerMajorVersion());return e},h.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(i.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(i.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in r)||h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8)},h.enabled=!h.emulated.pushState,h.bugs={setHash:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),safariPoll:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),ieDoubleCheck:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<7)},h.isEmptyObject=function(e){for(var t in e)return!1;return!0},h.cloneObject=function(e){var t,n;return e?(t=l.stringify(e),n=l.parse(t)):n={},n},h.getRootUrl=function(){var e=r.location.protocol+"//"+(r.location.hostname||r.location.host);if(r.location.port||!1)e+=":"+r.location.port;return e+="/",e},h.getBaseHref=function(){var e=r.getElementsByTagName("base"),t=null,n="";return e.length===1&&(t=e[0],n=t.href.replace(/[^\/]+$/,"")),n=n.replace(/\/+$/,""),n&&(n+="/"),n},h.getBaseUrl=function(){var e=h.getBaseHref()||h.getBasePageUrl()||h.getRootUrl();return e},h.getPageUrl=function(){var e=h.getState(!1,!1),t=(e||{}).url||r.location.href,n;return n=t.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,n){return/\./.test(e)?e:e+"/"}),n},h.getBasePageUrl=function(){var e=r.location.href.replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,n){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},h.getFullUrl=function(e,t){var n=e,r=e.substring(0,1);return t=typeof t=="undefined"?!0:t,/[a-z]+\:\/\//.test(e)||(r==="/"?n=h.getRootUrl()+e.replace(/^\/+/,""):r==="#"?n=h.getPageUrl().replace(/#.*/,"")+e:r==="?"?n=h.getPageUrl().replace(/[\?#].*/,"")+e:t?n=h.getBaseUrl()+e.replace(/^(\.\/)+/,""):n=h.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),n.replace(/\#$/,"")},h.getShortUrl=function(e){var t=e,n=h.getBaseUrl(),r=h.getRootUrl();return h.emulated.pushState&&(t=t.replace(n,"")),t=t.replace(r,"/"),h.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,""),t},h.store={},h.idToState=h.idToState||{},h.stateToId=h.stateToId||{},h.urlToId=h.urlToId||{},h.storedStates=h.storedStates||[],h.savedStates=h.savedStates||[],h.normalizeStore=function(){h.store.idToState=h.store.idToState||{},h.store.urlToId=h.store.urlToId||{},h.store.stateToId=h.store.stateToId||{}},h.getState=function(e,t){typeof e=="undefined"&&(e=!0),typeof t=="undefined"&&(t=!0);var n=h.getLastSavedState();return!n&&t&&(n=h.createStateObject()),e&&(n=h.cloneObject(n),n.url=n.cleanUrl||n.url),n},h.getIdByState=function(e){var t=h.extractId(e.url),n;if(!t){n=h.getStateString(e);if(typeof h.stateToId[n]!="undefined")t=h.stateToId[n];else if(typeof h.store.stateToId[n]!="undefined")t=h.store.stateToId[n];else{for(;;){t=(new Date).getTime()+String(Math.random()).replace(/\D/g,"");if(typeof h.idToState[t]=="undefined"&&typeof h.store.idToState[t]=="undefined")break}h.stateToId[n]=t,h.idToState[t]=e}}return t},h.normalizeState=function(e){var t,n;if(!e||typeof e!="object")e={};if(typeof e.normalized!="undefined")return e;if(!e.data||typeof e.data!="object")e.data={};t={},t.normalized=!0,t.title=e.title||"",t.url=h.getFullUrl(h.unescapeString(e.url||r.location.href)),t.hash=h.getShortUrl(t.url),t.data=h.cloneObject(e.data),t.id=h.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,n=!h.isEmptyObject(t.data);if(t.title||n)t.hash=h.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id;return t.hashedUrl=h.getFullUrl(t.hash),(h.emulated.pushState||h.bugs.safariPoll)&&h.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t},h.createStateObject=function(e,t,n){var r={data:e,title:t,url:n};return r=h.normalizeState(r),r},h.getStateById=function(e){e=String(e);var n=h.idToState[e]||h.store.idToState[e]||t;return n},h.getStateString=function(e){var t,n,r;return t=h.normalizeState(e),n={data:t.data,title:e.title,url:e.url},r=l.stringify(n),r},h.getStateId=function(e){var t,n;return t=h.normalizeState(e),n=t.id,n},h.getHashByState=function(e){var t,n;return t=h.normalizeState(e),n=t.hash,n},h.extractId=function(e){var t,n,r;return n=/(.*)\&_suid=([0-9]+)$/.exec(e),r=n?n[1]||e:e,t=n?String(n[2]||""):"",t||!1},h.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},h.extractState=function(e,t){var n=null,r,i;return t=t||!1,r=h.extractId(e),r&&(n=h.getStateById(r)),n||(i=h.getFullUrl(e),r=h.getIdByUrl(i)||!1,r&&(n=h.getStateById(r)),!n&&t&&!h.isTraditionalAnchor(e)&&(n=h.createStateObject(null,null,i))),n},h.getIdByUrl=function(e){var n=h.urlToId[e]||h.store.urlToId[e]||t;return n},h.getLastSavedState=function(){return h.savedStates[h.savedStates.length-1]||t},h.getLastStoredState=function(){return h.storedStates[h.storedStates.length-1]||t},h.hasUrlDuplicate=function(e){var t=!1,n;return n=h.extractState(e.url),t=n&&n.id!==e.id,t},h.storeState=function(e){return h.urlToId[e.url]=e.id,h.storedStates.push(h.cloneObject(e)),e},h.isLastSavedState=function(e){var t=!1,n,r,i;return h.savedStates.length&&(n=e.id,r=h.getLastSavedState(),i=r.id,t=n===i),t},h.saveState=function(e){return h.isLastSavedState(e)?!1:(h.savedStates.push(h.cloneObject(e)),!0)},h.getStateByIndex=function(e){var t=null;return typeof e=="undefined"?t=h.savedStates[h.savedStates.length-1]:e<0?t=h.savedStates[h.savedStates.length+e]:t=h.savedStates[e],t},h.getHash=function(){var e=h.unescapeHash(r.location.hash);return e},h.unescapeString=function(t){var n=t,r;for(;;){r=e.unescape(n);if(r===n)break;n=r}return n},h.unescapeHash=function(e){var t=h.normalizeHash(e);return t=h.unescapeString(t),t},h.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},h.setHash=function(e,t){var n,i,s;return t!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.setHash,args:arguments,queue:t}),!1):(n=h.escapeHash(e),h.busy(!0),i=h.extractState(e,!0),i&&!h.emulated.pushState?h.pushState(i.data,i.title,i.url,!1):r.location.hash!==n&&(h.bugs.setHash?(s=h.getPageUrl(),h.pushState(null,null,s+"#"+n,!1)):r.location.hash=n),h)},h.escapeHash=function(t){var n=h.normalizeHash(t);return n=e.escape(n),h.bugs.hashEscape||(n=n.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),n},h.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=h.unescapeHash(t),t},h.setTitle=function(e){var t=e.title,n;t||(n=h.getStateByIndex(0),n&&n.url===e.url&&(t=n.title||h.options.initialTitle));try{r.getElementsByTagName("title")[0].innerHTML=t.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(i){}return r.title=t,h},h.queues=[],h.busy=function(e){typeof e!="undefined"?h.busy.flag=e:typeof h.busy.flag=="undefined"&&(h.busy.flag=!1);if(!h.busy.flag){u(h.busy.timeout);var t=function(){var e,n,r;if(h.busy.flag)return;for(e=h.queues.length-1;e>=0;--e){n=h.queues[e];if(n.length===0)continue;r=n.shift(),h.fireQueueItem(r),h.busy.timeout=o(t,h.options.busyDelay)}};h.busy.timeout=o(t,h.options.busyDelay)}return h.busy.flag},h.busy.flag=!1,h.fireQueueItem=function(e){return e.callback.apply(e.scope||h,e.args||[])},h.pushQueue=function(e){return h.queues[e.queue||0]=h.queues[e.queue||0]||[],h.queues[e.queue||0].push(e),h},h.queue=function(e,t){return typeof e=="function"&&(e={callback:e}),typeof t!="undefined"&&(e.queue=t),h.busy()?h.pushQueue(e):h.fireQueueItem(e),h},h.clearQueue=function(){return h.busy.flag=!1,h.queues=[],h},h.stateChanged=!1,h.doubleChecker=!1,h.doubleCheckComplete=function(){return h.stateChanged=!0,h.doubleCheckClear(),h},h.doubleCheckClear=function(){return h.doubleChecker&&(u(h.doubleChecker),h.doubleChecker=!1),h},h.doubleCheck=function(e){return h.stateChanged=!1,h.doubleCheckClear(),h.bugs.ieDoubleCheck&&(h.doubleChecker=o(function(){return h.doubleCheckClear(),h.stateChanged||e(),!0},h.options.doubleCheckInterval)),h},h.safariStatePoll=function(){var t=h.extractState(r.location.href),n;if(!h.isLastSavedState(t))return n=t,n||(n=h.createStateObject()),h.Adapter.trigger(e,"popstate"),h;return},h.back=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.back,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.back(!1)}),p.go(-1),!0)},h.forward=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.forward,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.forward(!1)}),p.go(1),!0)},h.go=function(e,t){var n;if(e>0)for(n=1;n<=e;++n)h.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(n=-1;n>=e;--n)h.back(t)}return h};if(h.emulated.pushState){var d=function(){};h.pushState=h.pushState||d,h.replaceState=h.replaceState||d}else h.onPopState=function(t,n){var i=!1,s=!1,o,u;return h.doubleCheckComplete(),o=h.getHash(),o?(u=h.extractState(o||r.location.href,!0),u?h.replaceState(u.data,u.title,u.url,!1):(h.Adapter.trigger(e,"anchorchange"),h.busy(!1)),h.expectedStateId=!1,!1):(i=h.Adapter.extractEventData("state",t,n)||!1,i?s=h.getStateById(i):h.expectedStateId?s=h.getStateById(h.expectedStateId):s=h.extractState(r.location.href),s||(s=h.createStateObject(null,null,r.location.href)),h.expectedStateId=!1,h.isLastSavedState(s)?(h.busy(!1),!1):(h.storeState(s),h.saveState(s),h.setTitle(s),h.Adapter.trigger(e,"statechange"),h.busy(!1),!0))},h.Adapter.bind(e,"popstate",h.onPopState),h.pushState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.pushState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.pushState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0},h.replaceState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.replaceState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.replaceState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0};if(s){try{h.store=l.parse(s.getItem("History.store"))||{}}catch(v){h.store={}}h.normalizeStore()}else h.store={},h.normalizeStore();h.Adapter.bind(e,"beforeunload",h.clearAllIntervals),h.Adapter.bind(e,"unload",h.clearAllIntervals),h.saveState(h.storeState(h.extractState(r.location.href,!0))),s&&(h.onUnload=function(){var e,t;try{e=l.parse(s.getItem("History.store"))||{}}catch(n){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in h.idToState){if(!h.idToState.hasOwnProperty(t))continue;e.idToState[t]=h.idToState[t]}for(t in h.urlToId){if(!h.urlToId.hasOwnProperty(t))continue;e.urlToId[t]=h.urlToId[t]}for(t in h.stateToId){if(!h.stateToId.hasOwnProperty(t))continue;e.stateToId[t]=h.stateToId[t]}h.store=e,h.normalizeStore(),s.setItem("History.store",l.stringify(e))},h.intervalList.push(a(h.onUnload,h.options.storeInterval)),h.Adapter.bind(e,"beforeunload",h.onUnload),h.Adapter.bind(e,"unload",h.onUnload));if(!h.emulated.pushState){h.bugs.safariPoll&&h.intervalList.push(a(h.safariStatePoll,h.options.safariPollInterval));if(i.vendor==="Apple Computer, Inc."||(i.appCodeName||"")==="Mozilla")h.Adapter.bind(e,"hashchange",function(){h.Adapter.trigger(e,"popstate")}),h.getHash()&&h.Adapter.onDomLoad(function(){h.Adapter.trigger(e,"hashchange")})}},h.init()}(window)}catch(t){}}),timely.define("external_libs/jquery.tablescroller",["jquery_timely"],function(e){function n(){if(t)return t;var n=e('<div style="width:50px;height:50px;overflow:hidden;position:absolute;top:-200px;left:-200px;"><div style="height:100px;"></div></div>');e("body").append(n);var r=e("div",n).innerWidth();n.css("overflow-y","auto");var i=e("div",n).innerWidth();return e(n).remove(),t=r-i,t}var t=0;e.fn.tableScroll=function(t){if(t=="undo"){var r=e(this).parent().parent();r.hasClass("tablescroll_wrapper")&&(r.find(".tablescroll_head thead").prependTo(this),r.find(".tablescroll_foot tfoot").appendTo(this),r.before(this),r.empty());return}var i=e.extend({},e.fn.tableScroll.defaults,t);return i.scrollbarWidth=n(),this.each(function(){var t=i.flush,n=e(this).addClass("tablescroll_body"),r=e('<div class="tablescroll_wrapper ai1ec-popover-boundary"></div>').insertBefore(n).append(n);r.parent("div").hasClass(i.containerClass)||e("<div></div>").addClass(i.containerClass).insertBefore(r).append(r);var s=i.width?i.width:n.outerWidth(),o=i.scroll?"auto":"hidden";r.css({width:s+"px",height:i.height+"px",overflow:o}),n.css("width",s+"px");var u=r.outerWidth(),a=u-s;r.css({width:s-a-2+"px"}),n.css("width",s-a-i.scrollbarWidth+"px"),n.outerHeight()<=i.height&&(r.css({height:"auto",width:s-a+"px"}),t=!1);var f=e("thead",n).length?!0:!1,l=e("tfoot",n).length?!0:!1,c=e("thead tr:first",n),h=e("tbody tr:first",n),p=e("tfoot tr:first",n),d=0;e("th, td",c).each(function(t){d=e(this).width(),e("th:eq("+t+"), td:eq("+t+")",c).css("width",d+"px"),e("th:eq("+t+"), td:eq("+t+")",h).css("width",d+"px"),l&&e("th:eq("+t+"), td:eq("+t+")",p).css("width",d+"px")});if(f)var v=e('<table class="tablescroll_head" cellspacing="0"></table>').insertBefore(r).prepend(e("thead",n));if(l)var m=e('<table class="tablescroll_foot" cellspacing="0"></table>').insertAfter(r).prepend(e("tfoot",n));v!=undefined&&(v.css("width",s+"px"),t&&(e("tr:first th:last, tr:first td:last",v).css("width",d+i.scrollbarWidth+"px"),v.css("width",r.outerWidth()+"px"))),m!=undefined&&(m.css("width",s+"px"),t&&(e("tr:first th:last, tr:first td:last",m).css("width",d+i.scrollbarWidth+"px"),m.css("width",r.outerWidth()+"px")))}),this},e.fn.tableScroll.defaults={flush:!0,width:null,height:100,containerClass:"tablescroll",scroll:!0}}),timely.define("external_libs/jquery.scrollTo",["jquery_timely"],function(e){function n(e){return typeof e=="object"?e:{top:e,left:e}}var t=e.scrollTo=function(t,n,r){e(window).scrollTo(t,n,r)};t.defaults={axis:"xy",duration:parseFloat(e.fn.jquery)>=1.3?0:1,limit:!0},t.window=function(t){return e(window)._scrollable()},e.fn._scrollable=function(){return this.map(function(){var t=this,n=!t.nodeName||e.inArray(t.nodeName.toLowerCase(),["iframe","#document","html","body"])!=-1;if(!n)return t;var r=(t.contentWindow||t).document||t.ownerDocument||t;return/webkit/i.test(navigator.userAgent)||r.compatMode=="BackCompat"?r.body:r.documentElement})},e.fn.scrollTo=function(r,i,s){return typeof i=="object"&&(s=i,i=0),typeof s=="function"&&(s={onAfter:s}),r=="max"&&(r=9e9),s=e.extend({},t.defaults,s),i=i||s.duration,s.queue=s.queue&&s.axis.length>1,s.queue&&(i/=2),s.offset=n(s.offset),s.over=n(s.over),this._scrollable().each(function(){function h(e){u.animate(l,i,s.easing,e&&function(){e.call(this,r,s)})}if(r==null)return;var o=this,u=e(o),a=r,f,l={},c=u.is("html,body");switch(typeof a){case"number":case"string":if(/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(a)){a=n(a);break}a=e(a,this);if(!a.length)return;case"object":if(a.is||a.style)f=(a=e(a)).offset()}e.each(s.axis.split(""),function(e,n){var r=n=="x"?"Left":"Top",i=r.toLowerCase(),p="scroll"+r,d=o[p],v=t.max(o,n);if(f)l[p]=f[i]+(c?0:d-u.offset()[i]),s.margin&&(l[p]-=parseInt(a.css("margin"+r))||0,l[p]-=parseInt(a.css("border"+r+"Width"))||0),l[p]+=s.offset[i]||0,s.over[i]&&(l[p]+=a[n=="x"?"width":"height"]()*s.over[i]);else{var m=a[i];l[p]=m.slice&&m.slice(-1)=="%"?parseFloat(m)/100*v:m}s.limit&&/^\d+$/.test(l[p])&&(l[p]=l[p]<=0?0:Math.min(l[p],v)),!e&&s.queue&&(d!=l[p]&&h(s.onAfterFirst),delete l[p])}),h(s.onAfter)}).end()},t.max=function(t,n){var r=n=="x"?"Width":"Height",i="scroll"+r;if(!e(t).is("html,body"))return t[i]-e(t)[r.toLowerCase()]();var s="client"+r,o=t.ownerDocument.documentElement,u=t.ownerDocument.body;return Math.max(o[i],u[i])-Math.min(o[s],u[s])}}),timely.define("external_libs/locales/bootstrap-datepicker.bg",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.bg={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.br",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.br={days:["Domingo","Segunda","Tera","Quarta","Quinta","Sexta","Sbado","Domingo"],daysShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sb","Dom"],daysMin:["Do","Se","Te","Qu","Qu","Se","Sa","Do"],months:["Janeiro","Fevereiro","Maro","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthsShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.cs",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.cs={days:["Nedle","Pondl","ter","Steda","tvrtek","Ptek","Sobota","Nedle"],daysShort:["Ne","Po","t","St","t","P","So","Ne"],daysMin:["N","P","","St","","P","So","N"],months:["Leden","nor","Bezen","Duben","Kvten","erven","ervenec","Srpen","Z","jen","Listopad","Prosinec"],monthsShort:["Led","no","Be","Dub","Kv","er","nc","Srp","Z","j","Lis","Pro"],today:"Dnes"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.da",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.da={days:["Sndag","Mandag","Tirsdag","Onsdag","Torsdag","Fredag","Lrdag","Sndag"],daysShort:["Sn","Man","Tir","Ons","Tor","Fre","Lr","Sn"],daysMin:["S","Ma","Ti","On","To","Fr","L","S"],months:["Januar","Februar","Marts","April","Maj","Juni","Juli","August","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],today:"I Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.de",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.de={days:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag","Sonntag"],daysShort:["Son","Mon","Die","Mit","Don","Fre","Sam","Son"],daysMin:["So","Mo","Di","Mi","Do","Fr","Sa","So"],months:["Januar","Februar","Mrz","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],monthsShort:["Jan","Feb","Mr","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],today:"Heute"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.es",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.es={days:["Domingo","Lunes","Martes","Mircoles","Jueves","Viernes","Sbado","Domingo"],daysShort:["Dom","Lun","Mar","Mi","Jue","Vie","Sb","Dom"],daysMin:["Do","Lu","Ma","Mi","Ju","Vi","Sa","Do"],months:["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"],monthsShort:["Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic"],today:"Hoy"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.fi",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.fi={days:["sunnuntai","maanantai","tiistai","keskiviikko","torstai","perjantai","lauantai","sunnuntai"],daysShort:["sun","maa","tii","kes","tor","per","lau","sun"],daysMin:["su","ma","ti","ke","to","pe","la","su"],months:["tammikuu","helmikuu","maaliskuu","huhtikuu","toukokuu","keskuu","heinkuu","elokuu","syyskuu","lokakuu","marraskuu","joulukuu"],monthsShort:["tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mar","jou"],today:"tnn"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.fr",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.fr={days:["Dimanche","Lundi","Mardi","Mercredi","Jeudi","Vendredi","Samedi","Dimanche"],daysShort:["Dim","Lun","Mar","Mer","Jeu","Ven","Sam","Dim"],daysMin:["D","L","Ma","Me","J","V","S","D"],months:["Janvier","Fvrier","Mars","Avril","Mai","Juin","Juillet","Aot","Septembre","Octobre","Novembre","Dcembre"],monthsShort:["Jan","Fev","Mar","Avr","Mai","Jui","Jul","Aou","Sep","Oct","Nov","Dec"],today:"Aujourd'hui"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.id",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.id={days:["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu","Minggu"],daysShort:["Mgu","Sen","Sel","Rab","Kam","Jum","Sab","Mgu"],daysMin:["Mg","Sn","Sl","Ra","Ka","Ju","Sa","Mg"],months:["Januari","Februari","Maret","April","Mei","Juni","Juli","Agustus","September","Oktober","November","Desember"],monthsShort:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Ags","Sep","Okt","Nov","Des"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.is",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.is={days:["Sunnudagur","Mnudagur","rijudagur","Mivikudagur","Fimmtudagur","Fstudagur","Laugardagur","Sunnudagur"],daysShort:["Sun","Mn","ri","Mi","Fim","Fs","Lau","Sun"],daysMin:["Su","M","r","Mi","Fi","F","La","Su"],months:["Janar","Febrar","Mars","Aprl","Ma","Jn","Jl","gst","September","Oktber","Nvember","Desember"],monthsShort:["Jan","Feb","Mar","Apr","Ma","Jn","Jl","g","Sep","Okt","Nv","Des"],today:" Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.it",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.it={days:["Domenica","Lunedi","Martedi","Mercoledi","Giovedi","Venerdi","Sabato","Domenica"],daysShort:["Dom","Lun","Mar","Mer","Gio","Ven","Sab","Dom"],daysMin:["Do","Lu","Ma","Me","Gi","Ve","Sa","Do"],months:["Gennaio","Febbraio","Marzo","Aprile","Maggio","Giugno","Luglio","Agosto","Settembre","Ottobre","Novembre","Dicembre"],monthsShort:["Gen","Feb","Mar","Apr","Mag","Giu","Lug","Ago","Set","Ott","Nov","Dic"],today:"Oggi"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.ja",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.ja={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["1","2","3","4","5","6","7","8","9","10","11","12"],monthsShort:["1","2","3","4","5","6","7","8","9","10","11","12"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.kr",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.kr={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["1","2","3","4","5","6","7","8","9","10","11","12"],monthsShort:["1","2","3","4","5","6","7","8","9","10","11","12"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.lt",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.lt={days:["Sekmadienis","Pirmadienis","Antradienis","Treiadienis","Ketvirtadienis","Penktadienis","etadienis","Sekmadienis"],daysShort:["S","Pr","A","T","K","Pn","","S"],daysMin:["Sk","Pr","An","Tr","Ke","Pn","t","Sk"],months:["Sausis","Vasaris","Kovas","Balandis","Gegu","Birelis","Liepa","Rugpjtis","Rugsjis","Spalis","Lapkritis","Gruodis"],monthsShort:["Sau","Vas","Kov","Bal","Geg","Bir","Lie","Rugp","Rugs","Spa","Lap","Gru"],weekStart:1}}}}),timely.define("external_libs/locales/bootstrap-datepicker.lv",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.lv={days:["Svtdiena","Pirmdiena","Otrdiena","Trediena","Ceturtdiena","Piektdiena","Sestdiena","Svtdiena"],daysShort:["Sv","P","O","T","C","Pk","S","Sv"],daysMin:["Sv","Pr","Ot","Tr","Ce","Pk","St","Sv"],months:["Janvris","Februris","Marts","Aprlis","Maijs","Jnijs","Jlijs","Augusts","Septembris","Oktobris","Novembris","Decembris"],monthsShort:["Jan","Feb","Mar","Apr","Mai","Jn","Jl","Aug","Sep","Okt","Nov","Dec."],today:"odien",weekStart:1}}}}),timely.define("external_libs/locales/bootstrap-datepicker.ms",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.ms={days:["Ahad","Isnin","Selasa","Rabu","Khamis","Jumaat","Sabtu","Ahad"],daysShort:["Aha","Isn","Sel","Rab","Kha","Jum","Sab","Aha"],daysMin:["Ah","Is","Se","Ra","Kh","Ju","Sa","Ah"],months:["Januari","Februari","Mac","April","Mei","Jun","Julai","Ogos","September","Oktober","November","Disember"],monthsShort:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Ogo","Sep","Okt","Nov","Dis"],today:"Hari Ini"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.nb",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.nb={days:["Sndag","Mandag","Tirsdag","Onsdag","Torsdag","Fredag","Lrdag","Sndag"],daysShort:["Sn","Man","Tir","Ons","Tor","Fre","Lr","Sn"],daysMin:["S","Ma","Ti","On","To","Fr","L","S"],months:["Januar","Februar","Mars","April","Mai","Juni","Juli","August","September","Oktober","November","Desember"],monthsShort:["Jan","Feb","Mar","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Des"],today:"I Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.nl",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.nl={days:["Zondag","Maandag","Dinsdag","Woensdag","Donderdag","Vrijdag","Zaterdag","Zondag"],daysShort:["Zo","Ma","Di","Wo","Do","Vr","Za","Zo"],daysMin:["Zo","Ma","Di","Wo","Do","Vr","Za","Zo"],months:["Januari","Februari","Maart","April","Mei","Juni","Juli","Augustus","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mrt","Apr","Mei","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],today:"Vandaag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.pl",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.pl={days:["Niedziela","Poniedziaek","Wtorek","roda","Czwartek","Pitek","Sobota","Niedziela"],daysShort:["Nie","Pn","Wt","r","Czw","Pt","So","Nie"],daysMin:["N","Pn","Wt","r","Cz","Pt","So","N"],months:["Stycze","Luty","Marzec","Kwiecie","Maj","Czerwiec","Lipiec","Sierpie","Wrzesie","Padziernik","Listopad","Grudzie"],monthsShort:["Sty","Lu","Mar","Kw","Maj","Cze","Lip","Sie","Wrz","Pa","Lis","Gru"],today:"Dzisiaj"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.pt-BR",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates["pt-BR"]={days:["Domingo","Segunda","Tera","Quarta","Quinta","Sexta","Sbado","Domingo"],daysShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sb","Dom"],daysMin:["Do","Se","Te","Qu","Qu","Se","Sa","Do"],months:["Janeiro","Fevereiro","Maro","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthsShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],today:"Hoje"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.pt",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.pt={days:["Domingo","Segunda","Tera","Quarta","Quinta","Sexta","Sbado","Domingo"],daysShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sb","Dom"],daysMin:["Do","Se","Te","Qu","Qu","Se","Sa","Do"],months:["Janeiro","Fevereiro","Maro","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthsShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"]}}}}),timely.define("external_libs/locales/bootstrap-datepicker.ru",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.ru={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.sl",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.sl={days:["Nedelja","Ponedeljek","Torek","Sreda","etrtek","Petek","Sobota","Nedelja"],daysShort:["Ned","Pon","Tor","Sre","et","Pet","Sob","Ned"],daysMin:["Ne","Po","To","Sr","e","Pe","So","Ne"],months:["Januar","Februar","Marec","April","Maj","Junij","Julij","Avgust","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Avg","Sep","Okt","Nov","Dec"],today:"Danes"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.sv",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.sv={days:["Sndag","Mndag","Tisdag","Onsdag","Torsdag","Fredag","Lrdag","Sndag"],daysShort:["Sn","Mn","Tis","Ons","Tor","Fre","Lr","Sn"],daysMin:["S","M","Ti","On","To","Fr","L","S"],months:["Januari","Februari","Mars","April","Maj","Juni","Juli","Augusti","September","Oktober","November","December"],monthsShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],today:"I Dag"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.th",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.th={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["..","..","..","..","..","..","..","..","..","..","..",".."],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.tr",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates.tr={days:["Pazar","Pazartesi","Sal","aramba","Perembe","Cuma","Cumartesi","Pazar"],daysShort:["Pz","Pzt","Sal","r","Pr","Cu","Cts","Pz"],daysMin:["Pz","Pzt","Sa","r","Pr","Cu","Ct","Pz"],months:["Ocak","ubat","Mart","Nisan","Mays","Haziran","Temmuz","Austos","Eyll","Ekim","Kasm","Aralk"],monthsShort:["Oca","ub","Mar","Nis","May","Haz","Tem","Au","Eyl","Eki","Kas","Ara"],today:"Bugn"}}}}),timely.define("external_libs/locales/bootstrap-datepicker.zh-CN",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates["zh-CN"]={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""],today:""}}}}),timely.define("external_libs/locales/bootstrap-datepicker.zh-TW",["jquery_timely"],function(e){return{localize:function(){e.fn.datepicker.dates["zh-TW"]={days:["","","","","","","",""],daysShort:["","","","","","","",""],daysMin:["","","","","","","",""],months:["","","","","","","","","","","",""],monthsShort:["","","","","","","","","","","",""]}}}}),timely.define("external_libs/bootstrap_datepicker",["jquery_timely","ai1ec_config","external_libs/locales/bootstrap-datepicker.bg","external_libs/locales/bootstrap-datepicker.br","external_libs/locales/bootstrap-datepicker.cs","external_libs/locales/bootstrap-datepicker.da","external_libs/locales/bootstrap-datepicker.de","external_libs/locales/bootstrap-datepicker.es","external_libs/locales/bootstrap-datepicker.fi","external_libs/locales/bootstrap-datepicker.fr","external_libs/locales/bootstrap-datepicker.id","external_libs/locales/bootstrap-datepicker.is","external_libs/locales/bootstrap-datepicker.it","external_libs/locales/bootstrap-datepicker.ja","external_libs/locales/bootstrap-datepicker.kr","external_libs/locales/bootstrap-datepicker.lt","external_libs/locales/bootstrap-datepicker.lv","external_libs/locales/bootstrap-datepicker.ms","external_libs/locales/bootstrap-datepicker.nb","external_libs/locales/bootstrap-datepicker.nl","external_libs/locales/bootstrap-datepicker.pl","external_libs/locales/bootstrap-datepicker.pt-BR","external_libs/locales/bootstrap-datepicker.pt","external_libs/locales/bootstrap-datepicker.ru","external_libs/locales/bootstrap-datepicker.sl","external_libs/locales/bootstrap-datepicker.sv","external_libs/locales/bootstrap-datepicker.th","external_libs/locales/bootstrap-datepicker.tr","external_libs/locales/bootstrap-datepicker.zh-CN","external_libs/locales/bootstrap-datepicker.zh-TW"],function(e,t){function n(){return new Date(Date.UTC.apply(Date,arguments))}function r(){var e=new Date;return n(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate())}var i=function(n,r){var i=this;this.element=e(n),this.language=r.language||this.element.data("date-language")||t.language||"en",this.language=this.language in s?this.language:"en",this.format=o.parseFormat(r.format||this.element.data("date-format")||"mm/dd/yyyy"),this.picker=e(o.template).appendTo("body").on({click:e.proxy(this.click,this)}),this.isInput=this.element.is("input"),this.component=this.element.is(".date")?this.element.find(".add-on"):!1,this.hasInput=this.component&&this.element.find("input").length,this.component&&this.component.length===0&&(this.component=!1),this.isInput?this.element.on({focus:e.proxy(this.show,this),keyup:e.proxy(this.update,this),keydown:e.proxy(this.keydown,this)}):this.component&&this.hasInput?(this.element.find("input").on({focus:e.proxy(this.show,this),keyup:e.proxy(this.update,this),keydown:e.proxy(this.keydown,this)}),this.component.on("click",e.proxy(this.show,this))):this.element.on("click",e.proxy(this.show,this)),e(document).on("mousedown",function(t){e(t.target).closest(".datepicker").length==0&&i.hide()}),this.autoclose=!1,"autoclose"in r?this.autoclose=r.autoclose:"dateAutoclose"in this.element.data()&&(this.autoclose=this.element.data("date-autoclose")),this.keyboardNavigation=!0,"keyboardNavigation"in r?this.keyboardNavigation=r.keyboardNavigation:"dateKeyboardNavigation"in this.element.data()&&(this.keyboardNavigation=this.element.data("date-keyboard-navigation"));switch(r.startView||this.element.data("date-start-view")){case 2:case"decade":this.viewMode=this.startViewMode=2;break;case 1:case"year":this.viewMode=this.startViewMode=1;break;case 0:case"month":default:this.viewMode=this.startViewMode=0}this.todayBtn=r.todayBtn||this.element.data("date-today-btn")||!1,this.todayHighlight=r.todayHighlight||this.element.data("date-today-highlight")||!1,this.weekStart=(r.weekStart||this.element.data("date-weekstart")||s[this.language].weekStart||0)%7,this.weekEnd=(this.weekStart+6)%7,this.startDate=-Infinity,this.endDate=Infinity,this.setStartDate(r.startDate||this.element.data("date-startdate")),this.setEndDate(r.endDate||this.element.data("date-enddate")),this.fillDow(),this.fillMonths(),this.update(),this.showMode()};i.prototype={constructor:i,show:function(t){this.picker.show(),this.height=this.component?this.component.outerHeight():this.element.outerHeight(),this.update(),this.place(),e(window).on("resize",e.proxy(this.place,this)),t&&(t.stopPropagation(),t.preventDefault()),this.element.trigger({type:"show",date:this.date})},hide:function(t){this.picker.hide(),e(window).off("resize",this.place),this.viewMode=this.startViewMode,this.showMode(),this.isInput||e(document).off("mousedown",this.hide),t&&t.currentTarget.value&&this.setValue(),this.element.trigger({type:"hide",date:this.date})},getDate:function(){var e=this.getUTCDate();return new Date(e.getTime()+e.getTimezoneOffset()*6e4)},getUTCDate:function(){return this.date},setDate:function(e){this.setUTCDate(new Date(e.getTime()-e.getTimezoneOffset()*6e4))},setUTCDate:function(e){this.date=e,this.setValue()},setValue:function(){var e=o.formatDate(this.date,this.format,this.language);this.isInput?this.element.prop("value",e):(this.component&&this.element.find("input").prop("value",e),this.element.data("date",e))},setStartDate:function(e){this.startDate=e||-Infinity,this.startDate!==-Infinity&&(this.startDate=o.parseDate(this.startDate,this.format,this.language)),this.update(),this.updateNavArrows()},setEndDate:function(e){this.endDate=e||Infinity,this.endDate!==Infinity&&(this.endDate=o.parseDate(this.endDate,this.format,this.language)),this.update(),this.updateNavArrows()},place:function(){var t=parseInt(this.element.parents().filter(function(){return e(this).css("z-index")!="auto"}).first().css("z-index"))+10,n=this.component?this.component.offset():this.element.offset();this.picker.css({top:n.top+this.height,left:n.left,zIndex:t})},update:function(){this.date=o.parseDate(this.isInput?this.element.prop("value"):this.element.data("date")||this.element.find("input").prop("value"),this.format,this.language),this.date<this.startDate?this.viewDate=new Date(this.startDate):this.date>this.endDate?this.viewDate=new Date(this.endDate):this.viewDate=new Date(this.date),this.fill()},fillDow:function(){var e=this.weekStart,t="<tr>";while(e<this.weekStart+7)t+='<th class="dow">'+s[this.language].daysMin[e++%7]+"</th>";t+="</tr>",this.picker.find(".datepicker-days thead").append(t)},fillMonths:function(){var e="",t=0;while(t<12)e+='<span class="month">'+s[this.language].monthsShort[t++]+"</span>";this.picker.find(".datepicker-months td").html(e)},fill:function(){var e=new Date(this.viewDate),t=e.getUTCFullYear(),r=e.getUTCMonth(),i=this.startDate!==-Infinity?this.startDate.getUTCFullYear():-Infinity,u=this.startDate!==-Infinity?this.startDate.getUTCMonth():-Infinity,a=this.endDate!==Infinity?this.endDate.getUTCFullYear():Infinity,f=this.endDate!==Infinity?this.endDate.getUTCMonth():Infinity,l=this.date.valueOf(),c=new Date;this.picker.find(".datepicker-days thead th:eq(1)").text(s[this.language].months[r]+" "+t),this.picker.find("tfoot th.today").text(s[this.language].today).toggle(this.todayBtn),this.updateNavArrows(),this.fillMonths();var h=n(t,r-1,28,0,0,0,0),p=o.getDaysInMonth(h.getUTCFullYear(),h.getUTCMonth());h.setUTCDate(p),h.setUTCDate(p-(h.getUTCDay()-this.weekStart+7)%7);var d=new Date(h);d.setUTCDate(d.getUTCDate()+42),d=d.valueOf();var v=[],m;while(h.valueOf()<d){h.getUTCDay()==this.weekStart&&v.push("<tr>"),m="";if(h.getUTCFullYear()<t||h.getUTCFullYear()==t&&h.getUTCMonth()<r)m+=" old";else if(h.getUTCFullYear()>t||h.getUTCFullYear()==t&&h.getUTCMonth()>r)m+=" new";this.todayHighlight&&h.getUTCFullYear()==c.getFullYear()&&h.getUTCMonth()==c.getMonth()&&h.getUTCDate()==c.getDate()&&(m+=" today"),h.valueOf()==l&&(m+=" active");if(h.valueOf()<this.startDate||h.valueOf()>this.endDate)m+=" disabled";v.push('<td class="day'+m+'">'+h.getUTCDate()+"</td>"),h.getUTCDay()==this.weekEnd&&v.push("</tr>"),h.setUTCDate(h.getUTCDate()+1)}this.picker.find(".datepicker-days tbody").empty().append(v.join(""));var g=this.date.getUTCFullYear(),y=this.picker.find(".datepicker-months").find("th:eq(1)").text(t).end().find("span").removeClass("active");g==t&&y.eq(this.date.getUTCMonth()).addClass("active"),(t<i||t>a)&&y.addClass("disabled"),t==i&&y.slice(0,u).addClass("disabled"),t==a&&y.slice(f+1).addClass("disabled"),v="",t=parseInt(t/10,10)*10;var b=this.picker.find(".datepicker-years").find("th:eq(1)").text(t+"-"+(t+9)).end().find("td");t-=1;for(var w=-1;w<11;w++)v+='<span class="year'+(w==-1||w==10?" old":"")+(g==t?" active":"")+(t<i||t>a?" disabled":"")+'">'+t+"</span>",t+=1;b.html(v)},updateNavArrows:function(){var e=new Date(this.viewDate),t=e.getUTCFullYear(),n=e.getUTCMonth();switch(this.viewMode){case 0:this.startDate!==-Infinity&&t<=this.startDate.getUTCFullYear()&&n<=this.startDate.getUTCMonth()?this.picker.find(".prev").css({visibility:"hidden"}):this.picker.find(".prev").css({visibility:"visible"}),this.endDate!==Infinity&&t>=this.endDate.getUTCFullYear()&&n>=this.endDate.getUTCMonth()?this.picker.find(".next").css({visibility:"hidden"}):this.picker.find(".next").css({visibility:"visible"});break;case 1:case 2:this.startDate!==-Infinity&&t<=this.startDate.getUTCFullYear()?this.picker.find(".prev").css({visibility:"hidden"}):this.picker.find(".prev").css({visibility:"visible"}),this.endDate!==Infinity&&t>=this.endDate.getUTCFullYear()?this.picker.find(".next").css({visibility:"hidden"}):this.picker.find(".next").css({visibility:"visible"})}},click:function(t){t.stopPropagation(),t.preventDefault();var r=e(t.target).closest("span, td, th");if(r.length==1)switch(r[0].nodeName.toLowerCase()){case"th":switch(r[0].className){case"switch":this.showMode(1);break;case"prev":case"next":var i=o.modes[this.viewMode].navStep*(r[0].className=="prev"?-1:1);switch(this.viewMode){case 0:this.viewDate=this.moveMonth(this.viewDate,i);break;case 1:case 2:this.viewDate=this.moveYear(this.viewDate,i)}this.fill();break;case"today":var s=new Date;s.setUTCHours(0),s.setUTCMinutes(0),s.setUTCSeconds(0),s.setUTCMilliseconds(0),this.showMode(-2);var u=this.todayBtn=="linked"?null:"view";this._setDate(s,u)}break;case"span":if(!r.is(".disabled")){this.viewDate.setUTCDate(1);if(r.is(".month")){var a=r.parent().find("span").index(r);this.viewDate.setUTCMonth(a),this.element.trigger({type:"changeMonth",date:this.viewDate})}else{var f=parseInt(r.text(),10)||0;this.viewDate.setUTCFullYear(f),this.element.trigger({type:"changeYear",date:this.viewDate})}this.showMode(-1),this.fill()}break;case"td":if(r.is(".day")&&!r.is(".disabled")){var l=parseInt(r.text(),10)||1,f=this.viewDate.getUTCFullYear(),a=this.viewDate.getUTCMonth();r.is(".old")?a==0?(a=11,f-=1):a-=1:r.is(".new")&&(a==11?(a=0,f+=1):a+=1),this._setDate(n(f,a,l,0,0,0,0))}}},_setDate:function(e,t){if(!t||t=="date")this.date=e;if(!t||t=="view")this.viewDate=e;this.fill(),this.setValue(),this.element.trigger({type:"changeDate",date:this.date});var n;this.isInput?n=this.element:this.component&&(n=this.element.find("input")),n&&(n.change(),this.autoclose&&this.hide())},moveMonth:function(e,t){if(!t)return e;var n=new Date(e.valueOf()),r=n.getUTCDate(),i=n.getUTCMonth(),s=Math.abs(t),o,u;t=t>0?1:-1;if(s==1){u=t==-1?function(){return n.getUTCMonth()==i}:function(){return n.getUTCMonth()!=o},o=i+t,n.setUTCMonth(o);if(o<0||o>11)o=(o+12)%12}else{for(var a=0;a<s;a++)n=this.moveMonth(n,t);o=n.getUTCMonth(),n.setUTCDate(r),u=function(){return o!=n.getUTCMonth()}}while(u())n.setUTCDate(--r),n.setUTCMonth(o);return n},moveYear:function(e,t){return this.moveMonth(e,t*12)},dateWithinRange:function(e){return e>=this.startDate&&e<=this.endDate},keydown:function(e){if(this.picker.is(":not(:visible)")){e.keyCode==27&&this.show();return}var t=!1,n,r,i,s,o;switch(e.keyCode){case 27:this.hide(),e.preventDefault();break;case 37:case 39:if(!this.keyboardNavigation)break;n=e.keyCode==37?-1:1,e.ctrlKey?(s=this.moveYear(this.date,n),o=this.moveYear(this.viewDate,n)):e.shiftKey?(s=this.moveMonth(this.date,n),o=this.moveMonth(this.viewDate,n)):(s=new Date(this.date),s.setUTCDate(this.date.getUTCDate()+n),o=new Date(this.viewDate),o.setUTCDate(this.viewDate.getUTCDate()+n)),this.dateWithinRange(s)&&(this.date=s,this.viewDate=o,this.setValue(),this.update(),e.preventDefault(),t=!0);break;case 38:case 40:if(!this.keyboardNavigation)break;n=e.keyCode==38?-1:1,e.ctrlKey?(s=this.moveYear(this.date,n),o=this.moveYear(this.viewDate,n)):e.shiftKey?(s=this.moveMonth(this.date,n),o=this.moveMonth(this.viewDate,n)):(s=new Date(this.date),s.setUTCDate(this.date.getUTCDate()+n*7),o=new Date(this.viewDate),o.setUTCDate(this.viewDate.getUTCDate()+n*7)),this.dateWithinRange(s)&&(this.date=s,this.viewDate=o,this.setValue(),this.update(),e.preventDefault(),t=!0);break;case 13:this.hide(),e.preventDefault();break;case 9:this.hide()}if(t){this.element.trigger({type:"changeDate",date:this.date});var u;this.isInput?u=this.element:this.component&&(u=this.element.find("input")),u&&u.change()}},showMode:function(e){e&&(this.viewMode=Math.max(0,Math.min(2,this.viewMode+e))),this.picker.find(">div").hide().filter(".datepicker-"+o.modes[this.viewMode].clsName).show(),this.updateNavArrows()}},e.fn.datepicker=function(t){var n=Array.apply(null,arguments);return n.shift(),this.each(function(){var r=e(this),s=r.data("datepicker"),o=typeof t=="object"&&t;s||r.data("datepicker",s=new i(this,e.extend({},e.fn.datepicker.defaults,o))),typeof t=="string"&&typeof s[t]=="function"&&s[t].apply(s,n)})},e.fn.datepicker.defaults={},e.fn.datepicker.Constructor=i;var s=e.fn.datepicker.dates={en:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sun"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa","Su"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],today:"Today"}},o={modes:[{clsName:"days",navFnc:"Month",navStep:1},{clsName:"months",navFnc:"FullYear",navStep:1},{clsName:"years",navFnc:"FullYear",navStep:10}],isLeapYear:function(e){return e%4===0&&e%100!==0||e%400===0},getDaysInMonth:function(e,t){return[31,o.isLeapYear(e)?29:28,31,30,31,30,31,31,30,31,30,31][t]},validParts:/dd?|mm?|MM?|yy(?:yy)?/g,nonpunctuation:/[^ -\/:-@\[-`{-~\t\n\r]+/g,parseFormat:function(e){var t=e.replace(this.validParts,"\0").split("\0"),n=e.match(this.validParts);if(!t||!t.length||!n||n.length==0)throw new Error("Invalid date format.");return{separators:t,parts:n}},parseDate:function(t,r,o){if(t instanceof Date)return t;if(/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(t)){var u=/([-+]\d+)([dmwy])/,a=t.match(/([-+]\d+)([dmwy])/g),f,l;t=new Date;for(var c=0;c<a.length;c++){f=u.exec(a[c]),l=parseInt(f[1]);switch(f[2]){case"d":t.setUTCDate(t.getUTCDate()+l);break;case"m":t=i.prototype.moveMonth.call(i.prototype,t,l);break;case"w":t.setUTCDate(t.getUTCDate()+l*7);break;case"y":t=i.prototype.moveYear.call(i.prototype,t,l)}}return n(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate(),0,0,0)}var a=t&&t.match(this.nonpunctuation)||[],t=new Date,h={},p=["yyyy","yy","M","MM","m","mm","d","dd"],d={yyyy:function(e,t){return e.setUTCFullYear(t)},yy:function(e,t){return e.setUTCFullYear(2e3+t)},m:function(e,t){t-=1;while(t<0)t+=12;t%=12,e.setUTCMonth(t);while(e.getUTCMonth()!=t)e.setUTCDate(e.getUTCDate()-1);return e},d:function(e,t){return e.setUTCDate(t)}},v,m,f;d.M=d.MM=d.mm=d.m,d.dd=d.d,t=n(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate(),0,0,0);if(a.length==r.parts.length){for(var c=0,g=r.parts.length;c<g;c++){v=parseInt(a[c],10),f=r.parts[c];if(isNaN(v))switch(f){case"MM":m=e(s[o].months).filter(function(){var e=this.slice(0,a[c].length),t=a[c].slice(0,e.length);return e==t}),v=e.inArray(m[0],s[o].months)+1;break;case"M":m=e(s[o].monthsShort).filter(function(){var e=this.slice(0,a[c].length),t=a[c].slice(0,e.length);return e==t}),v=e.inArray(m[0],s[o].monthsShort)+1}h[f]=v}for(var c=0,y;c<p.length;c++)y=p[c],y in h&&d[y](t,h[y])}return t},formatDate:function(t,n,r){var i={d:t.getUTCDate(),m:t.getUTCMonth()+1,M:s[r].monthsShort[t.getUTCMonth()],MM:s[r].months[t.getUTCMonth()],yy:t.getUTCFullYear().toString().substring(2),yyyy:t.getUTCFullYear()};i.dd=(i.d<10?"0":"")+i.d,i.mm=(i.m<10?"0":"")+i.m;var t=[],o=e.extend([],n.separators);for(var u=0,a=n.parts.length;u<a;u++)o.length&&t.push(o.shift()),t.push(i[n.parts[u]]);return t.join("")},headTemplate:'<thead><tr><th class="prev"><i class="icon-arrow-left"/></th><th colspan="5" class="switch"></th><th class="next"><i class="icon-arrow-right"/></th></tr></thead>',contTemplate:'<tbody><tr><td colspan="7"></td></tr></tbody>',footTemplate:'<tfoot><tr><th colspan="7" class="today"></th></tr></tfoot>'};o.template='<div class="datepicker dropdown-menu"><div class="datepicker-days"><table class=" table-condensed">'+o.headTemplate+"<tbody></tbody>"+o.footTemplate+"</table>"+"</div>"+'<div class="datepicker-months">'+'<table class="table-condensed">'+o.headTemplate+o.contTemplate+o.footTemplate+"</table>"+"</div>"+'<div class="datepicker-years">'+'<table class="table-condensed">'+o.headTemplate+o.contTemplate+o.footTemplate+"</table>"+"</div>"+"</div>";for(var u=2,a=arguments.length;u<a;u++)arguments[u].localize()}),timely.define("external_libs/bootstrap_alert",["jquery_timely"],function(e){var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()},e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e(function(){e("body").on("click.alert.data-api",t,n.prototype.close)})}),timely.define("external_libs/jquery_cookie",["jquery_timely"],function(e){function n(e){return e}function r(e){return decodeURIComponent(e.replace(t," "))}function i(e){e.indexOf('"')===0&&(e=e.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,"\\"));try{return s.json?JSON.parse(e):e}catch(t){}}var t=/\+/g,s=e.cookie=function(t,o,u){if(o!==undefined){u=e.extend({},s.defaults,u);if(typeof u.expires=="number"){var a=u.expires,f=u.expires=new Date;f.setDate(f.getDate()+a)}return o=s.json?JSON.stringify(o):String(o),document.cookie=[s.raw?t:encodeURIComponent(t),"=",s.raw?o:encodeURIComponent(o),u.expires?"; expires="+u.expires.toUTCString():"",u.path?"; path="+u.path:"",u.domain?"; domain="+u.domain:"",u.secure?"; secure":""].join("")}var l=s.raw?n:r,c=document.cookie.split("; "),h=t?undefined:{};for(var p=0,d=c.length;p<d;p++){var v=c[p].split("="),m=l(v.shift()),g=l(v.join("="));if(t&&t===m){h=i(g);break}t||(h[m]=i(g))}return h};s.defaults={},e.removeCookie=function(t,n){return e.cookie(t)!==undefined?(e.cookie(t,"",e.extend({},n,{expires:-1})),!0):!1}}),timely.define("scripts/calendar/load_views",["jquery_timely","scripts/calendar/print","scripts/calendar/posterboard_view","scripts/calendar/agenda_view","scripts/calendar/month_view","libs/frontend_utils","libs/utils","ai1ec_calendar","ai1ec_config","scripts/common_scripts/frontend/common_frontend","libs/select2_multiselect_helper","external_libs/jquery_history","external_libs/jquery.tablescroller","external_libs/jquery.scrollTo","external_libs/bootstrap_datepicker","external_libs/bootstrap_alert","external_libs/jquery_cookie"],function(e,t,n,r,i,s,o,u,a,f,l){e.cookie.json=!0;var c="ai1ec_saved_filter",h=!e("#save_filtered_views").hasClass("hide"),p=function(){var t=e("#ai1ec-view-dropdown .dropdown-menu .active a"),r=a.week_view_ends_at-a.week_view_starts_at,s=r*60;e("table.ai1ec-week-view-original").tableScroll({height:s,containerClass:"ai1ec-week-view ai1ec-popover-boundary",scroll:!1}),e("table.ai1ec-oneday-view-original").tableScroll({height:s,containerClass:"ai1ec-oneday-view ai1ec-popover-boundary",scroll:!1});if(e(".ai1ec-week-view").length||e(".ai1ec-oneday-view").length)e(".ai1ec-oneday-view .tablescroll_wrapper, .ai1ec-week-view .tablescroll_wrapper").scrollTo(".ai1ec-hour-marker:eq("+a.week_view_starts_at+")"),e(".ai1ec-hour-marker:eq("+a.week_view_starts_at+")").addClass("ai1ec-first-visible");e(".ai1ec-month-view .ai1ec-multiday").length&&i.extend_multiday_events(),e(".ai1ec-posterboard-view").length&&n.resize_masonry()},d=function(){var t=e(".ai1ec-minical-trigger").data("datepicker");typeof t!="undefined"&&t.picker.parent(".timely").remove(),e(".tooltip.in, .ai1ec-popup").remove()},v=function(){var t=[],n=[],r=[],i;e(".ai1ec-category-filter .dropdown-menu .active").each(function(){t.push(e(this).data("term"))}),e(".ai1ec-tag-filter .dropdown-menu .active").each(function(){n.push(e(this).data("term"))}),e(".ai1ec-author-filter .dropdown-menu .active").each(function(){r.push(e(this).data("term"))});var s={};return s.cat_ids=t,s.tag_ids=n,s.auth_ids=r,i=e(".ai1ec-views-dropdown .dropdown-menu .active").data("action"),s.action=i,s},m=function(){var t=History.getState(),n=e.cookie(c);if(null===n||undefined===n)n={};var r=v();a.is_calendar_page?n.calendar_page=r:n[t.url]=r,e.cookie(c,n,{path:"/",expires:365}),e("#save_filtered_views").addClass("active").attr("data-original-title",a.clear_saved_filter_text);var i=o.make_alert(a.save_filter_text_ok,"success");e("#ai1ec-calendar").prepend(i)},g=function(t){t.stopImmediatePropagation();var n=e.cookie(c);if(a.is_calendar_page)delete n.calendar_page;else{var r=History.getState();delete n[r.url]}e.cookie(c,n,{path:"/",expires:365}),e("#save_filtered_views").removeClass("active").attr("data-original-title",a.reset_saved_filter_text),h||e("#save_filtered_views").addClass("hide");var i=o.make_alert(a.remove_filter_text_ok,"success");e("#ai1ec-calendar").prepend(i)},y=function(t,n){e("#ai1ec-calendar-view-loading").fadeIn("fast"),e("#ai1ec-calendar-view").fadeTo("fast",.3,function(){var r={request_type:n,ai1ec_doing_ajax:!0};e.ajax({url:t,dataType:n,data:r,method:"get",success:function(t){d(),typeof t.views_dropdown=="string"&&e(".ai1ec-views-dropdown").replaceWith(t.views_dropdown),typeof t.categories=="string"&&(e(".ai1ec-category-filter").replaceWith(t.categories),a.use_select2&&l.init(e(".ai1ec-category-filter"))),typeof t.authors=="string"&&(e(".ai1ec-author-filter").replaceWith(t.authors),a.use_select2&&l.init(e(".ai1ec-author-filter"))),typeof t.tags=="string"&&(e(".ai1ec-tag-filter").replaceWith(t.tags),a.use_select2&&l.init(e(".ai1ec-tag-filter"))),typeof t.subscribe_buttons=="string"&&e(".ai1ec-subscribe-container").replaceWith(t.subscribe_buttons),typeof t.save_view_btngroup=="string"&&e("#save_filtered_views").closest(".btn-group").replaceWith(t.save_view_btngroup),h=t.are_filters_set;var n=e("#ai1ec-calendar-view-container");n.height(n.height());var r=e("#ai1ec-calendar-view").html(t.html).height();n.animate({height:r},{complete:function(){n.height("auto")}}),e("#ai1ec-calendar-view-loading").fadeOut("fast"),e("#ai1ec-calendar-view").fadeTo("fast",1),p()}})})},b=function(e){var t=History.getState();t.data.ai1ec!==undefined&&!0===t.data.ai1ec&&y(t.url,"json")},w=function(e,t){if(e==="json"){var n={ai1ec:!0};History.pushState(n,null,t)}else y(t,"jsonp")},E=function(t){var n=e(this);t.preventDefault(),w(n.data("type"),n.attr("href"))},S=function(t){var n=e(this);t.preventDefault();if(typeof n.data("datepicker")=="undefined"){n.datepicker({todayBtn:"linked",todayHighlight:!0,templateOverrides:"headTemplate contTemplate",headTemplate:'<thead><tr class="datepicker-btn-group"><th class="prev"><div class="dp-btn"><i class="icon-arrow-left"/></div></th><th colspan="5" class="switch"><div class="dp-btn"></div></th><th class="next"><div class="dp-btn"><i class="icon-arrow-right"/></div></th></tr></thead>',contTemplate:'<tbody><tr><td colspan="7" class="grid-picker"></td></tr></tbody>'});var r=n.data("datepicker");r.picker.wrapAll('<div class="timely" />').addClass("ai1ec-right-aligned");var i=r.place;r.place=function(){i.call(this);var t=this.component?this.component:this.element,n=t.offset();this.picker.css({left:"auto",right:e(document).width()-n.left-t.outerWidth()})}}n.datepicker("show")},x=function(t){var n,r=e(this),i;r.datepicker("hide"),n=r.data("href"),i=r.data("date").replace(/\//g,"-"),n=n.replace("__DATE__",i),w(r.data("type"),n)},T=function(t){var n;typeof t.added!="undefined"?n=e(t.added.element).data("href"):n=e("option[value="+t.removed.id+"]",t.target).data("href"),data={ai1ec:!0},History.pushState(data,null,n)},N=function(){w(e(this).data("type"),e(this).data("href"))};return{initialize_view:p,handle_click_on_link_to_load_view:E,handle_minical_trigger:S,handle_minical_change_date:x,clear_filters:N,handle_state_change:b,load_view:y,save_current_filter:m,remove_current_filter:g,load_view_from_select2_filter:T}}),timely.define("libs/recaptcha",["jquery_timely","//www.google.com/recaptcha/api/js/recaptcha_ajax.js"],function(e){var t=function(t){var n=e(".ai1ec-recaptcha",t);if(n.length===0)return;if(n.is(".ai1ec-initializing, .ai1ec-initialized"))return;if(typeof Recaptcha=="undefined")return;Recaptcha.create(n.data("recaptchaKey"),n[0],{theme:"white",callback:function(){e("#recaptcha_response_field",n).attr("placeholder",n.data("placeholder")),n.removeClass("ai1ec-initializing").addClass("ai1ec-initialized")}}),n.addClass("ai1ec-initializing")};return{init_recaptcha:t}}),timely.define("external_libs/bootstrap_collapse",["jquery_timely"],function(e){var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning)return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning)return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}},e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=typeof n=="object"&&n;i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e(function(){e("body").on("click.collapse.data-api","[data-toggle=ai1ec_collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();e(i).collapse(s)})})}),timely.define("libs/collapse_helper",["jquery_timely","domReady","external_libs/bootstrap_collapse"],function(e,t){t(function(){e(document).on("click",'[data-toggle="ai1ec_collapse"]',function(){e(this).toggleClass("active"),e(".icon-caret-down, .icon-caret-up, .icon-chevron-down, .icon-chevron-up, .icon-arrow-down, .icon-arrow-up",this).toggleClass("hide")})})}),timely.define("external_libs/Placeholders",[],function(){function e(e,t,n){if(e.addEventListener)return e.addEventListener(t,n,!1);if(e.attachEvent)return e.attachEvent("on"+t,n)}function t(e,t){var n,r;for(n=0,r=e.length;n<r;n++)if(e[n]===t)return!0;return!1}function n(e,t){var n;e.createTextRange?(n=e.createTextRange(),n.move("character",t),n.select()):e.selectionStart&&(e.focus(),e.setSelectionRange(t,t))}function r(e,t){try{return e.type=t,!0}catch(n){return!1}}function P(e){var t;return e.value===e.getAttribute(h)&&e.getAttribute(p)==="true"?(e.setAttribute(p,"false"),e.value="",e.className=e.className.replace(f,""),t=e.getAttribute(d),t&&(e.type=t),!0):!1}function H(e){var t;return e.value===""?(e.setAttribute(p,"true"),e.value=e.getAttribute(h),e.className+=" "+a,t=e.getAttribute(d),t?e.type="text":e.type==="password"&&S.changeType(e,"text")&&e.setAttribute(d,"password"),!0):!1}function B(e,t){var n,r,i,s,o;if(e&&e.getAttribute(h))t(e);else{n=e?e.getElementsByTagName("input"):n,r=e?e.getElementsByTagName("textarea"):r;for(o=0,s=n.length+r.length;o<s;o++)i=o<n.length?n[o]:r[o-n.length],t(i)}}function j(e){B(e,P)}function F(e){B(e,H)}function I(e){return function(){x&&e.value===e.getAttribute(h)&&e.getAttribute(p)==="true"?S.moveCaret(e,0):P(e)}}function q(e){return function(){H(e)}}function R(e){return function(t){N=e.value;if(e.getAttribute(p)==="true")return N!==e.getAttribute(h)||!S.inArray(o,t.keyCode)}}function U(e){return function(){var t;e.getAttribute(p)==="true"&&e.value!==N&&(e.className=e.className.replace(f,""),e.value=e.value.replace(e.getAttribute(h),""),e.setAttribute(p,!1),t=e.getAttribute(d),t&&(e.type=t)),e.value===""&&(e.blur(),S.moveCaret(e,0))}}function z(e){return function(){e===document.activeElement&&e.value===e.getAttribute(h)&&e.getAttribute(p)==="true"&&S.moveCaret(e,0)}}function W(e){return function(){j(e)}}function X(e){e.form&&(O=e.form,O.getAttribute(v)||(S.addEventListener(O,"submit",W(O)),O.setAttribute(v,"true"))),S.addEventListener(e,"focus",I(e)),S.addEventListener(e,"blur",q(e)),x&&(S.addEventListener(e,"keydown",R(e)),S.addEventListener(e,"keyup",U(e)),S.addEventListener(e,"click",z(e))),e.setAttribute(m,"true"),e.setAttribute(h,L),H(e)}var i={Utils:{addEventListener:e,inArray:t,moveCaret:n,changeType:r}},s=["text","search","url","tel","email","password","number","textarea"],o=[27,33,34,35,36,37,38,39,40,8,46],u="#ccc",a="placeholdersjs",f=new RegExp("\\b"+a+"\\b"),l,c,h="data-placeholder-value",p="data-placeholder-active",d="data-placeholder-type",v="data-placeholder-submit",m="data-placeholder-bound",g="data-placeholder-focus",y="data-placeholder-live",b=document.createElement("input"),w=document.getElementsByTagName("head")[0],E=document.documentElement,S=i.Utils,x,T,N,C,k,L,A,O,M,_,D;if(b.placeholder===void 0){l=document.getElementsByTagName("input"),c=document.getElementsByTagName("textarea"),x=E.getAttribute(g)==="false",T=E.getAttribute(y)!=="false",C=document.createElement("style"),C.type="text/css",k=document.createTextNode("."+a+" { color:"+u+"; }"),C.styleSheet?C.styleSheet.cssText=k.nodeValue:C.appendChild(k),w.insertBefore(C,w.firstChild);for(D=0,_=l.length+c.length;D<_;D++)M=D<l.length?l[D]:c[D-l.length],L=M.getAttribute("placeholder"),L&&S.inArray(s,M.type)&&X(M);A=setInterval(function(){for(D=0,_=l.length+c.length;D<_;D++){M=D<l.length?l[D]:c[D-l.length],L=M.getAttribute("placeholder");if(L&&S.inArray(s,M.type)){M.getAttribute(m)||X(M);if(L!==M.getAttribute(h)||M.type==="password"&&!M.getAttribute(d))M.type==="password"&&!M.getAttribute(d)&&S.changeType(M,"text")&&M.setAttribute(d,"password"),M.value===M.getAttribute(h)&&(M.value=L),M.setAttribute(h,L)}}T||clearInterval(A)},100)}return i.disable=j,i.enable=F,i}),timely.define("scripts/calendar/submit_ics_modal",["jquery_timely","ai1ec_config","libs/utils","libs/recaptcha","libs/select2_multiselect_helper","libs/collapse_helper","external_libs/Placeholders"],function(e,t,n,r,i){var s=e(".ai1ec-submit-ics-form"),o=e("#ai1ec-submit-ics-modal .ai1ec-loading"),u=function(){r.init_recaptcha(s),i.init(s)},a=function(){r.init_recaptcha(s)},f=function(r){r.preventDefault(),e(".ai1ec-alerts",s).html("");var i=e("#ai1ec_calendar_url",s).val(),u=e("#ai1ec_submitter_email",s).val();if(i===""||u===""){var a=n.make_alert(t.mail_url_required,"error",!0);e(".ai1ec-alerts",s).append(a)}else{if(!n.isUrl(i)){var a=n.make_alert(t.invalid_url_message,"error",!0);e(".ai1ec-alerts",s).append(a),e("#ai1ec_calendar_url",s).focus();return}if(!n.isValidEmail(u)){var a=n.make_alert(t.invalid_email_message,"error",!0);e(".ai1ec-alerts",s).append(a),e("#ai1ec_submitter_email",s).focus();return}var f=s.serialize();o.addClass("show"),e.ajax({data:f+"&action=ai1ec_add_ics_frontend",type:"POST",dataType:"json",url:t.ajax_url,success:function(t){o.removeClass("show"),e("#recaptcha_response_field",s).length&&typeof Recaptcha!="undefined"&&Recaptcha.reload();var r=t.success?"success":"error",i=n.make_alert(t.message,r,!0);e(".ai1ec-alerts",s).append(i),e(".ai1ec-nonce-fields",s).html(t.nonce),"success"===r&&(e("#ai1ec_calendar_url, #ai1ec_submitter_email",s).val(""),e("#ai1ec_categories",s).select2("val",""))}})}};return{handle_form_submission:f,init_form:u,init_recaptcha:a}}),timely.define("external_libs/jquery.debouncedresize",["jquery_timely"],function(e){var t=e.event,n,r;n=t.special.debouncedresize={setup:function(){e(this).on("resize",n.handler)},teardown:function(){e(this).off("resize",n.handler)},handler:function(e,i){var s=this,o=arguments,u=function(){e.type="debouncedresize",t.dispatch.apply(s,o)};r&&clearTimeout(r),i?u():r=setTimeout(u,n.threshold)},threshold:150}}),timely.define("external_libs/bootstrap_transition",["jquery_timely"],function(e){e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}),timely.define("external_libs/bootstrap_modal",["jquery_timely"],function(e){var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="ai1ec_modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".ai1ec-modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(e){this.$element.hide().trigger("hidden"),this.backdrop()},removeBackdrop:function(){this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="ai1ec-modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,e.proxy(this.removeBackdrop,this)):this.removeBackdrop()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="ai1ec_modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}),timely.define("libs/modal_helper",["jquery_timely","domReady","external_libs/bootstrap_modal"],function(e,t){t(function(){var t=e("body");t.on("shown",".ai1ec-modal",function(){t.addClass("ai1ec-modal-open")}).on("hidden",".ai1ec-modal",function(){t.removeClass("ai1ec-modal-open")})})}),timely.define("scripts/calendar",["jquery_timely","domReady","scripts/calendar/load_views","scripts/calendar/print","scripts/calendar/agenda_view","scripts/calendar/posterboard_view","scripts/calendar/month_view","scripts/calendar/submit_ics_modal","ai1ec_calendar","ai1ec_config","scripts/common_scripts/frontend/common_frontend","libs/utils","libs/select2_multiselect_helper","external_libs/jquery.debouncedresize","external_libs/bootstrap_transition","libs/modal_helper","external_libs/jquery.scrollTo"],function(e,t,n,r,i,s,o,u,a,f,l,c,h){var p,d=function(){if(a.selector!==undefined&&a.selector!==""&&e(a.selector).length===1){var t=e(":header:contains("+a.title+"):first");t.length||(t=e('<h1 class="page-title"></h1>'),t.text(a.title));var n=e("#ai1ec-container").detach().before(t);e(a.selector).empty().append(n).hide().css("visibility","visible").fadeIn("fast")}},v=function(){var t=e("#ai1ec-create-event-modal");$timely=e('<div class="timely" />'),t.appendTo($timely),$timely.appendTo("body"),t.modal({show:!1}).one("show",function(){e(".ai1ec-ajax-placeholder",this).load(f.ajax_url+"?action=ai1ec_front_end_create_event_form",function(){e("> .ai1ec-loading",t).removeClass("show"),timely.require(["scripts/front_end_create_event_form"],function(e){p=e,e.start()})})}).on("show",function(){typeof p!="undefined"&&p.init_recaptcha()}).on("hidden",function(t){e(".ai1ec-recaptcha",this).removeClass("ai1ec-initializing ai1ec-initialized"),e(".ai1ec-modal-backdrop").remove(),Recaptcha.destroy()}),t.on("show hidden",".collapse",function(e){e.stopPropagation()})},m=function(){var t=e("#ai1ec-submit-ics-modal");$timely=e('<div class="timely" />'),t.appendTo($timely),$timely.appendTo("body"),t.modal({show:!1}).one("show",function(){u.init_form()}).on("show",function(){u.init_recaptcha()}).on("hidden",function(){e(".ai1ec-recaptcha",this).removeClass("ai1ec-initializing ai1ec-initialized"),e(".ai1ec-modal-backdrop").remove(),Recaptcha.destroy()}),t.on("show hidden",".collapse",function(e){e.stopPropagation()})},g=function(){var t=e(this).data("instanceId");e(".ai1ec-event-instance-id-"+t).addClass("ai1ec-hover")},y=function(){var t=e(this).data("instanceId");e(".ai1ec-event-instance-id-"+t).removeClass("ai1ec-hover")},b=function(){var t=e(this),n=t.data("instanceId");t.delay(500).queue(function(){e(".ai1ec-event-instance-id-"+n).addClass("ai1ec-raised")})},w=function(t){var n=e(this),r=n.data("instanceId"),i=e(t.toElement||t.relatedTarget);if(i.is(".ai1ec-event-instance-id-"+r)||i.parent().is(".ai1ec-event-instance-id-"+r))return;e(".ai1ec-event-instance-id-"+r).clearQueue().removeClass("ai1ec-raised")},E=function(){d(),v(),m()},S=function(){e(document).on({mouseenter:g,mouseleave:y},".ai1ec-event-container.ai1ec-multiday"),e(document).on({mouseenter:b,mouseleave:w},".ai1ec-oneday-view .ai1ec-oneday .ai1ec-event-container, .ai1ec-week-view .ai1ec-week .ai1ec-event-container"),e(document).on("click",".ai1ec-agenda-view .ai1ec-event-header",i.toggle_event),e(document).on("click","#ai1ec-agenda-expand-all",i.expand_all),e(document).on("click","#ai1ec-agenda-collapse-all",i.collapse_all),e.event.special.debouncedresize.threshold=400,e(window).on("debouncedresize",s.resize_masonry),e(document).on("click","a.ai1ec-load-view",n.handle_click_on_link_to_load_view),e(document).on("click",".ai1ec-minical-trigger",n.handle_minical_trigger),e(document).on("changeDate",".ai1ec-minical-trigger",n.handle_minical_change_date),e(document).on("click",".ai1ec-clear-filter",n.clear_filters),e(document).on("click","#ai1ec-print-button",r.handle_click_on_print_button),e(document).on("click",".ai1ec-reveal-full-day button",function(){e(this).fadeOut();var t=e(".ai1ec-oneday-view-original"),n=e(".ai1ec-week-view-original");n.length===0&&(n=t);var r=e(".tablescroll_wrapper").offset().top-n.offset().top;e(window).scrollTo("+="+r+"px",400);var i=1440;e(".tablescroll_wrapper").animate({height:i+"px"})}),e(document).on("submit",".ai1ec-submit-ics-form",u.handle_form_submission),e(document).on("click","#save_filtered_views:not(.active)",n.save_current_filter),e(document).on("click","#save_filtered_views.active",n.remove_current_filter),History.Adapter.bind(window,"statechange",n.handle_state_change)},x=function(){h.init(e(".ai1ec-select2-filters")),e(document).on("change",".ai1ec-select2-multiselect-selector",n.load_view_from_select2_filter)},T=function(){t(function(){E(),f.use_select2&&x(),S(),n.initialize_view()})};return{start:T}}),timely.require(["scripts/calendar"],function(e){e.start()}),timely.define("pages/calendar",function(){});
\ No newline at end of file
diff --git a/public/js/pages/common_backend.js b/public/js/pages/common_backend.js
new file mode 100644
index 0000000..1ddd3eb
--- /dev/null
+++ b/public/js/pages/common_backend.js
@@ -0,0 +1,93 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+
+/**
+	 * AJAX result after clicking Dismiss in license warning.
+	 * @param  {object} response Data returned by HTTP response
+	 */
+
+/**
+	 * Dismiss button clicked in invalid license warning.
+	 *
+	 * @param  {Event} e jQuery event object
+	 */
+
+/*
+ * The MIT License
+ *
+ * Copyright (c) 2012 James Allardice
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* ===========================================================
+   * bootstrap-tooltip.js v2.0.4
+   * http://twitter.github.com/bootstrap/javascript.html#tooltips
+   * Inspired by the original jQuery.tipsy by Jason Frame
+   * ===========================================================
+   * Copyright 2012 Twitter, Inc.
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   * http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   * ========================================================== */
+
+/* ===========================================================
+	 * bootstrap-popover.js v2.0.4
+	 * http://twitter.github.com/bootstrap/javascript.html#popovers
+	 * ===========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * =========================================================== */
+
+/* =========================================================
+	 * bootstrap-modal.js v2.2.2
+	 * http://twitter.github.com/bootstrap/javascript.html#modals
+	 * =========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * ========================================================= */
+
+timely.define("domReady",[],function(){function u(e){var t;for(t=0;t<e.length;t++)e[t](n)}function a(){var e=r;t&&e.length&&(r=[],u(e))}function f(){t||(t=!0,o&&clearInterval(o),a())}function c(e){return t?e(n):r.push(e),c}var e=typeof window!="undefined"&&window.document,t=!e,n=e?document:null,r=[],i,s,o;if(e){if(document.addEventListener)document.addEventListener("DOMContentLoaded",f,!1),window.addEventListener("load",f,!1);else if(window.attachEvent){window.attachEvent("onload",f),s=document.createElement("div");try{i=window.frameElement===null}catch(l){}s.doScroll&&i&&window.external&&(o=setInterval(function(){try{s.doScroll(),f()}catch(e){}},30))}(document.readyState==="complete"||document.readyState==="interactive")&&f()}return c.version="2.0.0",c.load=function(e,t,n,r){r.isBuild?n(null):c(n)},c}),timely.define("scripts/common_scripts/backend/common_ajax_handlers",["jquery_timely"],function(e){var t=function(t){t&&(typeof t.message!="undefined"?window.alert(t.message):e(".ai1ec-facebook-cron-dismiss-notification").closest(".message").fadeOut())},n=function(t){t.error?window.alert(t.message):e(".ai1ec-dismiss-notification").closest(".message").fadeOut()},r=function(t){t.error?window.alert(t.message):e(".ai1ec-dismiss-intro-video").closest(".message").fadeOut()},i=function(t){t.error?window.alert(t.message):e(".ai1ec-dismiss-license-warning").closest(".message").fadeOut()};return{handle_dismiss_plugins:t,handle_dismiss_notification:n,handle_dismiss_intro_video:r,handle_dismiss_license_warning:i}}),timely.define("scripts/common_scripts/backend/common_event_handlers",["jquery_timely","scripts/common_scripts/backend/common_ajax_handlers"],function(e,t){var n=function(n){var r={action:"ai1ec_facebook_cron_dismiss"};e.post(ajaxurl,r,t.handle_dismiss_plugins,"json")},r=function(n){var r=e(this);r.attr("disabled",!0);var i={action:"ai1ec_disable_notification",note:!1};e.post(ajaxurl,i,t.handle_dismiss_notification)},i=function(n){var r=e(this);r.attr("disabled",!0);var i={action:"ai1ec_disable_intro_video",note:!1};e.post(ajaxurl,i,t.handle_dismiss_intro_video)},s=function(n){var r=e(this);r.attr("disabled",!0);var i={action:"ai1ec_set_license_warning",value:"dismissed"};e.post(ajaxurl,i,t.handle_dismiss_license_warning)},o=function(t){e(this).parent().next(".ai1ec-limit-by-options-container").toggle()};return{dismiss_plugins_messages_handler:n,dismiss_notification_handler:r,dismiss_intro_video_handler:i,dismiss_license_warning_handler:s,handle_multiselect_containers_widget_page:o}}),timely.define("external_libs/Placeholders",[],function(){function e(e,t,n){if(e.addEventListener)return e.addEventListener(t,n,!1);if(e.attachEvent)return e.attachEvent("on"+t,n)}function t(e,t){var n,r;for(n=0,r=e.length;n<r;n++)if(e[n]===t)return!0;return!1}function n(e,t){var n;e.createTextRange?(n=e.createTextRange(),n.move("character",t),n.select()):e.selectionStart&&(e.focus(),e.setSelectionRange(t,t))}function r(e,t){try{return e.type=t,!0}catch(n){return!1}}function P(e){var t;return e.value===e.getAttribute(h)&&e.getAttribute(p)==="true"?(e.setAttribute(p,"false"),e.value="",e.className=e.className.replace(f,""),t=e.getAttribute(d),t&&(e.type=t),!0):!1}function H(e){var t;return e.value===""?(e.setAttribute(p,"true"),e.value=e.getAttribute(h),e.className+=" "+a,t=e.getAttribute(d),t?e.type="text":e.type==="password"&&S.changeType(e,"text")&&e.setAttribute(d,"password"),!0):!1}function B(e,t){var n,r,i,s,o;if(e&&e.getAttribute(h))t(e);else{n=e?e.getElementsByTagName("input"):n,r=e?e.getElementsByTagName("textarea"):r;for(o=0,s=n.length+r.length;o<s;o++)i=o<n.length?n[o]:r[o-n.length],t(i)}}function j(e){B(e,P)}function F(e){B(e,H)}function I(e){return function(){x&&e.value===e.getAttribute(h)&&e.getAttribute(p)==="true"?S.moveCaret(e,0):P(e)}}function q(e){return function(){H(e)}}function R(e){return function(t){N=e.value;if(e.getAttribute(p)==="true")return N!==e.getAttribute(h)||!S.inArray(o,t.keyCode)}}function U(e){return function(){var t;e.getAttribute(p)==="true"&&e.value!==N&&(e.className=e.className.replace(f,""),e.value=e.value.replace(e.getAttribute(h),""),e.setAttribute(p,!1),t=e.getAttribute(d),t&&(e.type=t)),e.value===""&&(e.blur(),S.moveCaret(e,0))}}function z(e){return function(){e===document.activeElement&&e.value===e.getAttribute(h)&&e.getAttribute(p)==="true"&&S.moveCaret(e,0)}}function W(e){return function(){j(e)}}function X(e){e.form&&(O=e.form,O.getAttribute(v)||(S.addEventListener(O,"submit",W(O)),O.setAttribute(v,"true"))),S.addEventListener(e,"focus",I(e)),S.addEventListener(e,"blur",q(e)),x&&(S.addEventListener(e,"keydown",R(e)),S.addEventListener(e,"keyup",U(e)),S.addEventListener(e,"click",z(e))),e.setAttribute(m,"true"),e.setAttribute(h,L),H(e)}var i={Utils:{addEventListener:e,inArray:t,moveCaret:n,changeType:r}},s=["text","search","url","tel","email","password","number","textarea"],o=[27,33,34,35,36,37,38,39,40,8,46],u="#ccc",a="placeholdersjs",f=new RegExp("\\b"+a+"\\b"),l,c,h="data-placeholder-value",p="data-placeholder-active",d="data-placeholder-type",v="data-placeholder-submit",m="data-placeholder-bound",g="data-placeholder-focus",y="data-placeholder-live",b=document.createElement("input"),w=document.getElementsByTagName("head")[0],E=document.documentElement,S=i.Utils,x,T,N,C,k,L,A,O,M,_,D;if(b.placeholder===void 0){l=document.getElementsByTagName("input"),c=document.getElementsByTagName("textarea"),x=E.getAttribute(g)==="false",T=E.getAttribute(y)!=="false",C=document.createElement("style"),C.type="text/css",k=document.createTextNode("."+a+" { color:"+u+"; }"),C.styleSheet?C.styleSheet.cssText=k.nodeValue:C.appendChild(k),w.insertBefore(C,w.firstChild);for(D=0,_=l.length+c.length;D<_;D++)M=D<l.length?l[D]:c[D-l.length],L=M.getAttribute("placeholder"),L&&S.inArray(s,M.type)&&X(M);A=setInterval(function(){for(D=0,_=l.length+c.length;D<_;D++){M=D<l.length?l[D]:c[D-l.length],L=M.getAttribute("placeholder");if(L&&S.inArray(s,M.type)){M.getAttribute(m)||X(M);if(L!==M.getAttribute(h)||M.type==="password"&&!M.getAttribute(d))M.type==="password"&&!M.getAttribute(d)&&S.changeType(M,"text")&&M.setAttribute(d,"password"),M.value===M.getAttribute(h)&&(M.value=L),M.setAttribute(h,L)}}T||clearInterval(A)},100)}return i.disable=j,i.enable=F,i}),timely.define("external_libs/bootstrap_tooltip",["jquery_timely"],function(e){if(!e.fn.tooltip){var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,this.options.trigger!="manual"&&(i=this.options.trigger=="hover"?"mouseenter":"focus",s=this.options.trigger=="hover"?"mouseleave":"blur",this.$element.on(i,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s,this.options.selector,e.proxy(this.leave,this))),this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,t,this.$element.data()),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);if(!n.options.delay||!n.options.delay.show)return n.show();clearTimeout(this.timeout),n.hoverState="in",this.timeout=setTimeout(function(){n.hoverState=="in"&&n.show()},n.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var e,t,n,r,i,s,o;if(this.hasContent()&&this.enabled){e=this.tip(),this.setContent(),this.options.animation&&e.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,t=/in/.test(s),e.remove().css({top:0,left:0,display:"block"}).appendTo(t?this.$element:document.body),n=this.getPosition(t),r=e[0].offsetWidth,i=e[0].offsetHeight;switch(t?s.split(" ")[1]:s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}e.css(o).addClass(s).addClass("in")}},isHTML:function(e){return typeof e!="string"||e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3||/^(?:[^<]*<[\w\W]+>[^>]*$)/.exec(e)},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.isHTML(t)?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function r(){var t=setTimeout(function(){n.off(e.support.transition.end).remove()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.remove()})}var t=this,n=this.tip();n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?r():n.remove()},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").removeAttr("title")},hasContent:function(){return this.getTitle()},getPosition:function(t){return e.extend({},t?{top:0,left:0}:this.$element.offset(),{width:this.$element[0].offsetWidth,height:this.$element[0].offsetHeight})},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(){this[this.tip().hasClass("in")?"hide":"show"]()}},e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover",title:"",delay:0}}}),timely.define("external_libs/bootstrap_popover",["jquery_timely","external_libs/bootstrap_tooltip"],function(e,t){if(!e.fn.popover){var n=function(e,t){this.init("popover",e,t)};n.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:n,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.isHTML(t)?"html":"text"](t),e.find(".popover-content > *")[this.isHTML(n)?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-content")||(typeof n.content=="function"?n.content.call(t[0]):n.content),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip}}),e.fn.popover=function(t){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof t=="object"&&t;i||r.data("popover",i=new n(this,s)),typeof t=="string"&&i[t]()})},e.fn.popover.Constructor=n,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",content:"",template:'<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'})}if(!e.fn.constrained_popover){var r=function(e,t){this.init("constrained_popover",e,t)};r.prototype=e.extend({},e.fn.popover.Constructor.prototype,{constructor:r,show:function(){var e,t,n,r,i,s,o,u,a={};if(this.hasContent()&&this.enabled){e=this.tip(),this.setContent(),this.options.animation&&e.addClass("fade"),o=typeof this.options.placement=="function"?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,t=/in/.test(o),e.remove().css({top:0,left:0,display:"block"}).appendTo(t?this.$element:document.body),n=this.getPosition(t),i=e[0].offsetWidth,s=e[0].offsetHeight;switch(t?o.split(" ")[1]:o){case"left":r=this.defineBounds(n),typeof r.top=="undefined"?a.top=n.top+n.height/2-s/2:a.top=r.top-s/2,typeof r.left=="undefined"?a.left=n.left-i:a.left=r.left-i,u={top:a.top,left:a.left};break;case"right":r=this.defineBounds(n),typeof r.top=="undefined"?a.top=n.top+n.height/2-s/2:a.top=r.top-s/2,typeof r.left=="undefined"?a.left=n.left+n.width:a.left=r.left+n.width,u={top:a.top,left:a.left}}e.css(u).addClass(o).addClass("in")}},defineBounds:function(t){var n,r,i,s,o,u,a={},f=e(this.options.container);return f.length?(r=f.offset(),i=r.top,s=r.left,o=i+f.height(),u=s+f.width(),t.top+t.height/2<i&&(a.top=i),t.top+t.height/2>o&&(a.top=o),t.left-t.width/2<s&&(a.left=s),t.left-t.width/2>u&&(a.left=u),a):!1}}),e.fn.constrained_popover=function(t){return this.each(function(){var n=e(this),i=n.data("constrained_popover"),s=typeof t=="object"&&t;i||n.data("constrained_popover",i=new r(this,s)),typeof t=="string"&&i[t]()})},e.fn.constrained_popover.Constructor=r,e.fn.constrained_popover.defaults=e.extend({},e.fn.popover.defaults,{container:"",content:this.options})}}),timely.define("external_libs/bootstrap_modal",["jquery_timely"],function(e){var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="ai1ec_modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".ai1ec-modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(e){this.$element.hide().trigger("hidden"),this.backdrop()},removeBackdrop:function(){this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="ai1ec-modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,e.proxy(this.removeBackdrop,this)):this.removeBackdrop()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="ai1ec_modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}),timely.define("libs/modal_helper",["jquery_timely","domReady","external_libs/bootstrap_modal"],function(e,t){t(function(){var t=e("body");t.on("shown",".ai1ec-modal",function(){t.addClass("ai1ec-modal-open")}).on("hidden",".ai1ec-modal",function(){t.removeClass("ai1ec-modal-open")})})}),timely.define("scripts/common_scripts/backend/common_backend",["jquery_timely","domReady","ai1ec_config","scripts/common_scripts/backend/common_event_handlers","external_libs/Placeholders","external_libs/bootstrap_tooltip","external_libs/bootstrap_popover","libs/modal_helper"],function(e,t,n,r){var i=function(){e("#ai1ec-facebook-filter option[value=exportable]:selected").length>0&&e("table.wp-list-table tr.no-items").length===0&&n.facebook_logged_in==="1"&&(e("<option>").val("export-facebook").text("Export to facebook").appendTo("select[name='action']"),e("<option>").val("export-facebook").text("Export to facebook").appendTo("select[name='action2']"))},s=function(){if(n.platform_active==="1"){e("#menu-posts-ai1ec_event li").each(function(){var t=e(this);if(t.has('a[href$="all-in-one-event-calendar-themes"], a[href$="all-in-one-event-calendar-edit-css"], a[href$="all-in-one-event-calendar-settings"]').length){if(t.is(".current")){var n=e("a",t).attr("href");e('#adminmenu a:not(.current)[href="'+n+'"]').parent().andSelf().addClass("current").end().closest("li.menu-top").find("> a.menu-top").andSelf().addClass("wp-has-current-submenu wp-menu-open").removeClass("wp-not-current-submenu"),t.closest("li.menu-top").find("> a.menu-top").andSelf().removeClass("wp-has-current-submenu wp-menu-open").addClass("wp-not-current-submenu")}t.hide()}});if(e("body.options-reading-php").length){var t=function(){e("#page_on_front").attr("disabled","disabled")};t(),e("#front-static-pages input:radio").change(t),e("#page_on_front").after('<span class="description">'+n.page_on_front_description+"</span>")}n.strict_mode==="1"&&(e("#dashboard-widgets .postbox").not("#ai1ec-calendar-tasks, #dashboard_right_now").remove(),e("#adminmenu > li").not(".wp-menu-separator, #menu-dashboard, #menu-posts-ai1ec_event, #menu-media, #menu-appearance, #menu-users, #menu-settings").remove(),e("#menu-appearance > .wp-submenu li, #menu-settings > .wp-submenu li").not(':has(a[href*="all-in-one-event-calendar"])').remove())}},o=function(){e("#ai1ec-video").length&&(e.ajax({cache:!0,async:!0,dataType:"script",url:"//www.youtube.com/iframe_api"}),window.onYouTubeIframeAPIReady=function(){var t=new YT.Player("ai1ec-video",{height:"368",width:"600",videoId:window.ai1ecVideo.youtubeId});e("#ai1ec-video").css("display","block"),e("#ai1ec-video-modal").on("hide",function(){t.stopVideo()})})},u=function(){e(document).on("click",".ai1ec-facebook-cron-dismiss-notification",r.dismiss_plugins_messages_handler).on("click",".ai1ec-dismiss-notification",r.dismiss_notification_handler).on("click",".ai1ec-dismiss-intro-video",r.dismiss_intro_video_handler).on("click",".ai1ec-dismiss-license-warning",r.dismiss_license_warning_handler).on("click",".ai1ec-limit-by-cat, .ai1ec-limit-by-tag, .ai1ec-limit-by-event",r.handle_multiselect_containers_widget_page)},a=function(){e("#ai1ec-support .ai1ec-download a[title]").popover({placement:"left"}),e(".ai1ec-tooltip-toggle").tooltip()};n.page!==""&&(e(".if-js-closed").removeClass("if-js-closed").addClass("closed"),postboxes.add_postbox_toggles(n.page));var f=function(){t(function(){i(),o(),u(),s(),a()})};return{start:f}}),timely.require(["scripts/common_scripts/backend/common_backend"],function(e){e.start()}),timely.define("pages/common_backend",function(){});
\ No newline at end of file
diff --git a/public/js/pages/common_frontend.js b/public/js/pages/common_frontend.js
new file mode 100644
index 0000000..f83478f
--- /dev/null
+++ b/public/js/pages/common_frontend.js
@@ -0,0 +1,92 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+
+/**
+ * jQuery Masonry v2.1.05
+ * A dynamic layout plugin for jQuery
+ * The flip-side of CSS Floats
+ * http://masonry.desandro.com
+ *
+ * Licensed under the MIT license.
+ * Copyright 2012 David DeSandro
+ */
+
+/*
+   * smartresize: debounced resize event for jQuery
+   *
+   * latest version and complete README available on Github:
+   * https://github.com/louisremi/jquery.smartresize.js
+   *
+   * Copyright 2011 @louis_remi
+   * Licensed under the MIT license.
+   */
+
+/*!
+   * jQuery imagesLoaded plugin v1.1.0
+   * http://github.com/desandro/imagesloaded
+   *
+   * MIT License. by Paul Irish et al.
+   */
+
+/* ===========================================================
+   * bootstrap-tooltip.js v2.0.4
+   * http://twitter.github.com/bootstrap/javascript.html#tooltips
+   * Inspired by the original jQuery.tipsy by Jason Frame
+   * ===========================================================
+   * Copyright 2012 Twitter, Inc.
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   * http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   * ========================================================== */
+
+/* ===========================================================
+	 * bootstrap-popover.js v2.0.4
+	 * http://twitter.github.com/bootstrap/javascript.html#popovers
+	 * ===========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * =========================================================== */
+
+/* ============================================================
+			 * bootstrap-dropdown.js v2.0.3
+			 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
+			 * ============================================================
+			 * Copyright 2012 Twitter, Inc.
+			 *
+			 * Licensed under the Apache License, Version 2.0 (the "License");
+			 * you may not use this file except in compliance with the License.
+			 * You may obtain a copy of the License at
+			 *
+			 * http://www.apache.org/licenses/LICENSE-2.0
+			 *
+			 * Unless required by applicable law or agreed to in writing, software
+			 * distributed under the License is distributed on an "AS IS" BASIS,
+			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+			 * See the License for the specific language governing permissions and
+			 * limitations under the License.
+			 * ============================================================ */
+
+timely.define("domReady",[],function(){function u(e){var t;for(t=0;t<e.length;t++)e[t](n)}function a(){var e=r;t&&e.length&&(r=[],u(e))}function f(){t||(t=!0,o&&clearInterval(o),a())}function c(e){return t?e(n):r.push(e),c}var e=typeof window!="undefined"&&window.document,t=!e,n=e?document:null,r=[],i,s,o;if(e){if(document.addEventListener)document.addEventListener("DOMContentLoaded",f,!1),window.addEventListener("load",f,!1);else if(window.attachEvent){window.attachEvent("onload",f),s=document.createElement("div");try{i=window.frameElement===null}catch(l){}s.doScroll&&i&&window.external&&(o=setInterval(function(){try{s.doScroll(),f()}catch(e){}},30))}(document.readyState==="complete"||document.readyState==="interactive")&&f()}return c.version="2.0.0",c.load=function(e,t,n,r){r.isBuild?n(null):c(n)},c}),timely.define("external_libs/jquery.masonry",["jquery_timely"],function(e){(function(e,t,n){var r=t.event,i;r.special.smartresize={setup:function(){t(this).bind("resize",r.special.smartresize.handler)},teardown:function(){t(this).unbind("resize",r.special.smartresize.handler)},handler:function(e,n){var r=this,s=arguments;e.type="smartresize",i&&clearTimeout(i),i=setTimeout(function(){t.event.handle.apply(r,s)},n==="execAsap"?0:100)}},t.fn.smartresize=function(e){return e?this.bind("smartresize",e):this.trigger("smartresize",["execAsap"])},t.Mason=function(e,n){this.element=t(n),this._create(e),this._init()},t.Mason.settings={isResizable:!0,isAnimated:!1,animationOptions:{queue:!1,duration:500},gutterWidth:0,isRTL:!1,isFitWidth:!1,containerStyle:{position:"relative"}},t.Mason.prototype={_filterFindBricks:function(e){var t=this.options.itemSelector;return t?e.filter(t).add(e.find(t)):e},_getBricks:function(e){var t=this._filterFindBricks(e).css({position:"absolute"}).addClass("masonry-brick");return t},_create:function(n){this.options=t.extend(!0,{},t.Mason.settings,n),this.styleQueue=[];var r=this.element[0].style;this.originalStyle={height:r.height||""};var i=this.options.containerStyle;for(var s in i)this.originalStyle[s]=r[s]||"";this.element.css(i),this.horizontalDirection=this.options.isRTL?"right":"left",this.offset={x:parseInt(this.element.css("padding-"+this.horizontalDirection),10),y:parseInt(this.element.css("padding-top"),10)},this.isFluid=this.options.columnWidth&&typeof this.options.columnWidth=="function";var o=this;setTimeout(function(){o.element.addClass("masonry")},0),this.options.isResizable&&t(e).bind("smartresize.masonry",function(){o.resize()}),this.reloadItems()},_init:function(e){this._getColumns(),this._reLayout(e)},option:function(e,n){t.isPlainObject(e)&&(this.options=t.extend(!0,this.options,e))},layout:function(e,t){for(var n=0,r=e.length;n<r;n++)this._placeBrick(e[n]);var i={};i.height=Math.max.apply(Math,this.colYs);if(this.options.isFitWidth){var s=0;n=this.cols;while(--n){if(this.colYs[n]!==0)break;s++}i.width=(this.cols-s)*this.columnWidth-this.options.gutterWidth}this.styleQueue.push({$el:this.element,style:i});var o=this.isLaidOut?this.options.isAnimated?"animate":"css":"css",u=this.options.animationOptions,a;for(n=0,r=this.styleQueue.length;n<r;n++)a=this.styleQueue[n],a.$el[o](a.style,u);this.styleQueue=[],t&&t.call(e),this.isLaidOut=!0},_getColumns:function(){var e=this.options.isFitWidth?this.element.parent():this.element,t=e.width();this.columnWidth=this.isFluid?this.options.columnWidth(t):this.options.columnWidth||this.$bricks.outerWidth(!0)||t,this.columnWidth+=this.options.gutterWidth,this.cols=Math.floor((t+this.options.gutterWidth)/this.columnWidth),this.cols=Math.max(this.cols,1)},_placeBrick:function(e){var n=t(e),r,i,s,o,u;r=Math.ceil(n.outerWidth(!0)/this.columnWidth),r=Math.min(r,this.cols);if(r===1)s=this.colYs;else{i=this.cols+1-r,s=[];for(u=0;u<i;u++)o=this.colYs.slice(u,u+r),s[u]=Math.max.apply(Math,o)}var a=Math.min.apply(Math,s),f=0;for(var l=0,c=s.length;l<c;l++)if(s[l]===a){f=l;break}var h={top:a+this.offset.y};h[this.horizontalDirection]=this.columnWidth*f+this.offset.x,this.styleQueue.push({$el:n,style:h});var p=a+n.outerHeight(!0),d=this.cols+1-c;for(l=0;l<d;l++)this.colYs[f+l]=p},resize:function(){var e=this.cols;this._getColumns(),(this.isFluid||this.cols!==e)&&this._reLayout()},_reLayout:function(e){var t=this.cols;this.colYs=[];while(t--)this.colYs.push(0);this.layout(this.$bricks,e)},reloadItems:function(){this.$bricks=this._getBricks(this.element.children())},reload:function(e){this.reloadItems(),this._init(e)},appended:function(e,t,n){if(t){this._filterFindBricks(e).css({top:this.element.height()});var r=this;setTimeout(function(){r._appended(e,n)},1)}else this._appended(e,n)},_appended:function(e,t){var n=this._getBricks(e);this.$bricks=this.$bricks.add(n),this.layout(n,t)},remove:function(e){this.$bricks=this.$bricks.not(e),e.remove()},destroy:function(){this.$bricks.removeClass("masonry-brick").each(function(){this.style.position="",this.style.top="",this.style.left=""});var n=this.element[0].style;for(var r in this.originalStyle)n[r]=this.originalStyle[r];this.element.unbind(".masonry").removeClass("masonry").removeData("masonry"),t(e).unbind(".masonry")}},t.fn.imagesLoaded=function(e){function u(){e.call(n,r)}function a(e){var n=e.target;n.src!==s&&t.inArray(n,o)===-1&&(o.push(n),--i<=0&&(setTimeout(u),r.unbind(".imagesLoaded",a)))}var n=this,r=n.find("img").add(n.filter("img")),i=r.length,s="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",o=[];return i||u(),r.bind("load.imagesLoaded error.imagesLoaded",a).each(function(){var e=this.src;this.src=s,this.src=e}),n};var s=function(t){e.console&&e.console.error(t)};t.fn.masonry=function(e){if(typeof e=="string"){var n=Array.prototype.slice.call(arguments,1);this.each(function(){var r=t.data(this,"masonry");if(!r){s("cannot call methods on masonry prior to initialization; attempted to call method '"+e+"'");return}if(!t.isFunction(r[e])||e.charAt(0)==="_"){s("no such method '"+e+"' for masonry instance");return}r[e].apply(r,n)})}else this.each(function(){var n=t.data(this,"masonry");n?(n.option(e||{}),n._init()):t.data(this,"masonry",new t.Mason(e,this))});return this}})(window,e)}),timely.define("scripts/calendar/posterboard_view",["jquery_timely","external_libs/jquery.masonry"],function(e,t){var n=function(){var t=e(".ai1ec-posterboard-view"),n=e("> .ai1ec-event",t),r,i,s;if(t.length===0)return;r=t.parent().width(),i=t.data("ai1ecTileMinWidth"),s=Math.floor(r/i),s=Math.min(s,n.length),i=Math.floor(r/s),t.css("width","auto"),n.width(i),t.imagesLoaded(function(){var n=e("#ai1ec-calendar-view-loading");t.masonry({itemSelector:".ai1ec-event",isFitWidth:!0,isResizable:!1,isAnimated:!0,columnWidth:i,animationOptions:{easing:"swing"}})}),t.imagesLoaded(function(){t.masonry("reload")})},r=function(){e(".ai1ec-posterboard-view").masonry("reload")};return{resize_masonry:n,reload_masonry:r}}),timely.define("scripts/common_scripts/frontend/common_event_handlers",["jquery_timely","scripts/calendar/posterboard_view"],function(e,t){var n=function(t){var n=e(this),r=n.next(".ai1ec-popup"),i,s,o;if(r.length===0)return;i=r.html(),s=r.attr("class");var u=n.closest("#ai1ec-calendar-view");u.length===0&&(u=e("body")),n.offset().left-u.offset().left>182?o="left":o="right",n.constrained_popover({content:i,title:"",placement:o,trigger:"manual",html:!0,template:'<div class="timely popover '+s+'"><div class="arrow"></div><div class="popover-inner">'+'<div class="popover-content"><div></div></div></div></div></div>',container:n.closest(".ai1ec-popover-boundary")}).constrained_popover("show")},r=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".ai1ec-popup").length===0&&e(this).constrained_popover("hide")},i=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".tooltip").length===0&&(e(this).remove(),e("body > .tooltip").remove())},s=function(t){var n=e(this),r={template:'<div class="timely tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"manual"};if(n.is(".ai1ec-category .ai1ec-color-swatch"))return;n.tooltip(r),n.tooltip("show")},o=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".tooltip").length===0&&e(this).tooltip("hide")},u=function(t){var n=e(t.toElement||t.relatedTarget);n.closest(".ai1ec-tooltip-trigger").length===0&&e(this).remove(),n.closest(".ai1ec-popup").length===0&&e("body > .ai1ec-popup").remove()},a=function(n){t.resize_masonry(),e("html").is("#ie8")};return{handle_popover_over:n,handle_popover_out:r,handle_popover_self_out:i,handle_tooltip_over:s,handle_tooltip_out:o,handle_tooltip_self_out:u,handle_fonts_loaded:a}}),timely.define("external_libs/modernizr",[],function(){var e=function(e,t,n){function S(e){f.cssText=e}function x(e,t){return S(h.join(e+";")+(t||""))}function T(e,t){return typeof e===t}function N(e,t){return!!~(""+e).indexOf(t)}function C(e,t,r){for(var i in e){var s=t[e[i]];if(s!==n)return r===!1?e[i]:T(s,"function")?s.bind(r||t):s}return!1}var r="2.5.3",i={},s=!0,o=t.documentElement,u="modernizr",a=t.createElement(u),f=a.style,l,c={}.toString,h=" -webkit- -moz- -o- -ms- ".split(" "),p={},d={},v={},m=[],g=m.slice,y,b=function(e,n,r,i){var s,a,f,l=t.createElement("div"),c=t.body,h=c?c:t.createElement("body");if(parseInt(r,10))while(r--)f=t.createElement("div"),f.id=i?i[r]:u+(r+1),l.appendChild(f);return s=["&#173;","<style>",e,"</style>"].join(""),l.id=u,(c?l:h).innerHTML+=s,h.appendChild(l),c||(h.style.background="",o.appendChild(h)),a=n(l,e),c?l.parentNode.removeChild(l):h.parentNode.removeChild(h),!!a},w={}.hasOwnProperty,E;!T(w,"undefined")&&!T(w.call,"undefined")?E=function(e,t){return w.call(e,t)}:E=function(e,t){return t in e&&T(e.constructor.prototype[t],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(t){var n=this;if(typeof n!="function")throw new TypeError;var r=g.call(arguments,1),i=function(){if(this instanceof i){var e=function(){};e.prototype=n.prototype;var s=new e,o=n.apply(s,r.concat(g.call(arguments)));return Object(o)===o?o:s}return n.apply(t,r.concat(g.call(arguments)))};return i});var k=function(n,r){var s=n.join(""),o=r.length;b(s,function(n,r){var s=t.styleSheets[t.styleSheets.length-1],u=s?s.cssRules&&s.cssRules[0]?s.cssRules[0].cssText:s.cssText||"":"",a=n.childNodes,f={};while(o--)f[a[o].id]=a[o];i.touch="ontouchstart"in e||e.DocumentTouch&&t instanceof DocumentTouch||(f.touch&&f.touch.offsetTop)===9},o,r)}([,["@media (",h.join("touch-enabled),("),u,")","{#touch{top:9px;position:absolute}}"].join("")],[,"touch"]);p.touch=function(){return i.touch};for(var L in p)E(p,L)&&(y=L.toLowerCase(),i[y]=p[L](),m.push((i[y]?"":"no-")+y));return S(""),a=l=null,i._version=r,i._prefixes=h,i.testStyles=b,o.className=o.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(s?" js "+m.join(" "):""),i}(window,window.document);return e}),timely.define("external_libs/bootstrap_tooltip",["jquery_timely"],function(e){if(!e.fn.tooltip){var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,this.options.trigger!="manual"&&(i=this.options.trigger=="hover"?"mouseenter":"focus",s=this.options.trigger=="hover"?"mouseleave":"blur",this.$element.on(i,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s,this.options.selector,e.proxy(this.leave,this))),this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,t,this.$element.data()),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);if(!n.options.delay||!n.options.delay.show)return n.show();clearTimeout(this.timeout),n.hoverState="in",this.timeout=setTimeout(function(){n.hoverState=="in"&&n.show()},n.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var e,t,n,r,i,s,o;if(this.hasContent()&&this.enabled){e=this.tip(),this.setContent(),this.options.animation&&e.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,t=/in/.test(s),e.remove().css({top:0,left:0,display:"block"}).appendTo(t?this.$element:document.body),n=this.getPosition(t),r=e[0].offsetWidth,i=e[0].offsetHeight;switch(t?s.split(" ")[1]:s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}e.css(o).addClass(s).addClass("in")}},isHTML:function(e){return typeof e!="string"||e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3||/^(?:[^<]*<[\w\W]+>[^>]*$)/.exec(e)},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.isHTML(t)?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function r(){var t=setTimeout(function(){n.off(e.support.transition.end).remove()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.remove()})}var t=this,n=this.tip();n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?r():n.remove()},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").removeAttr("title")},hasContent:function(){return this.getTitle()},getPosition:function(t){return e.extend({},t?{top:0,left:0}:this.$element.offset(),{width:this.$element[0].offsetWidth,height:this.$element[0].offsetHeight})},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(){this[this.tip().hasClass("in")?"hide":"show"]()}},e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover",title:"",delay:0}}}),timely.define("external_libs/bootstrap_popover",["jquery_timely","external_libs/bootstrap_tooltip"],function(e,t){if(!e.fn.popover){var n=function(e,t){this.init("popover",e,t)};n.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:n,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.isHTML(t)?"html":"text"](t),e.find(".popover-content > *")[this.isHTML(n)?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-content")||(typeof n.content=="function"?n.content.call(t[0]):n.content),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip}}),e.fn.popover=function(t){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof t=="object"&&t;i||r.data("popover",i=new n(this,s)),typeof t=="string"&&i[t]()})},e.fn.popover.Constructor=n,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",content:"",template:'<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'})}if(!e.fn.constrained_popover){var r=function(e,t){this.init("constrained_popover",e,t)};r.prototype=e.extend({},e.fn.popover.Constructor.prototype,{constructor:r,show:function(){var e,t,n,r,i,s,o,u,a={};if(this.hasContent()&&this.enabled){e=this.tip(),this.setContent(),this.options.animation&&e.addClass("fade"),o=typeof this.options.placement=="function"?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,t=/in/.test(o),e.remove().css({top:0,left:0,display:"block"}).appendTo(t?this.$element:document.body),n=this.getPosition(t),i=e[0].offsetWidth,s=e[0].offsetHeight;switch(t?o.split(" ")[1]:o){case"left":r=this.defineBounds(n),typeof r.top=="undefined"?a.top=n.top+n.height/2-s/2:a.top=r.top-s/2,typeof r.left=="undefined"?a.left=n.left-i:a.left=r.left-i,u={top:a.top,left:a.left};break;case"right":r=this.defineBounds(n),typeof r.top=="undefined"?a.top=n.top+n.height/2-s/2:a.top=r.top-s/2,typeof r.left=="undefined"?a.left=n.left+n.width:a.left=r.left+n.width,u={top:a.top,left:a.left}}e.css(u).addClass(o).addClass("in")}},defineBounds:function(t){var n,r,i,s,o,u,a={},f=e(this.options.container);return f.length?(r=f.offset(),i=r.top,s=r.left,o=i+f.height(),u=s+f.width(),t.top+t.height/2<i&&(a.top=i),t.top+t.height/2>o&&(a.top=o),t.left-t.width/2<s&&(a.left=s),t.left-t.width/2>u&&(a.left=u),a):!1}}),e.fn.constrained_popover=function(t){return this.each(function(){var n=e(this),i=n.data("constrained_popover"),s=typeof t=="object"&&t;i||n.data("constrained_popover",i=new r(this,s)),typeof t=="string"&&i[t]()})},e.fn.constrained_popover.Constructor=r,e.fn.constrained_popover.defaults=e.extend({},e.fn.popover.defaults,{container:"",content:this.options})}}),timely.define("external_libs/bootstrap_dropdown",["jquery_timely","domReady"],function(e,t){if(!e.fn.dropdown){var n='[data-toggle="dropdown"]',r=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};r.prototype={constructor:r,toggle:function(t){var n=e(this),r,s,o;if(n.is(".disabled, :disabled"))return;return s=n.attr("data-target"),s||(s=n.attr("href"),s=s&&s.replace(/.*(?=#[^\s]*$)/,"")),r=e(s),r.length||(r=n.parent()),o=r.hasClass("open"),i(),o||r.toggleClass("open"),!1}};function i(){e(n).parent().removeClass("open")}e.fn.dropdown=function(t){return this.each(function(){var n=e(this),i=n.data("dropdown");i||n.data("dropdown",i=new r(this)),typeof t=="string"&&i[t].call(n)})},e.fn.dropdown.Constructor=r,t(function(){e(document).on("click.dropdown.data-api",i),e(document).on("click.dropdown",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown.data-api",n,r.prototype.toggle)})}}),timely.define("scripts/common_scripts/frontend/common_frontend",["jquery_timely","domReady","scripts/common_scripts/frontend/common_event_handlers","ai1ec_calendar","external_libs/modernizr","external_libs/bootstrap_tooltip","external_libs/bootstrap_popover","external_libs/bootstrap_dropdown"],function(e,t,n,r,i){var s=!1,o=function(){s=!0,e(document).on("mouseenter",".ai1ec-popup-trigger",n.handle_popover_over),e(document).on("mouseleave",".ai1ec-popup-trigger",n.handle_popover_out),e(document).on("mouseleave",".ai1ec-popup",n.handle_popover_self_out),e(document).on("mouseenter",".ai1ec-tooltip-trigger",n.handle_tooltip_over),e(document).on("mouseleave",".ai1ec-tooltip-trigger",n.handle_tooltip_out),e(document).on("mouseleave",".tooltip",n.handle_tooltip_self_out)},u=function(){var t=[],i=[];e.each(r.fonts,function(){t.push(this.name),i.push(this.url)});var s={active:n.handle_fonts_loaded,custom:{families:t,urls:i}};timely.require(["external_libs/webfont"],function(){WebFont.load(s)})},a=function(){u(),t(function(){o()})},f=function(){return s};return{start:a,are_event_listeners_attached:f}}),timely.require(["scripts/common_scripts/frontend/common_frontend"],function(e){e.start()}),timely.define("pages/common_frontend",function(){});
\ No newline at end of file
diff --git a/public/js/pages/event.js b/public/js/pages/event.js
new file mode 100644
index 0000000..247c268
--- /dev/null
+++ b/public/js/pages/event.js
@@ -0,0 +1,26 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+
+/* =========================================================
+	 * bootstrap-modal.js v2.2.2
+	 * http://twitter.github.com/bootstrap/javascript.html#modals
+	 * =========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * ========================================================= */
+
+timely.define("domReady",[],function(){function u(e){var t;for(t=0;t<e.length;t++)e[t](n)}function a(){var e=r;t&&e.length&&(r=[],u(e))}function f(){t||(t=!0,o&&clearInterval(o),a())}function c(e){return t?e(n):r.push(e),c}var e=typeof window!="undefined"&&window.document,t=!e,n=e?document:null,r=[],i,s,o;if(e){if(document.addEventListener)document.addEventListener("DOMContentLoaded",f,!1),window.addEventListener("load",f,!1);else if(window.attachEvent){window.attachEvent("onload",f),s=document.createElement("div");try{i=window.frameElement===null}catch(l){}s.doScroll&&i&&window.external&&(o=setInterval(function(){try{s.doScroll(),f()}catch(e){}},30))}(document.readyState==="complete"||document.readyState==="interactive")&&f()}return c.version="2.0.0",c.load=function(e,t,n,r){r.isBuild?n(null):c(n)},c}),timely.define("scripts/event/gmaps_helper",["jquery_timely"],function(e){var t=function(){var e={zoom:14,mapTypeId:google.maps.MapTypeId.ROADMAP},t=new google.maps.Map(document.getElementById("ai1ec-gmap-canvas"),e),n=new google.maps.Marker({map:t}),r=new google.maps.Geocoder;r.geocode({address:document.getElementById("ai1ec-gmap-address").value},function(e,r){r===google.maps.GeocoderStatus.OK&&(t.setCenter(e[0].geometry.location),n.setPosition(e[0].geometry.location))})},n=function(){var t=e(".ai1ec-gmap-container-hidden:first");e(this).remove(),t.hide(),t.removeClass("ai1ec-gmap-container-hidden"),t.fadeIn()};return{handle_show_map_when_clicking_on_placeholder:n,init_gmaps:t}}),timely.define("external_libs/bootstrap_tab",["jquery_timely"],function(e){var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active a").last()[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}},e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e(function(){e("body").on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})})}),timely.define("libs/utils",["jquery_timely","external_libs/bootstrap_tab"],function(e){var t=function(){return{is_float:function(e){return!isNaN(parseFloat(e))},is_valid_coordinate:function(e,t){var n=t?90:180;return this.is_float(e)&&Math.abs(e)<n},convert_comma_to_dot:function(e){return e.replace(",",".")},field_has_value:function(t){var n="#"+t,r=e(n),i=!1;return r.length===1&&(i=e.trim(r.val())!==""),i},make_alert:function(t,n,r){var i="";switch(n){case"error":i="alert alert-error";break;case"success":i="alert alert-success";break;default:i="alert"}var s=e("<div />",{"class":i,html:t});if(!r){var o=e("<a />",{"class":"close","data-dismiss":"alert",href:"#",text:"x"});s.prepend(o)}return s},get_ajax_url:function(){return typeof window.ajaxurl=="undefined"?"http://localhost/wordpress/wp-admin/admin-ajax.php":window.ajaxurl},isUrl:function(e){var t=/(http|https|webcal):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;return t.test(e)},isValidEmail:function(e){var t=/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;return t.test(e)},activate_saved_tab_on_page_load:function(t){null===t||undefined===t?e("ul.nav-tabs a:first").tab("show"):e("ul.nav-tabs a[href="+t+"]").tab("show")}}}();return t}),timely.define("external_libs/jquery_cookie",["jquery_timely"],function(e){function n(e){return e}function r(e){return decodeURIComponent(e.replace(t," "))}function i(e){e.indexOf('"')===0&&(e=e.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,"\\"));try{return s.json?JSON.parse(e):e}catch(t){}}var t=/\+/g,s=e.cookie=function(t,o,u){if(o!==undefined){u=e.extend({},s.defaults,u);if(typeof u.expires=="number"){var a=u.expires,f=u.expires=new Date;f.setDate(f.getDate()+a)}return o=s.json?JSON.stringify(o):String(o),document.cookie=[s.raw?t:encodeURIComponent(t),"=",s.raw?o:encodeURIComponent(o),u.expires?"; expires="+u.expires.toUTCString():"",u.path?"; path="+u.path:"",u.domain?"; domain="+u.domain:"",u.secure?"; secure":""].join("")}var l=s.raw?n:r,c=document.cookie.split("; "),h=t?undefined:{};for(var p=0,d=c.length;p<d;p++){var v=c[p].split("="),m=l(v.shift()),g=l(v.join("="));if(t&&t===m){h=i(g);break}t||(h[m]=i(g))}return h};s.defaults={},e.removeCookie=function(t,n){return e.cookie(t)!==undefined?(e.cookie(t,"",e.extend({},n,{expires:-1})),!0):!1}}),timely.define("external_libs/bootstrap_modal",["jquery_timely"],function(e){var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="ai1ec_modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".ai1ec-modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(e){this.$element.hide().trigger("hidden"),this.backdrop()},removeBackdrop:function(){this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="ai1ec-modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,e.proxy(this.removeBackdrop,this)):this.removeBackdrop()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="ai1ec_modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}),timely.define("external_libs/bootstrap_transition",["jquery_timely"],function(e){e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}),timely.define("external_libs/bootstrap_alert",["jquery_timely"],function(e){var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()},e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e(function(){e("body").on("click.alert.data-api",t,n.prototype.close)})}),timely.define("libs/modal_helper",["jquery_timely","domReady","external_libs/bootstrap_modal"],function(e,t){t(function(){var t=e("body");t.on("shown",".ai1ec-modal",function(){t.addClass("ai1ec-modal-open")}).on("hidden",".ai1ec-modal",function(){t.removeClass("ai1ec-modal-open")})})}),timely.define("scripts/event",["jquery_timely","domReady","ai1ec_config","scripts/event/gmaps_helper","libs/utils","external_libs/jquery_cookie","external_libs/bootstrap_modal","external_libs/bootstrap_transition","external_libs/bootstrap_alert","libs/modal_helper"],function(e,t,n,r,i){var s="ai1ec_event_subscribed";e.cookie.json=!0;var o=function(){e("#ai1ec-gmap-canvas").length>0&&timely.require(["libs/gmaps"],function(e){e(r.init_gmaps)})},u=function(t){t.preventDefault();var r=e("#ai1ec_email_subscribe").val();if(!i.isValidEmail(r)){window.alert(n.invalid_email_message),e("#ai1ec_email_subscribe").focus();return}var o=e(".ai1ec_email_container").data("event_id"),u=e(".ai1ec_email_container").data("event_instance"),a={action:"ai1ec_subscribe_to_event",mail:r,event:o,event_instance:u};e.post(n.ajax_url,a,function(t){var n=i.make_alert(t.message,t.type);$modal=e("#ai1ec_subscribe_email_modal"),e(".alerts",$modal).append(n);if(t.type==="success"){var r=e.cookie(s);undefined===r&&(r=[]),r.push(u),e.cookie(s,r,{expires:365}),e(".ai1ec-subscribe-mail").remove()}e(".btn-danger",$modal).show(),e(".btn-primary",$modal).hide(),e(".ai1ec_email_container",$modal).hide()},"json")},a=function(){$modal=e("#ai1ec_subscribe_email_modal"),e(".ai1ec-gmap-placeholder:first").click(r.handle_show_map_when_clicking_on_placeholder),$modal.modal({show:!1}).on("hidden",function(){e(".ai1ec-modal-backdrop").remove()}),$modal.on("click",".btn-primary",u),$modal.on("click",".btn-danger",function(){$modal.modal("hide")})},f=function(){t(function(){o(),a()})};return{start:f}}),timely.require(["scripts/event"],function(e){e.start()}),timely.define("pages/event",function(){});
\ No newline at end of file
diff --git a/public/js/pages/event_category.js b/public/js/pages/event_category.js
new file mode 100644
index 0000000..abf3610
--- /dev/null
+++ b/public/js/pages/event_category.js
@@ -0,0 +1,7 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+
+timely.define("external_libs/colorpicker",["jquery_timely"],function(e){var t=function(){var t={},n,r=65,i,s='<div class="colorpicker"><div class="colorpicker_color"><div><div></div></div></div><div class="colorpicker_hue"><div></div></div><div class="colorpicker_new_color"></div><div class="colorpicker_current_color"></div><div class="colorpicker_hex"><input type="text" maxlength="6" size="6" /></div><div class="colorpicker_rgb_r colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_g colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_h colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_s colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_submit"></div></div>',o={eventName:"click",onShow:function(){},onBeforeShow:function(){},onHide:function(){},onChange:function(){},onSubmit:function(){},color:"ff0000",livePreview:!0,flat:!1},u=function(t,n){var r=q(t);e(n).data("colorpicker").fields.eq(1).val(r.r).end().eq(2).val(r.g).end().eq(3).val(r.b).end()},a=function(t,n){e(n).data("colorpicker").fields.eq(4).val(t.h).end().eq(5).val(t.s).end().eq(6).val(t.b).end()},f=function(t,n){e(n).data("colorpicker").fields.eq(0).val(U(t)).end()},l=function(t,n){e(n).data("colorpicker").selector.css("backgroundColor","#"+U({h:t.h,s:100,b:100})),e(n).data("colorpicker").selectorIndic.css({left:parseInt(150*t.s/100,10),top:parseInt(150*(100-t.b)/100,10)})},c=function(t,n){e(n).data("colorpicker").hue.css("top",parseInt(150-150*t.h/360,10))},h=function(t,n){e(n).data("colorpicker").currentColor.css("backgroundColor","#"+U(t))},p=function(t,n){e(n).data("colorpicker").newColor.css("backgroundColor","#"+U(t))},d=function(t){var n=t.charCode||t.keyCode||-1;if(n>r&&n<=90||n==32)return!1;var i=e(this).parent().parent();i.data("colorpicker").livePreview===!0&&v.apply(this)},v=function(t){var n=e(this).parent().parent(),r;this.parentNode.className.indexOf("_hex")>0?n.data("colorpicker").color=r=F(B(this.value)):this.parentNode.className.indexOf("_hsb")>0?n.data("colorpicker").color=r=P({h:parseInt(n.data("colorpicker").fields.eq(4).val(),10),s:parseInt(n.data("colorpicker").fields.eq(5).val(),10),b:parseInt(n.data("colorpicker").fields.eq(6).val(),10)}):n.data("colorpicker").color=r=I(H({r:parseInt(n.data("colorpicker").fields.eq(1).val(),10),g:parseInt(n.data("colorpicker").fields.eq(2).val(),10),b:parseInt(n.data("colorpicker").fields.eq(3).val(),10)})),t&&(u(r,n.get(0)),f(r,n.get(0)),a(r,n.get(0))),l(r,n.get(0)),c(r,n.get(0)),p(r,n.get(0)),n.data("colorpicker").onChange.apply(n,[r,U(r),q(r)])},m=function(t){var n=e(this).parent().parent();n.data("colorpicker").fields.parent().removeClass("colorpicker_focus")},g=function(){r=this.parentNode.className.indexOf("_hex")>0?70:65,e(this).parent().parent().data("colorpicker").fields.parent().removeClass("colorpicker_focus"),e(this).parent().addClass("colorpicker_focus")},y=function(t){var n=e(this).parent().find("input").focus(),r={el:e(this).parent().addClass("colorpicker_slider"),max:this.parentNode.className.indexOf("_hsb_h")>0?360:this.parentNode.className.indexOf("_hsb")>0?100:255,y:t.pageY,field:n,val:parseInt(n.val(),10),preview:e(this).parent().parent().data("colorpicker").livePreview};e(document).bind("mouseup",r,w),e(document).bind("mousemove",r,b)},b=function(e){return e.data.field.val(Math.max(0,Math.min(e.data.max,parseInt(e.data.val+e.pageY-e.data.y,10)))),e.data.preview&&v.apply(e.data.field.get(0),[!0]),!1},w=function(t){return v.apply(t.data.field.get(0),[!0]),t.data.el.removeClass("colorpicker_slider").find("input").focus(),e(document).unbind("mouseup",w),e(document).unbind("mousemove",b),!1},E=function(t){var n={cal:e(this).parent(),y:e(this).offset().top};n.preview=n.cal.data("colorpicker").livePreview,e(document).bind("mouseup",n,x),e(document).bind("mousemove",n,S)},S=function(e){return v.apply(e.data.cal.data("colorpicker").fields.eq(4).val(parseInt(360*(150-Math.max(0,Math.min(150,e.pageY-e.data.y)))/150,10)).get(0),[e.data.preview]),!1},x=function(t){return u(t.data.cal.data("colorpicker").color,t.data.cal.get(0)),f(t.data.cal.data("colorpicker").color,t.data.cal.get(0)),e(document).unbind("mouseup",x),e(document).unbind("mousemove",S),!1},T=function(t){var n={cal:e(this).parent(),pos:e(this).offset()};n.preview=n.cal.data("colorpicker").livePreview,e(document).bind("mouseup",n,C),e(document).bind("mousemove",n,N)},N=function(e){return v.apply(e.data.cal.data("colorpicker").fields.eq(6).val(parseInt(100*(150-Math.max(0,Math.min(150,e.pageY-e.data.pos.top)))/150,10)).end().eq(5).val(parseInt(100*Math.max(0,Math.min(150,e.pageX-e.data.pos.left))/150,10)).get(0),[e.data.preview]),!1},C=function(t){return u(t.data.cal.data("colorpicker").color,t.data.cal.get(0)),f(t.data.cal.data("colorpicker").color,t.data.cal.get(0)),e(document).unbind("mouseup",C),e(document).unbind("mousemove",N),!1},k=function(t){e(this).addClass("colorpicker_focus")},L=function(t){e(this).removeClass("colorpicker_focus")},A=function(t){var n=e(this).parent(),r=n.data("colorpicker").color;n.data("colorpicker").origColor=r,h(r,n.get(0)),n.data("colorpicker").onSubmit(r,U(r),q(r),n.data("colorpicker").el)},O=function(t){var n=e("#"+e(this).data("colorpickerId"));n.data("colorpicker").onBeforeShow.apply(this,[n.get(0)]);var r=e(this).offset(),i=D(),s=e("#tag-color").offset(),o=s.top+e("#tag-color").height(),u=s.left+1;return n.css({left:u+"px",top:o+"px"}),n.data("colorpicker").onShow.apply(this,[n.get(0)])!=0&&n.show(),e(document).bind("mousedown",{cal:n},M),!1},M=function(t){_(t.data.cal.get(0),t.target,t.data.cal.get(0))||(t.data.cal.data("colorpicker").onHide.apply(this,[t.data.cal.get(0)])!=0&&t.data.cal.hide(),e(document).unbind("mousedown",M))},_=function(e,t,n){if(e==t)return!0;if(e.contains)return e.contains(t);if(e.compareDocumentPosition)return!!(e.compareDocumentPosition(t)&16);var r=t.parentNode;while(r&&r!=n){if(r==e)return!0;r=r.parentNode}return!1},D=function(){var e=document.compatMode=="CSS1Compat";return{l:window.pageXOffset||(e?document.documentElement.scrollLeft:document.body.scrollLeft),t:window.pageYOffset||(e?document.documentElement.scrollTop:document.body.scrollTop),w:window.innerWidth||(e?document.documentElement.clientWidth:document.body.clientWidth),h:window.innerHeight||(e?document.documentElement.clientHeight:document.body.clientHeight)}},P=function(e){return{h:Math.min(360,Math.max(0,e.h)),s:Math.min(100,Math.max(0,e.s)),b:Math.min(100,Math.max(0,e.b))}},H=function(e){return{r:Math.min(255,Math.max(0,e.r)),g:Math.min(255,Math.max(0,e.g)),b:Math.min(255,Math.max(0,e.b))}},B=function(e){var t=6-e.length;if(t>0){var n=[];for(var r=0;r<t;r++)n.push("0");n.push(e),e=n.join("")}return e},j=function(e){var e=parseInt(e.indexOf("#")>-1?e.substring(1):e,16);return{r:e>>16,g:(e&65280)>>8,b:e&255}},F=function(e){return I(j(e))},I=function(e){var t={h:0,s:0,b:0},n=Math.min(e.r,e.g,e.b),r=Math.max(e.r,e.g,e.b),i=r-n;return t.b=r,r!=0,t.s=r!=0?255*i/r:0,t.s!=0?e.r==r?t.h=(e.g-e.b)/i:e.g==r?t.h=2+(e.b-e.r)/i:t.h=4+(e.r-e.g)/i:t.h=-1,t.h*=60,t.h<0&&(t.h+=360),t.s*=100/255,t.b*=100/255,t},q=function(e){var t={},n=Math.round(e.h),r=Math.round(e.s*255/100),i=Math.round(e.b*255/100);if(r==0)t.r=t.g=t.b=i;else{var s=i,o=(255-r)*i/255,u=(s-o)*(n%60)/60;n==360&&(n=0),n<60?(t.r=s,t.b=o,t.g=o+u):n<120?(t.g=s,t.b=o,t.r=s-u):n<180?(t.g=s,t.r=o,t.b=o+u):n<240?(t.b=s,t.r=o,t.g=s-u):n<300?(t.b=s,t.g=o,t.r=o+u):n<360?(t.r=s,t.g=o,t.b=s-u):(t.r=0,t.g=0,t.b=0)}return{r:Math.round(t.r),g:Math.round(t.g),b:Math.round(t.b)}},R=function(t){var n=[t.r.toString(16),t.g.toString(16),t.b.toString(16)];return e.each(n,function(e,t){t.length==1&&(n[e]="0"+t)}),n.join("")},U=function(e){return R(q(e))},z=function(){var t=e(this).parent(),n=t.data("colorpicker").origColor;t.data("colorpicker").color=n,u(n,t.get(0)),f(n,t.get(0)),a(n,t.get(0)),l(n,t.get(0)),c(n,t.get(0)),p(n,t.get(0))};return{init:function(t){t=e.extend({},o,t||{});if(typeof t.color=="string")t.color=F(t.color);else if(t.color.r!=undefined&&t.color.g!=undefined&&t.color.b!=undefined)t.color=I(t.color);else{if(t.color.h==undefined||t.color.s==undefined||t.color.b==undefined)return this;t.color=P(t.color)}return this.each(function(){if(!e(this).data("colorpickerId")){var n=e.extend({},t);n.origColor=t.color;var r="collorpicker_"+parseInt(Math.random()*1e3);e(this).data("colorpickerId",r);var i=e(s).attr("id",r);n.flat?i.appendTo(this).show():i.appendTo(document.body),n.fields=i.find("input").bind("keyup",d).bind("change",v).bind("blur",m).bind("focus",g),i.find("span").bind("mousedown",y).end().find(">div.colorpicker_current_color").bind("click",z),n.selector=i.find("div.colorpicker_color").bind("mousedown",T),n.selectorIndic=n.selector.find("div div"),n.el=this,n.hue=i.find("div.colorpicker_hue div"),i.find("div.colorpicker_hue").bind("mousedown",E),n.newColor=i.find("div.colorpicker_new_color"),n.currentColor=i.find("div.colorpicker_current_color"),i.data("colorpicker",n),i.find("div.colorpicker_submit").bind("mouseenter",k).bind("mouseleave",L).bind("click",A),u(n.color,i.get(0)),a(n.color,i.get(0)),f(n.color,i.get(0)),c(n.color,i.get(0)),l(n.color,i.get(0)),h(n.color,i.get(0)),p(n.color,i.get(0)),n.flat?i.css({position:"relative",display:"block"}):e(this).bind(n.eventName,O)}})},showPicker:function(){return this.each(function(){e(this).data("colorpickerId")&&O.apply(this)})},hidePicker:function(){return this.each(function(){e(this).data("colorpickerId")&&e("#"+e(this).data("colorpickerId")).hide()})},setColor:function(t){if(typeof t=="string")t=F(t);else if(t.r!=undefined&&t.g!=undefined&&t.b!=undefined)t=I(t);else{if(t.h==undefined||t.s==undefined||t.b==undefined)return this;t=P(t)}return this.each(function(){if(e(this).data("colorpickerId")){var n=e("#"+e(this).data("colorpickerId"));n.data("colorpicker").color=t,n.data("colorpicker").origColor=t,u(t,n.get(0)),a(t,n.get(0)),f(t,n.get(0)),c(t,n.get(0)),l(t,n.get(0)),h(t,n.get(0)),p(t,n.get(0))}})}}}();e.fn.extend({ColorPicker:t.init,ColorPickerHide:t.hidePicker,ColorPickerShow:t.showPicker,ColorPickerSetColor:t.setColor})}),timely.define("domReady",[],function(){function u(e){var t;for(t=0;t<e.length;t++)e[t](n)}function a(){var e=r;t&&e.length&&(r=[],u(e))}function f(){t||(t=!0,o&&clearInterval(o),a())}function c(e){return t?e(n):r.push(e),c}var e=typeof window!="undefined"&&window.document,t=!e,n=e?document:null,r=[],i,s,o;if(e){if(document.addEventListener)document.addEventListener("DOMContentLoaded",f,!1),window.addEventListener("load",f,!1);else if(window.attachEvent){window.attachEvent("onload",f),s=document.createElement("div");try{i=window.frameElement===null}catch(l){}s.doScroll&&i&&window.external&&(o=setInterval(function(){try{s.doScroll(),f()}catch(e){}},30))}(document.readyState==="complete"||document.readyState==="interactive")&&f()}return c.version="2.0.0",c.load=function(e,t,n,r){r.isBuild?n(null):c(n)},c}),timely.define("external_libs/tax_meta_class",["jquery_timely","domReady"],function(e,t){function n(){e(".at-date").each(function(){var t=e(this),n=t.attr("rel");t.datepicker({showButtonPanel:!0,dateFormat:n})}),e(".at-time").each(function(){var t=e(this),n=t.attr("rel");t.timepicker({showSecond:!0,timeFormat:n})}),e(".at-color-select").click(function(){var t=e(this),n=t.attr("rel");return e(this).siblings(".at-color-picker").farbtastic("#"+n).toggle(),!1}),e(".at-upload").delegate(".at-delete-file","click",function(){var t=e(this),n=t.parent(),r=t.attr("rel");return e.post(ajaxurl,{action:"at_delete_file",data:r},function(e){e=="0"?(alert("File has been successfully deleted."),n.remove()):alert("You do NOT have permission to delete this file.")}),!1}),e(".at-images").each(function(){var t=e(this),n,r;t.sortable({placeholder:"ui-state-highlight",update:function(){n=t.sortable("serialize"),r=n+"|"+t.siblings(".at-images-data").val(),e.post(ajaxurl,{action:"at_reorder_images",data:r},function(e){e=="0"?alert("Order saved!"):alert("You don't have permission to reorder images.")})}})})}t(function(){function t(e){var t=RegExp("[?&]"+e+"=([^&#]*)").exec(location.href);return t&&decodeURIComponent(t[1].replace(/\+/g," "))}function n(){jQuery(".mupload_img_holder").each(function(e,t){jQuery(this).next().next().val()!=""&&!jQuery(this).children().size()>0&&(jQuery(this).append('<img src="'+jQuery(this).next().next().val()+'" style="height: 150px;width: 150px;" />'),jQuery(this).next().next().next().val("Delete"),jQuery(this).next().next().next().removeClass("at-upload_image_button").addClass("at-delete_image_button"))})}e(document).on("click",".at-re-toggle",function(){e(this).prev().toggle("slow")}),e(".at-date").each(function(){var t=e(this),n=t.attr("rel");t.datepicker({showButtonPanel:!0,dateFormat:n})}),e(".at-time").each(function(){var t=e(this),n=t.attr("rel");t.timepicker({showSecond:!0,timeFormat:n})}),e(document).on("focus",".at-color",function(){var t=e(this);e(this).siblings(".at-color-picker").farbtastic(t).toggle()}),e(document).on("focusout",".at-color",function(){var t=e(this);e(this).siblings(".at-color-picker").farbtastic(t).toggle()}),e(".at-add-file").click(function(){var t=e(this).parent().find(".file-input:first");return t.clone().insertAfter(t).show(),!1}),e(".at-upload").delegate(".at-delete-file","click",function(){var n=e(this),r=n.parent(),i=n.attr("rel"),s=e(this).index();return e.post(ajaxurl,{action:"at_delete_file",data:i,tag_id:t("tag_ID")},function(e){e=="0"?(alert("File has been successfully deleted."),r.remove()):alert("You do NOT have permission to delete this file.")}),!1}),n(),jQuery(document).on("click",".at-delete_image_button",function(r){var i=jQuery(this).attr("rel"),s=jQuery(this).prev().prev(),o=jQuery(this).prev(),u=jQuery(this);return data={action:"at_delete_mupload",_wpnonce:e("#nonce-delete-mupload_"+i).val(),post_id:t("tag_ID"),field_id:i,attachment_id:jQuery(s).val()},e.getJSON(ajaxurl,data,function(e){"success"==e.status?(jQuery(u).val("Add Image"),jQuery(u).removeClass("at-delete_image_button").addClass("at-upload_image_button"),jQuery(s).val(""),jQuery(o).val(""),jQuery(s).prev().html(""),n()):alert(e.message)}),!1});var r,i;jQuery(document).on("click",".at-upload_image_button",function(t){return r=jQuery(this).prev(),i=jQuery(this).prev().prev(),tb_show("","media-upload.php?post_id=0&type=image&amp;TB_iframe=true&tax_meta_c=instopo"),tbframe_interval=setInterval(function(){e("#TB_iframeContent").contents().find(".url").hide(),e("#TB_iframeContent").contents().find(".align").hide(),e("#TB_iframeContent").contents().find(".image_alt").hide(),e("#TB_iframeContent").contents().find(".post_excerpt").hide(),e("#TB_iframeContent").contents().find(".post_content").hide(),e("#TB_iframeContent").contents().find(".image-size").hide(),e("#TB_iframeContent").contents().find('[value="Insert into Post"]').val("Use this image")},2e3),window.restore_send_to_editor=window.send_to_editor,window.send_to_editor=function(e){imgurl=jQuery("img",e).attr("src"),img_calsses=jQuery("img",e).attr("class").split(" "),att_id="",jQuery.each(img_calsses,function(e,t){t.indexOf("wp-image")!=-1&&(att_id=t.replace("wp-image-",""))}),jQuery(i).val(att_id),jQuery(r).val(imgurl),n(),tb_remove(),window.send_to_editor=window.restore_send_to_editor},!1})})}),timely.define("scripts/event_category",["jquery_timely","external_libs/colorpicker","external_libs/tax_meta_class"],function(e){e("#tag-color").click(function(){var n=e("#tag-color").offset(),i=n.top+e("#tag-color").height(),s=n.left+1,o=e("<ul></ul>"),u=e('<li style="color: #60a;" class="color-1"></li><li style="color: #807;" class="color-2"></li><li style="color: #920;" class="color-3"></li><li style="color: #a60;" class="color-4"></li><li style="color: #990;" class="color-5"></li><li style="color: #080;" class="color-6"></li><li style="color: #077;" class="color-7"></li><li style="color: #00a;" class="color-8"></li><li style="color: #000;" class="color-9"></li><li style="color: #444;" class="color-10"></li><li style="color: #85e;" class="color-11"></li><li style="color: #d5d;" class="color-12"></li><li style="color: #d43;" class="color-13"></li><li style="color: #d90;" class="color-14"></li><li style="color: #bb0;" class="color-15"></li><li style="color: #2b0;" class="color-16"></li><li style="color: #0ba;" class="color-17"></li><li style="color: #26d;" class="color-18"></li><li style="color: #777;" class="color-19"></li><li style="color: #aaa;" class="color-20"></li><li style="color: #aab;" class="color-21"></li>'),a=e('<li class="select-more-colors">More colors</li>');e(a).ColorPicker({onSubmit:function(t,n,r,i){e("#tag-color-background").css("background-color","#"+n),e("#tag-color-value").val("#"+n),e(i).ColorPickerHide(),o.remove()},onBeforeShow:function(){o.hide(),e(document).unbind("mousedown",r);var t=e("#tag-color-value").val();t=t.length>0?t:"#ffffff",e(this).ColorPickerSetColor(t)}}),u.click(function(){t(e(this).css("color"))!=="#aaaabb"?(e("#tag-color-background").css("background-color",e(this).css("color")),e("#tag-color-value").val(t(e(this).css("color"))),o.remove()):(e("#tag-color-background").css("background-color",""),e("#tag-color-value").val(""),o.remove())}),o.append(u).append(a),o.appendTo("body").css({position:"absolute",top:i+"px",left:s+"px",width:"105px",height:"70px","z-index":1,background:"#fff",border:"1px solid #ccc"}).addClass("colorpicker-list"),e(document).bind("mousedown",{ls:o},r)}),e("#tag-color-value-remove").click(function(){e("#tag-color-background").css("background-color",""),e("#tag-color-value").val("")});var t=function(e){return e=e.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/),"#"+n(e[1])+n(e[2])+n(e[3])},n=function(e){return("0"+parseInt(e,10).toString(16)).slice(-2)},r=function(t){i(t.data.ls.get(0),t.target,t.data.ls.get(0))||(e(t.data.ls.get(0)).remove(),e(document).unbind("mousedown",r))},i=function(e,t,n){if(e===t)return!0;if(e.contains)return e.contains(t);if(e.compareDocumentPosition)return!!(e.compareDocumentPosition(t)&16);var r=t.parentNode;while(r&&r!==n){if(r===e)return!0;r=r.parentNode}return!1}}),timely.require(["scripts/event_category"]),timely.define("pages/event_category",function(){});
\ No newline at end of file
diff --git a/public/js/require.js b/public/js/require.js
new file mode 100644
index 0000000..ad7c981
--- /dev/null
+++ b/public/js/require.js
@@ -0,0 +1,7 @@
+/** vim: et:ts=4:sw=4:sts=4
+ * @license RequireJS 2.1.5 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+var timely;(function(){if(!timely||!timely.requirejs){timely?require=timely:timely={};var requirejs,require,define;(function(global){function isFunction(e){return ostring.call(e)==="[object Function]"}function isArray(e){return ostring.call(e)==="[object Array]"}function each(e,t){if(e){var n;for(n=0;n<e.length;n+=1)if(e[n]&&t(e[n],n,e))break}}function eachReverse(e,t){if(e){var n;for(n=e.length-1;n>-1;n-=1)if(e[n]&&t(e[n],n,e))break}}function hasProp(e,t){return hasOwn.call(e,t)}function getOwn(e,t){return hasProp(e,t)&&e[t]}function eachProp(e,t){var n;for(n in e)if(hasProp(e,n)&&t(e[n],n))break}function mixin(e,t,n,r){return t&&eachProp(t,function(t,i){if(n||!hasProp(e,i))r&&typeof t!="string"?(e[i]||(e[i]={}),mixin(e[i],t,n,r)):e[i]=t}),e}function bind(e,t){return function(){return t.apply(e,arguments)}}function scripts(){return document.getElementsByTagName("script")}function getGlobal(e){if(!e)return e;var t=global;return each(e.split("."),function(e){t=t[e]}),t}function makeError(e,t,n,r){var i=new Error(t+"\nhttp://requirejs.org/docs/errors.html#"+e);return i.requireType=e,i.requireModules=r,n&&(i.originalError=n),i}function newContext(e){function v(e){var t,n;for(t=0;e[t];t+=1){n=e[t];if(n===".")e.splice(t,1),t-=1;else if(n===".."){if(t===1&&(e[2]===".."||e[0]===".."))break;t>0&&(e.splice(t-1,2),t-=2)}}}function m(e,t,n){var r,i,s,u,a,f,l,c,h,p,d,m=t&&t.split("/"),g=m,y=o.map,b=y&&y["*"];e&&e.charAt(0)==="."&&(t?(getOwn(o.pkgs,t)?g=m=[t]:g=m.slice(0,m.length-1),e=g.concat(e.split("/")),v(e),i=getOwn(o.pkgs,r=e[0]),e=e.join("/"),i&&e===r+"/"+i.main&&(e=r)):e.indexOf("./")===0&&(e=e.substring(2)));if(n&&y&&(m||b)){u=e.split("/");for(a=u.length;a>0;a-=1){l=u.slice(0,a).join("/");if(m)for(f=m.length;f>0;f-=1){s=getOwn(y,m.slice(0,f).join("/"));if(s){s=getOwn(s,l);if(s){c=s,h=a;break}}}if(c)break;!p&&b&&getOwn(b,l)&&(p=getOwn(b,l),d=a)}!c&&p&&(c=p,h=d),c&&(u.splice(0,h,c),e=u.join("/"))}return e}function g(e){isBrowser&&each(scripts(),function(t){if(t.getAttribute("data-requiremodule")===e&&t.getAttribute("data-requirecontext")===r.contextName)return t.parentNode.removeChild(t),!0})}function y(e){var t=getOwn(o.paths,e);if(t&&isArray(t)&&t.length>1)return g(e),t.shift(),r.require.undef(e),r.require([e]),!0}function b(e){var t,n=e?e.indexOf("!"):-1;return n>-1&&(t=e.substring(0,n),e=e.substring(n+1,e.length)),[t,e]}function w(e,t,n,i){var s,o,u,a,f=null,l=t?t.name:null,h=e,v=!0,g="";return e||(v=!1,e="_@r"+(p+=1)),a=b(e),f=a[0],e=a[1],f&&(f=m(f,l,i),o=getOwn(c,f)),e&&(f?o&&o.normalize?g=o.normalize(e,function(e){return m(e,l,i)}):g=m(e,l,i):(g=m(e,l,i),a=b(g),f=a[0],g=a[1],n=!0,s=r.nameToUrl(g))),u=f&&!o&&!n?"_unnormalized"+(d+=1):"",{prefix:f,name:g,parentMap:t,unnormalized:!!u,url:s,originalName:h,isDefine:v,id:(f?f+"!"+g:g)+u}}function E(e){var t=e.id,n=getOwn(u,t);return n||(n=u[t]=new r.Module(e)),n}function S(e,t,n){var r=e.id,i=getOwn(u,r);hasProp(c,r)&&(!i||i.defineEmitComplete)?t==="defined"&&n(c[r]):E(e).on(t,n)}function x(e,t){var n=e.requireModules,r=!1;t?t(e):(each(n,function(t){var n=getOwn(u,t);n&&(n.error=e,n.events.error&&(r=!0,n.emit("error",e)))}),r||req.onError(e))}function T(){globalDefQueue.length&&(apsp.apply(l,[l.length-1,0].concat(globalDefQueue)),globalDefQueue=[])}function N(e){delete u[e],delete a[e]}function C(e,t,n){var r=e.map.id;e.error?e.emit("error",e.error):(t[r]=!0,each(e.depMaps,function(r,i){var s=r.id,o=getOwn(u,s);o&&!e.depMatched[i]&&!n[s]&&(getOwn(t,s)?(e.defineDep(i,c[s]),e.check()):C(o,t,n))}),n[r]=!0)}function k(){var e,n,i,u,f=o.waitSeconds*1e3,l=f&&r.startTime+f<(new Date).getTime(),c=[],h=[],p=!1,d=!0;if(t)return;t=!0,eachProp(a,function(t){e=t.map,n=e.id;if(!t.enabled)return;e.isDefine||h.push(t);if(!t.error)if(!t.inited&&l)y(n)?(u=!0,p=!0):(c.push(n),g(n));else if(!t.inited&&t.fetched&&e.isDefine){p=!0;if(!e.prefix)return d=!1}});if(l&&c.length)return i=makeError("timeout","Load timeout for modules: "+c,null,c),i.contextName=r.contextName,x(i);d&&each(h,function(e){C(e,{},{})}),(!l||u)&&p&&(isBrowser||isWebWorker)&&!s&&(s=setTimeout(function(){s=0,k()},50)),t=!1}function L(e){hasProp(c,e[0])||E(w(e[0],null,!0)).init(e[1],e[2])}function A(e,t,n,r){e.detachEvent&&!isOpera?r&&e.detachEvent(r,t):e.removeEventListener(n,t,!1)}function O(e){var t=e.currentTarget||e.srcElement;return A(t,r.onScriptLoad,"load","onreadystatechange"),A(t,r.onScriptError,"error"),{node:t,id:t&&t.getAttribute("data-requiremodule")}}function M(){var e;T();while(l.length){e=l.shift();if(e[0]===null)return x(makeError("mismatch","Mismatched anonymous define() module: "+e[e.length-1]));L(e)}}var t,n,r,i,s,o={waitSeconds:7,baseUrl:"./",paths:{},pkgs:{},shim:{},config:{}},u={},a={},f={},l=[],c={},h={},p=1,d=1;return i={require:function(e){return e.require?e.require:e.require=r.makeRequire(e.map)},exports:function(e){e.usingExports=!0;if(e.map.isDefine)return e.exports?e.exports:e.exports=c[e.map.id]={}},module:function(e){return e.module?e.module:e.module={id:e.map.id,uri:e.map.url,config:function(){return o.config&&getOwn(o.config,e.map.id)||{}},exports:c[e.map.id]}}},n=function(e){this.events=getOwn(f,e.id)||{},this.map=e,this.shim=getOwn(o.shim,e.id),this.depExports=[],this.depMaps=[],this.depMatched=[],this.pluginMaps={},this.depCount=0},n.prototype={init:function(e,t,n,r){r=r||{};if(this.inited)return;this.factory=t,n?this.on("error",n):this.events.error&&(n=bind(this,function(e){this.emit("error",e)})),this.depMaps=e&&e.slice(0),this.errback=n,this.inited=!0,this.ignore=r.ignore,r.enabled||this.enabled?this.enable():this.check()},defineDep:function(e,t){this.depMatched[e]||(this.depMatched[e]=!0,this.depCount-=1,this.depExports[e]=t)},fetch:function(){if(this.fetched)return;this.fetched=!0,r.startTime=(new Date).getTime();var e=this.map;if(!this.shim)return e.prefix?this.callPlugin():this.load();r.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],bind(this,function(){return e.prefix?this.callPlugin():this.load()}))},load:function(){var e=this.map.url;h[e]||(h[e]=!0,r.load(this.map.id,e))},check:function(){if(!this.enabled||this.enabling)return;var e,t,n=this.map.id,i=this.depExports,s=this.exports,o=this.factory;if(!this.inited)this.fetch();else if(this.error)this.emit("error",this.error);else if(!this.defining){this.defining=!0;if(this.depCount<1&&!this.defined){if(isFunction(o)){if(this.events.error)try{s=r.execCb(n,o,i,s)}catch(u){e=u}else s=r.execCb(n,o,i,s);this.map.isDefine&&(t=this.module,t&&t.exports!==undefined&&t.exports!==this.exports?s=t.exports:s===undefined&&this.usingExports&&(s=this.exports));if(e)return e.requireMap=this.map,e.requireModules=[this.map.id],e.requireType="define",x(this.error=e)}else s=o;this.exports=s,this.map.isDefine&&!this.ignore&&(c[n]=s,req.onResourceLoad&&req.onResourceLoad(r,this.map,this.depMaps)),N(n),this.defined=!0}this.defining=!1,this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=!0)}},callPlugin:function(){var e=this.map,t=e.id,n=w(e.prefix);this.depMaps.push(n),S(n,"defined",bind(this,function(n){var i,s,a,f=this.map.name,l=this.map.parentMap?this.map.parentMap.name:null,c=r.makeRequire(e.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){n.normalize&&(f=n.normalize(f,function(e){return m(e,l,!0)})||""),s=w(e.prefix+"!"+f,this.map.parentMap),S(s,"defined",bind(this,function(e){this.init([],function(){return e},null,{enabled:!0,ignore:!0})})),a=getOwn(u,s.id),a&&(this.depMaps.push(s),this.events.error&&a.on("error",bind(this,function(e){this.emit("error",e)})),a.enable());return}i=bind(this,function(e){this.init([],function(){return e},null,{enabled:!0})}),i.error=bind(this,function(e){this.inited=!0,this.error=e,e.requireModules=[t],eachProp(u,function(e){e.map.id.indexOf(t+"_unnormalized")===0&&N(e.map.id)}),x(e)}),i.fromText=bind(this,function(n,s){var u=e.name,a=w(u),f=useInteractive;s&&(n=s),f&&(useInteractive=!1),E(a),hasProp(o.config,t)&&(o.config[u]=o.config[t]);try{req.exec(n)}catch(l){return x(makeError("fromtexteval","fromText eval for "+t+" failed: "+l,l,[t]))}f&&(useInteractive=!0),this.depMaps.push(a),r.completeLoad(u),c([u],i)}),n.load(e.name,c,i,o)})),r.enable(n,this),this.pluginMaps[n.id]=n},enable:function(){a[this.map.id]=this,this.enabled=!0,this.enabling=!0,each(this.depMaps,bind(this,function(e,t){var n,s,o;if(typeof e=="string"){e=w(e,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap),this.depMaps[t]=e,o=getOwn(i,e.id);if(o){this.depExports[t]=o(this);return}this.depCount+=1,S(e,"defined",bind(this,function(e){this.defineDep(t,e),this.check()})),this.errback&&S(e,"error",this.errback)}n=e.id,s=u[n],!hasProp(i,n)&&s&&!s.enabled&&r.enable(e,this)})),eachProp(this.pluginMaps,bind(this,function(e){var t=getOwn(u,e.id);t&&!t.enabled&&r.enable(e,this)})),this.enabling=!1,this.check()},on:function(e,t){var n=this.events[e];n||(n=this.events[e]=[]),n.push(t)},emit:function(e,t){each(this.events[e],function(e){e(t)}),e==="error"&&delete this.events[e]}},r={config:o,contextName:e,registry:u,defined:c,urlFetched:h,defQueue:l,Module:n,makeModuleMap:w,nextTick:req.nextTick,onError:x,configure:function(e){e.baseUrl&&e.baseUrl.charAt(e.baseUrl.length-1)!=="/"&&(e.baseUrl+="/");var t=o.pkgs,n=o.shim,i={paths:!0,config:!0,map:!0};eachProp(e,function(e,t){i[t]?t==="map"?(o.map||(o.map={}),mixin(o[t],e,!0,!0)):mixin(o[t],e,!0):o[t]=e}),e.shim&&(eachProp(e.shim,function(e,t){isArray(e)&&(e={deps:e}),(e.exports||e.init)&&!e.exportsFn&&(e.exportsFn=r.makeShimExports(e)),n[t]=e}),o.shim=n),e.packages&&(each(e.packages,function(e){var n;e=typeof e=="string"?{name:e}:e,n=e.location,t[e.name]={name:e.name,location:n||e.name,main:(e.main||"main").replace(currDirRegExp,"").replace(jsSuffixRegExp,"")}}),o.pkgs=t),eachProp(u,function(e,t){!e.inited&&!e.map.unnormalized&&(e.map=w(t))}),(e.deps||e.callback)&&r.require(e.deps||[],e.callback)},makeShimExports:function(e){function t(){var t;return e.init&&(t=e.init.apply(global,arguments)),t||e.exports&&getGlobal(e.exports)}return t},makeRequire:function(t,n){function s(o,a,f){var l,h,p;return n.enableBuildCallback&&a&&isFunction(a)&&(a.__requireJsBuild=!0),typeof o=="string"?isFunction(a)?x(makeError("requireargs","Invalid require call"),f):t&&hasProp(i,o)?i[o](u[t.id]):req.get?req.get(r,o,t,s):(h=w(o,t,!1,!0),l=h.id,hasProp(c,l)?c[l]:x(makeError("notloaded",'Module name "'+l+'" has not been loaded yet for context: '+e+(t?"":". Use require([])")))):(M(),r.nextTick(function(){M(),p=E(w(null,t)),p.skipMap=n.skipMap,p.init(o,a,f,{enabled:!0}),k()}),s)}return n=n||{},mixin(s,{isBrowser:isBrowser,toUrl:function(e){var n,i=e.lastIndexOf("."),s=e.split("/")[0],o=s==="."||s==="..";return i!==-1&&(!o||i>1)&&(n=e.substring(i,e.length),e=e.substring(0,i)),r.nameToUrl(m(e,t&&t.id,!0),n,!0)},defined:function(e){return hasProp(c,w(e,t,!1,!0).id)},specified:function(e){return e=w(e,t,!1,!0).id,hasProp(c,e)||hasProp(u,e)}}),t||(s.undef=function(e){T();var n=w(e,t,!0),r=getOwn(u,e);delete c[e],delete h[n.url],delete f[e],r&&(r.events.defined&&(f[e]=r.events),N(e))}),s},enable:function(e){var t=getOwn(u,e.id);t&&E(e).enable()},completeLoad:function(e){var t,n,r,i=getOwn(o.shim,e)||{},s=i.exports;T();while(l.length){n=l.shift();if(n[0]===null){n[0]=e;if(t)break;t=!0}else n[0]===e&&(t=!0);L(n)}r=getOwn(u,e);if(!t&&!hasProp(c,e)&&r&&!r.inited){if(o.enforceDefine&&(!s||!getGlobal(s))){if(y(e))return;return x(makeError("nodefine","No define call for "+e,null,[e]))}L([e,i.deps||[],i.exportsFn])}k()},nameToUrl:function(e,t,n){var r,i,s,u,a,f,l,c,h;if(req.jsExtRegExp.test(e))c=e+(t||"");else{r=o.paths,i=o.pkgs,a=e.split("/");for(f=a.length;f>0;f-=1){l=a.slice(0,f).join("/"),s=getOwn(i,l),h=getOwn(r,l);if(h){isArray(h)&&(h=h[0]),a.splice(0,f,h);break}if(s){e===s.name?u=s.location+"/"+s.main:u=s.location,a.splice(0,f,u);break}}c=a.join("/"),c+=t||(/\?/.test(c)||n?"":".js"),c=(c.charAt(0)==="/"||c.match(/^[\w\+\.\-]+:/)?"":o.baseUrl)+c}return o.urlArgs?c+((c.indexOf("?")===-1?"?":"&")+o.urlArgs):c},load:function(e,t){req.load(r,e,t)},execCb:function(e,t,n,r){return t.apply(r,n)},onScriptLoad:function(e){if(e.type==="load"||readyRegExp.test((e.currentTarget||e.srcElement).readyState)){interactiveScript=null;var t=O(e);r.completeLoad(t.id)}},onScriptError:function(e){var t=O(e);if(!y(t.id))return x(makeError("scripterror","Script error",e,[t.id]))}},r.require=r.makeRequire(),r}function getInteractiveScript(){return interactiveScript&&interactiveScript.readyState==="interactive"?interactiveScript:(eachReverse(scripts(),function(e){if(e.readyState==="interactive")return interactiveScript=e}),interactiveScript)}var req,s,head,baseElement,dataMain,src,interactiveScript,currentlyAddingScript,mainScript,subPath,version="2.1.5",commentRegExp=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,cjsRequireRegExp=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,jsSuffixRegExp=/\.js$/,currDirRegExp=/^\.\//,op=Object.prototype,ostring=op.toString,hasOwn=op.hasOwnProperty,ap=Array.prototype,apsp=ap.splice,isBrowser=typeof window!="undefined"&&!!navigator&&!!document,isWebWorker=!isBrowser&&typeof importScripts!="undefined",readyRegExp=isBrowser&&navigator.platform==="PLAYSTATION 3"?/^complete$/:/^(complete|loaded)$/,defContextName="_",isOpera=typeof opera!="undefined"&&opera.toString()==="[object Opera]",contexts={},cfg={},globalDefQueue=[],useInteractive=!1;if(typeof define!="undefined")return;if(typeof requirejs!="undefined"){if(isFunction(requirejs))return;cfg=requirejs,requirejs=undefined}typeof require!="undefined"&&!isFunction(require)&&(cfg=require,require=undefined),req=requirejs=function(e,t,n,r){var i,s,o=defContextName;return!isArray(e)&&typeof e!="string"&&(s=e,isArray(t)?(e=t,t=n,n=r):e=[]),s&&s.context&&(o=s.context),i=getOwn(contexts,o),i||(i=contexts[o]=req.s.newContext(o)),s&&i.configure(s),i.require(e,t,n)},req.config=function(e){return req(e)},req.nextTick=typeof setTimeout!="undefined"?function(e){setTimeout(e,4)}:function(e){e()},require||(require=req),req.version=version,req.jsExtRegExp=/^\/|:|\?|\.js$/,req.isBrowser=isBrowser,s=req.s={contexts:contexts,newContext:newContext},req({}),each(["toUrl","undef","defined","specified"],function(e){req[e]=function(){var t=contexts[defContextName];return t.require[e].apply(t,arguments)}}),isBrowser&&(head=s.head=document.getElementsByTagName("head")[0],baseElement=document.getElementsByTagName("base")[0],baseElement&&(head=s.head=baseElement.parentNode)),req.onError=function(e){throw e},req.load=function(e,t,n){var r=e&&e.config||{},i;if(isBrowser)return i=r.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script"),i.type=r.scriptType||"text/javascript",i.charset="utf-8",i.async=!0,i.setAttribute("data-requirecontext",e.contextName),i.setAttribute("data-requiremodule",t),i.attachEvent&&!(i.attachEvent.toString&&i.attachEvent.toString().indexOf("[native code")<0)&&!isOpera?(useInteractive=!0,i.attachEvent("onreadystatechange",e.onScriptLoad)):(i.addEventListener("load",e.onScriptLoad,!1),i.addEventListener("error",e.onScriptError,!1)),i.src=n,currentlyAddingScript=i,baseElement?head.insertBefore(i,baseElement):head.appendChild(i),currentlyAddingScript=null,i;if(isWebWorker)try{importScripts(n),e.completeLoad(t)}catch(s){e.onError(makeError("importscripts","importScripts failed for "+t+" at "+n,s,[t]))}},isBrowser&&eachReverse(scripts(),function(e){head||(head=e.parentNode),dataMain=e.getAttribute("data-main");if(dataMain)return cfg.baseUrl||(src=dataMain.split("/"),mainScript=src.pop(),subPath=src.length?src.join("/")+"/":"./",cfg.baseUrl=subPath,dataMain=mainScript),dataMain=dataMain.replace(jsSuffixRegExp,""),cfg.deps=cfg.deps?cfg.deps.concat(dataMain):[dataMain],!0}),define=function(e,t,n){var r,i;typeof e!="string"&&(n=t,t=e,e=null),isArray(t)||(n=t,t=[]),!t.length&&isFunction(n)&&n.length&&(n.toString().replace(commentRegExp,"").replace(cjsRequireRegExp,function(e,n){t.push(n)}),t=(n.length===1?["require"]:["require","exports","module"]).concat(t)),useInteractive&&(r=currentlyAddingScript||getInteractiveScript(),r&&(e||(e=r.getAttribute("data-requiremodule")),i=contexts[r.getAttribute("data-requirecontext")])),(i?i.defQueue:globalDefQueue).push([e,t,n])},define.amd={jQuery:!0},req.exec=function(text){return eval(text)},req(cfg)})(this),timely.requirejs=requirejs,timely.require=require,timely.define=define}})();
\ No newline at end of file
diff --git a/public/js_src/.jshintignore b/public/js_src/.jshintignore
new file mode 100644
index 0000000..06e1424
--- /dev/null
+++ b/public/js_src/.jshintignore
@@ -0,0 +1,5 @@
+build
+jasmine/lib
+external_libs
+jquery_lib.js
+require.js
diff --git a/public/js_src/.jshintrc b/public/js_src/.jshintrc
new file mode 100644
index 0000000..691c425
--- /dev/null
+++ b/public/js_src/.jshintrc
@@ -0,0 +1,40 @@
+{
+	"predef": [
+		"jasmine",
+		"spyOn",
+		"it",
+		"console",
+		"describe",
+		"expect",
+		"beforeEach",
+		"waits",
+		"waitsFor",
+		"runs",
+		"require",
+		"requirejs",
+		"define",
+		"google",
+		"postboxes",
+		"ajaxurl",
+		"afterEach",
+		"loadFixtures",
+		"spyOnEvent",
+		"ai1ec_requirejs"
+	],
+	"node" : true,
+	"es5" : true,
+	"browser" : true,
+ 	"forin" : true,
+ 	"noarg" : true,
+ 	"noempty" : true,
+ 	"eqeqeq" : true,
+ 	"bitwise" : true,
+ 	"strict" : true,
+ 	"undef" : true,
+ 	"curly" : true,
+ 	"newcap" : true,
+ 	"maxerr" : 50,
+ 	"trailing" : true,
+ 	"smarttabs" : true,
+ 	"nonstandard" : true
+}
\ No newline at end of file
diff --git a/public/js_src/async.js b/public/js_src/async.js
new file mode 100644
index 0000000..4d17df3
--- /dev/null
+++ b/public/js_src/async.js
@@ -0,0 +1,42 @@
+/** @license
+ * RequireJS plugin for async dependency load like JSONP and Google Maps
+ * Author: Miller Medeiros
+ * Version: 0.1.1 (2011/11/17)
+ * Released under the MIT license
+ */
+define(function(){
+	"use strict"; // jshint ;_;
+    var DEFAULT_PARAM_NAME = 'callback',
+        _uid = 0;
+
+    function injectScript(src){
+        var s, t;
+        s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = src;
+        t = document.getElementsByTagName('script')[0]; t.parentNode.insertBefore(s,t);
+    }
+
+    function formatUrl(name, id){
+        var paramRegex = /!(.+)/,
+            url = name.replace(paramRegex, ''),
+            param = (paramRegex.test(name))? name.replace(/.+!/, '') : DEFAULT_PARAM_NAME;
+        url += (url.indexOf('?') < 0)? '?' : '&';
+        return url + param +'='+ id;
+    }
+
+    function uid() {
+        _uid += 1;
+        return '__async_req_'+ _uid +'__';
+    }
+
+    return{
+        load : function(name, req, onLoad, config){
+            if(config.isBuild){
+                onLoad(null); //avoid errors on the optimizer
+            }else{
+                var id = uid();
+                window[id] = onLoad; //create a global variable that stores onLoad so callback function can define new module after async load
+                injectScript(formatUrl(name, id));
+            }
+        }
+    };
+});
\ No newline at end of file
diff --git a/public/js_src/build-js.bat b/public/js_src/build-js.bat
new file mode 100644
index 0000000..6c63dee
--- /dev/null
+++ b/public/js_src/build-js.bat
@@ -0,0 +1,7 @@
+@echo off
+where /q nodemon || (
+	echo nodemon node package is not installed. You must install node, npm and then run npm install -g nodemon
+	goto :eof
+)
+nodemon -L --watch ./ --watch ./scripts --watch ./libs --watch ./external_libs --watch ./pages --watch ./themes  build/r.js -o build/app.build.js 
+:end
diff --git a/public/js_src/build-js.sh b/public/js_src/build-js.sh
new file mode 100755
index 0000000..9207a78
--- /dev/null
+++ b/public/js_src/build-js.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+which nodemon >/dev/null
+
+if [[ $? -eq 0 ]]
+then
+
+	nodemon \
+	    --watch ./ \
+	    --watch ./scripts \
+	    --watch ./libs \
+	    --watch ./external_libs \
+	    --watch ./pages \
+	    --watch ./themes build/r.js \
+	    -o build/app.build.js
+	exit 0
+else
+
+	echo 'Error: nodemon not found. Install Node.js then: npm install -g nodemon'
+	exit 1
+fi
diff --git a/public/js_src/build/app.build.js b/public/js_src/build/app.build.js
new file mode 100644
index 0000000..b5481bc
--- /dev/null
+++ b/public/js_src/build/app.build.js
@@ -0,0 +1,39 @@
+({
+	appDir: "../",
+	baseUrl: "./",                // This is relative to appDir
+	dir: "../../js",              // This is relative to this file's dir
+	keepBuildDir: false,
+	fileExclusionRegExp: /(jasmine|build|jshintr|^\.|.bat|.sh$)/,
+	mainConfigFile: '../main.js', // This is relative to this file's dir
+	// optimize: "none",          // Uncomment this line if you need to debug
+	modules: [ {
+				name: "pages/calendar"
+			},
+			{
+				name: "pages/event"
+			},
+			{
+				name: "pages/admin_settings"
+			},
+			{
+				name: "pages/add_new_event"
+			},
+			{
+				name: "pages/event_category"
+			},
+			{
+				name: "pages/common_backend"
+			},
+			{
+				name: "pages/common_frontend"
+			}
+	],
+	namespace: 'timely', // Set the namespace.
+	paths: {
+		"ai1ec_calendar" : "empty:", // This modules are created dynamically in WP
+		"ai1ec_config"   : "empty:",
+		"jquery_timely"  : "empty:"
+	},
+	wrap: false,
+	removeCombined: true
+})
diff --git a/public/js_src/build/r.js b/public/js_src/build/r.js
new file mode 100644
index 0000000..2a534f0
--- /dev/null
+++ b/public/js_src/build/r.js
@@ -0,0 +1,25256 @@
+/**
+ * @license r.js 2.1.6 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*
+ * This is a bootstrap script to allow running RequireJS in the command line
+ * in either a Java/Rhino or Node environment. It is modified by the top-level
+ * dist.js file to inject other files to completely enable this file. It is
+ * the shell of the r.js file.
+ */
+
+/*jslint evil: true, nomen: true, sloppy: true */
+/*global readFile: true, process: false, Packages: false, print: false,
+console: false, java: false, module: false, requirejsVars, navigator,
+document, importScripts, self, location, Components, FileUtils */
+
+var requirejs, require, define, xpcUtil;
+(function (console, args, readFileFunc) {
+    var fileName, env, fs, vm, path, exec, rhinoContext, dir, nodeRequire,
+        nodeDefine, exists, reqMain, loadedOptimizedLib, existsForNode, Cc, Ci,
+        version = '2.1.6',
+        jsSuffixRegExp = /\.js$/,
+        commandOption = '',
+        useLibLoaded = {},
+        //Used by jslib/rhino/args.js
+        rhinoArgs = args,
+        //Used by jslib/xpconnect/args.js
+        xpconnectArgs = args,
+        readFile = typeof readFileFunc !== 'undefined' ? readFileFunc : null;
+
+    function showHelp() {
+        console.log('See https://github.com/jrburke/r.js for usage.');
+    }
+
+    if ((typeof navigator !== 'undefined' && typeof document !== 'undefined') ||
+            (typeof importScripts !== 'undefined' && typeof self !== 'undefined')) {
+        env = 'browser';
+
+        readFile = function (path) {
+            return fs.readFileSync(path, 'utf8');
+        };
+
+        exec = function (string) {
+            return eval(string);
+        };
+
+        exists = function () {
+            console.log('x.js exists not applicable in browser env');
+            return false;
+        };
+
+    } else if (typeof Packages !== 'undefined') {
+        env = 'rhino';
+
+        fileName = args[0];
+
+        if (fileName && fileName.indexOf('-') === 0) {
+            commandOption = fileName.substring(1);
+            fileName = args[1];
+        }
+
+        //Set up execution context.
+        rhinoContext = Packages.org.mozilla.javascript.ContextFactory.getGlobal().enterContext();
+
+        exec = function (string, name) {
+            return rhinoContext.evaluateString(this, string, name, 0, null);
+        };
+
+        exists = function (fileName) {
+            return (new java.io.File(fileName)).exists();
+        };
+
+        //Define a console.log for easier logging. Don't
+        //get fancy though.
+        if (typeof console === 'undefined') {
+            console = {
+                log: function () {
+                    print.apply(undefined, arguments);
+                }
+            };
+        }
+    } else if (typeof process !== 'undefined' && process.versions && !!process.versions.node) {
+        env = 'node';
+
+        //Get the fs module via Node's require before it
+        //gets replaced. Used in require/node.js
+        fs = require('fs');
+        vm = require('vm');
+        path = require('path');
+        //In Node 0.7+ existsSync is on fs.
+        existsForNode = fs.existsSync || path.existsSync;
+
+        nodeRequire = require;
+        nodeDefine = define;
+        reqMain = require.main;
+
+        //Temporarily hide require and define to allow require.js to define
+        //them.
+        require = undefined;
+        define = undefined;
+
+        readFile = function (path) {
+            return fs.readFileSync(path, 'utf8');
+        };
+
+        exec = function (string, name) {
+            return vm.runInThisContext(this.requirejsVars.require.makeNodeWrapper(string),
+                                       name ? fs.realpathSync(name) : '');
+        };
+
+        exists = function (fileName) {
+            return existsForNode(fileName);
+        };
+
+
+        fileName = process.argv[2];
+
+        if (fileName && fileName.indexOf('-') === 0) {
+            commandOption = fileName.substring(1);
+            fileName = process.argv[3];
+        }
+    } else if (typeof Components !== 'undefined' && Components.classes && Components.interfaces) {
+        env = 'xpconnect';
+
+        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
+        Cc = Components.classes;
+        Ci = Components.interfaces;
+
+        fileName = args[0];
+
+        if (fileName && fileName.indexOf('-') === 0) {
+            commandOption = fileName.substring(1);
+            fileName = args[1];
+        }
+
+        xpcUtil = {
+            cwd: function () {
+                return FileUtils.getFile("CurWorkD", []).path;
+            },
+
+            //Remove . and .. from paths, normalize on front slashes
+            normalize: function (path) {
+                //There has to be an easier way to do this.
+                var i, part, ary,
+                    firstChar = path.charAt(0);
+
+                if (firstChar !== '/' &&
+                        firstChar !== '\\' &&
+                        path.indexOf(':') === -1) {
+                    //A relative path. Use the current working directory.
+                    path = xpcUtil.cwd() + '/' + path;
+                }
+
+                ary = path.replace(/\\/g, '/').split('/');
+
+                for (i = 0; i < ary.length; i += 1) {
+                    part = ary[i];
+                    if (part === '.') {
+                        ary.splice(i, 1);
+                        i -= 1;
+                    } else if (part === '..') {
+                        ary.splice(i - 1, 2);
+                        i -= 2;
+                    }
+                }
+                return ary.join('/');
+            },
+
+            xpfile: function (path) {
+                try {
+                    return new FileUtils.File(xpcUtil.normalize(path));
+                } catch (e) {
+                    throw new Error(path + ' failed: ' + e);
+                }
+            },
+
+            readFile: function (/*String*/path, /*String?*/encoding) {
+                //A file read function that can deal with BOMs
+                encoding = encoding || "utf-8";
+
+                var inStream, convertStream,
+                    readData = {},
+                    fileObj = xpcUtil.xpfile(path);
+
+                //XPCOM, you so crazy
+                try {
+                    inStream = Cc['@mozilla.org/network/file-input-stream;1']
+                               .createInstance(Ci.nsIFileInputStream);
+                    inStream.init(fileObj, 1, 0, false);
+
+                    convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
+                                    .createInstance(Ci.nsIConverterInputStream);
+                    convertStream.init(inStream, encoding, inStream.available(),
+                    Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);
+
+                    convertStream.readString(inStream.available(), readData);
+                    return readData.value;
+                } catch (e) {
+                    throw new Error((fileObj && fileObj.path || '') + ': ' + e);
+                } finally {
+                    if (convertStream) {
+                        convertStream.close();
+                    }
+                    if (inStream) {
+                        inStream.close();
+                    }
+                }
+            }
+        };
+
+        readFile = xpcUtil.readFile;
+
+        exec = function (string) {
+            return eval(string);
+        };
+
+        exists = function (fileName) {
+            return xpcUtil.xpfile(fileName).exists();
+        };
+
+        //Define a console.log for easier logging. Don't
+        //get fancy though.
+        if (typeof console === 'undefined') {
+            console = {
+                log: function () {
+                    print.apply(undefined, arguments);
+                }
+            };
+        }
+    }
+
+    /** vim: et:ts=4:sw=4:sts=4
+ * @license RequireJS 2.1.6 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+//Not using strict: uneven strict support in browsers, #392, and causes
+//problems with requirejs.exec()/transpiler plugins that may not be strict.
+/*jslint regexp: true, nomen: true, sloppy: true */
+/*global window, navigator, document, importScripts, setTimeout, opera */
+
+
+(function (global) {
+    var req, s, head, baseElement, dataMain, src,
+        interactiveScript, currentlyAddingScript, mainScript, subPath,
+        version = '2.1.6',
+        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
+        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
+        jsSuffixRegExp = /\.js$/,
+        currDirRegExp = /^\.\//,
+        op = Object.prototype,
+        ostring = op.toString,
+        hasOwn = op.hasOwnProperty,
+        ap = Array.prototype,
+        apsp = ap.splice,
+        isBrowser = !!(typeof window !== 'undefined' && navigator && window.document),
+        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
+        //PS3 indicates loaded and complete, but need to wait for complete
+        //specifically. Sequence is 'loading', 'loaded', execution,
+        // then 'complete'. The UA check is unfortunate, but not sure how
+        //to feature test w/o causing perf issues.
+        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
+                      /^complete$/ : /^(complete|loaded)$/,
+        defContextName = '_',
+        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
+        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
+        contexts = {},
+        cfg = {},
+        globalDefQueue = [],
+        useInteractive = false;
+
+    function isFunction(it) {
+        return ostring.call(it) === '[object Function]';
+    }
+
+    function isArray(it) {
+        return ostring.call(it) === '[object Array]';
+    }
+
+    /**
+     * Helper function for iterating over an array. If the func returns
+     * a true value, it will break out of the loop.
+     */
+    function each(ary, func) {
+        if (ary) {
+            var i;
+            for (i = 0; i < ary.length; i += 1) {
+                if (ary[i] && func(ary[i], i, ary)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Helper function for iterating over an array backwards. If the func
+     * returns a true value, it will break out of the loop.
+     */
+    function eachReverse(ary, func) {
+        if (ary) {
+            var i;
+            for (i = ary.length - 1; i > -1; i -= 1) {
+                if (ary[i] && func(ary[i], i, ary)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    function hasProp(obj, prop) {
+        return hasOwn.call(obj, prop);
+    }
+
+    function getOwn(obj, prop) {
+        return hasProp(obj, prop) && obj[prop];
+    }
+
+    /**
+     * Cycles over properties in an object and calls a function for each
+     * property value. If the function returns a truthy value, then the
+     * iteration is stopped.
+     */
+    function eachProp(obj, func) {
+        var prop;
+        for (prop in obj) {
+            if (hasProp(obj, prop)) {
+                if (func(obj[prop], prop)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Simple function to mix in properties from source into target,
+     * but only if target does not already have a property of the same name.
+     */
+    function mixin(target, source, force, deepStringMixin) {
+        if (source) {
+            eachProp(source, function (value, prop) {
+                if (force || !hasProp(target, prop)) {
+                    if (deepStringMixin && typeof value !== 'string') {
+                        if (!target[prop]) {
+                            target[prop] = {};
+                        }
+                        mixin(target[prop], value, force, deepStringMixin);
+                    } else {
+                        target[prop] = value;
+                    }
+                }
+            });
+        }
+        return target;
+    }
+
+    //Similar to Function.prototype.bind, but the 'this' object is specified
+    //first, since it is easier to read/figure out what 'this' will be.
+    function bind(obj, fn) {
+        return function () {
+            return fn.apply(obj, arguments);
+        };
+    }
+
+    function scripts() {
+        return document.getElementsByTagName('script');
+    }
+
+    function defaultOnError(err) {
+        throw err;
+    }
+
+    //Allow getting a global that expressed in
+    //dot notation, like 'a.b.c'.
+    function getGlobal(value) {
+        if (!value) {
+            return value;
+        }
+        var g = global;
+        each(value.split('.'), function (part) {
+            g = g[part];
+        });
+        return g;
+    }
+
+    /**
+     * Constructs an error with a pointer to an URL with more information.
+     * @param {String} id the error ID that maps to an ID on a web page.
+     * @param {String} message human readable error.
+     * @param {Error} [err] the original error, if there is one.
+     *
+     * @returns {Error}
+     */
+    function makeError(id, msg, err, requireModules) {
+        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
+        e.requireType = id;
+        e.requireModules = requireModules;
+        if (err) {
+            e.originalError = err;
+        }
+        return e;
+    }
+
+    if (typeof define !== 'undefined') {
+        //If a define is already in play via another AMD loader,
+        //do not overwrite.
+        return;
+    }
+
+    if (typeof requirejs !== 'undefined') {
+        if (isFunction(requirejs)) {
+            //Do not overwrite and existing requirejs instance.
+            return;
+        }
+        cfg = requirejs;
+        requirejs = undefined;
+    }
+
+    //Allow for a require config object
+    if (typeof require !== 'undefined' && !isFunction(require)) {
+        //assume it is a config object.
+        cfg = require;
+        require = undefined;
+    }
+
+    function newContext(contextName) {
+        var inCheckLoaded, Module, context, handlers,
+            checkLoadedTimeoutId,
+            config = {
+                //Defaults. Do not set a default for map
+                //config to speed up normalize(), which
+                //will run faster if there is no default.
+                waitSeconds: 7,
+                baseUrl: './',
+                paths: {},
+                pkgs: {},
+                shim: {},
+                config: {}
+            },
+            registry = {},
+            //registry of just enabled modules, to speed
+            //cycle breaking code when lots of modules
+            //are registered, but not activated.
+            enabledRegistry = {},
+            undefEvents = {},
+            defQueue = [],
+            defined = {},
+            urlFetched = {},
+            requireCounter = 1,
+            unnormalizedCounter = 1;
+
+        /**
+         * Trims the . and .. from an array of path segments.
+         * It will keep a leading path segment if a .. will become
+         * the first path segment, to help with module name lookups,
+         * which act like paths, but can be remapped. But the end result,
+         * all paths that use this function should look normalized.
+         * NOTE: this method MODIFIES the input array.
+         * @param {Array} ary the array of path segments.
+         */
+        function trimDots(ary) {
+            var i, part;
+            for (i = 0; ary[i]; i += 1) {
+                part = ary[i];
+                if (part === '.') {
+                    ary.splice(i, 1);
+                    i -= 1;
+                } else if (part === '..') {
+                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
+                        //End of the line. Keep at least one non-dot
+                        //path segment at the front so it can be mapped
+                        //correctly to disk. Otherwise, there is likely
+                        //no path mapping for a path starting with '..'.
+                        //This can still fail, but catches the most reasonable
+                        //uses of ..
+                        break;
+                    } else if (i > 0) {
+                        ary.splice(i - 1, 2);
+                        i -= 2;
+                    }
+                }
+            }
+        }
+
+        /**
+         * Given a relative module name, like ./something, normalize it to
+         * a real name that can be mapped to a path.
+         * @param {String} name the relative name
+         * @param {String} baseName a real name that the name arg is relative
+         * to.
+         * @param {Boolean} applyMap apply the map config to the value. Should
+         * only be done if this normalization is for a dependency ID.
+         * @returns {String} normalized name
+         */
+        function normalize(name, baseName, applyMap) {
+            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
+                foundMap, foundI, foundStarMap, starI,
+                baseParts = baseName && baseName.split('/'),
+                normalizedBaseParts = baseParts,
+                map = config.map,
+                starMap = map && map['*'];
+
+            //Adjust any relative paths.
+            if (name && name.charAt(0) === '.') {
+                //If have a base name, try to normalize against it,
+                //otherwise, assume it is a top-level require that will
+                //be relative to baseUrl in the end.
+                if (baseName) {
+                    if (getOwn(config.pkgs, baseName)) {
+                        //If the baseName is a package name, then just treat it as one
+                        //name to concat the name with.
+                        normalizedBaseParts = baseParts = [baseName];
+                    } else {
+                        //Convert baseName to array, and lop off the last part,
+                        //so that . matches that 'directory' and not name of the baseName's
+                        //module. For instance, baseName of 'one/two/three', maps to
+                        //'one/two/three.js', but we want the directory, 'one/two' for
+                        //this normalization.
+                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
+                    }
+
+                    name = normalizedBaseParts.concat(name.split('/'));
+                    trimDots(name);
+
+                    //Some use of packages may use a . path to reference the
+                    //'main' module name, so normalize for that.
+                    pkgConfig = getOwn(config.pkgs, (pkgName = name[0]));
+                    name = name.join('/');
+                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
+                        name = pkgName;
+                    }
+                } else if (name.indexOf('./') === 0) {
+                    // No baseName, so this is ID is resolved relative
+                    // to baseUrl, pull off the leading dot.
+                    name = name.substring(2);
+                }
+            }
+
+            //Apply map config if available.
+            if (applyMap && map && (baseParts || starMap)) {
+                nameParts = name.split('/');
+
+                for (i = nameParts.length; i > 0; i -= 1) {
+                    nameSegment = nameParts.slice(0, i).join('/');
+
+                    if (baseParts) {
+                        //Find the longest baseName segment match in the config.
+                        //So, do joins on the biggest to smallest lengths of baseParts.
+                        for (j = baseParts.length; j > 0; j -= 1) {
+                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));
+
+                            //baseName segment has config, find if it has one for
+                            //this name.
+                            if (mapValue) {
+                                mapValue = getOwn(mapValue, nameSegment);
+                                if (mapValue) {
+                                    //Match, update name to the new value.
+                                    foundMap = mapValue;
+                                    foundI = i;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+
+                    if (foundMap) {
+                        break;
+                    }
+
+                    //Check for a star map match, but just hold on to it,
+                    //if there is a shorter segment match later in a matching
+                    //config, then favor over this star map.
+                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
+                        foundStarMap = getOwn(starMap, nameSegment);
+                        starI = i;
+                    }
+                }
+
+                if (!foundMap && foundStarMap) {
+                    foundMap = foundStarMap;
+                    foundI = starI;
+                }
+
+                if (foundMap) {
+                    nameParts.splice(0, foundI, foundMap);
+                    name = nameParts.join('/');
+                }
+            }
+
+            return name;
+        }
+
+        function removeScript(name) {
+            if (isBrowser) {
+                each(scripts(), function (scriptNode) {
+                    if (scriptNode.getAttribute('data-requiremodule') === name &&
+                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
+                        scriptNode.parentNode.removeChild(scriptNode);
+                        return true;
+                    }
+                });
+            }
+        }
+
+        function hasPathFallback(id) {
+            var pathConfig = getOwn(config.paths, id);
+            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
+                removeScript(id);
+                //Pop off the first array value, since it failed, and
+                //retry
+                pathConfig.shift();
+                context.require.undef(id);
+                context.require([id]);
+                return true;
+            }
+        }
+
+        //Turns a plugin!resource to [plugin, resource]
+        //with the plugin being undefined if the name
+        //did not have a plugin prefix.
+        function splitPrefix(name) {
+            var prefix,
+                index = name ? name.indexOf('!') : -1;
+            if (index > -1) {
+                prefix = name.substring(0, index);
+                name = name.substring(index + 1, name.length);
+            }
+            return [prefix, name];
+        }
+
+        /**
+         * Creates a module mapping that includes plugin prefix, module
+         * name, and path. If parentModuleMap is provided it will
+         * also normalize the name via require.normalize()
+         *
+         * @param {String} name the module name
+         * @param {String} [parentModuleMap] parent module map
+         * for the module name, used to resolve relative names.
+         * @param {Boolean} isNormalized: is the ID already normalized.
+         * This is true if this call is done for a define() module ID.
+         * @param {Boolean} applyMap: apply the map config to the ID.
+         * Should only be true if this map is for a dependency.
+         *
+         * @returns {Object}
+         */
+        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
+            var url, pluginModule, suffix, nameParts,
+                prefix = null,
+                parentName = parentModuleMap ? parentModuleMap.name : null,
+                originalName = name,
+                isDefine = true,
+                normalizedName = '';
+
+            //If no name, then it means it is a require call, generate an
+            //internal name.
+            if (!name) {
+                isDefine = false;
+                name = '_@r' + (requireCounter += 1);
+            }
+
+            nameParts = splitPrefix(name);
+            prefix = nameParts[0];
+            name = nameParts[1];
+
+            if (prefix) {
+                prefix = normalize(prefix, parentName, applyMap);
+                pluginModule = getOwn(defined, prefix);
+            }
+
+            //Account for relative paths if there is a base name.
+            if (name) {
+                if (prefix) {
+                    if (pluginModule && pluginModule.normalize) {
+                        //Plugin is loaded, use its normalize method.
+                        normalizedName = pluginModule.normalize(name, function (name) {
+                            return normalize(name, parentName, applyMap);
+                        });
+                    } else {
+                        normalizedName = normalize(name, parentName, applyMap);
+                    }
+                } else {
+                    //A regular module.
+                    normalizedName = normalize(name, parentName, applyMap);
+
+                    //Normalized name may be a plugin ID due to map config
+                    //application in normalize. The map config values must
+                    //already be normalized, so do not need to redo that part.
+                    nameParts = splitPrefix(normalizedName);
+                    prefix = nameParts[0];
+                    normalizedName = nameParts[1];
+                    isNormalized = true;
+
+                    url = context.nameToUrl(normalizedName);
+                }
+            }
+
+            //If the id is a plugin id that cannot be determined if it needs
+            //normalization, stamp it with a unique ID so two matching relative
+            //ids that may conflict can be separate.
+            suffix = prefix && !pluginModule && !isNormalized ?
+                     '_unnormalized' + (unnormalizedCounter += 1) :
+                     '';
+
+            return {
+                prefix: prefix,
+                name: normalizedName,
+                parentMap: parentModuleMap,
+                unnormalized: !!suffix,
+                url: url,
+                originalName: originalName,
+                isDefine: isDefine,
+                id: (prefix ?
+                        prefix + '!' + normalizedName :
+                        normalizedName) + suffix
+            };
+        }
+
+        function getModule(depMap) {
+            var id = depMap.id,
+                mod = getOwn(registry, id);
+
+            if (!mod) {
+                mod = registry[id] = new context.Module(depMap);
+            }
+
+            return mod;
+        }
+
+        function on(depMap, name, fn) {
+            var id = depMap.id,
+                mod = getOwn(registry, id);
+
+            if (hasProp(defined, id) &&
+                    (!mod || mod.defineEmitComplete)) {
+                if (name === 'defined') {
+                    fn(defined[id]);
+                }
+            } else {
+                mod = getModule(depMap);
+                if (mod.error && name === 'error') {
+                    fn(mod.error);
+                } else {
+                    mod.on(name, fn);
+                }
+            }
+        }
+
+        function onError(err, errback) {
+            var ids = err.requireModules,
+                notified = false;
+
+            if (errback) {
+                errback(err);
+            } else {
+                each(ids, function (id) {
+                    var mod = getOwn(registry, id);
+                    if (mod) {
+                        //Set error on module, so it skips timeout checks.
+                        mod.error = err;
+                        if (mod.events.error) {
+                            notified = true;
+                            mod.emit('error', err);
+                        }
+                    }
+                });
+
+                if (!notified) {
+                    req.onError(err);
+                }
+            }
+        }
+
+        /**
+         * Internal method to transfer globalQueue items to this context's
+         * defQueue.
+         */
+        function takeGlobalQueue() {
+            //Push all the globalDefQueue items into the context's defQueue
+            if (globalDefQueue.length) {
+                //Array splice in the values since the context code has a
+                //local var ref to defQueue, so cannot just reassign the one
+                //on context.
+                apsp.apply(defQueue,
+                           [defQueue.length - 1, 0].concat(globalDefQueue));
+                globalDefQueue = [];
+            }
+        }
+
+        handlers = {
+            'require': function (mod) {
+                if (mod.require) {
+                    return mod.require;
+                } else {
+                    return (mod.require = context.makeRequire(mod.map));
+                }
+            },
+            'exports': function (mod) {
+                mod.usingExports = true;
+                if (mod.map.isDefine) {
+                    if (mod.exports) {
+                        return mod.exports;
+                    } else {
+                        return (mod.exports = defined[mod.map.id] = {});
+                    }
+                }
+            },
+            'module': function (mod) {
+                if (mod.module) {
+                    return mod.module;
+                } else {
+                    return (mod.module = {
+                        id: mod.map.id,
+                        uri: mod.map.url,
+                        config: function () {
+                            var c,
+                                pkg = getOwn(config.pkgs, mod.map.id);
+                            // For packages, only support config targeted
+                            // at the main module.
+                            c = pkg ? getOwn(config.config, mod.map.id + '/' + pkg.main) :
+                                      getOwn(config.config, mod.map.id);
+                            return  c || {};
+                        },
+                        exports: defined[mod.map.id]
+                    });
+                }
+            }
+        };
+
+        function cleanRegistry(id) {
+            //Clean up machinery used for waiting modules.
+            delete registry[id];
+            delete enabledRegistry[id];
+        }
+
+        function breakCycle(mod, traced, processed) {
+            var id = mod.map.id;
+
+            if (mod.error) {
+                mod.emit('error', mod.error);
+            } else {
+                traced[id] = true;
+                each(mod.depMaps, function (depMap, i) {
+                    var depId = depMap.id,
+                        dep = getOwn(registry, depId);
+
+                    //Only force things that have not completed
+                    //being defined, so still in the registry,
+                    //and only if it has not been matched up
+                    //in the module already.
+                    if (dep && !mod.depMatched[i] && !processed[depId]) {
+                        if (getOwn(traced, depId)) {
+                            mod.defineDep(i, defined[depId]);
+                            mod.check(); //pass false?
+                        } else {
+                            breakCycle(dep, traced, processed);
+                        }
+                    }
+                });
+                processed[id] = true;
+            }
+        }
+
+        function checkLoaded() {
+            var map, modId, err, usingPathFallback,
+                waitInterval = config.waitSeconds * 1000,
+                //It is possible to disable the wait interval by using waitSeconds of 0.
+                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
+                noLoads = [],
+                reqCalls = [],
+                stillLoading = false,
+                needCycleCheck = true;
+
+            //Do not bother if this call was a result of a cycle break.
+            if (inCheckLoaded) {
+                return;
+            }
+
+            inCheckLoaded = true;
+
+            //Figure out the state of all the modules.
+            eachProp(enabledRegistry, function (mod) {
+                map = mod.map;
+                modId = map.id;
+
+                //Skip things that are not enabled or in error state.
+                if (!mod.enabled) {
+                    return;
+                }
+
+                if (!map.isDefine) {
+                    reqCalls.push(mod);
+                }
+
+                if (!mod.error) {
+                    //If the module should be executed, and it has not
+                    //been inited and time is up, remember it.
+                    if (!mod.inited && expired) {
+                        if (hasPathFallback(modId)) {
+                            usingPathFallback = true;
+                            stillLoading = true;
+                        } else {
+                            noLoads.push(modId);
+                            removeScript(modId);
+                        }
+                    } else if (!mod.inited && mod.fetched && map.isDefine) {
+                        stillLoading = true;
+                        if (!map.prefix) {
+                            //No reason to keep looking for unfinished
+                            //loading. If the only stillLoading is a
+                            //plugin resource though, keep going,
+                            //because it may be that a plugin resource
+                            //is waiting on a non-plugin cycle.
+                            return (needCycleCheck = false);
+                        }
+                    }
+                }
+            });
+
+            if (expired && noLoads.length) {
+                //If wait time expired, throw error of unloaded modules.
+                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
+                err.contextName = context.contextName;
+                return onError(err);
+            }
+
+            //Not expired, check for a cycle.
+            if (needCycleCheck) {
+                each(reqCalls, function (mod) {
+                    breakCycle(mod, {}, {});
+                });
+            }
+
+            //If still waiting on loads, and the waiting load is something
+            //other than a plugin resource, or there are still outstanding
+            //scripts, then just try back later.
+            if ((!expired || usingPathFallback) && stillLoading) {
+                //Something is still waiting to load. Wait for it, but only
+                //if a timeout is not already in effect.
+                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
+                    checkLoadedTimeoutId = setTimeout(function () {
+                        checkLoadedTimeoutId = 0;
+                        checkLoaded();
+                    }, 50);
+                }
+            }
+
+            inCheckLoaded = false;
+        }
+
+        Module = function (map) {
+            this.events = getOwn(undefEvents, map.id) || {};
+            this.map = map;
+            this.shim = getOwn(config.shim, map.id);
+            this.depExports = [];
+            this.depMaps = [];
+            this.depMatched = [];
+            this.pluginMaps = {};
+            this.depCount = 0;
+
+            /* this.exports this.factory
+               this.depMaps = [],
+               this.enabled, this.fetched
+            */
+        };
+
+        Module.prototype = {
+            init: function (depMaps, factory, errback, options) {
+                options = options || {};
+
+                //Do not do more inits if already done. Can happen if there
+                //are multiple define calls for the same module. That is not
+                //a normal, common case, but it is also not unexpected.
+                if (this.inited) {
+                    return;
+                }
+
+                this.factory = factory;
+
+                if (errback) {
+                    //Register for errors on this module.
+                    this.on('error', errback);
+                } else if (this.events.error) {
+                    //If no errback already, but there are error listeners
+                    //on this module, set up an errback to pass to the deps.
+                    errback = bind(this, function (err) {
+                        this.emit('error', err);
+                    });
+                }
+
+                //Do a copy of the dependency array, so that
+                //source inputs are not modified. For example
+                //"shim" deps are passed in here directly, and
+                //doing a direct modification of the depMaps array
+                //would affect that config.
+                this.depMaps = depMaps && depMaps.slice(0);
+
+                this.errback = errback;
+
+                //Indicate this module has be initialized
+                this.inited = true;
+
+                this.ignore = options.ignore;
+
+                //Could have option to init this module in enabled mode,
+                //or could have been previously marked as enabled. However,
+                //the dependencies are not known until init is called. So
+                //if enabled previously, now trigger dependencies as enabled.
+                if (options.enabled || this.enabled) {
+                    //Enable this module and dependencies.
+                    //Will call this.check()
+                    this.enable();
+                } else {
+                    this.check();
+                }
+            },
+
+            defineDep: function (i, depExports) {
+                //Because of cycles, defined callback for a given
+                //export can be called more than once.
+                if (!this.depMatched[i]) {
+                    this.depMatched[i] = true;
+                    this.depCount -= 1;
+                    this.depExports[i] = depExports;
+                }
+            },
+
+            fetch: function () {
+                if (this.fetched) {
+                    return;
+                }
+                this.fetched = true;
+
+                context.startTime = (new Date()).getTime();
+
+                var map = this.map;
+
+                //If the manager is for a plugin managed resource,
+                //ask the plugin to load it now.
+                if (this.shim) {
+                    context.makeRequire(this.map, {
+                        enableBuildCallback: true
+                    })(this.shim.deps || [], bind(this, function () {
+                        return map.prefix ? this.callPlugin() : this.load();
+                    }));
+                } else {
+                    //Regular dependency.
+                    return map.prefix ? this.callPlugin() : this.load();
+                }
+            },
+
+            load: function () {
+                var url = this.map.url;
+
+                //Regular dependency.
+                if (!urlFetched[url]) {
+                    urlFetched[url] = true;
+                    context.load(this.map.id, url);
+                }
+            },
+
+            /**
+             * Checks if the module is ready to define itself, and if so,
+             * define it.
+             */
+            check: function () {
+                if (!this.enabled || this.enabling) {
+                    return;
+                }
+
+                var err, cjsModule,
+                    id = this.map.id,
+                    depExports = this.depExports,
+                    exports = this.exports,
+                    factory = this.factory;
+
+                if (!this.inited) {
+                    this.fetch();
+                } else if (this.error) {
+                    this.emit('error', this.error);
+                } else if (!this.defining) {
+                    //The factory could trigger another require call
+                    //that would result in checking this module to
+                    //define itself again. If already in the process
+                    //of doing that, skip this work.
+                    this.defining = true;
+
+                    if (this.depCount < 1 && !this.defined) {
+                        if (isFunction(factory)) {
+                            //If there is an error listener, favor passing
+                            //to that instead of throwing an error. However,
+                            //only do it for define()'d  modules. require
+                            //errbacks should not be called for failures in
+                            //their callbacks (#699). However if a global
+                            //onError is set, use that.
+                            if ((this.events.error && this.map.isDefine) ||
+                                req.onError !== defaultOnError) {
+                                try {
+                                    exports = context.execCb(id, factory, depExports, exports);
+                                } catch (e) {
+                                    err = e;
+                                }
+                            } else {
+                                exports = context.execCb(id, factory, depExports, exports);
+                            }
+
+                            if (this.map.isDefine) {
+                                //If setting exports via 'module' is in play,
+                                //favor that over return value and exports. After that,
+                                //favor a non-undefined return value over exports use.
+                                cjsModule = this.module;
+                                if (cjsModule &&
+                                        cjsModule.exports !== undefined &&
+                                        //Make sure it is not already the exports value
+                                        cjsModule.exports !== this.exports) {
+                                    exports = cjsModule.exports;
+                                } else if (exports === undefined && this.usingExports) {
+                                    //exports already set the defined value.
+                                    exports = this.exports;
+                                }
+                            }
+
+                            if (err) {
+                                err.requireMap = this.map;
+                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
+                                err.requireType = this.map.isDefine ? 'define' : 'require';
+                                return onError((this.error = err));
+                            }
+
+                        } else {
+                            //Just a literal value
+                            exports = factory;
+                        }
+
+                        this.exports = exports;
+
+                        if (this.map.isDefine && !this.ignore) {
+                            defined[id] = exports;
+
+                            if (req.onResourceLoad) {
+                                req.onResourceLoad(context, this.map, this.depMaps);
+                            }
+                        }
+
+                        //Clean up
+                        cleanRegistry(id);
+
+                        this.defined = true;
+                    }
+
+                    //Finished the define stage. Allow calling check again
+                    //to allow define notifications below in the case of a
+                    //cycle.
+                    this.defining = false;
+
+                    if (this.defined && !this.defineEmitted) {
+                        this.defineEmitted = true;
+                        this.emit('defined', this.exports);
+                        this.defineEmitComplete = true;
+                    }
+
+                }
+            },
+
+            callPlugin: function () {
+                var map = this.map,
+                    id = map.id,
+                    //Map already normalized the prefix.
+                    pluginMap = makeModuleMap(map.prefix);
+
+                //Mark this as a dependency for this plugin, so it
+                //can be traced for cycles.
+                this.depMaps.push(pluginMap);
+
+                on(pluginMap, 'defined', bind(this, function (plugin) {
+                    var load, normalizedMap, normalizedMod,
+                        name = this.map.name,
+                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
+                        localRequire = context.makeRequire(map.parentMap, {
+                            enableBuildCallback: true
+                        });
+
+                    //If current map is not normalized, wait for that
+                    //normalized name to load instead of continuing.
+                    if (this.map.unnormalized) {
+                        //Normalize the ID if the plugin allows it.
+                        if (plugin.normalize) {
+                            name = plugin.normalize(name, function (name) {
+                                return normalize(name, parentName, true);
+                            }) || '';
+                        }
+
+                        //prefix and name should already be normalized, no need
+                        //for applying map config again either.
+                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
+                                                      this.map.parentMap);
+                        on(normalizedMap,
+                            'defined', bind(this, function (value) {
+                                this.init([], function () { return value; }, null, {
+                                    enabled: true,
+                                    ignore: true
+                                });
+                            }));
+
+                        normalizedMod = getOwn(registry, normalizedMap.id);
+                        if (normalizedMod) {
+                            //Mark this as a dependency for this plugin, so it
+                            //can be traced for cycles.
+                            this.depMaps.push(normalizedMap);
+
+                            if (this.events.error) {
+                                normalizedMod.on('error', bind(this, function (err) {
+                                    this.emit('error', err);
+                                }));
+                            }
+                            normalizedMod.enable();
+                        }
+
+                        return;
+                    }
+
+                    load = bind(this, function (value) {
+                        this.init([], function () { return value; }, null, {
+                            enabled: true
+                        });
+                    });
+
+                    load.error = bind(this, function (err) {
+                        this.inited = true;
+                        this.error = err;
+                        err.requireModules = [id];
+
+                        //Remove temp unnormalized modules for this module,
+                        //since they will never be resolved otherwise now.
+                        eachProp(registry, function (mod) {
+                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
+                                cleanRegistry(mod.map.id);
+                            }
+                        });
+
+                        onError(err);
+                    });
+
+                    //Allow plugins to load other code without having to know the
+                    //context or how to 'complete' the load.
+                    load.fromText = bind(this, function (text, textAlt) {
+                        /*jslint evil: true */
+                        var moduleName = map.name,
+                            moduleMap = makeModuleMap(moduleName),
+                            hasInteractive = useInteractive;
+
+                        //As of 2.1.0, support just passing the text, to reinforce
+                        //fromText only being called once per resource. Still
+                        //support old style of passing moduleName but discard
+                        //that moduleName in favor of the internal ref.
+                        if (textAlt) {
+                            text = textAlt;
+                        }
+
+                        //Turn off interactive script matching for IE for any define
+                        //calls in the text, then turn it back on at the end.
+                        if (hasInteractive) {
+                            useInteractive = false;
+                        }
+
+                        //Prime the system by creating a module instance for
+                        //it.
+                        getModule(moduleMap);
+
+                        //Transfer any config to this other module.
+                        if (hasProp(config.config, id)) {
+                            config.config[moduleName] = config.config[id];
+                        }
+
+                        try {
+                            req.exec(text);
+                        } catch (e) {
+                            return onError(makeError('fromtexteval',
+                                             'fromText eval for ' + id +
+                                            ' failed: ' + e,
+                                             e,
+                                             [id]));
+                        }
+
+                        if (hasInteractive) {
+                            useInteractive = true;
+                        }
+
+                        //Mark this as a dependency for the plugin
+                        //resource
+                        this.depMaps.push(moduleMap);
+
+                        //Support anonymous modules.
+                        context.completeLoad(moduleName);
+
+                        //Bind the value of that module to the value for this
+                        //resource ID.
+                        localRequire([moduleName], load);
+                    });
+
+                    //Use parentName here since the plugin's name is not reliable,
+                    //could be some weird string with no path that actually wants to
+                    //reference the parentName's path.
+                    plugin.load(map.name, localRequire, load, config);
+                }));
+
+                context.enable(pluginMap, this);
+                this.pluginMaps[pluginMap.id] = pluginMap;
+            },
+
+            enable: function () {
+                enabledRegistry[this.map.id] = this;
+                this.enabled = true;
+
+                //Set flag mentioning that the module is enabling,
+                //so that immediate calls to the defined callbacks
+                //for dependencies do not trigger inadvertent load
+                //with the depCount still being zero.
+                this.enabling = true;
+
+                //Enable each dependency
+                each(this.depMaps, bind(this, function (depMap, i) {
+                    var id, mod, handler;
+
+                    if (typeof depMap === 'string') {
+                        //Dependency needs to be converted to a depMap
+                        //and wired up to this module.
+                        depMap = makeModuleMap(depMap,
+                                               (this.map.isDefine ? this.map : this.map.parentMap),
+                                               false,
+                                               !this.skipMap);
+                        this.depMaps[i] = depMap;
+
+                        handler = getOwn(handlers, depMap.id);
+
+                        if (handler) {
+                            this.depExports[i] = handler(this);
+                            return;
+                        }
+
+                        this.depCount += 1;
+
+                        on(depMap, 'defined', bind(this, function (depExports) {
+                            this.defineDep(i, depExports);
+                            this.check();
+                        }));
+
+                        if (this.errback) {
+                            on(depMap, 'error', bind(this, this.errback));
+                        }
+                    }
+
+                    id = depMap.id;
+                    mod = registry[id];
+
+                    //Skip special modules like 'require', 'exports', 'module'
+                    //Also, don't call enable if it is already enabled,
+                    //important in circular dependency cases.
+                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
+                        context.enable(depMap, this);
+                    }
+                }));
+
+                //Enable each plugin that is used in
+                //a dependency
+                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
+                    var mod = getOwn(registry, pluginMap.id);
+                    if (mod && !mod.enabled) {
+                        context.enable(pluginMap, this);
+                    }
+                }));
+
+                this.enabling = false;
+
+                this.check();
+            },
+
+            on: function (name, cb) {
+                var cbs = this.events[name];
+                if (!cbs) {
+                    cbs = this.events[name] = [];
+                }
+                cbs.push(cb);
+            },
+
+            emit: function (name, evt) {
+                each(this.events[name], function (cb) {
+                    cb(evt);
+                });
+                if (name === 'error') {
+                    //Now that the error handler was triggered, remove
+                    //the listeners, since this broken Module instance
+                    //can stay around for a while in the registry.
+                    delete this.events[name];
+                }
+            }
+        };
+
+        function callGetModule(args) {
+            //Skip modules already defined.
+            if (!hasProp(defined, args[0])) {
+                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
+            }
+        }
+
+        function removeListener(node, func, name, ieName) {
+            //Favor detachEvent because of IE9
+            //issue, see attachEvent/addEventListener comment elsewhere
+            //in this file.
+            if (node.detachEvent && !isOpera) {
+                //Probably IE. If not it will throw an error, which will be
+                //useful to know.
+                if (ieName) {
+                    node.detachEvent(ieName, func);
+                }
+            } else {
+                node.removeEventListener(name, func, false);
+            }
+        }
+
+        /**
+         * Given an event from a script node, get the requirejs info from it,
+         * and then removes the event listeners on the node.
+         * @param {Event} evt
+         * @returns {Object}
+         */
+        function getScriptData(evt) {
+            //Using currentTarget instead of target for Firefox 2.0's sake. Not
+            //all old browsers will be supported, but this one was easy enough
+            //to support and still makes sense.
+            var node = evt.currentTarget || evt.srcElement;
+
+            //Remove the listeners once here.
+            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
+            removeListener(node, context.onScriptError, 'error');
+
+            return {
+                node: node,
+                id: node && node.getAttribute('data-requiremodule')
+            };
+        }
+
+        function intakeDefines() {
+            var args;
+
+            //Any defined modules in the global queue, intake them now.
+            takeGlobalQueue();
+
+            //Make sure any remaining defQueue items get properly processed.
+            while (defQueue.length) {
+                args = defQueue.shift();
+                if (args[0] === null) {
+                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
+                } else {
+                    //args are id, deps, factory. Should be normalized by the
+                    //define() function.
+                    callGetModule(args);
+                }
+            }
+        }
+
+        context = {
+            config: config,
+            contextName: contextName,
+            registry: registry,
+            defined: defined,
+            urlFetched: urlFetched,
+            defQueue: defQueue,
+            Module: Module,
+            makeModuleMap: makeModuleMap,
+            nextTick: req.nextTick,
+            onError: onError,
+
+            /**
+             * Set a configuration for the context.
+             * @param {Object} cfg config object to integrate.
+             */
+            configure: function (cfg) {
+                //Make sure the baseUrl ends in a slash.
+                if (cfg.baseUrl) {
+                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
+                        cfg.baseUrl += '/';
+                    }
+                }
+
+                //Save off the paths and packages since they require special processing,
+                //they are additive.
+                var pkgs = config.pkgs,
+                    shim = config.shim,
+                    objs = {
+                        paths: true,
+                        config: true,
+                        map: true
+                    };
+
+                eachProp(cfg, function (value, prop) {
+                    if (objs[prop]) {
+                        if (prop === 'map') {
+                            if (!config.map) {
+                                config.map = {};
+                            }
+                            mixin(config[prop], value, true, true);
+                        } else {
+                            mixin(config[prop], value, true);
+                        }
+                    } else {
+                        config[prop] = value;
+                    }
+                });
+
+                //Merge shim
+                if (cfg.shim) {
+                    eachProp(cfg.shim, function (value, id) {
+                        //Normalize the structure
+                        if (isArray(value)) {
+                            value = {
+                                deps: value
+                            };
+                        }
+                        if ((value.exports || value.init) && !value.exportsFn) {
+                            value.exportsFn = context.makeShimExports(value);
+                        }
+                        shim[id] = value;
+                    });
+                    config.shim = shim;
+                }
+
+                //Adjust packages if necessary.
+                if (cfg.packages) {
+                    each(cfg.packages, function (pkgObj) {
+                        var location;
+
+                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
+                        location = pkgObj.location;
+
+                        //Create a brand new object on pkgs, since currentPackages can
+                        //be passed in again, and config.pkgs is the internal transformed
+                        //state for all package configs.
+                        pkgs[pkgObj.name] = {
+                            name: pkgObj.name,
+                            location: location || pkgObj.name,
+                            //Remove leading dot in main, so main paths are normalized,
+                            //and remove any trailing .js, since different package
+                            //envs have different conventions: some use a module name,
+                            //some use a file name.
+                            main: (pkgObj.main || 'main')
+                                  .replace(currDirRegExp, '')
+                                  .replace(jsSuffixRegExp, '')
+                        };
+                    });
+
+                    //Done with modifications, assing packages back to context config
+                    config.pkgs = pkgs;
+                }
+
+                //If there are any "waiting to execute" modules in the registry,
+                //update the maps for them, since their info, like URLs to load,
+                //may have changed.
+                eachProp(registry, function (mod, id) {
+                    //If module already has init called, since it is too
+                    //late to modify them, and ignore unnormalized ones
+                    //since they are transient.
+                    if (!mod.inited && !mod.map.unnormalized) {
+                        mod.map = makeModuleMap(id);
+                    }
+                });
+
+                //If a deps array or a config callback is specified, then call
+                //require with those args. This is useful when require is defined as a
+                //config object before require.js is loaded.
+                if (cfg.deps || cfg.callback) {
+                    context.require(cfg.deps || [], cfg.callback);
+                }
+            },
+
+            makeShimExports: function (value) {
+                function fn() {
+                    var ret;
+                    if (value.init) {
+                        ret = value.init.apply(global, arguments);
+                    }
+                    return ret || (value.exports && getGlobal(value.exports));
+                }
+                return fn;
+            },
+
+            makeRequire: function (relMap, options) {
+                options = options || {};
+
+                function localRequire(deps, callback, errback) {
+                    var id, map, requireMod;
+
+                    if (options.enableBuildCallback && callback && isFunction(callback)) {
+                        callback.__requireJsBuild = true;
+                    }
+
+                    if (typeof deps === 'string') {
+                        if (isFunction(callback)) {
+                            //Invalid call
+                            return onError(makeError('requireargs', 'Invalid require call'), errback);
+                        }
+
+                        //If require|exports|module are requested, get the
+                        //value for them from the special handlers. Caveat:
+                        //this only works while module is being defined.
+                        if (relMap && hasProp(handlers, deps)) {
+                            return handlers[deps](registry[relMap.id]);
+                        }
+
+                        //Synchronous access to one module. If require.get is
+                        //available (as in the Node adapter), prefer that.
+                        if (req.get) {
+                            return req.get(context, deps, relMap, localRequire);
+                        }
+
+                        //Normalize module name, if it contains . or ..
+                        map = makeModuleMap(deps, relMap, false, true);
+                        id = map.id;
+
+                        if (!hasProp(defined, id)) {
+                            return onError(makeError('notloaded', 'Module name "' +
+                                        id +
+                                        '" has not been loaded yet for context: ' +
+                                        contextName +
+                                        (relMap ? '' : '. Use require([])')));
+                        }
+                        return defined[id];
+                    }
+
+                    //Grab defines waiting in the global queue.
+                    intakeDefines();
+
+                    //Mark all the dependencies as needing to be loaded.
+                    context.nextTick(function () {
+                        //Some defines could have been added since the
+                        //require call, collect them.
+                        intakeDefines();
+
+                        requireMod = getModule(makeModuleMap(null, relMap));
+
+                        //Store if map config should be applied to this require
+                        //call for dependencies.
+                        requireMod.skipMap = options.skipMap;
+
+                        requireMod.init(deps, callback, errback, {
+                            enabled: true
+                        });
+
+                        checkLoaded();
+                    });
+
+                    return localRequire;
+                }
+
+                mixin(localRequire, {
+                    isBrowser: isBrowser,
+
+                    /**
+                     * Converts a module name + .extension into an URL path.
+                     * *Requires* the use of a module name. It does not support using
+                     * plain URLs like nameToUrl.
+                     */
+                    toUrl: function (moduleNamePlusExt) {
+                        var ext,
+                            index = moduleNamePlusExt.lastIndexOf('.'),
+                            segment = moduleNamePlusExt.split('/')[0],
+                            isRelative = segment === '.' || segment === '..';
+
+                        //Have a file extension alias, and it is not the
+                        //dots from a relative path.
+                        if (index !== -1 && (!isRelative || index > 1)) {
+                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
+                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
+                        }
+
+                        return context.nameToUrl(normalize(moduleNamePlusExt,
+                                                relMap && relMap.id, true), ext,  true);
+                    },
+
+                    defined: function (id) {
+                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
+                    },
+
+                    specified: function (id) {
+                        id = makeModuleMap(id, relMap, false, true).id;
+                        return hasProp(defined, id) || hasProp(registry, id);
+                    }
+                });
+
+                //Only allow undef on top level require calls
+                if (!relMap) {
+                    localRequire.undef = function (id) {
+                        //Bind any waiting define() calls to this context,
+                        //fix for #408
+                        takeGlobalQueue();
+
+                        var map = makeModuleMap(id, relMap, true),
+                            mod = getOwn(registry, id);
+
+                        delete defined[id];
+                        delete urlFetched[map.url];
+                        delete undefEvents[id];
+
+                        if (mod) {
+                            //Hold on to listeners in case the
+                            //module will be attempted to be reloaded
+                            //using a different config.
+                            if (mod.events.defined) {
+                                undefEvents[id] = mod.events;
+                            }
+
+                            cleanRegistry(id);
+                        }
+                    };
+                }
+
+                return localRequire;
+            },
+
+            /**
+             * Called to enable a module if it is still in the registry
+             * awaiting enablement. A second arg, parent, the parent module,
+             * is passed in for context, when this method is overriden by
+             * the optimizer. Not shown here to keep code compact.
+             */
+            enable: function (depMap) {
+                var mod = getOwn(registry, depMap.id);
+                if (mod) {
+                    getModule(depMap).enable();
+                }
+            },
+
+            /**
+             * Internal method used by environment adapters to complete a load event.
+             * A load event could be a script load or just a load pass from a synchronous
+             * load call.
+             * @param {String} moduleName the name of the module to potentially complete.
+             */
+            completeLoad: function (moduleName) {
+                var found, args, mod,
+                    shim = getOwn(config.shim, moduleName) || {},
+                    shExports = shim.exports;
+
+                takeGlobalQueue();
+
+                while (defQueue.length) {
+                    args = defQueue.shift();
+                    if (args[0] === null) {
+                        args[0] = moduleName;
+                        //If already found an anonymous module and bound it
+                        //to this name, then this is some other anon module
+                        //waiting for its completeLoad to fire.
+                        if (found) {
+                            break;
+                        }
+                        found = true;
+                    } else if (args[0] === moduleName) {
+                        //Found matching define call for this script!
+                        found = true;
+                    }
+
+                    callGetModule(args);
+                }
+
+                //Do this after the cycle of callGetModule in case the result
+                //of those calls/init calls changes the registry.
+                mod = getOwn(registry, moduleName);
+
+                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
+                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
+                        if (hasPathFallback(moduleName)) {
+                            return;
+                        } else {
+                            return onError(makeError('nodefine',
+                                             'No define call for ' + moduleName,
+                                             null,
+                                             [moduleName]));
+                        }
+                    } else {
+                        //A script that does not call define(), so just simulate
+                        //the call for it.
+                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
+                    }
+                }
+
+                checkLoaded();
+            },
+
+            /**
+             * Converts a module name to a file path. Supports cases where
+             * moduleName may actually be just an URL.
+             * Note that it **does not** call normalize on the moduleName,
+             * it is assumed to have already been normalized. This is an
+             * internal API, not a public one. Use toUrl for the public API.
+             */
+            nameToUrl: function (moduleName, ext, skipExt) {
+                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
+                    parentPath;
+
+                //If a colon is in the URL, it indicates a protocol is used and it is just
+                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
+                //or ends with .js, then assume the user meant to use an url and not a module id.
+                //The slash is important for protocol-less URLs as well as full paths.
+                if (req.jsExtRegExp.test(moduleName)) {
+                    //Just a plain path, not module name lookup, so just return it.
+                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
+                    //an extension, this method probably needs to be reworked.
+                    url = moduleName + (ext || '');
+                } else {
+                    //A module that needs to be converted to a path.
+                    paths = config.paths;
+                    pkgs = config.pkgs;
+
+                    syms = moduleName.split('/');
+                    //For each module name segment, see if there is a path
+                    //registered for it. Start with most specific name
+                    //and work up from it.
+                    for (i = syms.length; i > 0; i -= 1) {
+                        parentModule = syms.slice(0, i).join('/');
+                        pkg = getOwn(pkgs, parentModule);
+                        parentPath = getOwn(paths, parentModule);
+                        if (parentPath) {
+                            //If an array, it means there are a few choices,
+                            //Choose the one that is desired
+                            if (isArray(parentPath)) {
+                                parentPath = parentPath[0];
+                            }
+                            syms.splice(0, i, parentPath);
+                            break;
+                        } else if (pkg) {
+                            //If module name is just the package name, then looking
+                            //for the main module.
+                            if (moduleName === pkg.name) {
+                                pkgPath = pkg.location + '/' + pkg.main;
+                            } else {
+                                pkgPath = pkg.location;
+                            }
+                            syms.splice(0, i, pkgPath);
+                            break;
+                        }
+                    }
+
+                    //Join the path parts together, then figure out if baseUrl is needed.
+                    url = syms.join('/');
+                    url += (ext || (/\?/.test(url) || skipExt ? '' : '.js'));
+                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
+                }
+
+                return config.urlArgs ? url +
+                                        ((url.indexOf('?') === -1 ? '?' : '&') +
+                                         config.urlArgs) : url;
+            },
+
+            //Delegates to req.load. Broken out as a separate function to
+            //allow overriding in the optimizer.
+            load: function (id, url) {
+                req.load(context, id, url);
+            },
+
+            /**
+             * Executes a module callback function. Broken out as a separate function
+             * solely to allow the build system to sequence the files in the built
+             * layer in the right sequence.
+             *
+             * @private
+             */
+            execCb: function (name, callback, args, exports) {
+                return callback.apply(exports, args);
+            },
+
+            /**
+             * callback for script loads, used to check status of loading.
+             *
+             * @param {Event} evt the event from the browser for the script
+             * that was loaded.
+             */
+            onScriptLoad: function (evt) {
+                //Using currentTarget instead of target for Firefox 2.0's sake. Not
+                //all old browsers will be supported, but this one was easy enough
+                //to support and still makes sense.
+                if (evt.type === 'load' ||
+                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
+                    //Reset interactive script so a script node is not held onto for
+                    //to long.
+                    interactiveScript = null;
+
+                    //Pull out the name of the module and the context.
+                    var data = getScriptData(evt);
+                    context.completeLoad(data.id);
+                }
+            },
+
+            /**
+             * Callback for script errors.
+             */
+            onScriptError: function (evt) {
+                var data = getScriptData(evt);
+                if (!hasPathFallback(data.id)) {
+                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
+                }
+            }
+        };
+
+        context.require = context.makeRequire();
+        return context;
+    }
+
+    /**
+     * Main entry point.
+     *
+     * If the only argument to require is a string, then the module that
+     * is represented by that string is fetched for the appropriate context.
+     *
+     * If the first argument is an array, then it will be treated as an array
+     * of dependency string names to fetch. An optional function callback can
+     * be specified to execute when all of those dependencies are available.
+     *
+     * Make a local req variable to help Caja compliance (it assumes things
+     * on a require that are not standardized), and to give a short
+     * name for minification/local scope use.
+     */
+    req = requirejs = function (deps, callback, errback, optional) {
+
+        //Find the right context, use default
+        var context, config,
+            contextName = defContextName;
+
+        // Determine if have config object in the call.
+        if (!isArray(deps) && typeof deps !== 'string') {
+            // deps is a config object
+            config = deps;
+            if (isArray(callback)) {
+                // Adjust args if there are dependencies
+                deps = callback;
+                callback = errback;
+                errback = optional;
+            } else {
+                deps = [];
+            }
+        }
+
+        if (config && config.context) {
+            contextName = config.context;
+        }
+
+        context = getOwn(contexts, contextName);
+        if (!context) {
+            context = contexts[contextName] = req.s.newContext(contextName);
+        }
+
+        if (config) {
+            context.configure(config);
+        }
+
+        return context.require(deps, callback, errback);
+    };
+
+    /**
+     * Support require.config() to make it easier to cooperate with other
+     * AMD loaders on globally agreed names.
+     */
+    req.config = function (config) {
+        return req(config);
+    };
+
+    /**
+     * Execute something after the current tick
+     * of the event loop. Override for other envs
+     * that have a better solution than setTimeout.
+     * @param  {Function} fn function to execute later.
+     */
+    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
+        setTimeout(fn, 4);
+    } : function (fn) { fn(); };
+
+    /**
+     * Export require as a global, but only if it does not already exist.
+     */
+    if (!require) {
+        require = req;
+    }
+
+    req.version = version;
+
+    //Used to filter out dependencies that are already paths.
+    req.jsExtRegExp = /^\/|:|\?|\.js$/;
+    req.isBrowser = isBrowser;
+    s = req.s = {
+        contexts: contexts,
+        newContext: newContext
+    };
+
+    //Create default context.
+    req({});
+
+    //Exports some context-sensitive methods on global require.
+    each([
+        'toUrl',
+        'undef',
+        'defined',
+        'specified'
+    ], function (prop) {
+        //Reference from contexts instead of early binding to default context,
+        //so that during builds, the latest instance of the default context
+        //with its config gets used.
+        req[prop] = function () {
+            var ctx = contexts[defContextName];
+            return ctx.require[prop].apply(ctx, arguments);
+        };
+    });
+
+    if (isBrowser) {
+        head = s.head = document.getElementsByTagName('head')[0];
+        //If BASE tag is in play, using appendChild is a problem for IE6.
+        //When that browser dies, this can be removed. Details in this jQuery bug:
+        //http://dev.jquery.com/ticket/2709
+        baseElement = document.getElementsByTagName('base')[0];
+        if (baseElement) {
+            head = s.head = baseElement.parentNode;
+        }
+    }
+
+    /**
+     * Any errors that require explicitly generates will be passed to this
+     * function. Intercept/override it if you want custom error handling.
+     * @param {Error} err the error object.
+     */
+    req.onError = defaultOnError;
+
+    /**
+     * Does the request to load a module for the browser case.
+     * Make this a separate function to allow other environments
+     * to override it.
+     *
+     * @param {Object} context the require context to find state.
+     * @param {String} moduleName the name of the module.
+     * @param {Object} url the URL to the module.
+     */
+    req.load = function (context, moduleName, url) {
+        var config = (context && context.config) || {},
+            node;
+        if (isBrowser) {
+            //In the browser so use a script tag
+            node = config.xhtml ?
+                    document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
+                    document.createElement('script');
+            node.type = config.scriptType || 'text/javascript';
+            node.charset = 'utf-8';
+            node.async = true;
+
+            node.setAttribute('data-requirecontext', context.contextName);
+            node.setAttribute('data-requiremodule', moduleName);
+
+            //Set up load listener. Test attachEvent first because IE9 has
+            //a subtle issue in its addEventListener and script onload firings
+            //that do not match the behavior of all other browsers with
+            //addEventListener support, which fire the onload event for a
+            //script right after the script execution. See:
+            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
+            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
+            //script execution mode.
+            if (node.attachEvent &&
+                    //Check if node.attachEvent is artificially added by custom script or
+                    //natively supported by browser
+                    //read https://github.com/jrburke/requirejs/issues/187
+                    //if we can NOT find [native code] then it must NOT natively supported.
+                    //in IE8, node.attachEvent does not have toString()
+                    //Note the test for "[native code" with no closing brace, see:
+                    //https://github.com/jrburke/requirejs/issues/273
+                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
+                    !isOpera) {
+                //Probably IE. IE (at least 6-8) do not fire
+                //script onload right after executing the script, so
+                //we cannot tie the anonymous define call to a name.
+                //However, IE reports the script as being in 'interactive'
+                //readyState at the time of the define call.
+                useInteractive = true;
+
+                node.attachEvent('onreadystatechange', context.onScriptLoad);
+                //It would be great to add an error handler here to catch
+                //404s in IE9+. However, onreadystatechange will fire before
+                //the error handler, so that does not help. If addEventListener
+                //is used, then IE will fire error before load, but we cannot
+                //use that pathway given the connect.microsoft.com issue
+                //mentioned above about not doing the 'script execute,
+                //then fire the script load event listener before execute
+                //next script' that other browsers do.
+                //Best hope: IE10 fixes the issues,
+                //and then destroys all installs of IE 6-9.
+                //node.attachEvent('onerror', context.onScriptError);
+            } else {
+                node.addEventListener('load', context.onScriptLoad, false);
+                node.addEventListener('error', context.onScriptError, false);
+            }
+            node.src = url;
+
+            //For some cache cases in IE 6-8, the script executes before the end
+            //of the appendChild execution, so to tie an anonymous define
+            //call to the module name (which is stored on the node), hold on
+            //to a reference to this node, but clear after the DOM insertion.
+            currentlyAddingScript = node;
+            if (baseElement) {
+                head.insertBefore(node, baseElement);
+            } else {
+                head.appendChild(node);
+            }
+            currentlyAddingScript = null;
+
+            return node;
+        } else if (isWebWorker) {
+            try {
+                //In a web worker, use importScripts. This is not a very
+                //efficient use of importScripts, importScripts will block until
+                //its script is downloaded and evaluated. However, if web workers
+                //are in play, the expectation that a build has been done so that
+                //only one script needs to be loaded anyway. This may need to be
+                //reevaluated if other use cases become common.
+                importScripts(url);
+
+                //Account for anonymous modules
+                context.completeLoad(moduleName);
+            } catch (e) {
+                context.onError(makeError('importscripts',
+                                'importScripts failed for ' +
+                                    moduleName + ' at ' + url,
+                                e,
+                                [moduleName]));
+            }
+        }
+    };
+
+    function getInteractiveScript() {
+        if (interactiveScript && interactiveScript.readyState === 'interactive') {
+            return interactiveScript;
+        }
+
+        eachReverse(scripts(), function (script) {
+            if (script.readyState === 'interactive') {
+                return (interactiveScript = script);
+            }
+        });
+        return interactiveScript;
+    }
+
+    //Look for a data-main script attribute, which could also adjust the baseUrl.
+    if (isBrowser) {
+        //Figure out baseUrl. Get it from the script tag with require.js in it.
+        eachReverse(scripts(), function (script) {
+            //Set the 'head' where we can append children by
+            //using the script's parent.
+            if (!head) {
+                head = script.parentNode;
+            }
+
+            //Look for a data-main attribute to set main script for the page
+            //to load. If it is there, the path to data main becomes the
+            //baseUrl, if it is not already set.
+            dataMain = script.getAttribute('data-main');
+            if (dataMain) {
+                //Preserve dataMain in case it is a path (i.e. contains '?')
+                mainScript = dataMain;
+
+                //Set final baseUrl if there is not already an explicit one.
+                if (!cfg.baseUrl) {
+                    //Pull off the directory of data-main for use as the
+                    //baseUrl.
+                    src = mainScript.split('/');
+                    mainScript = src.pop();
+                    subPath = src.length ? src.join('/')  + '/' : './';
+
+                    cfg.baseUrl = subPath;
+                }
+
+                //Strip off any trailing .js since mainScript is now
+                //like a module name.
+                mainScript = mainScript.replace(jsSuffixRegExp, '');
+
+                 //If mainScript is still a path, fall back to dataMain
+                if (req.jsExtRegExp.test(mainScript)) {
+                    mainScript = dataMain;
+                }
+
+                //Put the data-main script in the files to load.
+                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];
+
+                return true;
+            }
+        });
+    }
+
+    /**
+     * The function that handles definitions of modules. Differs from
+     * require() in that a string for the module should be the first argument,
+     * and the function to execute after dependencies are loaded should
+     * return a value to define the module corresponding to the first argument's
+     * name.
+     */
+    define = function (name, deps, callback) {
+        var node, context;
+
+        //Allow for anonymous modules
+        if (typeof name !== 'string') {
+            //Adjust args appropriately
+            callback = deps;
+            deps = name;
+            name = null;
+        }
+
+        //This module may not have dependencies
+        if (!isArray(deps)) {
+            callback = deps;
+            deps = null;
+        }
+
+        //If no name, and callback is a function, then figure out if it a
+        //CommonJS thing with dependencies.
+        if (!deps && isFunction(callback)) {
+            deps = [];
+            //Remove comments from the callback string,
+            //look for require calls, and pull them into the dependencies,
+            //but only if there are function args.
+            if (callback.length) {
+                callback
+                    .toString()
+                    .replace(commentRegExp, '')
+                    .replace(cjsRequireRegExp, function (match, dep) {
+                        deps.push(dep);
+                    });
+
+                //May be a CommonJS thing even without require calls, but still
+                //could use exports, and module. Avoid doing exports and module
+                //work though if it just needs require.
+                //REQUIRES the function to expect the CommonJS variables in the
+                //order listed below.
+                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
+            }
+        }
+
+        //If in IE 6-8 and hit an anonymous define() call, do the interactive
+        //work.
+        if (useInteractive) {
+            node = currentlyAddingScript || getInteractiveScript();
+            if (node) {
+                if (!name) {
+                    name = node.getAttribute('data-requiremodule');
+                }
+                context = contexts[node.getAttribute('data-requirecontext')];
+            }
+        }
+
+        //Always save off evaluating the def call until the script onload handler.
+        //This allows multiple modules to be in a file without prematurely
+        //tracing dependencies, and allows for anonymous module support,
+        //where the module name is not known until the script onload event
+        //occurs. If no context, use the global queue, and get it processed
+        //in the onscript load callback.
+        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
+    };
+
+    define.amd = {
+        jQuery: true
+    };
+
+
+    /**
+     * Executes the text. Normally just uses eval, but can be modified
+     * to use a better, environment-specific call. Only used for transpiling
+     * loader plugins, not for plain JS modules.
+     * @param {String} text the text to execute/evaluate.
+     */
+    req.exec = function (text) {
+        /*jslint evil: true */
+        return eval(text);
+    };
+
+    //Set up with config info.
+    req(cfg);
+}(this));
+
+
+
+    this.requirejsVars = {
+        require: require,
+        requirejs: require,
+        define: define
+    };
+
+    if (env === 'browser') {
+        /**
+ * @license RequireJS rhino Copyright (c) 2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+//sloppy since eval enclosed with use strict causes problems if the source
+//text is not strict-compliant.
+/*jslint sloppy: true, evil: true */
+/*global require, XMLHttpRequest */
+
+(function () {
+    require.load = function (context, moduleName, url) {
+        var xhr = new XMLHttpRequest();
+
+        xhr.open('GET', url, true);
+        xhr.send();
+
+        xhr.onreadystatechange = function () {
+            if (xhr.readyState === 4) {
+                eval(xhr.responseText);
+
+                //Support anonymous modules.
+                context.completeLoad(moduleName);
+            }
+        };
+    };
+}());
+    } else if (env === 'rhino') {
+        /**
+ * @license RequireJS rhino Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint */
+/*global require: false, java: false, load: false */
+
+(function () {
+    'use strict';
+    require.load = function (context, moduleName, url) {
+
+        load(url);
+
+        //Support anonymous modules.
+        context.completeLoad(moduleName);
+    };
+
+}());
+    } else if (env === 'node') {
+        this.requirejsVars.nodeRequire = nodeRequire;
+        require.nodeRequire = nodeRequire;
+
+        /**
+ * @license RequireJS node Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint regexp: false */
+/*global require: false, define: false, requirejsVars: false, process: false */
+
+/**
+ * This adapter assumes that x.js has loaded it and set up
+ * some variables. This adapter just allows limited RequireJS
+ * usage from within the requirejs directory. The general
+ * node adapater is r.js.
+ */
+
+(function () {
+    'use strict';
+
+    var nodeReq = requirejsVars.nodeRequire,
+        req = requirejsVars.require,
+        def = requirejsVars.define,
+        fs = nodeReq('fs'),
+        path = nodeReq('path'),
+        vm = nodeReq('vm'),
+        //In Node 0.7+ existsSync is on fs.
+        exists = fs.existsSync || path.existsSync,
+        hasOwn = Object.prototype.hasOwnProperty;
+
+    function hasProp(obj, prop) {
+        return hasOwn.call(obj, prop);
+    }
+
+    function syncTick(fn) {
+        fn();
+    }
+
+    //Supply an implementation that allows synchronous get of a module.
+    req.get = function (context, moduleName, relModuleMap, localRequire) {
+        if (moduleName === "require" || moduleName === "exports" || moduleName === "module") {
+            req.onError(new Error("Explicit require of " + moduleName + " is not allowed."));
+        }
+
+        var ret, oldTick,
+            moduleMap = context.makeModuleMap(moduleName, relModuleMap, false, true);
+
+        //Normalize module name, if it contains . or ..
+        moduleName = moduleMap.id;
+
+        if (hasProp(context.defined, moduleName)) {
+            ret = context.defined[moduleName];
+        } else {
+            if (ret === undefined) {
+                //Make sure nextTick for this type of call is sync-based.
+                oldTick = context.nextTick;
+                context.nextTick = syncTick;
+                try {
+                    if (moduleMap.prefix) {
+                        //A plugin, call requirejs to handle it. Now that
+                        //nextTick is syncTick, the require will complete
+                        //synchronously.
+                        localRequire([moduleMap.originalName]);
+
+                        //Now that plugin is loaded, can regenerate the moduleMap
+                        //to get the final, normalized ID.
+                        moduleMap = context.makeModuleMap(moduleMap.originalName, relModuleMap, false, true);
+                        moduleName = moduleMap.id;
+                    } else {
+                        //Try to dynamically fetch it.
+                        req.load(context, moduleName, moduleMap.url);
+
+                        //Enable the module
+                        context.enable(moduleMap, relModuleMap);
+                    }
+
+                    //Break any cycles by requiring it normally, but this will
+                    //finish synchronously
+                    require([moduleName]);
+
+                    //The above calls are sync, so can do the next thing safely.
+                    ret = context.defined[moduleName];
+                } finally {
+                    context.nextTick = oldTick;
+                }
+            }
+        }
+
+        return ret;
+    };
+
+    req.nextTick = function (fn) {
+        process.nextTick(fn);
+    };
+
+    //Add wrapper around the code so that it gets the requirejs
+    //API instead of the Node API, and it is done lexically so
+    //that it survives later execution.
+    req.makeNodeWrapper = function (contents) {
+        return '(function (require, requirejs, define) { ' +
+                contents +
+                '\n}(requirejsVars.require, requirejsVars.requirejs, requirejsVars.define));';
+    };
+
+    req.load = function (context, moduleName, url) {
+        var contents, err;
+
+        if (context.config.shim[moduleName]) {
+            throw new Error('Shim config not supported in Node: detected ' +
+                            'for module: ' + moduleName);
+        }
+
+        if (exists(url)) {
+            contents = fs.readFileSync(url, 'utf8');
+
+            contents = req.makeNodeWrapper(contents);
+            try {
+                vm.runInThisContext(contents, fs.realpathSync(url));
+            } catch (e) {
+                err = new Error('Evaluating ' + url + ' as module "' +
+                                moduleName + '" failed with error: ' + e);
+                err.originalError = e;
+                err.moduleName = moduleName;
+                err.fileName = url;
+                return req.onError(err);
+            }
+        } else {
+            def(moduleName, function () {
+                //Get the original name, since relative requires may be
+                //resolved differently in node (issue #202). Also, if relative,
+                //make it relative to the URL of the item requesting it
+                //(issue #393)
+                var dirName,
+                    map = hasProp(context.registry, moduleName) &&
+                            context.registry[moduleName].map,
+                    parentMap = map && map.parentMap,
+                    originalName = map && map.originalName;
+
+                if (originalName.charAt(0) === '.' && parentMap) {
+                    dirName = parentMap.url.split('/');
+                    dirName.pop();
+                    originalName = dirName.join('/') + '/' + originalName;
+                }
+
+                try {
+                    return (context.config.nodeRequire || req.nodeRequire)(originalName);
+                } catch (e) {
+                    err = new Error('Tried loading "' + moduleName + '" at ' +
+                                     url + ' then tried node\'s require("' +
+                                        originalName + '") and it failed ' +
+                                     'with error: ' + e);
+                    err.originalError = e;
+                    err.moduleName = originalName;
+                    return req.onError(err);
+                }
+            });
+        }
+
+        //Support anonymous modules.
+        context.completeLoad(moduleName);
+    };
+
+    //Override to provide the function wrapper for define/require.
+    req.exec = function (text) {
+        /*jslint evil: true */
+        text = req.makeNodeWrapper(text);
+        return eval(text);
+    };
+}());
+
+    } else if (env === 'xpconnect') {
+        /**
+ * @license RequireJS xpconnect Copyright (c) 2013, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint */
+/*global require, load */
+
+(function () {
+    'use strict';
+    require.load = function (context, moduleName, url) {
+
+        load(url);
+
+        //Support anonymous modules.
+        context.completeLoad(moduleName);
+    };
+
+}());
+
+    }
+
+    //Support a default file name to execute. Useful for hosted envs
+    //like Joyent where it defaults to a server.js as the only executed
+    //script. But only do it if this is not an optimization run.
+    if (commandOption !== 'o' && (!fileName || !jsSuffixRegExp.test(fileName))) {
+        fileName = 'main.js';
+    }
+
+    /**
+     * Loads the library files that can be used for the optimizer, or for other
+     * tasks.
+     */
+    function loadLib() {
+        /**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global Packages: false, process: false, window: false, navigator: false,
+  document: false, define: false */
+
+/**
+ * A plugin that modifies any /env/ path to be the right path based on
+ * the host environment. Right now only works for Node, Rhino and browser.
+ */
+(function () {
+    var pathRegExp = /(\/|^)env\/|\{env\}/,
+        env = 'unknown';
+
+    if (typeof Packages !== 'undefined') {
+        env = 'rhino';
+    } else if (typeof process !== 'undefined' && process.versions && !!process.versions.node) {
+        env = 'node';
+    } else if ((typeof navigator !== 'undefined' && typeof document !== 'undefined') ||
+            (typeof importScripts !== 'undefined' && typeof self !== 'undefined')) {
+        env = 'browser';
+    } else if (typeof Components !== 'undefined' && Components.classes && Components.interfaces) {
+        env = 'xpconnect';
+    }
+
+    define('env', {
+        get: function () {
+            return env;
+        },
+
+        load: function (name, req, load, config) {
+            //Allow override in the config.
+            if (config.env) {
+                env = config.env;
+            }
+
+            name = name.replace(pathRegExp, function (match, prefix) {
+                if (match.indexOf('{') === -1) {
+                    return prefix + env + '/';
+                } else {
+                    return env;
+                }
+            });
+
+            req([name], function (mod) {
+                load(mod);
+            });
+        }
+    });
+}());/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint plusplus: true */
+/*global define */
+
+define('lang', function () {
+    'use strict';
+
+    var lang,
+        hasOwn = Object.prototype.hasOwnProperty;
+
+    function hasProp(obj, prop) {
+        return hasOwn.call(obj, prop);
+    }
+
+    lang = {
+        backSlashRegExp: /\\/g,
+        ostring: Object.prototype.toString,
+
+        isArray: Array.isArray || function (it) {
+            return lang.ostring.call(it) === "[object Array]";
+        },
+
+        isFunction: function(it) {
+            return lang.ostring.call(it) === "[object Function]";
+        },
+
+        isRegExp: function(it) {
+            return it && it instanceof RegExp;
+        },
+
+        hasProp: hasProp,
+
+        //returns true if the object does not have an own property prop,
+        //or if it does, it is a falsy value.
+        falseProp: function (obj, prop) {
+            return !hasProp(obj, prop) || !obj[prop];
+        },
+
+        //gets own property value for given prop on object
+        getOwn: function (obj, prop) {
+            return hasProp(obj, prop) && obj[prop];
+        },
+
+        _mixin: function(dest, source, override){
+            var name;
+            for (name in source) {
+                if(source.hasOwnProperty(name)
+                    && (override || !dest.hasOwnProperty(name))) {
+                    dest[name] = source[name];
+                }
+            }
+
+            return dest; // Object
+        },
+
+        /**
+         * mixin({}, obj1, obj2) is allowed. If the last argument is a boolean,
+         * then the source objects properties are force copied over to dest.
+         */
+        mixin: function(dest){
+            var parameters = Array.prototype.slice.call(arguments),
+                override, i, l;
+
+            if (!dest) { dest = {}; }
+
+            if (parameters.length > 2 && typeof arguments[parameters.length-1] === 'boolean') {
+                override = parameters.pop();
+            }
+
+            for (i = 1, l = parameters.length; i < l; i++) {
+                lang._mixin(dest, parameters[i], override);
+            }
+            return dest; // Object
+        },
+
+        delegate: (function () {
+            // boodman/crockford delegation w/ cornford optimization
+            function TMP() {}
+            return function (obj, props) {
+                TMP.prototype = obj;
+                var tmp = new TMP();
+                TMP.prototype = null;
+                if (props) {
+                    lang.mixin(tmp, props);
+                }
+                return tmp; // Object
+            };
+        }()),
+
+        /**
+         * Helper function for iterating over an array. If the func returns
+         * a true value, it will break out of the loop.
+         */
+        each: function each(ary, func) {
+            if (ary) {
+                var i;
+                for (i = 0; i < ary.length; i += 1) {
+                    if (func(ary[i], i, ary)) {
+                        break;
+                    }
+                }
+            }
+        },
+
+        /**
+         * Cycles over properties in an object and calls a function for each
+         * property value. If the function returns a truthy value, then the
+         * iteration is stopped.
+         */
+        eachProp: function eachProp(obj, func) {
+            var prop;
+            for (prop in obj) {
+                if (hasProp(obj, prop)) {
+                    if (func(obj[prop], prop)) {
+                        break;
+                    }
+                }
+            }
+        },
+
+        //Similar to Function.prototype.bind, but the "this" object is specified
+        //first, since it is easier to read/figure out what "this" will be.
+        bind: function bind(obj, fn) {
+            return function () {
+                return fn.apply(obj, arguments);
+            };
+        },
+
+        //Escapes a content string to be be a string that has characters escaped
+        //for inclusion as part of a JS string.
+        jsEscape: function (content) {
+            return content.replace(/(["'\\])/g, '\\$1')
+                .replace(/[\f]/g, "\\f")
+                .replace(/[\b]/g, "\\b")
+                .replace(/[\n]/g, "\\n")
+                .replace(/[\t]/g, "\\t")
+                .replace(/[\r]/g, "\\r");
+        }
+    };
+    return lang;
+});
+/**
+ * prim 0.0.1 Copyright (c) 2012-2013, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/prim for details
+ */
+
+/*global setImmediate, process, setTimeout, define, module */
+
+//Set prime.hideResolutionConflict = true to allow "resolution-races"
+//in promise-tests to pass.
+//Since the goal of prim is to be a small impl for trusted code, it is
+//more important to normally throw in this case so that we can find
+//logic errors quicker.
+
+var prim;
+(function () {
+    'use strict';
+    var op = Object.prototype,
+        hasOwn = op.hasOwnProperty;
+
+    function hasProp(obj, prop) {
+        return hasOwn.call(obj, prop);
+    }
+
+    /**
+     * Helper function for iterating over an array. If the func returns
+     * a true value, it will break out of the loop.
+     */
+    function each(ary, func) {
+        if (ary) {
+            var i;
+            for (i = 0; i < ary.length; i += 1) {
+                if (ary[i]) {
+                    func(ary[i], i, ary);
+                }
+            }
+        }
+    }
+
+    function check(p) {
+        if (hasProp(p, 'e') || hasProp(p, 'v')) {
+            if (!prim.hideResolutionConflict) {
+                throw new Error('nope');
+            }
+            return false;
+        }
+        return true;
+    }
+
+    function notify(ary, value) {
+        prim.nextTick(function () {
+            each(ary, function (item) {
+                item(value);
+            });
+        });
+    }
+
+    prim = function prim() {
+        var p,
+            ok = [],
+            fail = [];
+
+        return (p = {
+            callback: function (yes, no) {
+                if (no) {
+                    p.errback(no);
+                }
+
+                if (hasProp(p, 'v')) {
+                    prim.nextTick(function () {
+                        yes(p.v);
+                    });
+                } else {
+                    ok.push(yes);
+                }
+            },
+
+            errback: function (no) {
+                if (hasProp(p, 'e')) {
+                    prim.nextTick(function () {
+                        no(p.e);
+                    });
+                } else {
+                    fail.push(no);
+                }
+            },
+
+            finished: function () {
+                return hasProp(p, 'e') || hasProp(p, 'v');
+            },
+
+            rejected: function () {
+                return hasProp(p, 'e');
+            },
+
+            resolve: function (v) {
+                if (check(p)) {
+                    p.v = v;
+                    notify(ok, v);
+                }
+                return p;
+            },
+            reject: function (e) {
+                if (check(p)) {
+                    p.e = e;
+                    notify(fail, e);
+                }
+                return p;
+            },
+
+            start: function (fn) {
+                p.resolve();
+                return p.promise.then(fn);
+            },
+
+            promise: {
+                then: function (yes, no) {
+                    var next = prim();
+
+                    p.callback(function (v) {
+                        try {
+                            if (yes && typeof yes === 'function') {
+                                v = yes(v);
+                            }
+
+                            if (v && v.then) {
+                                v.then(next.resolve, next.reject);
+                            } else {
+                                next.resolve(v);
+                            }
+                        } catch (e) {
+                            next.reject(e);
+                        }
+                    }, function (e) {
+                        var err;
+
+                        try {
+                            if (!no || typeof no !== 'function') {
+                                next.reject(e);
+                            } else {
+                                err = no(e);
+
+                                if (err && err.then) {
+                                    err.then(next.resolve, next.reject);
+                                } else {
+                                    next.resolve(err);
+                                }
+                            }
+                        } catch (e2) {
+                            next.reject(e2);
+                        }
+                    });
+
+                    return next.promise;
+                },
+
+                fail: function (no) {
+                    return p.promise.then(null, no);
+                },
+
+                end: function () {
+                    p.errback(function (e) {
+                        throw e;
+                    });
+                }
+            }
+        });
+    };
+
+    prim.serial = function (ary) {
+        var result = prim().resolve().promise;
+        each(ary, function (item) {
+            result = result.then(function () {
+                return item();
+            });
+        });
+        return result;
+    };
+
+    prim.nextTick = typeof setImmediate === 'function' ? setImmediate :
+        (typeof process !== 'undefined' && process.nextTick ?
+            process.nextTick : (typeof setTimeout !== 'undefined' ?
+                function (fn) {
+                setTimeout(fn, 0);
+            } : function (fn) {
+        fn();
+    }));
+
+    if (typeof define === 'function' && define.amd) {
+        define('prim', function () { return prim; });
+    } else if (typeof module !== 'undefined' && module.exports) {
+        module.exports = prim;
+    }
+}());
+if(env === 'browser') {
+/**
+ * @license RequireJS Copyright (c) 2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, load: false */
+
+//Just a stub for use with uglify's consolidator.js
+define('browser/assert', function () {
+    return {};
+});
+
+}
+
+if(env === 'node') {
+/**
+ * @license RequireJS Copyright (c) 2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, load: false */
+
+//Needed so that rhino/assert can return a stub for uglify's consolidator.js
+define('node/assert', ['assert'], function (assert) {
+    return assert;
+});
+
+}
+
+if(env === 'rhino') {
+/**
+ * @license RequireJS Copyright (c) 2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, load: false */
+
+//Just a stub for use with uglify's consolidator.js
+define('rhino/assert', function () {
+    return {};
+});
+
+}
+
+if(env === 'xpconnect') {
+/**
+ * @license RequireJS Copyright (c) 2013, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, load: false */
+
+//Just a stub for use with uglify's consolidator.js
+define('xpconnect/assert', function () {
+    return {};
+});
+
+}
+
+if(env === 'browser') {
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, process: false */
+
+define('browser/args', function () {
+    //Always expect config via an API call
+    return [];
+});
+
+}
+
+if(env === 'node') {
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, process: false */
+
+define('node/args', function () {
+    //Do not return the "node" or "r.js" arguments
+    var args = process.argv.slice(2);
+
+    //Ignore any command option used for main x.js branching
+    if (args[0] && args[0].indexOf('-') === 0) {
+        args = args.slice(1);
+    }
+
+    return args;
+});
+
+}
+
+if(env === 'rhino') {
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, process: false */
+
+var jsLibRhinoArgs = (typeof rhinoArgs !== 'undefined' && rhinoArgs) || [].concat(Array.prototype.slice.call(arguments, 0));
+
+define('rhino/args', function () {
+    var args = jsLibRhinoArgs;
+
+    //Ignore any command option used for main x.js branching
+    if (args[0] && args[0].indexOf('-') === 0) {
+        args = args.slice(1);
+    }
+
+    return args;
+});
+
+}
+
+if(env === 'xpconnect') {
+/**
+ * @license Copyright (c) 2013, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define, xpconnectArgs */
+
+var jsLibXpConnectArgs = (typeof xpconnectArgs !== 'undefined' && xpconnectArgs) || [].concat(Array.prototype.slice.call(arguments, 0));
+
+define('xpconnect/args', function () {
+    var args = jsLibXpConnectArgs;
+
+    //Ignore any command option used for main x.js branching
+    if (args[0] && args[0].indexOf('-') === 0) {
+        args = args.slice(1);
+    }
+
+    return args;
+});
+
+}
+
+if(env === 'browser') {
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, console: false */
+
+define('browser/load', ['./file'], function (file) {
+    function load(fileName) {
+        eval(file.readFile(fileName));
+    }
+
+    return load;
+});
+
+}
+
+if(env === 'node') {
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, console: false */
+
+define('node/load', ['fs'], function (fs) {
+    function load(fileName) {
+        var contents = fs.readFileSync(fileName, 'utf8');
+        process.compile(contents, fileName);
+    }
+
+    return load;
+});
+
+}
+
+if(env === 'rhino') {
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, load: false */
+
+define('rhino/load', function () {
+    return load;
+});
+
+}
+
+if(env === 'xpconnect') {
+/**
+ * @license RequireJS Copyright (c) 2013, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, load: false */
+
+define('xpconnect/load', function () {
+    return load;
+});
+
+}
+
+if(env === 'browser') {
+/**
+ * @license Copyright (c) 2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint sloppy: true, nomen: true */
+/*global require, define, console, XMLHttpRequest, requirejs, location */
+
+define('browser/file', ['prim'], function (prim) {
+
+    var file,
+        currDirRegExp = /^\.(\/|$)/;
+
+    function frontSlash(path) {
+        return path.replace(/\\/g, '/');
+    }
+
+    function exists(path) {
+        var status, xhr = new XMLHttpRequest();
+
+        //Oh yeah, that is right SYNC IO. Behold its glory
+        //and horrible blocking behavior.
+        xhr.open('HEAD', path, false);
+        xhr.send();
+        status = xhr.status;
+
+        return status === 200 || status === 304;
+    }
+
+    function mkDir(dir) {
+        console.log('mkDir is no-op in browser');
+    }
+
+    function mkFullDir(dir) {
+        console.log('mkFullDir is no-op in browser');
+    }
+
+    file = {
+        backSlashRegExp: /\\/g,
+        exclusionRegExp: /^\./,
+        getLineSeparator: function () {
+            return '/';
+        },
+
+        exists: function (fileName) {
+            return exists(fileName);
+        },
+
+        parent: function (fileName) {
+            var parts = fileName.split('/');
+            parts.pop();
+            return parts.join('/');
+        },
+
+        /**
+         * Gets the absolute file path as a string, normalized
+         * to using front slashes for path separators.
+         * @param {String} fileName
+         */
+        absPath: function (fileName) {
+            var dir;
+            if (currDirRegExp.test(fileName)) {
+                dir = frontSlash(location.href);
+                if (dir.indexOf('/') !== -1) {
+                    dir = dir.split('/');
+
+                    //Pull off protocol and host, just want
+                    //to allow paths (other build parts, like
+                    //require._isSupportedBuildUrl do not support
+                    //full URLs), but a full path from
+                    //the root.
+                    dir.splice(0, 3);
+
+                    dir.pop();
+                    dir = '/' + dir.join('/');
+                }
+
+                fileName = dir + fileName.substring(1);
+            }
+
+            return fileName;
+        },
+
+        normalize: function (fileName) {
+            return fileName;
+        },
+
+        isFile: function (path) {
+            return true;
+        },
+
+        isDirectory: function (path) {
+            return false;
+        },
+
+        getFilteredFileList: function (startDir, regExpFilters, makeUnixPaths) {
+            console.log('file.getFilteredFileList is no-op in browser');
+        },
+
+        copyDir: function (srcDir, destDir, regExpFilter, onlyCopyNew) {
+            console.log('file.copyDir is no-op in browser');
+
+        },
+
+        copyFile: function (srcFileName, destFileName, onlyCopyNew) {
+            console.log('file.copyFile is no-op in browser');
+        },
+
+        /**
+         * Renames a file. May fail if "to" already exists or is on another drive.
+         */
+        renameFile: function (from, to) {
+            console.log('file.renameFile is no-op in browser');
+        },
+
+        /**
+         * Reads a *text* file.
+         */
+        readFile: function (path, encoding) {
+            var xhr = new XMLHttpRequest();
+
+            //Oh yeah, that is right SYNC IO. Behold its glory
+            //and horrible blocking behavior.
+            xhr.open('GET', path, false);
+            xhr.send();
+
+            return xhr.responseText;
+        },
+
+        readFileAsync: function (path, encoding) {
+            var xhr = new XMLHttpRequest(),
+                d = prim();
+
+            xhr.open('GET', path, true);
+            xhr.send();
+
+            xhr.onreadystatechange = function () {
+                if (xhr.readyState === 4) {
+                    if (xhr.status > 400) {
+                        d.reject(new Error('Status: ' + xhr.status + ': ' + xhr.statusText));
+                    } else {
+                        d.resolve(xhr.responseText);
+                    }
+                }
+            };
+
+            return d.promise;
+        },
+
+        saveUtf8File: function (fileName, fileContents) {
+            //summary: saves a *text* file using UTF-8 encoding.
+            file.saveFile(fileName, fileContents, "utf8");
+        },
+
+        saveFile: function (fileName, fileContents, encoding) {
+            requirejs.browser.saveFile(fileName, fileContents, encoding);
+        },
+
+        deleteFile: function (fileName) {
+            console.log('file.deleteFile is no-op in browser');
+        },
+
+        /**
+         * Deletes any empty directories under the given directory.
+         */
+        deleteEmptyDirs: function (startDir) {
+            console.log('file.deleteEmptyDirs is no-op in browser');
+        }
+    };
+
+    return file;
+
+});
+
+}
+
+if(env === 'node') {
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint plusplus: false, octal:false, strict: false */
+/*global define: false, process: false */
+
+define('node/file', ['fs', 'path', 'prim'], function (fs, path, prim) {
+
+    var isWindows = process.platform === 'win32',
+        windowsDriveRegExp = /^[a-zA-Z]\:\/$/,
+        file;
+
+    function frontSlash(path) {
+        return path.replace(/\\/g, '/');
+    }
+
+    function exists(path) {
+        if (isWindows && path.charAt(path.length - 1) === '/' &&
+            path.charAt(path.length - 2) !== ':') {
+            path = path.substring(0, path.length - 1);
+        }
+
+        try {
+            fs.statSync(path);
+            return true;
+        } catch (e) {
+            return false;
+        }
+    }
+
+    function mkDir(dir) {
+        if (!exists(dir) && (!isWindows || !windowsDriveRegExp.test(dir))) {
+            fs.mkdirSync(dir, 511);
+        }
+    }
+
+    function mkFullDir(dir) {
+        var parts = dir.split('/'),
+            currDir = '',
+            first = true;
+
+        parts.forEach(function (part) {
+            //First part may be empty string if path starts with a slash.
+            currDir += part + '/';
+            first = false;
+
+            if (part) {
+                mkDir(currDir);
+            }
+        });
+    }
+
+    file = {
+        backSlashRegExp: /\\/g,
+        exclusionRegExp: /^\./,
+        getLineSeparator: function () {
+            return '/';
+        },
+
+        exists: function (fileName) {
+            return exists(fileName);
+        },
+
+        parent: function (fileName) {
+            var parts = fileName.split('/');
+            parts.pop();
+            return parts.join('/');
+        },
+
+        /**
+         * Gets the absolute file path as a string, normalized
+         * to using front slashes for path separators.
+         * @param {String} fileName
+         */
+        absPath: function (fileName) {
+            return frontSlash(path.normalize(frontSlash(fs.realpathSync(fileName))));
+        },
+
+        normalize: function (fileName) {
+            return frontSlash(path.normalize(fileName));
+        },
+
+        isFile: function (path) {
+            return fs.statSync(path).isFile();
+        },
+
+        isDirectory: function (path) {
+            return fs.statSync(path).isDirectory();
+        },
+
+        getFilteredFileList: function (/*String*/startDir, /*RegExp*/regExpFilters, /*boolean?*/makeUnixPaths) {
+            //summary: Recurses startDir and finds matches to the files that match regExpFilters.include
+            //and do not match regExpFilters.exclude. Or just one regexp can be passed in for regExpFilters,
+            //and it will be treated as the "include" case.
+            //Ignores files/directories that start with a period (.) unless exclusionRegExp
+            //is set to another value.
+            var files = [], topDir, regExpInclude, regExpExclude, dirFileArray,
+                i, stat, filePath, ok, dirFiles, fileName;
+
+            topDir = startDir;
+
+            regExpInclude = regExpFilters.include || regExpFilters;
+            regExpExclude = regExpFilters.exclude || null;
+
+            if (file.exists(topDir)) {
+                dirFileArray = fs.readdirSync(topDir);
+                for (i = 0; i < dirFileArray.length; i++) {
+                    fileName = dirFileArray[i];
+                    filePath = path.join(topDir, fileName);
+                    stat = fs.statSync(filePath);
+                    if (stat.isFile()) {
+                        if (makeUnixPaths) {
+                            //Make sure we have a JS string.
+                            if (filePath.indexOf("/") === -1) {
+                                filePath = frontSlash(filePath);
+                            }
+                        }
+
+                        ok = true;
+                        if (regExpInclude) {
+                            ok = filePath.match(regExpInclude);
+                        }
+                        if (ok && regExpExclude) {
+                            ok = !filePath.match(regExpExclude);
+                        }
+
+                        if (ok && (!file.exclusionRegExp ||
+                            !file.exclusionRegExp.test(fileName))) {
+                            files.push(filePath);
+                        }
+                    } else if (stat.isDirectory() &&
+                              (!file.exclusionRegExp || !file.exclusionRegExp.test(fileName))) {
+                        dirFiles = this.getFilteredFileList(filePath, regExpFilters, makeUnixPaths);
+                        files.push.apply(files, dirFiles);
+                    }
+                }
+            }
+
+            return files; //Array
+        },
+
+        copyDir: function (/*String*/srcDir, /*String*/destDir, /*RegExp?*/regExpFilter, /*boolean?*/onlyCopyNew) {
+            //summary: copies files from srcDir to destDir using the regExpFilter to determine if the
+            //file should be copied. Returns a list file name strings of the destinations that were copied.
+            regExpFilter = regExpFilter || /\w/;
+
+            //Normalize th directory names, but keep front slashes.
+            //path module on windows now returns backslashed paths.
+            srcDir = frontSlash(path.normalize(srcDir));
+            destDir = frontSlash(path.normalize(destDir));
+
+            var fileNames = file.getFilteredFileList(srcDir, regExpFilter, true),
+            copiedFiles = [], i, srcFileName, destFileName;
+
+            for (i = 0; i < fileNames.length; i++) {
+                srcFileName = fileNames[i];
+                destFileName = srcFileName.replace(srcDir, destDir);
+
+                if (file.copyFile(srcFileName, destFileName, onlyCopyNew)) {
+                    copiedFiles.push(destFileName);
+                }
+            }
+
+            return copiedFiles.length ? copiedFiles : null; //Array or null
+        },
+
+        copyFile: function (/*String*/srcFileName, /*String*/destFileName, /*boolean?*/onlyCopyNew) {
+            //summary: copies srcFileName to destFileName. If onlyCopyNew is set, it only copies the file if
+            //srcFileName is newer than destFileName. Returns a boolean indicating if the copy occurred.
+            var parentDir;
+
+            //logger.trace("Src filename: " + srcFileName);
+            //logger.trace("Dest filename: " + destFileName);
+
+            //If onlyCopyNew is true, then compare dates and only copy if the src is newer
+            //than dest.
+            if (onlyCopyNew) {
+                if (file.exists(destFileName) && fs.statSync(destFileName).mtime.getTime() >= fs.statSync(srcFileName).mtime.getTime()) {
+                    return false; //Boolean
+                }
+            }
+
+            //Make sure destination dir exists.
+            parentDir = path.dirname(destFileName);
+            if (!file.exists(parentDir)) {
+                mkFullDir(parentDir);
+            }
+
+            fs.writeFileSync(destFileName, fs.readFileSync(srcFileName, 'binary'), 'binary');
+
+            return true; //Boolean
+        },
+
+        /**
+         * Renames a file. May fail if "to" already exists or is on another drive.
+         */
+        renameFile: function (from, to) {
+            return fs.renameSync(from, to);
+        },
+
+        /**
+         * Reads a *text* file.
+         */
+        readFile: function (/*String*/path, /*String?*/encoding) {
+            if (encoding === 'utf-8') {
+                encoding = 'utf8';
+            }
+            if (!encoding) {
+                encoding = 'utf8';
+            }
+
+            var text = fs.readFileSync(path, encoding);
+
+            //Hmm, would not expect to get A BOM, but it seems to happen,
+            //remove it just in case.
+            if (text.indexOf('\uFEFF') === 0) {
+                text = text.substring(1, text.length);
+            }
+
+            return text;
+        },
+
+        readFileAsync: function (path, encoding) {
+            var d = prim();
+            try {
+                d.resolve(file.readFile(path, encoding));
+            } catch (e) {
+                d.reject(e);
+            }
+            return d.promise;
+        },
+
+        saveUtf8File: function (/*String*/fileName, /*String*/fileContents) {
+            //summary: saves a *text* file using UTF-8 encoding.
+            file.saveFile(fileName, fileContents, "utf8");
+        },
+
+        saveFile: function (/*String*/fileName, /*String*/fileContents, /*String?*/encoding) {
+            //summary: saves a *text* file.
+            var parentDir;
+
+            if (encoding === 'utf-8') {
+                encoding = 'utf8';
+            }
+            if (!encoding) {
+                encoding = 'utf8';
+            }
+
+            //Make sure destination directories exist.
+            parentDir = path.dirname(fileName);
+            if (!file.exists(parentDir)) {
+                mkFullDir(parentDir);
+            }
+
+            fs.writeFileSync(fileName, fileContents, encoding);
+        },
+
+        deleteFile: function (/*String*/fileName) {
+            //summary: deletes a file or directory if it exists.
+            var files, i, stat;
+            if (file.exists(fileName)) {
+                stat = fs.statSync(fileName);
+                if (stat.isDirectory()) {
+                    files = fs.readdirSync(fileName);
+                    for (i = 0; i < files.length; i++) {
+                        this.deleteFile(path.join(fileName, files[i]));
+                    }
+                    fs.rmdirSync(fileName);
+                } else {
+                    fs.unlinkSync(fileName);
+                }
+            }
+        },
+
+
+        /**
+         * Deletes any empty directories under the given directory.
+         */
+        deleteEmptyDirs: function (startDir) {
+            var dirFileArray, i, fileName, filePath, stat;
+
+            if (file.exists(startDir)) {
+                dirFileArray = fs.readdirSync(startDir);
+                for (i = 0; i < dirFileArray.length; i++) {
+                    fileName = dirFileArray[i];
+                    filePath = path.join(startDir, fileName);
+                    stat = fs.statSync(filePath);
+                    if (stat.isDirectory()) {
+                        file.deleteEmptyDirs(filePath);
+                    }
+                }
+
+                //If directory is now empty, remove it.
+                if (fs.readdirSync(startDir).length ===  0) {
+                    file.deleteFile(startDir);
+                }
+            }
+        }
+    };
+
+    return file;
+
+});
+
+}
+
+if(env === 'rhino') {
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+//Helper functions to deal with file I/O.
+
+/*jslint plusplus: false */
+/*global java: false, define: false */
+
+define('rhino/file', ['prim'], function (prim) {
+    var file = {
+        backSlashRegExp: /\\/g,
+
+        exclusionRegExp: /^\./,
+
+        getLineSeparator: function () {
+            return file.lineSeparator;
+        },
+
+        lineSeparator: java.lang.System.getProperty("line.separator"), //Java String
+
+        exists: function (fileName) {
+            return (new java.io.File(fileName)).exists();
+        },
+
+        parent: function (fileName) {
+            return file.absPath((new java.io.File(fileName)).getParentFile());
+        },
+
+        normalize: function (fileName) {
+            return file.absPath(fileName);
+        },
+
+        isFile: function (path) {
+            return (new java.io.File(path)).isFile();
+        },
+
+        isDirectory: function (path) {
+            return (new java.io.File(path)).isDirectory();
+        },
+
+        /**
+         * Gets the absolute file path as a string, normalized
+         * to using front slashes for path separators.
+         * @param {java.io.File||String} file
+         */
+        absPath: function (fileObj) {
+            if (typeof fileObj === "string") {
+                fileObj = new java.io.File(fileObj);
+            }
+            return (fileObj.getCanonicalPath() + "").replace(file.backSlashRegExp, "/");
+        },
+
+        getFilteredFileList: function (/*String*/startDir, /*RegExp*/regExpFilters, /*boolean?*/makeUnixPaths, /*boolean?*/startDirIsJavaObject) {
+            //summary: Recurses startDir and finds matches to the files that match regExpFilters.include
+            //and do not match regExpFilters.exclude. Or just one regexp can be passed in for regExpFilters,
+            //and it will be treated as the "include" case.
+            //Ignores files/directories that start with a period (.) unless exclusionRegExp
+            //is set to another value.
+            var files = [], topDir, regExpInclude, regExpExclude, dirFileArray,
+                i, fileObj, filePath, ok, dirFiles;
+
+            topDir = startDir;
+            if (!startDirIsJavaObject) {
+                topDir = new java.io.File(startDir);
+            }
+
+            regExpInclude = regExpFilters.include || regExpFilters;
+            regExpExclude = regExpFilters.exclude || null;
+
+            if (topDir.exists()) {
+                dirFileArray = topDir.listFiles();
+                for (i = 0; i < dirFileArray.length; i++) {
+                    fileObj = dirFileArray[i];
+                    if (fileObj.isFile()) {
+                        filePath = fileObj.getPath();
+                        if (makeUnixPaths) {
+                            //Make sure we have a JS string.
+                            filePath = String(filePath);
+                            if (filePath.indexOf("/") === -1) {
+                                filePath = filePath.replace(/\\/g, "/");
+                            }
+                        }
+
+                        ok = true;
+                        if (regExpInclude) {
+                            ok = filePath.match(regExpInclude);
+                        }
+                        if (ok && regExpExclude) {
+                            ok = !filePath.match(regExpExclude);
+                        }
+
+                        if (ok && (!file.exclusionRegExp ||
+                            !file.exclusionRegExp.test(fileObj.getName()))) {
+                            files.push(filePath);
+                        }
+                    } else if (fileObj.isDirectory() &&
+                              (!file.exclusionRegExp || !file.exclusionRegExp.test(fileObj.getName()))) {
+                        dirFiles = this.getFilteredFileList(fileObj, regExpFilters, makeUnixPaths, true);
+                        files.push.apply(files, dirFiles);
+                    }
+                }
+            }
+
+            return files; //Array
+        },
+
+        copyDir: function (/*String*/srcDir, /*String*/destDir, /*RegExp?*/regExpFilter, /*boolean?*/onlyCopyNew) {
+            //summary: copies files from srcDir to destDir using the regExpFilter to determine if the
+            //file should be copied. Returns a list file name strings of the destinations that were copied.
+            regExpFilter = regExpFilter || /\w/;
+
+            var fileNames = file.getFilteredFileList(srcDir, regExpFilter, true),
+            copiedFiles = [], i, srcFileName, destFileName;
+
+            for (i = 0; i < fileNames.length; i++) {
+                srcFileName = fileNames[i];
+                destFileName = srcFileName.replace(srcDir, destDir);
+
+                if (file.copyFile(srcFileName, destFileName, onlyCopyNew)) {
+                    copiedFiles.push(destFileName);
+                }
+            }
+
+            return copiedFiles.length ? copiedFiles : null; //Array or null
+        },
+
+        copyFile: function (/*String*/srcFileName, /*String*/destFileName, /*boolean?*/onlyCopyNew) {
+            //summary: copies srcFileName to destFileName. If onlyCopyNew is set, it only copies the file if
+            //srcFileName is newer than destFileName. Returns a boolean indicating if the copy occurred.
+            var destFile = new java.io.File(destFileName), srcFile, parentDir,
+            srcChannel, destChannel;
+
+            //logger.trace("Src filename: " + srcFileName);
+            //logger.trace("Dest filename: " + destFileName);
+
+            //If onlyCopyNew is true, then compare dates and only copy if the src is newer
+            //than dest.
+            if (onlyCopyNew) {
+                srcFile = new java.io.File(srcFileName);
+                if (destFile.exists() && destFile.lastModified() >= srcFile.lastModified()) {
+                    return false; //Boolean
+                }
+            }
+
+            //Make sure destination dir exists.
+            parentDir = destFile.getParentFile();
+            if (!parentDir.exists()) {
+                if (!parentDir.mkdirs()) {
+                    throw "Could not create directory: " + parentDir.getCanonicalPath();
+                }
+            }
+
+            //Java's version of copy file.
+            srcChannel = new java.io.FileInputStream(srcFileName).getChannel();
+            destChannel = new java.io.FileOutputStream(destFileName).getChannel();
+            destChannel.transferFrom(srcChannel, 0, srcChannel.size());
+            srcChannel.close();
+            destChannel.close();
+
+            return true; //Boolean
+        },
+
+        /**
+         * Renames a file. May fail if "to" already exists or is on another drive.
+         */
+        renameFile: function (from, to) {
+            return (new java.io.File(from)).renameTo((new java.io.File(to)));
+        },
+
+        readFile: function (/*String*/path, /*String?*/encoding) {
+            //A file read function that can deal with BOMs
+            encoding = encoding || "utf-8";
+            var fileObj = new java.io.File(path),
+                    input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(fileObj), encoding)),
+                    stringBuffer, line;
+            try {
+                stringBuffer = new java.lang.StringBuffer();
+                line = input.readLine();
+
+                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
+                // http://www.unicode.org/faq/utf_bom.html
+
+                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
+                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
+                if (line && line.length() && line.charAt(0) === 0xfeff) {
+                    // Eat the BOM, since we've already found the encoding on this file,
+                    // and we plan to concatenating this buffer with others; the BOM should
+                    // only appear at the top of a file.
+                    line = line.substring(1);
+                }
+                while (line !== null) {
+                    stringBuffer.append(line);
+                    stringBuffer.append(file.lineSeparator);
+                    line = input.readLine();
+                }
+                //Make sure we return a JavaScript string and not a Java string.
+                return String(stringBuffer.toString()); //String
+            } finally {
+                input.close();
+            }
+        },
+
+        readFileAsync: function (path, encoding) {
+            var d = prim();
+            try {
+                d.resolve(file.readFile(path, encoding));
+            } catch (e) {
+                d.reject(e);
+            }
+            return d.promise;
+        },
+
+        saveUtf8File: function (/*String*/fileName, /*String*/fileContents) {
+            //summary: saves a file using UTF-8 encoding.
+            file.saveFile(fileName, fileContents, "utf-8");
+        },
+
+        saveFile: function (/*String*/fileName, /*String*/fileContents, /*String?*/encoding) {
+            //summary: saves a file.
+            var outFile = new java.io.File(fileName), outWriter, parentDir, os;
+
+            parentDir = outFile.getAbsoluteFile().getParentFile();
+            if (!parentDir.exists()) {
+                if (!parentDir.mkdirs()) {
+                    throw "Could not create directory: " + parentDir.getAbsolutePath();
+                }
+            }
+
+            if (encoding) {
+                outWriter = new java.io.OutputStreamWriter(new java.io.FileOutputStream(outFile), encoding);
+            } else {
+                outWriter = new java.io.OutputStreamWriter(new java.io.FileOutputStream(outFile));
+            }
+
+            os = new java.io.BufferedWriter(outWriter);
+            try {
+                os.write(fileContents);
+            } finally {
+                os.close();
+            }
+        },
+
+        deleteFile: function (/*String*/fileName) {
+            //summary: deletes a file or directory if it exists.
+            var fileObj = new java.io.File(fileName), files, i;
+            if (fileObj.exists()) {
+                if (fileObj.isDirectory()) {
+                    files = fileObj.listFiles();
+                    for (i = 0; i < files.length; i++) {
+                        this.deleteFile(files[i]);
+                    }
+                }
+                fileObj["delete"]();
+            }
+        },
+
+        /**
+         * Deletes any empty directories under the given directory.
+         * The startDirIsJavaObject is private to this implementation's
+         * recursion needs.
+         */
+        deleteEmptyDirs: function (startDir, startDirIsJavaObject) {
+            var topDir = startDir,
+                dirFileArray, i, fileObj;
+
+            if (!startDirIsJavaObject) {
+                topDir = new java.io.File(startDir);
+            }
+
+            if (topDir.exists()) {
+                dirFileArray = topDir.listFiles();
+                for (i = 0; i < dirFileArray.length; i++) {
+                    fileObj = dirFileArray[i];
+                    if (fileObj.isDirectory()) {
+                        file.deleteEmptyDirs(fileObj, true);
+                    }
+                }
+
+                //If the directory is empty now, delete it.
+                if (topDir.listFiles().length === 0) {
+                    file.deleteFile(String(topDir.getPath()));
+                }
+            }
+        }
+    };
+
+    return file;
+});
+
+}
+
+if(env === 'xpconnect') {
+/**
+ * @license RequireJS Copyright (c) 2013, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+//Helper functions to deal with file I/O.
+
+/*jslint plusplus: false */
+/*global define, Components, xpcUtil */
+
+define('xpconnect/file', ['prim'], function (prim) {
+    var file,
+        Cc = Components.classes,
+        Ci = Components.interfaces,
+        //Depends on xpcUtil which is set up in x.js
+        xpfile = xpcUtil.xpfile;
+
+    function mkFullDir(dirObj) {
+        //1 is DIRECTORY_TYPE, 511 is 0777 permissions
+        if (!dirObj.exists()) {
+            dirObj.create(1, 511);
+        }
+    }
+
+    file = {
+        backSlashRegExp: /\\/g,
+
+        exclusionRegExp: /^\./,
+
+        getLineSeparator: function () {
+            return file.lineSeparator;
+        },
+
+        lineSeparator: ('@mozilla.org/windows-registry-key;1' in Cc) ?
+                        '\r\n' : '\n',
+
+        exists: function (fileName) {
+            return xpfile(fileName).exists();
+        },
+
+        parent: function (fileName) {
+            return xpfile(fileName).parent;
+        },
+
+        normalize: function (fileName) {
+            return file.absPath(fileName);
+        },
+
+        isFile: function (path) {
+            return xpfile(path).isFile();
+        },
+
+        isDirectory: function (path) {
+            return xpfile(path).isDirectory();
+        },
+
+        /**
+         * Gets the absolute file path as a string, normalized
+         * to using front slashes for path separators.
+         * @param {java.io.File||String} file
+         */
+        absPath: function (fileObj) {
+            if (typeof fileObj === "string") {
+                fileObj = xpfile(fileObj);
+            }
+            return fileObj.path;
+        },
+
+        getFilteredFileList: function (/*String*/startDir, /*RegExp*/regExpFilters, /*boolean?*/makeUnixPaths, /*boolean?*/startDirIsObject) {
+            //summary: Recurses startDir and finds matches to the files that match regExpFilters.include
+            //and do not match regExpFilters.exclude. Or just one regexp can be passed in for regExpFilters,
+            //and it will be treated as the "include" case.
+            //Ignores files/directories that start with a period (.) unless exclusionRegExp
+            //is set to another value.
+            var files = [], topDir, regExpInclude, regExpExclude, dirFileArray,
+                fileObj, filePath, ok, dirFiles;
+
+            topDir = startDir;
+            if (!startDirIsObject) {
+                topDir = xpfile(startDir);
+            }
+
+            regExpInclude = regExpFilters.include || regExpFilters;
+            regExpExclude = regExpFilters.exclude || null;
+
+            if (topDir.exists()) {
+                dirFileArray = topDir.directoryEntries;
+                while (dirFileArray.hasMoreElements()) {
+                    fileObj = dirFileArray.getNext().QueryInterface(Ci.nsILocalFile);
+                    if (fileObj.isFile()) {
+                        filePath = fileObj.path;
+                        if (makeUnixPaths) {
+                            if (filePath.indexOf("/") === -1) {
+                                filePath = filePath.replace(/\\/g, "/");
+                            }
+                        }
+
+                        ok = true;
+                        if (regExpInclude) {
+                            ok = filePath.match(regExpInclude);
+                        }
+                        if (ok && regExpExclude) {
+                            ok = !filePath.match(regExpExclude);
+                        }
+
+                        if (ok && (!file.exclusionRegExp ||
+                            !file.exclusionRegExp.test(fileObj.leafName))) {
+                            files.push(filePath);
+                        }
+                    } else if (fileObj.isDirectory() &&
+                              (!file.exclusionRegExp || !file.exclusionRegExp.test(fileObj.leafName))) {
+                        dirFiles = this.getFilteredFileList(fileObj, regExpFilters, makeUnixPaths, true);
+                        files.push.apply(files, dirFiles);
+                    }
+                }
+            }
+
+            return files; //Array
+        },
+
+        copyDir: function (/*String*/srcDir, /*String*/destDir, /*RegExp?*/regExpFilter, /*boolean?*/onlyCopyNew) {
+            //summary: copies files from srcDir to destDir using the regExpFilter to determine if the
+            //file should be copied. Returns a list file name strings of the destinations that were copied.
+            regExpFilter = regExpFilter || /\w/;
+
+            var fileNames = file.getFilteredFileList(srcDir, regExpFilter, true),
+            copiedFiles = [], i, srcFileName, destFileName;
+
+            for (i = 0; i < fileNames.length; i += 1) {
+                srcFileName = fileNames[i];
+                destFileName = srcFileName.replace(srcDir, destDir);
+
+                if (file.copyFile(srcFileName, destFileName, onlyCopyNew)) {
+                    copiedFiles.push(destFileName);
+                }
+            }
+
+            return copiedFiles.length ? copiedFiles : null; //Array or null
+        },
+
+        copyFile: function (/*String*/srcFileName, /*String*/destFileName, /*boolean?*/onlyCopyNew) {
+            //summary: copies srcFileName to destFileName. If onlyCopyNew is set, it only copies the file if
+            //srcFileName is newer than destFileName. Returns a boolean indicating if the copy occurred.
+            var destFile = xpfile(destFileName),
+            srcFile = xpfile(srcFileName);
+
+            //logger.trace("Src filename: " + srcFileName);
+            //logger.trace("Dest filename: " + destFileName);
+
+            //If onlyCopyNew is true, then compare dates and only copy if the src is newer
+            //than dest.
+            if (onlyCopyNew) {
+                if (destFile.exists() && destFile.lastModifiedTime >= srcFile.lastModifiedTime) {
+                    return false; //Boolean
+                }
+            }
+
+            srcFile.copyTo(destFile.parent, destFile.leafName);
+
+            return true; //Boolean
+        },
+
+        /**
+         * Renames a file. May fail if "to" already exists or is on another drive.
+         */
+        renameFile: function (from, to) {
+            var toFile = xpfile(to);
+            return xpfile(from).moveTo(toFile.parent, toFile.leafName);
+        },
+
+        readFile: xpcUtil.readFile,
+
+        readFileAsync: function (path, encoding) {
+            var d = prim();
+            try {
+                d.resolve(file.readFile(path, encoding));
+            } catch (e) {
+                d.reject(e);
+            }
+            return d.promise;
+        },
+
+        saveUtf8File: function (/*String*/fileName, /*String*/fileContents) {
+            //summary: saves a file using UTF-8 encoding.
+            file.saveFile(fileName, fileContents, "utf-8");
+        },
+
+        saveFile: function (/*String*/fileName, /*String*/fileContents, /*String?*/encoding) {
+            var outStream, convertStream,
+                fileObj = xpfile(fileName);
+
+            mkFullDir(fileObj.parent);
+
+            try {
+                outStream = Cc['@mozilla.org/network/file-output-stream;1']
+                             .createInstance(Ci.nsIFileOutputStream);
+                //438 is decimal for 0777
+                outStream.init(fileObj, 0x02 | 0x08 | 0x20, 511, 0);
+
+                convertStream = Cc['@mozilla.org/intl/converter-output-stream;1']
+                                  .createInstance(Ci.nsIConverterOutputStream);
+
+                convertStream.init(outStream, encoding, 0, 0);
+                convertStream.writeString(fileContents);
+            } catch (e) {
+                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
+            } finally {
+                if (convertStream) {
+                    convertStream.close();
+                }
+                if (outStream) {
+                    outStream.close();
+                }
+            }
+        },
+
+        deleteFile: function (/*String*/fileName) {
+            //summary: deletes a file or directory if it exists.
+            var fileObj = xpfile(fileName);
+            if (fileObj.exists()) {
+                fileObj.remove(true);
+            }
+        },
+
+        /**
+         * Deletes any empty directories under the given directory.
+         * The startDirIsJavaObject is private to this implementation's
+         * recursion needs.
+         */
+        deleteEmptyDirs: function (startDir, startDirIsObject) {
+            var topDir = startDir,
+                dirFileArray, fileObj;
+
+            if (!startDirIsObject) {
+                topDir = xpfile(startDir);
+            }
+
+            if (topDir.exists()) {
+                dirFileArray = topDir.directoryEntries;
+                while (dirFileArray.hasMoreElements()) {
+                    fileObj = dirFileArray.getNext().QueryInterface(Ci.nsILocalFile);
+
+                    if (fileObj.isDirectory()) {
+                        file.deleteEmptyDirs(fileObj, true);
+                    }
+                }
+
+                //If the directory is empty now, delete it.
+                dirFileArray = topDir.directoryEntries;
+                if (!dirFileArray.hasMoreElements()) {
+                    file.deleteFile(topDir.path);
+                }
+            }
+        }
+    };
+
+    return file;
+});
+
+}
+
+if(env === 'browser') {
+/*global process */
+define('browser/quit', function () {
+    'use strict';
+    return function (code) {
+    };
+});
+}
+
+if(env === 'node') {
+/*global process */
+define('node/quit', function () {
+    'use strict';
+    return function (code) {
+        var draining = 0;
+        var exit = function () {
+            if (draining === 0) {
+                process.exit(code);
+            } else {
+                draining -= 1;
+            }
+        };
+        if (process.stdout.bufferSize) {
+            draining += 1;
+            process.stdout.once('drain', exit);
+        }
+        if (process.stderr.bufferSize) {
+            draining += 1;
+            process.stderr.once('drain', exit);
+        }
+        exit();
+    };
+});
+
+}
+
+if(env === 'rhino') {
+/*global quit */
+define('rhino/quit', function () {
+    'use strict';
+    return function (code) {
+        return quit(code);
+    };
+});
+
+}
+
+if(env === 'xpconnect') {
+/*global quit */
+define('xpconnect/quit', function () {
+    'use strict';
+    return function (code) {
+        return quit(code);
+    };
+});
+
+}
+
+if(env === 'browser') {
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, console: false */
+
+define('browser/print', function () {
+    function print(msg) {
+        console.log(msg);
+    }
+
+    return print;
+});
+
+}
+
+if(env === 'node') {
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, console: false */
+
+define('node/print', function () {
+    function print(msg) {
+        console.log(msg);
+    }
+
+    return print;
+});
+
+}
+
+if(env === 'rhino') {
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, print: false */
+
+define('rhino/print', function () {
+    return print;
+});
+
+}
+
+if(env === 'xpconnect') {
+/**
+ * @license RequireJS Copyright (c) 2013, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false, print: false */
+
+define('xpconnect/print', function () {
+    return print;
+});
+
+}
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint nomen: false, strict: false */
+/*global define: false */
+
+define('logger', ['env!env/print'], function (print) {
+    var logger = {
+        TRACE: 0,
+        INFO: 1,
+        WARN: 2,
+        ERROR: 3,
+        SILENT: 4,
+        level: 0,
+        logPrefix: "",
+
+        logLevel: function( level ) {
+            this.level = level;
+        },
+
+        trace: function (message) {
+            if (this.level <= this.TRACE) {
+                this._print(message);
+            }
+        },
+
+        info: function (message) {
+            if (this.level <= this.INFO) {
+                this._print(message);
+            }
+        },
+
+        warn: function (message) {
+            if (this.level <= this.WARN) {
+                this._print(message);
+            }
+        },
+
+        error: function (message) {
+            if (this.level <= this.ERROR) {
+                this._print(message);
+            }
+        },
+
+        _print: function (message) {
+            this._sysPrint((this.logPrefix ? (this.logPrefix + " ") : "") + message);
+        },
+
+        _sysPrint: function (message) {
+            print(message);
+        }
+    };
+
+    return logger;
+});
+//Just a blank file to use when building the optimizer with the optimizer,
+//so that the build does not attempt to inline some env modules,
+//like Node's fs and path.
+
+//Commit 465a4eae86c7bae191b1ee427571543ace777117 on July 19, 2012
+define('esprima', ['exports'], function(exports) {
+/*
+  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
+  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
+  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
+  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
+  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
+  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
+  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/*jslint bitwise:true plusplus:true */
+/*global esprima:true, exports:true,
+throwError: true, createLiteral: true, generateStatement: true,
+parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
+parseFunctionDeclaration: true, parseFunctionExpression: true,
+parseFunctionSourceElements: true, parseVariableIdentifier: true,
+parseLeftHandSideExpression: true,
+parseStatement: true, parseSourceElement: true */
+
+(function (exports) {
+    'use strict';
+
+    var Token,
+        TokenName,
+        Syntax,
+        PropertyKind,
+        Messages,
+        Regex,
+        source,
+        strict,
+        index,
+        lineNumber,
+        lineStart,
+        length,
+        buffer,
+        state,
+        extra;
+
+    Token = {
+        BooleanLiteral: 1,
+        EOF: 2,
+        Identifier: 3,
+        Keyword: 4,
+        NullLiteral: 5,
+        NumericLiteral: 6,
+        Punctuator: 7,
+        StringLiteral: 8
+    };
+
+    TokenName = {};
+    TokenName[Token.BooleanLiteral] = 'Boolean';
+    TokenName[Token.EOF] = '<end>';
+    TokenName[Token.Identifier] = 'Identifier';
+    TokenName[Token.Keyword] = 'Keyword';
+    TokenName[Token.NullLiteral] = 'Null';
+    TokenName[Token.NumericLiteral] = 'Numeric';
+    TokenName[Token.Punctuator] = 'Punctuator';
+    TokenName[Token.StringLiteral] = 'String';
+
+    Syntax = {
+        AssignmentExpression: 'AssignmentExpression',
+        ArrayExpression: 'ArrayExpression',
+        BlockStatement: 'BlockStatement',
+        BinaryExpression: 'BinaryExpression',
+        BreakStatement: 'BreakStatement',
+        CallExpression: 'CallExpression',
+        CatchClause: 'CatchClause',
+        ConditionalExpression: 'ConditionalExpression',
+        ContinueStatement: 'ContinueStatement',
+        DoWhileStatement: 'DoWhileStatement',
+        DebuggerStatement: 'DebuggerStatement',
+        EmptyStatement: 'EmptyStatement',
+        ExpressionStatement: 'ExpressionStatement',
+        ForStatement: 'ForStatement',
+        ForInStatement: 'ForInStatement',
+        FunctionDeclaration: 'FunctionDeclaration',
+        FunctionExpression: 'FunctionExpression',
+        Identifier: 'Identifier',
+        IfStatement: 'IfStatement',
+        Literal: 'Literal',
+        LabeledStatement: 'LabeledStatement',
+        LogicalExpression: 'LogicalExpression',
+        MemberExpression: 'MemberExpression',
+        NewExpression: 'NewExpression',
+        ObjectExpression: 'ObjectExpression',
+        Program: 'Program',
+        Property: 'Property',
+        ReturnStatement: 'ReturnStatement',
+        SequenceExpression: 'SequenceExpression',
+        SwitchStatement: 'SwitchStatement',
+        SwitchCase: 'SwitchCase',
+        ThisExpression: 'ThisExpression',
+        ThrowStatement: 'ThrowStatement',
+        TryStatement: 'TryStatement',
+        UnaryExpression: 'UnaryExpression',
+        UpdateExpression: 'UpdateExpression',
+        VariableDeclaration: 'VariableDeclaration',
+        VariableDeclarator: 'VariableDeclarator',
+        WhileStatement: 'WhileStatement',
+        WithStatement: 'WithStatement'
+    };
+
+    PropertyKind = {
+        Data: 1,
+        Get: 2,
+        Set: 4
+    };
+
+    // Error messages should be identical to V8.
+    Messages = {
+        UnexpectedToken:  'Unexpected token %0',
+        UnexpectedNumber:  'Unexpected number',
+        UnexpectedString:  'Unexpected string',
+        UnexpectedIdentifier:  'Unexpected identifier',
+        UnexpectedReserved:  'Unexpected reserved word',
+        UnexpectedEOS:  'Unexpected end of input',
+        NewlineAfterThrow:  'Illegal newline after throw',
+        InvalidRegExp: 'Invalid regular expression',
+        UnterminatedRegExp:  'Invalid regular expression: missing /',
+        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
+        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
+        NoCatchOrFinally:  'Missing catch or finally after try',
+        UnknownLabel: 'Undefined label \'%0\'',
+        Redeclaration: '%0 \'%1\' has already been declared',
+        IllegalContinue: 'Illegal continue statement',
+        IllegalBreak: 'Illegal break statement',
+        IllegalReturn: 'Illegal return statement',
+        StrictModeWith:  'Strict mode code may not include a with statement',
+        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
+        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
+        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
+        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
+        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
+        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
+        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
+        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
+        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
+        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
+        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
+        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
+        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
+        StrictReservedWord:  'Use of future reserved word in strict mode'
+    };
+
+    // See also tools/generate-unicode-regex.py.
+    Regex = {
+        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
+        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
+    };
+
+    // Ensure the condition is true, otherwise throw an error.
+    // This is only to have a better contract semantic, i.e. another safety net
+    // to catch a logic error. The condition shall be fulfilled in normal case.
+    // Do NOT use this to enforce a certain condition on any user input.
+
+    function assert(condition, message) {
+        if (!condition) {
+            throw new Error('ASSERT: ' + message);
+        }
+    }
+
+    function sliceSource(from, to) {
+        return source.slice(from, to);
+    }
+
+    if (typeof 'esprima'[0] === 'undefined') {
+        sliceSource = function sliceArraySource(from, to) {
+            return source.slice(from, to).join('');
+        };
+    }
+
+    function isDecimalDigit(ch) {
+        return '0123456789'.indexOf(ch) >= 0;
+    }
+
+    function isHexDigit(ch) {
+        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
+    }
+
+    function isOctalDigit(ch) {
+        return '01234567'.indexOf(ch) >= 0;
+    }
+
+
+    // 7.2 White Space
+
+    function isWhiteSpace(ch) {
+        return (ch === ' ') || (ch === '\u0009') || (ch === '\u000B') ||
+            (ch === '\u000C') || (ch === '\u00A0') ||
+            (ch.charCodeAt(0) >= 0x1680 &&
+             '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(ch) >= 0);
+    }
+
+    // 7.3 Line Terminators
+
+    function isLineTerminator(ch) {
+        return (ch === '\n' || ch === '\r' || ch === '\u2028' || ch === '\u2029');
+    }
+
+    // 7.6 Identifier Names and Identifiers
+
+    function isIdentifierStart(ch) {
+        return (ch === '$') || (ch === '_') || (ch === '\\') ||
+            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
+            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));
+    }
+
+    function isIdentifierPart(ch) {
+        return (ch === '$') || (ch === '_') || (ch === '\\') ||
+            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
+            ((ch >= '0') && (ch <= '9')) ||
+            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));
+    }
+
+    // 7.6.1.2 Future Reserved Words
+
+    function isFutureReservedWord(id) {
+        switch (id) {
+
+        // Future reserved words.
+        case 'class':
+        case 'enum':
+        case 'export':
+        case 'extends':
+        case 'import':
+        case 'super':
+            return true;
+        }
+
+        return false;
+    }
+
+    function isStrictModeReservedWord(id) {
+        switch (id) {
+
+        // Strict Mode reserved words.
+        case 'implements':
+        case 'interface':
+        case 'package':
+        case 'private':
+        case 'protected':
+        case 'public':
+        case 'static':
+        case 'yield':
+        case 'let':
+            return true;
+        }
+
+        return false;
+    }
+
+    function isRestrictedWord(id) {
+        return id === 'eval' || id === 'arguments';
+    }
+
+    // 7.6.1.1 Keywords
+
+    function isKeyword(id) {
+        var keyword = false;
+        switch (id.length) {
+        case 2:
+            keyword = (id === 'if') || (id === 'in') || (id === 'do');
+            break;
+        case 3:
+            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
+            break;
+        case 4:
+            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');
+            break;
+        case 5:
+            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');
+            break;
+        case 6:
+            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');
+            break;
+        case 7:
+            keyword = (id === 'default') || (id === 'finally');
+            break;
+        case 8:
+            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');
+            break;
+        case 10:
+            keyword = (id === 'instanceof');
+            break;
+        }
+
+        if (keyword) {
+            return true;
+        }
+
+        switch (id) {
+        // Future reserved words.
+        // 'const' is specialized as Keyword in V8.
+        case 'const':
+            return true;
+
+        // For compatiblity to SpiderMonkey and ES.next
+        case 'yield':
+        case 'let':
+            return true;
+        }
+
+        if (strict && isStrictModeReservedWord(id)) {
+            return true;
+        }
+
+        return isFutureReservedWord(id);
+    }
+
+    // Return the next character and move forward.
+
+    function nextChar() {
+        return source[index++];
+    }
+
+    // 7.4 Comments
+
+    function skipComment() {
+        var ch, blockComment, lineComment;
+
+        blockComment = false;
+        lineComment = false;
+
+        while (index < length) {
+            ch = source[index];
+
+            if (lineComment) {
+                ch = nextChar();
+                if (isLineTerminator(ch)) {
+                    lineComment = false;
+                    if (ch === '\r' && source[index] === '\n') {
+                        ++index;
+                    }
+                    ++lineNumber;
+                    lineStart = index;
+                }
+            } else if (blockComment) {
+                if (isLineTerminator(ch)) {
+                    if (ch === '\r' && source[index + 1] === '\n') {
+                        ++index;
+                    }
+                    ++lineNumber;
+                    ++index;
+                    lineStart = index;
+                    if (index >= length) {
+                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                    }
+                } else {
+                    ch = nextChar();
+                    if (index >= length) {
+                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                    }
+                    if (ch === '*') {
+                        ch = source[index];
+                        if (ch === '/') {
+                            ++index;
+                            blockComment = false;
+                        }
+                    }
+                }
+            } else if (ch === '/') {
+                ch = source[index + 1];
+                if (ch === '/') {
+                    index += 2;
+                    lineComment = true;
+                } else if (ch === '*') {
+                    index += 2;
+                    blockComment = true;
+                    if (index >= length) {
+                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                    }
+                } else {
+                    break;
+                }
+            } else if (isWhiteSpace(ch)) {
+                ++index;
+            } else if (isLineTerminator(ch)) {
+                ++index;
+                if (ch ===  '\r' && source[index] === '\n') {
+                    ++index;
+                }
+                ++lineNumber;
+                lineStart = index;
+            } else {
+                break;
+            }
+        }
+    }
+
+    function scanHexEscape(prefix) {
+        var i, len, ch, code = 0;
+
+        len = (prefix === 'u') ? 4 : 2;
+        for (i = 0; i < len; ++i) {
+            if (index < length && isHexDigit(source[index])) {
+                ch = nextChar();
+                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
+            } else {
+                return '';
+            }
+        }
+        return String.fromCharCode(code);
+    }
+
+    function scanIdentifier() {
+        var ch, start, id, restore;
+
+        ch = source[index];
+        if (!isIdentifierStart(ch)) {
+            return;
+        }
+
+        start = index;
+        if (ch === '\\') {
+            ++index;
+            if (source[index] !== 'u') {
+                return;
+            }
+            ++index;
+            restore = index;
+            ch = scanHexEscape('u');
+            if (ch) {
+                if (ch === '\\' || !isIdentifierStart(ch)) {
+                    return;
+                }
+                id = ch;
+            } else {
+                index = restore;
+                id = 'u';
+            }
+        } else {
+            id = nextChar();
+        }
+
+        while (index < length) {
+            ch = source[index];
+            if (!isIdentifierPart(ch)) {
+                break;
+            }
+            if (ch === '\\') {
+                ++index;
+                if (source[index] !== 'u') {
+                    return;
+                }
+                ++index;
+                restore = index;
+                ch = scanHexEscape('u');
+                if (ch) {
+                    if (ch === '\\' || !isIdentifierPart(ch)) {
+                        return;
+                    }
+                    id += ch;
+                } else {
+                    index = restore;
+                    id += 'u';
+                }
+            } else {
+                id += nextChar();
+            }
+        }
+
+        // There is no keyword or literal with only one character.
+        // Thus, it must be an identifier.
+        if (id.length === 1) {
+            return {
+                type: Token.Identifier,
+                value: id,
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        if (isKeyword(id)) {
+            return {
+                type: Token.Keyword,
+                value: id,
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        // 7.8.1 Null Literals
+
+        if (id === 'null') {
+            return {
+                type: Token.NullLiteral,
+                value: id,
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        // 7.8.2 Boolean Literals
+
+        if (id === 'true' || id === 'false') {
+            return {
+                type: Token.BooleanLiteral,
+                value: id,
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        return {
+            type: Token.Identifier,
+            value: id,
+            lineNumber: lineNumber,
+            lineStart: lineStart,
+            range: [start, index]
+        };
+    }
+
+    // 7.7 Punctuators
+
+    function scanPunctuator() {
+        var start = index,
+            ch1 = source[index],
+            ch2,
+            ch3,
+            ch4;
+
+        // Check for most common single-character punctuators.
+
+        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {
+            ++index;
+            return {
+                type: Token.Punctuator,
+                value: ch1,
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {
+            ++index;
+            return {
+                type: Token.Punctuator,
+                value: ch1,
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        // Dot (.) can also start a floating-point number, hence the need
+        // to check the next character.
+
+        ch2 = source[index + 1];
+        if (ch1 === '.' && !isDecimalDigit(ch2)) {
+            return {
+                type: Token.Punctuator,
+                value: nextChar(),
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        // Peek more characters.
+
+        ch3 = source[index + 2];
+        ch4 = source[index + 3];
+
+        // 4-character punctuator: >>>=
+
+        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
+            if (ch4 === '=') {
+                index += 4;
+                return {
+                    type: Token.Punctuator,
+                    value: '>>>=',
+                    lineNumber: lineNumber,
+                    lineStart: lineStart,
+                    range: [start, index]
+                };
+            }
+        }
+
+        // 3-character punctuators: === !== >>> <<= >>=
+
+        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {
+            index += 3;
+            return {
+                type: Token.Punctuator,
+                value: '===',
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {
+            index += 3;
+            return {
+                type: Token.Punctuator,
+                value: '!==',
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
+            index += 3;
+            return {
+                type: Token.Punctuator,
+                value: '>>>',
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
+            index += 3;
+            return {
+                type: Token.Punctuator,
+                value: '<<=',
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
+            index += 3;
+            return {
+                type: Token.Punctuator,
+                value: '>>=',
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+
+        // 2-character punctuators: <= >= == != ++ -- << >> && ||
+        // += -= *= %= &= |= ^= /=
+
+        if (ch2 === '=') {
+            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
+                index += 2;
+                return {
+                    type: Token.Punctuator,
+                    value: ch1 + ch2,
+                    lineNumber: lineNumber,
+                    lineStart: lineStart,
+                    range: [start, index]
+                };
+            }
+        }
+
+        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
+            if ('+-<>&|'.indexOf(ch2) >= 0) {
+                index += 2;
+                return {
+                    type: Token.Punctuator,
+                    value: ch1 + ch2,
+                    lineNumber: lineNumber,
+                    lineStart: lineStart,
+                    range: [start, index]
+                };
+            }
+        }
+
+        // The remaining 1-character punctuators.
+
+        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {
+            return {
+                type: Token.Punctuator,
+                value: nextChar(),
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [start, index]
+            };
+        }
+    }
+
+    // 7.8.3 Numeric Literals
+
+    function scanNumericLiteral() {
+        var number, start, ch;
+
+        ch = source[index];
+        assert(isDecimalDigit(ch) || (ch === '.'),
+            'Numeric literal must start with a decimal digit or a decimal point');
+
+        start = index;
+        number = '';
+        if (ch !== '.') {
+            number = nextChar();
+            ch = source[index];
+
+            // Hex number starts with '0x'.
+            // Octal number starts with '0'.
+            if (number === '0') {
+                if (ch === 'x' || ch === 'X') {
+                    number += nextChar();
+                    while (index < length) {
+                        ch = source[index];
+                        if (!isHexDigit(ch)) {
+                            break;
+                        }
+                        number += nextChar();
+                    }
+
+                    if (number.length <= 2) {
+                        // only 0x
+                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                    }
+
+                    if (index < length) {
+                        ch = source[index];
+                        if (isIdentifierStart(ch)) {
+                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                        }
+                    }
+                    return {
+                        type: Token.NumericLiteral,
+                        value: parseInt(number, 16),
+                        lineNumber: lineNumber,
+                        lineStart: lineStart,
+                        range: [start, index]
+                    };
+                } else if (isOctalDigit(ch)) {
+                    number += nextChar();
+                    while (index < length) {
+                        ch = source[index];
+                        if (!isOctalDigit(ch)) {
+                            break;
+                        }
+                        number += nextChar();
+                    }
+
+                    if (index < length) {
+                        ch = source[index];
+                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
+                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                        }
+                    }
+                    return {
+                        type: Token.NumericLiteral,
+                        value: parseInt(number, 8),
+                        octal: true,
+                        lineNumber: lineNumber,
+                        lineStart: lineStart,
+                        range: [start, index]
+                    };
+                }
+
+                // decimal number starts with '0' such as '09' is illegal.
+                if (isDecimalDigit(ch)) {
+                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                }
+            }
+
+            while (index < length) {
+                ch = source[index];
+                if (!isDecimalDigit(ch)) {
+                    break;
+                }
+                number += nextChar();
+            }
+        }
+
+        if (ch === '.') {
+            number += nextChar();
+            while (index < length) {
+                ch = source[index];
+                if (!isDecimalDigit(ch)) {
+                    break;
+                }
+                number += nextChar();
+            }
+        }
+
+        if (ch === 'e' || ch === 'E') {
+            number += nextChar();
+
+            ch = source[index];
+            if (ch === '+' || ch === '-') {
+                number += nextChar();
+            }
+
+            ch = source[index];
+            if (isDecimalDigit(ch)) {
+                number += nextChar();
+                while (index < length) {
+                    ch = source[index];
+                    if (!isDecimalDigit(ch)) {
+                        break;
+                    }
+                    number += nextChar();
+                }
+            } else {
+                ch = 'character ' + ch;
+                if (index >= length) {
+                    ch = '<end>';
+                }
+                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+            }
+        }
+
+        if (index < length) {
+            ch = source[index];
+            if (isIdentifierStart(ch)) {
+                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+            }
+        }
+
+        return {
+            type: Token.NumericLiteral,
+            value: parseFloat(number),
+            lineNumber: lineNumber,
+            lineStart: lineStart,
+            range: [start, index]
+        };
+    }
+
+    // 7.8.4 String Literals
+
+    function scanStringLiteral() {
+        var str = '', quote, start, ch, code, unescaped, restore, octal = false;
+
+        quote = source[index];
+        assert((quote === '\'' || quote === '"'),
+            'String literal must starts with a quote');
+
+        start = index;
+        ++index;
+
+        while (index < length) {
+            ch = nextChar();
+
+            if (ch === quote) {
+                quote = '';
+                break;
+            } else if (ch === '\\') {
+                ch = nextChar();
+                if (!isLineTerminator(ch)) {
+                    switch (ch) {
+                    case 'n':
+                        str += '\n';
+                        break;
+                    case 'r':
+                        str += '\r';
+                        break;
+                    case 't':
+                        str += '\t';
+                        break;
+                    case 'u':
+                    case 'x':
+                        restore = index;
+                        unescaped = scanHexEscape(ch);
+                        if (unescaped) {
+                            str += unescaped;
+                        } else {
+                            index = restore;
+                            str += ch;
+                        }
+                        break;
+                    case 'b':
+                        str += '\b';
+                        break;
+                    case 'f':
+                        str += '\f';
+                        break;
+                    case 'v':
+                        str += '\v';
+                        break;
+
+                    default:
+                        if (isOctalDigit(ch)) {
+                            code = '01234567'.indexOf(ch);
+
+                            // \0 is not octal escape sequence
+                            if (code !== 0) {
+                                octal = true;
+                            }
+
+                            if (index < length && isOctalDigit(source[index])) {
+                                octal = true;
+                                code = code * 8 + '01234567'.indexOf(nextChar());
+
+                                // 3 digits are only allowed when string starts
+                                // with 0, 1, 2, 3
+                                if ('0123'.indexOf(ch) >= 0 &&
+                                        index < length &&
+                                        isOctalDigit(source[index])) {
+                                    code = code * 8 + '01234567'.indexOf(nextChar());
+                                }
+                            }
+                            str += String.fromCharCode(code);
+                        } else {
+                            str += ch;
+                        }
+                        break;
+                    }
+                } else {
+                    ++lineNumber;
+                    if (ch ===  '\r' && source[index] === '\n') {
+                        ++index;
+                    }
+                }
+            } else if (isLineTerminator(ch)) {
+                break;
+            } else {
+                str += ch;
+            }
+        }
+
+        if (quote !== '') {
+            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+        }
+
+        return {
+            type: Token.StringLiteral,
+            value: str,
+            octal: octal,
+            lineNumber: lineNumber,
+            lineStart: lineStart,
+            range: [start, index]
+        };
+    }
+
+    function scanRegExp() {
+        var str = '', ch, start, pattern, flags, value, classMarker = false, restore;
+
+        buffer = null;
+        skipComment();
+
+        start = index;
+        ch = source[index];
+        assert(ch === '/', 'Regular expression literal must start with a slash');
+        str = nextChar();
+
+        while (index < length) {
+            ch = nextChar();
+            str += ch;
+            if (classMarker) {
+                if (ch === ']') {
+                    classMarker = false;
+                }
+            } else {
+                if (ch === '\\') {
+                    ch = nextChar();
+                    // ECMA-262 7.8.5
+                    if (isLineTerminator(ch)) {
+                        throwError({}, Messages.UnterminatedRegExp);
+                    }
+                    str += ch;
+                } else if (ch === '/') {
+                    break;
+                } else if (ch === '[') {
+                    classMarker = true;
+                } else if (isLineTerminator(ch)) {
+                    throwError({}, Messages.UnterminatedRegExp);
+                }
+            }
+        }
+
+        if (str.length === 1) {
+            throwError({}, Messages.UnterminatedRegExp);
+        }
+
+        // Exclude leading and trailing slash.
+        pattern = str.substr(1, str.length - 2);
+
+        flags = '';
+        while (index < length) {
+            ch = source[index];
+            if (!isIdentifierPart(ch)) {
+                break;
+            }
+
+            ++index;
+            if (ch === '\\' && index < length) {
+                ch = source[index];
+                if (ch === 'u') {
+                    ++index;
+                    restore = index;
+                    ch = scanHexEscape('u');
+                    if (ch) {
+                        flags += ch;
+                        str += '\\u';
+                        for (; restore < index; ++restore) {
+                            str += source[restore];
+                        }
+                    } else {
+                        index = restore;
+                        flags += 'u';
+                        str += '\\u';
+                    }
+                } else {
+                    str += '\\';
+                }
+            } else {
+                flags += ch;
+                str += ch;
+            }
+        }
+
+        try {
+            value = new RegExp(pattern, flags);
+        } catch (e) {
+            throwError({}, Messages.InvalidRegExp);
+        }
+
+        return {
+            literal: str,
+            value: value,
+            range: [start, index]
+        };
+    }
+
+    function isIdentifierName(token) {
+        return token.type === Token.Identifier ||
+            token.type === Token.Keyword ||
+            token.type === Token.BooleanLiteral ||
+            token.type === Token.NullLiteral;
+    }
+
+    function advance() {
+        var ch, token;
+
+        skipComment();
+
+        if (index >= length) {
+            return {
+                type: Token.EOF,
+                lineNumber: lineNumber,
+                lineStart: lineStart,
+                range: [index, index]
+            };
+        }
+
+        token = scanPunctuator();
+        if (typeof token !== 'undefined') {
+            return token;
+        }
+
+        ch = source[index];
+
+        if (ch === '\'' || ch === '"') {
+            return scanStringLiteral();
+        }
+
+        if (ch === '.' || isDecimalDigit(ch)) {
+            return scanNumericLiteral();
+        }
+
+        token = scanIdentifier();
+        if (typeof token !== 'undefined') {
+            return token;
+        }
+
+        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+    }
+
+    function lex() {
+        var token;
+
+        if (buffer) {
+            index = buffer.range[1];
+            lineNumber = buffer.lineNumber;
+            lineStart = buffer.lineStart;
+            token = buffer;
+            buffer = null;
+            return token;
+        }
+
+        buffer = null;
+        return advance();
+    }
+
+    function lookahead() {
+        var pos, line, start;
+
+        if (buffer !== null) {
+            return buffer;
+        }
+
+        pos = index;
+        line = lineNumber;
+        start = lineStart;
+        buffer = advance();
+        index = pos;
+        lineNumber = line;
+        lineStart = start;
+
+        return buffer;
+    }
+
+    // Return true if there is a line terminator before the next token.
+
+    function peekLineTerminator() {
+        var pos, line, start, found;
+
+        pos = index;
+        line = lineNumber;
+        start = lineStart;
+        skipComment();
+        found = lineNumber !== line;
+        index = pos;
+        lineNumber = line;
+        lineStart = start;
+
+        return found;
+    }
+
+    // Throw an exception
+
+    function throwError(token, messageFormat) {
+        var error,
+            args = Array.prototype.slice.call(arguments, 2),
+            msg = messageFormat.replace(
+                /%(\d)/g,
+                function (whole, index) {
+                    return args[index] || '';
+                }
+            );
+
+        if (typeof token.lineNumber === 'number') {
+            error = new Error('Line ' + token.lineNumber + ': ' + msg);
+            error.index = token.range[0];
+            error.lineNumber = token.lineNumber;
+            error.column = token.range[0] - lineStart + 1;
+        } else {
+            error = new Error('Line ' + lineNumber + ': ' + msg);
+            error.index = index;
+            error.lineNumber = lineNumber;
+            error.column = index - lineStart + 1;
+        }
+
+        throw error;
+    }
+
+    function throwErrorTolerant() {
+        var error;
+        try {
+            throwError.apply(null, arguments);
+        } catch (e) {
+            if (extra.errors) {
+                extra.errors.push(e);
+            } else {
+                throw e;
+            }
+        }
+    }
+
+
+    // Throw an exception because of the token.
+
+    function throwUnexpected(token) {
+        var s;
+
+        if (token.type === Token.EOF) {
+            throwError(token, Messages.UnexpectedEOS);
+        }
+
+        if (token.type === Token.NumericLiteral) {
+            throwError(token, Messages.UnexpectedNumber);
+        }
+
+        if (token.type === Token.StringLiteral) {
+            throwError(token, Messages.UnexpectedString);
+        }
+
+        if (token.type === Token.Identifier) {
+            throwError(token, Messages.UnexpectedIdentifier);
+        }
+
+        if (token.type === Token.Keyword) {
+            if (isFutureReservedWord(token.value)) {
+                throwError(token, Messages.UnexpectedReserved);
+            } else if (strict && isStrictModeReservedWord(token.value)) {
+                throwError(token, Messages.StrictReservedWord);
+            }
+            throwError(token, Messages.UnexpectedToken, token.value);
+        }
+
+        // BooleanLiteral, NullLiteral, or Punctuator.
+        throwError(token, Messages.UnexpectedToken, token.value);
+    }
+
+    // Expect the next token to match the specified punctuator.
+    // If not, an exception will be thrown.
+
+    function expect(value) {
+        var token = lex();
+        if (token.type !== Token.Punctuator || token.value !== value) {
+            throwUnexpected(token);
+        }
+    }
+
+    // Expect the next token to match the specified keyword.
+    // If not, an exception will be thrown.
+
+    function expectKeyword(keyword) {
+        var token = lex();
+        if (token.type !== Token.Keyword || token.value !== keyword) {
+            throwUnexpected(token);
+        }
+    }
+
+    // Return true if the next token matches the specified punctuator.
+
+    function match(value) {
+        var token = lookahead();
+        return token.type === Token.Punctuator && token.value === value;
+    }
+
+    // Return true if the next token matches the specified keyword
+
+    function matchKeyword(keyword) {
+        var token = lookahead();
+        return token.type === Token.Keyword && token.value === keyword;
+    }
+
+    // Return true if the next token is an assignment operator
+
+    function matchAssign() {
+        var token = lookahead(),
+            op = token.value;
+
+        if (token.type !== Token.Punctuator) {
+            return false;
+        }
+        return op === '=' ||
+            op === '*=' ||
+            op === '/=' ||
+            op === '%=' ||
+            op === '+=' ||
+            op === '-=' ||
+            op === '<<=' ||
+            op === '>>=' ||
+            op === '>>>=' ||
+            op === '&=' ||
+            op === '^=' ||
+            op === '|=';
+    }
+
+    function consumeSemicolon() {
+        var token, line;
+
+        // Catch the very common case first.
+        if (source[index] === ';') {
+            lex();
+            return;
+        }
+
+        line = lineNumber;
+        skipComment();
+        if (lineNumber !== line) {
+            return;
+        }
+
+        if (match(';')) {
+            lex();
+            return;
+        }
+
+        token = lookahead();
+        if (token.type !== Token.EOF && !match('}')) {
+            throwUnexpected(token);
+        }
+        return;
+    }
+
+    // Return true if provided expression is LeftHandSideExpression
+
+    function isLeftHandSide(expr) {
+        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
+    }
+
+    // 11.1.4 Array Initialiser
+
+    function parseArrayInitialiser() {
+        var elements = [],
+            undef;
+
+        expect('[');
+
+        while (!match(']')) {
+            if (match(',')) {
+                lex();
+                elements.push(undef);
+            } else {
+                elements.push(parseAssignmentExpression());
+
+                if (!match(']')) {
+                    expect(',');
+                }
+            }
+        }
+
+        expect(']');
+
+        return {
+            type: Syntax.ArrayExpression,
+            elements: elements
+        };
+    }
+
+    // 11.1.5 Object Initialiser
+
+    function parsePropertyFunction(param, first) {
+        var previousStrict, body;
+
+        previousStrict = strict;
+        body = parseFunctionSourceElements();
+        if (first && strict && isRestrictedWord(param[0].name)) {
+            throwError(first, Messages.StrictParamName);
+        }
+        strict = previousStrict;
+
+        return {
+            type: Syntax.FunctionExpression,
+            id: null,
+            params: param,
+            body: body
+        };
+    }
+
+    function parseObjectPropertyKey() {
+        var token = lex();
+
+        // Note: This function is called only from parseObjectProperty(), where
+        // EOF and Punctuator tokens are already filtered out.
+
+        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
+            if (strict && token.octal) {
+                throwError(token, Messages.StrictOctalLiteral);
+            }
+            return createLiteral(token);
+        }
+
+        return {
+            type: Syntax.Identifier,
+            name: token.value
+        };
+    }
+
+    function parseObjectProperty() {
+        var token, key, id, param;
+
+        token = lookahead();
+
+        if (token.type === Token.Identifier) {
+
+            id = parseObjectPropertyKey();
+
+            // Property Assignment: Getter and Setter.
+
+            if (token.value === 'get' && !match(':')) {
+                key = parseObjectPropertyKey();
+                expect('(');
+                expect(')');
+                return {
+                    type: Syntax.Property,
+                    key: key,
+                    value: parsePropertyFunction([]),
+                    kind: 'get'
+                };
+            } else if (token.value === 'set' && !match(':')) {
+                key = parseObjectPropertyKey();
+                expect('(');
+                token = lookahead();
+                if (token.type !== Token.Identifier) {
+                    throwUnexpected(lex());
+                }
+                param = [ parseVariableIdentifier() ];
+                expect(')');
+                return {
+                    type: Syntax.Property,
+                    key: key,
+                    value: parsePropertyFunction(param, token),
+                    kind: 'set'
+                };
+            } else {
+                expect(':');
+                return {
+                    type: Syntax.Property,
+                    key: id,
+                    value: parseAssignmentExpression(),
+                    kind: 'init'
+                };
+            }
+        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {
+            throwUnexpected(token);
+        } else {
+            key = parseObjectPropertyKey();
+            expect(':');
+            return {
+                type: Syntax.Property,
+                key: key,
+                value: parseAssignmentExpression(),
+                kind: 'init'
+            };
+        }
+    }
+
+    function parseObjectInitialiser() {
+        var token, properties = [], property, name, kind, map = {}, toString = String;
+
+        expect('{');
+
+        while (!match('}')) {
+            property = parseObjectProperty();
+
+            if (property.key.type === Syntax.Identifier) {
+                name = property.key.name;
+            } else {
+                name = toString(property.key.value);
+            }
+            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
+            if (Object.prototype.hasOwnProperty.call(map, name)) {
+                if (map[name] === PropertyKind.Data) {
+                    if (strict && kind === PropertyKind.Data) {
+                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
+                    } else if (kind !== PropertyKind.Data) {
+                        throwError({}, Messages.AccessorDataProperty);
+                    }
+                } else {
+                    if (kind === PropertyKind.Data) {
+                        throwError({}, Messages.AccessorDataProperty);
+                    } else if (map[name] & kind) {
+                        throwError({}, Messages.AccessorGetSet);
+                    }
+                }
+                map[name] |= kind;
+            } else {
+                map[name] = kind;
+            }
+
+            properties.push(property);
+
+            if (!match('}')) {
+                expect(',');
+            }
+        }
+
+        expect('}');
+
+        return {
+            type: Syntax.ObjectExpression,
+            properties: properties
+        };
+    }
+
+    // 11.1 Primary Expressions
+
+    function parsePrimaryExpression() {
+        var expr,
+            token = lookahead(),
+            type = token.type;
+
+        if (type === Token.Identifier) {
+            return {
+                type: Syntax.Identifier,
+                name: lex().value
+            };
+        }
+
+        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
+            if (strict && token.octal) {
+                throwErrorTolerant(token, Messages.StrictOctalLiteral);
+            }
+            return createLiteral(lex());
+        }
+
+        if (type === Token.Keyword) {
+            if (matchKeyword('this')) {
+                lex();
+                return {
+                    type: Syntax.ThisExpression
+                };
+            }
+
+            if (matchKeyword('function')) {
+                return parseFunctionExpression();
+            }
+        }
+
+        if (type === Token.BooleanLiteral) {
+            lex();
+            token.value = (token.value === 'true');
+            return createLiteral(token);
+        }
+
+        if (type === Token.NullLiteral) {
+            lex();
+            token.value = null;
+            return createLiteral(token);
+        }
+
+        if (match('[')) {
+            return parseArrayInitialiser();
+        }
+
+        if (match('{')) {
+            return parseObjectInitialiser();
+        }
+
+        if (match('(')) {
+            lex();
+            state.lastParenthesized = expr = parseExpression();
+            expect(')');
+            return expr;
+        }
+
+        if (match('/') || match('/=')) {
+            return createLiteral(scanRegExp());
+        }
+
+        return throwUnexpected(lex());
+    }
+
+    // 11.2 Left-Hand-Side Expressions
+
+    function parseArguments() {
+        var args = [];
+
+        expect('(');
+
+        if (!match(')')) {
+            while (index < length) {
+                args.push(parseAssignmentExpression());
+                if (match(')')) {
+                    break;
+                }
+                expect(',');
+            }
+        }
+
+        expect(')');
+
+        return args;
+    }
+
+    function parseNonComputedProperty() {
+        var token = lex();
+
+        if (!isIdentifierName(token)) {
+            throwUnexpected(token);
+        }
+
+        return {
+            type: Syntax.Identifier,
+            name: token.value
+        };
+    }
+
+    function parseNonComputedMember(object) {
+        return {
+            type: Syntax.MemberExpression,
+            computed: false,
+            object: object,
+            property: parseNonComputedProperty()
+        };
+    }
+
+    function parseComputedMember(object) {
+        var property, expr;
+
+        expect('[');
+        property = parseExpression();
+        expr = {
+            type: Syntax.MemberExpression,
+            computed: true,
+            object: object,
+            property: property
+        };
+        expect(']');
+        return expr;
+    }
+
+    function parseCallMember(object) {
+        return {
+            type: Syntax.CallExpression,
+            callee: object,
+            'arguments': parseArguments()
+        };
+    }
+
+    function parseNewExpression() {
+        var expr;
+
+        expectKeyword('new');
+
+        expr = {
+            type: Syntax.NewExpression,
+            callee: parseLeftHandSideExpression(),
+            'arguments': []
+        };
+
+        if (match('(')) {
+            expr['arguments'] = parseArguments();
+        }
+
+        return expr;
+    }
+
+    function parseLeftHandSideExpressionAllowCall() {
+        var useNew, expr;
+
+        useNew = matchKeyword('new');
+        expr = useNew ? parseNewExpression() : parsePrimaryExpression();
+
+        while (index < length) {
+            if (match('.')) {
+                lex();
+                expr = parseNonComputedMember(expr);
+            } else if (match('[')) {
+                expr = parseComputedMember(expr);
+            } else if (match('(')) {
+                expr = parseCallMember(expr);
+            } else {
+                break;
+            }
+        }
+
+        return expr;
+    }
+
+    function parseLeftHandSideExpression() {
+        var useNew, expr;
+
+        useNew = matchKeyword('new');
+        expr = useNew ? parseNewExpression() : parsePrimaryExpression();
+
+        while (index < length) {
+            if (match('.')) {
+                lex();
+                expr = parseNonComputedMember(expr);
+            } else if (match('[')) {
+                expr = parseComputedMember(expr);
+            } else {
+                break;
+            }
+        }
+
+        return expr;
+    }
+
+    // 11.3 Postfix Expressions
+
+    function parsePostfixExpression() {
+        var expr = parseLeftHandSideExpressionAllowCall();
+
+        if ((match('++') || match('--')) && !peekLineTerminator()) {
+            // 11.3.1, 11.3.2
+            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
+                throwError({}, Messages.StrictLHSPostfix);
+            }
+
+            if (!isLeftHandSide(expr)) {
+                throwError({}, Messages.InvalidLHSInAssignment);
+            }
+
+            expr = {
+                type: Syntax.UpdateExpression,
+                operator: lex().value,
+                argument: expr,
+                prefix: false
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.4 Unary Operators
+
+    function parseUnaryExpression() {
+        var token, expr;
+
+        if (match('++') || match('--')) {
+            token = lex();
+            expr = parseUnaryExpression();
+            // 11.4.4, 11.4.5
+            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
+                throwError({}, Messages.StrictLHSPrefix);
+            }
+
+            if (!isLeftHandSide(expr)) {
+                throwError({}, Messages.InvalidLHSInAssignment);
+            }
+
+            expr = {
+                type: Syntax.UpdateExpression,
+                operator: token.value,
+                argument: expr,
+                prefix: true
+            };
+            return expr;
+        }
+
+        if (match('+') || match('-') || match('~') || match('!')) {
+            expr = {
+                type: Syntax.UnaryExpression,
+                operator: lex().value,
+                argument: parseUnaryExpression()
+            };
+            return expr;
+        }
+
+        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
+            expr = {
+                type: Syntax.UnaryExpression,
+                operator: lex().value,
+                argument: parseUnaryExpression()
+            };
+            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
+                throwErrorTolerant({}, Messages.StrictDelete);
+            }
+            return expr;
+        }
+
+        return parsePostfixExpression();
+    }
+
+    // 11.5 Multiplicative Operators
+
+    function parseMultiplicativeExpression() {
+        var expr = parseUnaryExpression();
+
+        while (match('*') || match('/') || match('%')) {
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: lex().value,
+                left: expr,
+                right: parseUnaryExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.6 Additive Operators
+
+    function parseAdditiveExpression() {
+        var expr = parseMultiplicativeExpression();
+
+        while (match('+') || match('-')) {
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: lex().value,
+                left: expr,
+                right: parseMultiplicativeExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.7 Bitwise Shift Operators
+
+    function parseShiftExpression() {
+        var expr = parseAdditiveExpression();
+
+        while (match('<<') || match('>>') || match('>>>')) {
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: lex().value,
+                left: expr,
+                right: parseAdditiveExpression()
+            };
+        }
+
+        return expr;
+    }
+    // 11.8 Relational Operators
+
+    function parseRelationalExpression() {
+        var expr, previousAllowIn;
+
+        previousAllowIn = state.allowIn;
+        state.allowIn = true;
+
+        expr = parseShiftExpression();
+
+        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: lex().value,
+                left: expr,
+                right: parseShiftExpression()
+            };
+        }
+
+        state.allowIn = previousAllowIn;
+        return expr;
+    }
+
+    // 11.9 Equality Operators
+
+    function parseEqualityExpression() {
+        var expr = parseRelationalExpression();
+
+        while (match('==') || match('!=') || match('===') || match('!==')) {
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: lex().value,
+                left: expr,
+                right: parseRelationalExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.10 Binary Bitwise Operators
+
+    function parseBitwiseANDExpression() {
+        var expr = parseEqualityExpression();
+
+        while (match('&')) {
+            lex();
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: '&',
+                left: expr,
+                right: parseEqualityExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    function parseBitwiseXORExpression() {
+        var expr = parseBitwiseANDExpression();
+
+        while (match('^')) {
+            lex();
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: '^',
+                left: expr,
+                right: parseBitwiseANDExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    function parseBitwiseORExpression() {
+        var expr = parseBitwiseXORExpression();
+
+        while (match('|')) {
+            lex();
+            expr = {
+                type: Syntax.BinaryExpression,
+                operator: '|',
+                left: expr,
+                right: parseBitwiseXORExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.11 Binary Logical Operators
+
+    function parseLogicalANDExpression() {
+        var expr = parseBitwiseORExpression();
+
+        while (match('&&')) {
+            lex();
+            expr = {
+                type: Syntax.LogicalExpression,
+                operator: '&&',
+                left: expr,
+                right: parseBitwiseORExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    function parseLogicalORExpression() {
+        var expr = parseLogicalANDExpression();
+
+        while (match('||')) {
+            lex();
+            expr = {
+                type: Syntax.LogicalExpression,
+                operator: '||',
+                left: expr,
+                right: parseLogicalANDExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.12 Conditional Operator
+
+    function parseConditionalExpression() {
+        var expr, previousAllowIn, consequent;
+
+        expr = parseLogicalORExpression();
+
+        if (match('?')) {
+            lex();
+            previousAllowIn = state.allowIn;
+            state.allowIn = true;
+            consequent = parseAssignmentExpression();
+            state.allowIn = previousAllowIn;
+            expect(':');
+
+            expr = {
+                type: Syntax.ConditionalExpression,
+                test: expr,
+                consequent: consequent,
+                alternate: parseAssignmentExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.13 Assignment Operators
+
+    function parseAssignmentExpression() {
+        var expr;
+
+        expr = parseConditionalExpression();
+
+        if (matchAssign()) {
+            // LeftHandSideExpression
+            if (!isLeftHandSide(expr)) {
+                throwError({}, Messages.InvalidLHSInAssignment);
+            }
+
+            // 11.13.1
+            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
+                throwError({}, Messages.StrictLHSAssignment);
+            }
+
+            expr = {
+                type: Syntax.AssignmentExpression,
+                operator: lex().value,
+                left: expr,
+                right: parseAssignmentExpression()
+            };
+        }
+
+        return expr;
+    }
+
+    // 11.14 Comma Operator
+
+    function parseExpression() {
+        var expr = parseAssignmentExpression();
+
+        if (match(',')) {
+            expr = {
+                type: Syntax.SequenceExpression,
+                expressions: [ expr ]
+            };
+
+            while (index < length) {
+                if (!match(',')) {
+                    break;
+                }
+                lex();
+                expr.expressions.push(parseAssignmentExpression());
+            }
+
+        }
+        return expr;
+    }
+
+    // 12.1 Block
+
+    function parseStatementList() {
+        var list = [],
+            statement;
+
+        while (index < length) {
+            if (match('}')) {
+                break;
+            }
+            statement = parseSourceElement();
+            if (typeof statement === 'undefined') {
+                break;
+            }
+            list.push(statement);
+        }
+
+        return list;
+    }
+
+    function parseBlock() {
+        var block;
+
+        expect('{');
+
+        block = parseStatementList();
+
+        expect('}');
+
+        return {
+            type: Syntax.BlockStatement,
+            body: block
+        };
+    }
+
+    // 12.2 Variable Statement
+
+    function parseVariableIdentifier() {
+        var token = lex();
+
+        if (token.type !== Token.Identifier) {
+            throwUnexpected(token);
+        }
+
+        return {
+            type: Syntax.Identifier,
+            name: token.value
+        };
+    }
+
+    function parseVariableDeclaration(kind) {
+        var id = parseVariableIdentifier(),
+            init = null;
+
+        // 12.2.1
+        if (strict && isRestrictedWord(id.name)) {
+            throwErrorTolerant({}, Messages.StrictVarName);
+        }
+
+        if (kind === 'const') {
+            expect('=');
+            init = parseAssignmentExpression();
+        } else if (match('=')) {
+            lex();
+            init = parseAssignmentExpression();
+        }
+
+        return {
+            type: Syntax.VariableDeclarator,
+            id: id,
+            init: init
+        };
+    }
+
+    function parseVariableDeclarationList(kind) {
+        var list = [];
+
+        while (index < length) {
+            list.push(parseVariableDeclaration(kind));
+            if (!match(',')) {
+                break;
+            }
+            lex();
+        }
+
+        return list;
+    }
+
+    function parseVariableStatement() {
+        var declarations;
+
+        expectKeyword('var');
+
+        declarations = parseVariableDeclarationList();
+
+        consumeSemicolon();
+
+        return {
+            type: Syntax.VariableDeclaration,
+            declarations: declarations,
+            kind: 'var'
+        };
+    }
+
+    // kind may be `const` or `let`
+    // Both are experimental and not in the specification yet.
+    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
+    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
+    function parseConstLetDeclaration(kind) {
+        var declarations;
+
+        expectKeyword(kind);
+
+        declarations = parseVariableDeclarationList(kind);
+
+        consumeSemicolon();
+
+        return {
+            type: Syntax.VariableDeclaration,
+            declarations: declarations,
+            kind: kind
+        };
+    }
+
+    // 12.3 Empty Statement
+
+    function parseEmptyStatement() {
+        expect(';');
+
+        return {
+            type: Syntax.EmptyStatement
+        };
+    }
+
+    // 12.4 Expression Statement
+
+    function parseExpressionStatement() {
+        var expr = parseExpression();
+
+        consumeSemicolon();
+
+        return {
+            type: Syntax.ExpressionStatement,
+            expression: expr
+        };
+    }
+
+    // 12.5 If statement
+
+    function parseIfStatement() {
+        var test, consequent, alternate;
+
+        expectKeyword('if');
+
+        expect('(');
+
+        test = parseExpression();
+
+        expect(')');
+
+        consequent = parseStatement();
+
+        if (matchKeyword('else')) {
+            lex();
+            alternate = parseStatement();
+        } else {
+            alternate = null;
+        }
+
+        return {
+            type: Syntax.IfStatement,
+            test: test,
+            consequent: consequent,
+            alternate: alternate
+        };
+    }
+
+    // 12.6 Iteration Statements
+
+    function parseDoWhileStatement() {
+        var body, test, oldInIteration;
+
+        expectKeyword('do');
+
+        oldInIteration = state.inIteration;
+        state.inIteration = true;
+
+        body = parseStatement();
+
+        state.inIteration = oldInIteration;
+
+        expectKeyword('while');
+
+        expect('(');
+
+        test = parseExpression();
+
+        expect(')');
+
+        if (match(';')) {
+            lex();
+        }
+
+        return {
+            type: Syntax.DoWhileStatement,
+            body: body,
+            test: test
+        };
+    }
+
+    function parseWhileStatement() {
+        var test, body, oldInIteration;
+
+        expectKeyword('while');
+
+        expect('(');
+
+        test = parseExpression();
+
+        expect(')');
+
+        oldInIteration = state.inIteration;
+        state.inIteration = true;
+
+        body = parseStatement();
+
+        state.inIteration = oldInIteration;
+
+        return {
+            type: Syntax.WhileStatement,
+            test: test,
+            body: body
+        };
+    }
+
+    function parseForVariableDeclaration() {
+        var token = lex();
+
+        return {
+            type: Syntax.VariableDeclaration,
+            declarations: parseVariableDeclarationList(),
+            kind: token.value
+        };
+    }
+
+    function parseForStatement() {
+        var init, test, update, left, right, body, oldInIteration;
+
+        init = test = update = null;
+
+        expectKeyword('for');
+
+        expect('(');
+
+        if (match(';')) {
+            lex();
+        } else {
+            if (matchKeyword('var') || matchKeyword('let')) {
+                state.allowIn = false;
+                init = parseForVariableDeclaration();
+                state.allowIn = true;
+
+                if (init.declarations.length === 1 && matchKeyword('in')) {
+                    lex();
+                    left = init;
+                    right = parseExpression();
+                    init = null;
+                }
+            } else {
+                state.allowIn = false;
+                init = parseExpression();
+                state.allowIn = true;
+
+                if (matchKeyword('in')) {
+                    // LeftHandSideExpression
+                    if (!isLeftHandSide(init)) {
+                        throwError({}, Messages.InvalidLHSInForIn);
+                    }
+
+                    lex();
+                    left = init;
+                    right = parseExpression();
+                    init = null;
+                }
+            }
+
+            if (typeof left === 'undefined') {
+                expect(';');
+            }
+        }
+
+        if (typeof left === 'undefined') {
+
+            if (!match(';')) {
+                test = parseExpression();
+            }
+            expect(';');
+
+            if (!match(')')) {
+                update = parseExpression();
+            }
+        }
+
+        expect(')');
+
+        oldInIteration = state.inIteration;
+        state.inIteration = true;
+
+        body = parseStatement();
+
+        state.inIteration = oldInIteration;
+
+        if (typeof left === 'undefined') {
+            return {
+                type: Syntax.ForStatement,
+                init: init,
+                test: test,
+                update: update,
+                body: body
+            };
+        }
+
+        return {
+            type: Syntax.ForInStatement,
+            left: left,
+            right: right,
+            body: body,
+            each: false
+        };
+    }
+
+    // 12.7 The continue statement
+
+    function parseContinueStatement() {
+        var token, label = null;
+
+        expectKeyword('continue');
+
+        // Optimize the most common form: 'continue;'.
+        if (source[index] === ';') {
+            lex();
+
+            if (!state.inIteration) {
+                throwError({}, Messages.IllegalContinue);
+            }
+
+            return {
+                type: Syntax.ContinueStatement,
+                label: null
+            };
+        }
+
+        if (peekLineTerminator()) {
+            if (!state.inIteration) {
+                throwError({}, Messages.IllegalContinue);
+            }
+
+            return {
+                type: Syntax.ContinueStatement,
+                label: null
+            };
+        }
+
+        token = lookahead();
+        if (token.type === Token.Identifier) {
+            label = parseVariableIdentifier();
+
+            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
+                throwError({}, Messages.UnknownLabel, label.name);
+            }
+        }
+
+        consumeSemicolon();
+
+        if (label === null && !state.inIteration) {
+            throwError({}, Messages.IllegalContinue);
+        }
+
+        return {
+            type: Syntax.ContinueStatement,
+            label: label
+        };
+    }
+
+    // 12.8 The break statement
+
+    function parseBreakStatement() {
+        var token, label = null;
+
+        expectKeyword('break');
+
+        // Optimize the most common form: 'break;'.
+        if (source[index] === ';') {
+            lex();
+
+            if (!(state.inIteration || state.inSwitch)) {
+                throwError({}, Messages.IllegalBreak);
+            }
+
+            return {
+                type: Syntax.BreakStatement,
+                label: null
+            };
+        }
+
+        if (peekLineTerminator()) {
+            if (!(state.inIteration || state.inSwitch)) {
+                throwError({}, Messages.IllegalBreak);
+            }
+
+            return {
+                type: Syntax.BreakStatement,
+                label: null
+            };
+        }
+
+        token = lookahead();
+        if (token.type === Token.Identifier) {
+            label = parseVariableIdentifier();
+
+            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
+                throwError({}, Messages.UnknownLabel, label.name);
+            }
+        }
+
+        consumeSemicolon();
+
+        if (label === null && !(state.inIteration || state.inSwitch)) {
+            throwError({}, Messages.IllegalBreak);
+        }
+
+        return {
+            type: Syntax.BreakStatement,
+            label: label
+        };
+    }
+
+    // 12.9 The return statement
+
+    function parseReturnStatement() {
+        var token, argument = null;
+
+        expectKeyword('return');
+
+        if (!state.inFunctionBody) {
+            throwErrorTolerant({}, Messages.IllegalReturn);
+        }
+
+        // 'return' followed by a space and an identifier is very common.
+        if (source[index] === ' ') {
+            if (isIdentifierStart(source[index + 1])) {
+                argument = parseExpression();
+                consumeSemicolon();
+                return {
+                    type: Syntax.ReturnStatement,
+                    argument: argument
+                };
+            }
+        }
+
+        if (peekLineTerminator()) {
+            return {
+                type: Syntax.ReturnStatement,
+                argument: null
+            };
+        }
+
+        if (!match(';')) {
+            token = lookahead();
+            if (!match('}') && token.type !== Token.EOF) {
+                argument = parseExpression();
+            }
+        }
+
+        consumeSemicolon();
+
+        return {
+            type: Syntax.ReturnStatement,
+            argument: argument
+        };
+    }
+
+    // 12.10 The with statement
+
+    function parseWithStatement() {
+        var object, body;
+
+        if (strict) {
+            throwErrorTolerant({}, Messages.StrictModeWith);
+        }
+
+        expectKeyword('with');
+
+        expect('(');
+
+        object = parseExpression();
+
+        expect(')');
+
+        body = parseStatement();
+
+        return {
+            type: Syntax.WithStatement,
+            object: object,
+            body: body
+        };
+    }
+
+    // 12.10 The swith statement
+
+    function parseSwitchCase() {
+        var test,
+            consequent = [],
+            statement;
+
+        if (matchKeyword('default')) {
+            lex();
+            test = null;
+        } else {
+            expectKeyword('case');
+            test = parseExpression();
+        }
+        expect(':');
+
+        while (index < length) {
+            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
+                break;
+            }
+            statement = parseStatement();
+            if (typeof statement === 'undefined') {
+                break;
+            }
+            consequent.push(statement);
+        }
+
+        return {
+            type: Syntax.SwitchCase,
+            test: test,
+            consequent: consequent
+        };
+    }
+
+    function parseSwitchStatement() {
+        var discriminant, cases, oldInSwitch;
+
+        expectKeyword('switch');
+
+        expect('(');
+
+        discriminant = parseExpression();
+
+        expect(')');
+
+        expect('{');
+
+        if (match('}')) {
+            lex();
+            return {
+                type: Syntax.SwitchStatement,
+                discriminant: discriminant
+            };
+        }
+
+        cases = [];
+
+        oldInSwitch = state.inSwitch;
+        state.inSwitch = true;
+
+        while (index < length) {
+            if (match('}')) {
+                break;
+            }
+            cases.push(parseSwitchCase());
+        }
+
+        state.inSwitch = oldInSwitch;
+
+        expect('}');
+
+        return {
+            type: Syntax.SwitchStatement,
+            discriminant: discriminant,
+            cases: cases
+        };
+    }
+
+    // 12.13 The throw statement
+
+    function parseThrowStatement() {
+        var argument;
+
+        expectKeyword('throw');
+
+        if (peekLineTerminator()) {
+            throwError({}, Messages.NewlineAfterThrow);
+        }
+
+        argument = parseExpression();
+
+        consumeSemicolon();
+
+        return {
+            type: Syntax.ThrowStatement,
+            argument: argument
+        };
+    }
+
+    // 12.14 The try statement
+
+    function parseCatchClause() {
+        var param;
+
+        expectKeyword('catch');
+
+        expect('(');
+        if (!match(')')) {
+            param = parseExpression();
+            // 12.14.1
+            if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {
+                throwErrorTolerant({}, Messages.StrictCatchVariable);
+            }
+        }
+        expect(')');
+
+        return {
+            type: Syntax.CatchClause,
+            param: param,
+            guard: null,
+            body: parseBlock()
+        };
+    }
+
+    function parseTryStatement() {
+        var block, handlers = [], finalizer = null;
+
+        expectKeyword('try');
+
+        block = parseBlock();
+
+        if (matchKeyword('catch')) {
+            handlers.push(parseCatchClause());
+        }
+
+        if (matchKeyword('finally')) {
+            lex();
+            finalizer = parseBlock();
+        }
+
+        if (handlers.length === 0 && !finalizer) {
+            throwError({}, Messages.NoCatchOrFinally);
+        }
+
+        return {
+            type: Syntax.TryStatement,
+            block: block,
+            handlers: handlers,
+            finalizer: finalizer
+        };
+    }
+
+    // 12.15 The debugger statement
+
+    function parseDebuggerStatement() {
+        expectKeyword('debugger');
+
+        consumeSemicolon();
+
+        return {
+            type: Syntax.DebuggerStatement
+        };
+    }
+
+    // 12 Statements
+
+    function parseStatement() {
+        var token = lookahead(),
+            expr,
+            labeledBody;
+
+        if (token.type === Token.EOF) {
+            throwUnexpected(token);
+        }
+
+        if (token.type === Token.Punctuator) {
+            switch (token.value) {
+            case ';':
+                return parseEmptyStatement();
+            case '{':
+                return parseBlock();
+            case '(':
+                return parseExpressionStatement();
+            default:
+                break;
+            }
+        }
+
+        if (token.type === Token.Keyword) {
+            switch (token.value) {
+            case 'break':
+                return parseBreakStatement();
+            case 'continue':
+                return parseContinueStatement();
+            case 'debugger':
+                return parseDebuggerStatement();
+            case 'do':
+                return parseDoWhileStatement();
+            case 'for':
+                return parseForStatement();
+            case 'function':
+                return parseFunctionDeclaration();
+            case 'if':
+                return parseIfStatement();
+            case 'return':
+                return parseReturnStatement();
+            case 'switch':
+                return parseSwitchStatement();
+            case 'throw':
+                return parseThrowStatement();
+            case 'try':
+                return parseTryStatement();
+            case 'var':
+                return parseVariableStatement();
+            case 'while':
+                return parseWhileStatement();
+            case 'with':
+                return parseWithStatement();
+            default:
+                break;
+            }
+        }
+
+        expr = parseExpression();
+
+        // 12.12 Labelled Statements
+        if ((expr.type === Syntax.Identifier) && match(':')) {
+            lex();
+
+            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {
+                throwError({}, Messages.Redeclaration, 'Label', expr.name);
+            }
+
+            state.labelSet[expr.name] = true;
+            labeledBody = parseStatement();
+            delete state.labelSet[expr.name];
+
+            return {
+                type: Syntax.LabeledStatement,
+                label: expr,
+                body: labeledBody
+            };
+        }
+
+        consumeSemicolon();
+
+        return {
+            type: Syntax.ExpressionStatement,
+            expression: expr
+        };
+    }
+
+    // 13 Function Definition
+
+    function parseFunctionSourceElements() {
+        var sourceElement, sourceElements = [], token, directive, firstRestricted,
+            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;
+
+        expect('{');
+
+        while (index < length) {
+            token = lookahead();
+            if (token.type !== Token.StringLiteral) {
+                break;
+            }
+
+            sourceElement = parseSourceElement();
+            sourceElements.push(sourceElement);
+            if (sourceElement.expression.type !== Syntax.Literal) {
+                // this is not directive
+                break;
+            }
+            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
+            if (directive === 'use strict') {
+                strict = true;
+                if (firstRestricted) {
+                    throwError(firstRestricted, Messages.StrictOctalLiteral);
+                }
+            } else {
+                if (!firstRestricted && token.octal) {
+                    firstRestricted = token;
+                }
+            }
+        }
+
+        oldLabelSet = state.labelSet;
+        oldInIteration = state.inIteration;
+        oldInSwitch = state.inSwitch;
+        oldInFunctionBody = state.inFunctionBody;
+
+        state.labelSet = {};
+        state.inIteration = false;
+        state.inSwitch = false;
+        state.inFunctionBody = true;
+
+        while (index < length) {
+            if (match('}')) {
+                break;
+            }
+            sourceElement = parseSourceElement();
+            if (typeof sourceElement === 'undefined') {
+                break;
+            }
+            sourceElements.push(sourceElement);
+        }
+
+        expect('}');
+
+        state.labelSet = oldLabelSet;
+        state.inIteration = oldInIteration;
+        state.inSwitch = oldInSwitch;
+        state.inFunctionBody = oldInFunctionBody;
+
+        return {
+            type: Syntax.BlockStatement,
+            body: sourceElements
+        };
+    }
+
+    function parseFunctionDeclaration() {
+        var id, param, params = [], body, token, firstRestricted, message, previousStrict, paramSet;
+
+        expectKeyword('function');
+        token = lookahead();
+        id = parseVariableIdentifier();
+        if (strict) {
+            if (isRestrictedWord(token.value)) {
+                throwError(token, Messages.StrictFunctionName);
+            }
+        } else {
+            if (isRestrictedWord(token.value)) {
+                firstRestricted = token;
+                message = Messages.StrictFunctionName;
+            } else if (isStrictModeReservedWord(token.value)) {
+                firstRestricted = token;
+                message = Messages.StrictReservedWord;
+            }
+        }
+
+        expect('(');
+
+        if (!match(')')) {
+            paramSet = {};
+            while (index < length) {
+                token = lookahead();
+                param = parseVariableIdentifier();
+                if (strict) {
+                    if (isRestrictedWord(token.value)) {
+                        throwError(token, Messages.StrictParamName);
+                    }
+                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
+                        throwError(token, Messages.StrictParamDupe);
+                    }
+                } else if (!firstRestricted) {
+                    if (isRestrictedWord(token.value)) {
+                        firstRestricted = token;
+                        message = Messages.StrictParamName;
+                    } else if (isStrictModeReservedWord(token.value)) {
+                        firstRestricted = token;
+                        message = Messages.StrictReservedWord;
+                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
+                        firstRestricted = token;
+                        message = Messages.StrictParamDupe;
+                    }
+                }
+                params.push(param);
+                paramSet[param.name] = true;
+                if (match(')')) {
+                    break;
+                }
+                expect(',');
+            }
+        }
+
+        expect(')');
+
+        previousStrict = strict;
+        body = parseFunctionSourceElements();
+        if (strict && firstRestricted) {
+            throwError(firstRestricted, message);
+        }
+        strict = previousStrict;
+
+        return {
+            type: Syntax.FunctionDeclaration,
+            id: id,
+            params: params,
+            body: body
+        };
+    }
+
+    function parseFunctionExpression() {
+        var token, id = null, firstRestricted, message, param, params = [], body, previousStrict, paramSet;
+
+        expectKeyword('function');
+
+        if (!match('(')) {
+            token = lookahead();
+            id = parseVariableIdentifier();
+            if (strict) {
+                if (isRestrictedWord(token.value)) {
+                    throwError(token, Messages.StrictFunctionName);
+                }
+            } else {
+                if (isRestrictedWord(token.value)) {
+                    firstRestricted = token;
+                    message = Messages.StrictFunctionName;
+                } else if (isStrictModeReservedWord(token.value)) {
+                    firstRestricted = token;
+                    message = Messages.StrictReservedWord;
+                }
+            }
+        }
+
+        expect('(');
+
+        if (!match(')')) {
+            paramSet = {};
+            while (index < length) {
+                token = lookahead();
+                param = parseVariableIdentifier();
+                if (strict) {
+                    if (isRestrictedWord(token.value)) {
+                        throwError(token, Messages.StrictParamName);
+                    }
+                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
+                        throwError(token, Messages.StrictParamDupe);
+                    }
+                } else if (!firstRestricted) {
+                    if (isRestrictedWord(token.value)) {
+                        firstRestricted = token;
+                        message = Messages.StrictParamName;
+                    } else if (isStrictModeReservedWord(token.value)) {
+                        firstRestricted = token;
+                        message = Messages.StrictReservedWord;
+                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
+                        firstRestricted = token;
+                        message = Messages.StrictParamDupe;
+                    }
+                }
+                params.push(param);
+                paramSet[param.name] = true;
+                if (match(')')) {
+                    break;
+                }
+                expect(',');
+            }
+        }
+
+        expect(')');
+
+        previousStrict = strict;
+        body = parseFunctionSourceElements();
+        if (strict && firstRestricted) {
+            throwError(firstRestricted, message);
+        }
+        strict = previousStrict;
+
+        return {
+            type: Syntax.FunctionExpression,
+            id: id,
+            params: params,
+            body: body
+        };
+    }
+
+    // 14 Program
+
+    function parseSourceElement() {
+        var token = lookahead();
+
+        if (token.type === Token.Keyword) {
+            switch (token.value) {
+            case 'const':
+            case 'let':
+                return parseConstLetDeclaration(token.value);
+            case 'function':
+                return parseFunctionDeclaration();
+            default:
+                return parseStatement();
+            }
+        }
+
+        if (token.type !== Token.EOF) {
+            return parseStatement();
+        }
+    }
+
+    function parseSourceElements() {
+        var sourceElement, sourceElements = [], token, directive, firstRestricted;
+
+        while (index < length) {
+            token = lookahead();
+            if (token.type !== Token.StringLiteral) {
+                break;
+            }
+
+            sourceElement = parseSourceElement();
+            sourceElements.push(sourceElement);
+            if (sourceElement.expression.type !== Syntax.Literal) {
+                // this is not directive
+                break;
+            }
+            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
+            if (directive === 'use strict') {
+                strict = true;
+                if (firstRestricted) {
+                    throwError(firstRestricted, Messages.StrictOctalLiteral);
+                }
+            } else {
+                if (!firstRestricted && token.octal) {
+                    firstRestricted = token;
+                }
+            }
+        }
+
+        while (index < length) {
+            sourceElement = parseSourceElement();
+            if (typeof sourceElement === 'undefined') {
+                break;
+            }
+            sourceElements.push(sourceElement);
+        }
+        return sourceElements;
+    }
+
+    function parseProgram() {
+        var program;
+        strict = false;
+        program = {
+            type: Syntax.Program,
+            body: parseSourceElements()
+        };
+        return program;
+    }
+
+    // The following functions are needed only when the option to preserve
+    // the comments is active.
+
+    function addComment(start, end, type, value) {
+        assert(typeof start === 'number', 'Comment must have valid position');
+
+        // Because the way the actual token is scanned, often the comments
+        // (if any) are skipped twice during the lexical analysis.
+        // Thus, we need to skip adding a comment if the comment array already
+        // handled it.
+        if (extra.comments.length > 0) {
+            if (extra.comments[extra.comments.length - 1].range[1] > start) {
+                return;
+            }
+        }
+
+        extra.comments.push({
+            range: [start, end],
+            type: type,
+            value: value
+        });
+    }
+
+    function scanComment() {
+        var comment, ch, start, blockComment, lineComment;
+
+        comment = '';
+        blockComment = false;
+        lineComment = false;
+
+        while (index < length) {
+            ch = source[index];
+
+            if (lineComment) {
+                ch = nextChar();
+                if (index >= length) {
+                    lineComment = false;
+                    comment += ch;
+                    addComment(start, index, 'Line', comment);
+                } else if (isLineTerminator(ch)) {
+                    lineComment = false;
+                    addComment(start, index, 'Line', comment);
+                    if (ch === '\r' && source[index] === '\n') {
+                        ++index;
+                    }
+                    ++lineNumber;
+                    lineStart = index;
+                    comment = '';
+                } else {
+                    comment += ch;
+                }
+            } else if (blockComment) {
+                if (isLineTerminator(ch)) {
+                    if (ch === '\r' && source[index + 1] === '\n') {
+                        ++index;
+                        comment += '\r\n';
+                    } else {
+                        comment += ch;
+                    }
+                    ++lineNumber;
+                    ++index;
+                    lineStart = index;
+                    if (index >= length) {
+                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                    }
+                } else {
+                    ch = nextChar();
+                    if (index >= length) {
+                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                    }
+                    comment += ch;
+                    if (ch === '*') {
+                        ch = source[index];
+                        if (ch === '/') {
+                            comment = comment.substr(0, comment.length - 1);
+                            blockComment = false;
+                            ++index;
+                            addComment(start, index, 'Block', comment);
+                            comment = '';
+                        }
+                    }
+                }
+            } else if (ch === '/') {
+                ch = source[index + 1];
+                if (ch === '/') {
+                    start = index;
+                    index += 2;
+                    lineComment = true;
+                } else if (ch === '*') {
+                    start = index;
+                    index += 2;
+                    blockComment = true;
+                    if (index >= length) {
+                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
+                    }
+                } else {
+                    break;
+                }
+            } else if (isWhiteSpace(ch)) {
+                ++index;
+            } else if (isLineTerminator(ch)) {
+                ++index;
+                if (ch ===  '\r' && source[index] === '\n') {
+                    ++index;
+                }
+                ++lineNumber;
+                lineStart = index;
+            } else {
+                break;
+            }
+        }
+    }
+
+    function collectToken() {
+        var token = extra.advance(),
+            range,
+            value;
+
+        if (token.type !== Token.EOF) {
+            range = [token.range[0], token.range[1]];
+            value = sliceSource(token.range[0], token.range[1]);
+            extra.tokens.push({
+                type: TokenName[token.type],
+                value: value,
+                range: range
+            });
+        }
+
+        return token;
+    }
+
+    function collectRegex() {
+        var pos, regex, token;
+
+        skipComment();
+
+        pos = index;
+        regex = extra.scanRegExp();
+
+        // Pop the previous token, which is likely '/' or '/='
+        if (extra.tokens.length > 0) {
+            token = extra.tokens[extra.tokens.length - 1];
+            if (token.range[0] === pos && token.type === 'Punctuator') {
+                if (token.value === '/' || token.value === '/=') {
+                    extra.tokens.pop();
+                }
+            }
+        }
+
+        extra.tokens.push({
+            type: 'RegularExpression',
+            value: regex.literal,
+            range: [pos, index]
+        });
+
+        return regex;
+    }
+
+    function createLiteral(token) {
+        return {
+            type: Syntax.Literal,
+            value: token.value
+        };
+    }
+
+    function createRawLiteral(token) {
+        return {
+            type: Syntax.Literal,
+            value: token.value,
+            raw: sliceSource(token.range[0], token.range[1])
+        };
+    }
+
+    function wrapTrackingFunction(range, loc) {
+
+        return function (parseFunction) {
+
+            function isBinary(node) {
+                return node.type === Syntax.LogicalExpression ||
+                    node.type === Syntax.BinaryExpression;
+            }
+
+            function visit(node) {
+                if (isBinary(node.left)) {
+                    visit(node.left);
+                }
+                if (isBinary(node.right)) {
+                    visit(node.right);
+                }
+
+                if (range && typeof node.range === 'undefined') {
+                    node.range = [node.left.range[0], node.right.range[1]];
+                }
+                if (loc && typeof node.loc === 'undefined') {
+                    node.loc = {
+                        start: node.left.loc.start,
+                        end: node.right.loc.end
+                    };
+                }
+            }
+
+            return function () {
+                var node, rangeInfo, locInfo;
+
+                skipComment();
+                rangeInfo = [index, 0];
+                locInfo = {
+                    start: {
+                        line: lineNumber,
+                        column: index - lineStart
+                    }
+                };
+
+                node = parseFunction.apply(null, arguments);
+                if (typeof node !== 'undefined') {
+
+                    if (range) {
+                        rangeInfo[1] = index;
+                        node.range = rangeInfo;
+                    }
+
+                    if (loc) {
+                        locInfo.end = {
+                            line: lineNumber,
+                            column: index - lineStart
+                        };
+                        node.loc = locInfo;
+                    }
+
+                    if (isBinary(node)) {
+                        visit(node);
+                    }
+
+                    if (node.type === Syntax.MemberExpression) {
+                        if (typeof node.object.range !== 'undefined') {
+                            node.range[0] = node.object.range[0];
+                        }
+                        if (typeof node.object.loc !== 'undefined') {
+                            node.loc.start = node.object.loc.start;
+                        }
+                    }
+
+                    if (node.type === Syntax.CallExpression) {
+                        if (typeof node.callee.range !== 'undefined') {
+                            node.range[0] = node.callee.range[0];
+                        }
+                        if (typeof node.callee.loc !== 'undefined') {
+                            node.loc.start = node.callee.loc.start;
+                        }
+                    }
+                    return node;
+                }
+            };
+
+        };
+    }
+
+    function patch() {
+
+        var wrapTracking;
+
+        if (extra.comments) {
+            extra.skipComment = skipComment;
+            skipComment = scanComment;
+        }
+
+        if (extra.raw) {
+            extra.createLiteral = createLiteral;
+            createLiteral = createRawLiteral;
+        }
+
+        if (extra.range || extra.loc) {
+
+            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);
+
+            extra.parseAdditiveExpression = parseAdditiveExpression;
+            extra.parseAssignmentExpression = parseAssignmentExpression;
+            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;
+            extra.parseBitwiseORExpression = parseBitwiseORExpression;
+            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;
+            extra.parseBlock = parseBlock;
+            extra.parseFunctionSourceElements = parseFunctionSourceElements;
+            extra.parseCallMember = parseCallMember;
+            extra.parseCatchClause = parseCatchClause;
+            extra.parseComputedMember = parseComputedMember;
+            extra.parseConditionalExpression = parseConditionalExpression;
+            extra.parseConstLetDeclaration = parseConstLetDeclaration;
+            extra.parseEqualityExpression = parseEqualityExpression;
+            extra.parseExpression = parseExpression;
+            extra.parseForVariableDeclaration = parseForVariableDeclaration;
+            extra.parseFunctionDeclaration = parseFunctionDeclaration;
+            extra.parseFunctionExpression = parseFunctionExpression;
+            extra.parseLogicalANDExpression = parseLogicalANDExpression;
+            extra.parseLogicalORExpression = parseLogicalORExpression;
+            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;
+            extra.parseNewExpression = parseNewExpression;
+            extra.parseNonComputedMember = parseNonComputedMember;
+            extra.parseNonComputedProperty = parseNonComputedProperty;
+            extra.parseObjectProperty = parseObjectProperty;
+            extra.parseObjectPropertyKey = parseObjectPropertyKey;
+            extra.parsePostfixExpression = parsePostfixExpression;
+            extra.parsePrimaryExpression = parsePrimaryExpression;
+            extra.parseProgram = parseProgram;
+            extra.parsePropertyFunction = parsePropertyFunction;
+            extra.parseRelationalExpression = parseRelationalExpression;
+            extra.parseStatement = parseStatement;
+            extra.parseShiftExpression = parseShiftExpression;
+            extra.parseSwitchCase = parseSwitchCase;
+            extra.parseUnaryExpression = parseUnaryExpression;
+            extra.parseVariableDeclaration = parseVariableDeclaration;
+            extra.parseVariableIdentifier = parseVariableIdentifier;
+
+            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);
+            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
+            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);
+            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);
+            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);
+            parseBlock = wrapTracking(extra.parseBlock);
+            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
+            parseCallMember = wrapTracking(extra.parseCallMember);
+            parseCatchClause = wrapTracking(extra.parseCatchClause);
+            parseComputedMember = wrapTracking(extra.parseComputedMember);
+            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
+            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
+            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);
+            parseExpression = wrapTracking(extra.parseExpression);
+            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
+            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
+            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
+            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);
+            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);
+            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);
+            parseNewExpression = wrapTracking(extra.parseNewExpression);
+            parseNonComputedMember = wrapTracking(extra.parseNonComputedMember);
+            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
+            parseObjectProperty = wrapTracking(extra.parseObjectProperty);
+            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
+            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
+            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
+            parseProgram = wrapTracking(extra.parseProgram);
+            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
+            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);
+            parseStatement = wrapTracking(extra.parseStatement);
+            parseShiftExpression = wrapTracking(extra.parseShiftExpression);
+            parseSwitchCase = wrapTracking(extra.parseSwitchCase);
+            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
+            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
+            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
+        }
+
+        if (typeof extra.tokens !== 'undefined') {
+            extra.advance = advance;
+            extra.scanRegExp = scanRegExp;
+
+            advance = collectToken;
+            scanRegExp = collectRegex;
+        }
+    }
+
+    function unpatch() {
+        if (typeof extra.skipComment === 'function') {
+            skipComment = extra.skipComment;
+        }
+
+        if (extra.raw) {
+            createLiteral = extra.createLiteral;
+        }
+
+        if (extra.range || extra.loc) {
+            parseAdditiveExpression = extra.parseAdditiveExpression;
+            parseAssignmentExpression = extra.parseAssignmentExpression;
+            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;
+            parseBitwiseORExpression = extra.parseBitwiseORExpression;
+            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;
+            parseBlock = extra.parseBlock;
+            parseFunctionSourceElements = extra.parseFunctionSourceElements;
+            parseCallMember = extra.parseCallMember;
+            parseCatchClause = extra.parseCatchClause;
+            parseComputedMember = extra.parseComputedMember;
+            parseConditionalExpression = extra.parseConditionalExpression;
+            parseConstLetDeclaration = extra.parseConstLetDeclaration;
+            parseEqualityExpression = extra.parseEqualityExpression;
+            parseExpression = extra.parseExpression;
+            parseForVariableDeclaration = extra.parseForVariableDeclaration;
+            parseFunctionDeclaration = extra.parseFunctionDeclaration;
+            parseFunctionExpression = extra.parseFunctionExpression;
+            parseLogicalANDExpression = extra.parseLogicalANDExpression;
+            parseLogicalORExpression = extra.parseLogicalORExpression;
+            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;
+            parseNewExpression = extra.parseNewExpression;
+            parseNonComputedMember = extra.parseNonComputedMember;
+            parseNonComputedProperty = extra.parseNonComputedProperty;
+            parseObjectProperty = extra.parseObjectProperty;
+            parseObjectPropertyKey = extra.parseObjectPropertyKey;
+            parsePrimaryExpression = extra.parsePrimaryExpression;
+            parsePostfixExpression = extra.parsePostfixExpression;
+            parseProgram = extra.parseProgram;
+            parsePropertyFunction = extra.parsePropertyFunction;
+            parseRelationalExpression = extra.parseRelationalExpression;
+            parseStatement = extra.parseStatement;
+            parseShiftExpression = extra.parseShiftExpression;
+            parseSwitchCase = extra.parseSwitchCase;
+            parseUnaryExpression = extra.parseUnaryExpression;
+            parseVariableDeclaration = extra.parseVariableDeclaration;
+            parseVariableIdentifier = extra.parseVariableIdentifier;
+        }
+
+        if (typeof extra.scanRegExp === 'function') {
+            advance = extra.advance;
+            scanRegExp = extra.scanRegExp;
+        }
+    }
+
+    function stringToArray(str) {
+        var length = str.length,
+            result = [],
+            i;
+        for (i = 0; i < length; ++i) {
+            result[i] = str.charAt(i);
+        }
+        return result;
+    }
+
+    function parse(code, options) {
+        var program, toString;
+
+        toString = String;
+        if (typeof code !== 'string' && !(code instanceof String)) {
+            code = toString(code);
+        }
+
+        source = code;
+        index = 0;
+        lineNumber = (source.length > 0) ? 1 : 0;
+        lineStart = 0;
+        length = source.length;
+        buffer = null;
+        state = {
+            allowIn: true,
+            labelSet: {},
+            lastParenthesized: null,
+            inFunctionBody: false,
+            inIteration: false,
+            inSwitch: false
+        };
+
+        extra = {};
+        if (typeof options !== 'undefined') {
+            extra.range = (typeof options.range === 'boolean') && options.range;
+            extra.loc = (typeof options.loc === 'boolean') && options.loc;
+            extra.raw = (typeof options.raw === 'boolean') && options.raw;
+            if (typeof options.tokens === 'boolean' && options.tokens) {
+                extra.tokens = [];
+            }
+            if (typeof options.comment === 'boolean' && options.comment) {
+                extra.comments = [];
+            }
+            if (typeof options.tolerant === 'boolean' && options.tolerant) {
+                extra.errors = [];
+            }
+        }
+
+        if (length > 0) {
+            if (typeof source[0] === 'undefined') {
+                // Try first to convert to a string. This is good as fast path
+                // for old IE which understands string indexing for string
+                // literals only and not for string object.
+                if (code instanceof String) {
+                    source = code.valueOf();
+                }
+
+                // Force accessing the characters via an array.
+                if (typeof source[0] === 'undefined') {
+                    source = stringToArray(code);
+                }
+            }
+        }
+
+        patch();
+        try {
+            program = parseProgram();
+            if (typeof extra.comments !== 'undefined') {
+                program.comments = extra.comments;
+            }
+            if (typeof extra.tokens !== 'undefined') {
+                program.tokens = extra.tokens;
+            }
+            if (typeof extra.errors !== 'undefined') {
+                program.errors = extra.errors;
+            }
+        } catch (e) {
+            throw e;
+        } finally {
+            unpatch();
+            extra = {};
+        }
+
+        return program;
+    }
+
+    // Sync with package.json.
+    exports.version = '1.0.0-dev';
+
+    exports.parse = parse;
+
+    // Deep copy.
+    exports.Syntax = (function () {
+        var name, types = {};
+
+        if (typeof Object.create === 'function') {
+            types = Object.create(null);
+        }
+
+        for (name in Syntax) {
+            if (Syntax.hasOwnProperty(name)) {
+                types[name] = Syntax[name];
+            }
+        }
+
+        if (typeof Object.freeze === 'function') {
+            Object.freeze(types);
+        }
+
+        return types;
+    }());
+
+}(typeof exports === 'undefined' ? (esprima = {}) : exports));
+/* vim: set sw=4 ts=4 et tw=80 : */
+
+});define('uglifyjs/consolidator', ["require", "exports", "module", "./parse-js", "./process"], function(require, exports, module) {
+/**
+ * @preserve Copyright 2012 Robert Gust-Bardon <http://robert.gust-bardon.org/>.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *     * Redistributions of source code must retain the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/**
+ * @fileoverview Enhances <a href="https://github.com/mishoo/UglifyJS/"
+ * >UglifyJS</a> with consolidation of null, Boolean, and String values.
+ * <p>Also known as aliasing, this feature has been deprecated in <a href=
+ * "http://closure-compiler.googlecode.com/">the Closure Compiler</a> since its
+ * initial release, where it is unavailable from the <abbr title=
+ * "command line interface">CLI</a>. The Closure Compiler allows one to log and
+ * influence this process. In contrast, this implementation does not introduce
+ * any variable declarations in global code and derives String values from
+ * identifier names used as property accessors.</p>
+ * <p>Consolidating literals may worsen the data compression ratio when an <a
+ * href="http://tools.ietf.org/html/rfc2616#section-3.5">encoding
+ * transformation</a> is applied. For instance, <a href=
+ * "http://code.jquery.com/jquery-1.7.1.js">jQuery 1.7.1</a> takes 248235 bytes.
+ * Building it with <a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">
+ * UglifyJS v1.2.5</a> results in 93647 bytes (37.73% of the original) which are
+ * then compressed to 33154 bytes (13.36% of the original) using <a href=
+ * "http://linux.die.net/man/1/gzip">gzip(1)</a>. Building it with the same
+ * version of UglifyJS 1.2.5 patched with the implementation of consolidation
+ * results in 80784 bytes (a decrease of 12863 bytes, i.e. 13.74%, in comparison
+ * to the aforementioned 93647 bytes) which are then compressed to 34013 bytes
+ * (an increase of 859 bytes, i.e. 2.59%, in comparison to the aforementioned
+ * 33154 bytes).</p>
+ * <p>Written in <a href="http://es5.github.com/#x4.2.2">the strict variant</a>
+ * of <a href="http://es5.github.com/">ECMA-262 5.1 Edition</a>. Encoded in <a
+ * href="http://tools.ietf.org/html/rfc3629">UTF-8</a>. Follows <a href=
+ * "http://google-styleguide.googlecode.com/svn-history/r76/trunk/javascriptguide.xml"
+ * >Revision 2.28 of the Google JavaScript Style Guide</a> (except for the
+ * discouraged use of the {@code function} tag and the {@code namespace} tag).
+ * 100% typed for the <a href=
+ * "http://closure-compiler.googlecode.com/files/compiler-20120123.tar.gz"
+ * >Closure Compiler Version 1741</a>.</p>
+ * <p>Should you find this software useful, please consider <a href=
+ * "https://paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=JZLW72X8FD4WG"
+ * >a donation</a>.</p>
+ * @author follow.me@RGustBardon (Robert Gust-Bardon)
+ * @supported Tested with:
+ *     <ul>
+ *     <li><a href="http://nodejs.org/dist/v0.6.10/">Node v0.6.10</a>,</li>
+ *     <li><a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">UglifyJS
+ *       v1.2.5</a>.</li>
+ *     </ul>
+ */
+
+/*global console:false, exports:true, module:false, require:false */
+/*jshint sub:true */
+/**
+ * Consolidates null, Boolean, and String values found inside an <abbr title=
+ * "abstract syntax tree">AST</abbr>.
+ * @param {!TSyntacticCodeUnit} oAbstractSyntaxTree An array-like object
+ *     representing an <abbr title="abstract syntax tree">AST</abbr>.
+ * @return {!TSyntacticCodeUnit} An array-like object representing an <abbr
+ *     title="abstract syntax tree">AST</abbr> with its null, Boolean, and
+ *     String values consolidated.
+ */
+// TODO(user) Consolidation of mathematical values found in numeric literals.
+// TODO(user) Unconsolidation.
+// TODO(user) Consolidation of ECMA-262 6th Edition programs.
+// TODO(user) Rewrite in ECMA-262 6th Edition.
+exports['ast_consolidate'] = function(oAbstractSyntaxTree) {
+  'use strict';
+  /*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true,
+        latedef:true, newcap:true, noarge:true, noempty:true, nonew:true,
+        onevar:true, plusplus:true, regexp:true, undef:true, strict:true,
+        sub:false, trailing:true */
+
+  var _,
+      /**
+       * A record consisting of data about one or more source elements.
+       * @constructor
+       * @nosideeffects
+       */
+      TSourceElementsData = function() {
+        /**
+         * The category of the elements.
+         * @type {number}
+         * @see ESourceElementCategories
+         */
+        this.nCategory = ESourceElementCategories.N_OTHER;
+        /**
+         * The number of occurrences (within the elements) of each primitive
+         * value that could be consolidated.
+         * @type {!Array.<!Object.<string, number>>}
+         */
+        this.aCount = [];
+        this.aCount[EPrimaryExpressionCategories.N_IDENTIFIER_NAMES] = {};
+        this.aCount[EPrimaryExpressionCategories.N_STRING_LITERALS] = {};
+        this.aCount[EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS] =
+            {};
+        /**
+         * Identifier names found within the elements.
+         * @type {!Array.<string>}
+         */
+        this.aIdentifiers = [];
+        /**
+         * Prefixed representation Strings of each primitive value that could be
+         * consolidated within the elements.
+         * @type {!Array.<string>}
+         */
+        this.aPrimitiveValues = [];
+      },
+      /**
+       * A record consisting of data about a primitive value that could be
+       * consolidated.
+       * @constructor
+       * @nosideeffects
+       */
+      TPrimitiveValue = function() {
+        /**
+         * The difference in the number of terminal symbols between the original
+         * source text and the one with the primitive value consolidated. If the
+         * difference is positive, the primitive value is considered worthwhile.
+         * @type {number}
+         */
+        this.nSaving = 0;
+        /**
+         * An identifier name of the variable that will be declared and assigned
+         * the primitive value if the primitive value is consolidated.
+         * @type {string}
+         */
+        this.sName = '';
+      },
+      /**
+       * A record consisting of data on what to consolidate within the range of
+       * source elements that is currently being considered.
+       * @constructor
+       * @nosideeffects
+       */
+      TSolution = function() {
+        /**
+         * An object whose keys are prefixed representation Strings of each
+         * primitive value that could be consolidated within the elements and
+         * whose values are corresponding data about those primitive values.
+         * @type {!Object.<string, {nSaving: number, sName: string}>}
+         * @see TPrimitiveValue
+         */
+        this.oPrimitiveValues = {};
+        /**
+         * The difference in the number of terminal symbols between the original
+         * source text and the one with all the worthwhile primitive values
+         * consolidated.
+         * @type {number}
+         * @see TPrimitiveValue#nSaving
+         */
+        this.nSavings = 0;
+      },
+      /**
+       * The processor of <abbr title="abstract syntax tree">AST</abbr>s found
+       * in UglifyJS.
+       * @namespace
+       * @type {!TProcessor}
+       */
+      oProcessor = (/** @type {!TProcessor} */ require('./process')),
+      /**
+       * A record consisting of a number of constants that represent the
+       * difference in the number of terminal symbols between a source text with
+       * a modified syntactic code unit and the original one.
+       * @namespace
+       * @type {!Object.<string, number>}
+       */
+      oWeights = {
+        /**
+         * The difference in the number of punctuators required by the bracket
+         * notation and the dot notation.
+         * <p><code>'[]'.length - '.'.length</code></p>
+         * @const
+         * @type {number}
+         */
+        N_PROPERTY_ACCESSOR: 1,
+        /**
+         * The number of punctuators required by a variable declaration with an
+         * initialiser.
+         * <p><code>':'.length + ';'.length</code></p>
+         * @const
+         * @type {number}
+         */
+        N_VARIABLE_DECLARATION: 2,
+        /**
+         * The number of terminal symbols required to introduce a variable
+         * statement (excluding its variable declaration list).
+         * <p><code>'var '.length</code></p>
+         * @const
+         * @type {number}
+         */
+        N_VARIABLE_STATEMENT_AFFIXATION: 4,
+        /**
+         * The number of terminal symbols needed to enclose source elements
+         * within a function call with no argument values to a function with an
+         * empty parameter list.
+         * <p><code>'(function(){}());'.length</code></p>
+         * @const
+         * @type {number}
+         */
+        N_CLOSURE: 17
+      },
+      /**
+       * Categories of primary expressions from which primitive values that
+       * could be consolidated are derivable.
+       * @namespace
+       * @enum {number}
+       */
+      EPrimaryExpressionCategories = {
+        /**
+         * Identifier names used as property accessors.
+         * @type {number}
+         */
+        N_IDENTIFIER_NAMES: 0,
+        /**
+         * String literals.
+         * @type {number}
+         */
+        N_STRING_LITERALS: 1,
+        /**
+         * Null and Boolean literals.
+         * @type {number}
+         */
+        N_NULL_AND_BOOLEAN_LITERALS: 2
+      },
+      /**
+       * Prefixes of primitive values that could be consolidated.
+       * The String values of the prefixes must have same number of characters.
+       * The prefixes must not be used in any properties defined in any version
+       * of <a href=
+       * "http://www.ecma-international.org/publications/standards/Ecma-262.htm"
+       * >ECMA-262</a>.
+       * @namespace
+       * @enum {string}
+       */
+      EValuePrefixes = {
+        /**
+         * Identifies String values.
+         * @type {string}
+         */
+        S_STRING: '#S',
+        /**
+         * Identifies null and Boolean values.
+         * @type {string}
+         */
+        S_SYMBOLIC: '#O'
+      },
+      /**
+       * Categories of source elements in terms of their appropriateness of
+       * having their primitive values consolidated.
+       * @namespace
+       * @enum {number}
+       */
+      ESourceElementCategories = {
+        /**
+         * Identifies a source element that includes the <a href=
+         * "http://es5.github.com/#x12.10">{@code with}</a> statement.
+         * @type {number}
+         */
+        N_WITH: 0,
+        /**
+         * Identifies a source element that includes the <a href=
+         * "http://es5.github.com/#x15.1.2.1">{@code eval}</a> identifier name.
+         * @type {number}
+         */
+        N_EVAL: 1,
+        /**
+         * Identifies a source element that must be excluded from the process
+         * unless its whole scope is examined.
+         * @type {number}
+         */
+        N_EXCLUDABLE: 2,
+        /**
+         * Identifies source elements not posing any problems.
+         * @type {number}
+         */
+        N_OTHER: 3
+      },
+      /**
+       * The list of literals (other than the String ones) whose primitive
+       * values can be consolidated.
+       * @const
+       * @type {!Array.<string>}
+       */
+      A_OTHER_SUBSTITUTABLE_LITERALS = [
+        'null',   // The null literal.
+        'false',  // The Boolean literal {@code false}.
+        'true'    // The Boolean literal {@code true}.
+      ];
+
+  (/**
+    * Consolidates all worthwhile primitive values in a syntactic code unit.
+    * @param {!TSyntacticCodeUnit} oSyntacticCodeUnit An array-like object
+    *     representing the branch of the abstract syntax tree representing the
+    *     syntactic code unit along with its scope.
+    * @see TPrimitiveValue#nSaving
+    */
+   function fExamineSyntacticCodeUnit(oSyntacticCodeUnit) {
+     var _,
+         /**
+          * Indicates whether the syntactic code unit represents global code.
+          * @type {boolean}
+          */
+         bIsGlobal = 'toplevel' === oSyntacticCodeUnit[0],
+         /**
+          * Indicates whether the whole scope is being examined.
+          * @type {boolean}
+          */
+         bIsWhollyExaminable = !bIsGlobal,
+         /**
+          * An array-like object representing source elements that constitute a
+          * syntactic code unit.
+          * @type {!TSyntacticCodeUnit}
+          */
+         oSourceElements,
+         /**
+          * A record consisting of data about the source element that is
+          * currently being examined.
+          * @type {!TSourceElementsData}
+          */
+         oSourceElementData,
+         /**
+          * The scope of the syntactic code unit.
+          * @type {!TScope}
+          */
+         oScope,
+         /**
+          * An instance of an object that allows the traversal of an <abbr
+          * title="abstract syntax tree">AST</abbr>.
+          * @type {!TWalker}
+          */
+         oWalker,
+         /**
+          * An object encompassing collections of functions used during the
+          * traversal of an <abbr title="abstract syntax tree">AST</abbr>.
+          * @namespace
+          * @type {!Object.<string, !Object.<string, function(...[*])>>}
+          */
+         oWalkers = {
+           /**
+            * A collection of functions used during the surveyance of source
+            * elements.
+            * @namespace
+            * @type {!Object.<string, function(...[*])>}
+            */
+           oSurveySourceElement: {
+             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
+             /**
+              * Classifies the source element as excludable if it does not
+              * contain a {@code with} statement or the {@code eval} identifier
+              * name. Adds the identifier of the function and its formal
+              * parameters to the list of identifier names found.
+              * @param {string} sIdentifier The identifier of the function.
+              * @param {!Array.<string>} aFormalParameterList Formal parameters.
+              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
+              */
+             'defun': function(
+                 sIdentifier,
+                 aFormalParameterList,
+                 oFunctionBody) {
+               fClassifyAsExcludable();
+               fAddIdentifier(sIdentifier);
+               aFormalParameterList.forEach(fAddIdentifier);
+             },
+             /**
+              * Increments the count of the number of occurrences of the String
+              * value that is equivalent to the sequence of terminal symbols
+              * that constitute the encountered identifier name.
+              * @param {!TSyntacticCodeUnit} oExpression The nonterminal
+              *     MemberExpression.
+              * @param {string} sIdentifierName The identifier name used as the
+              *     property accessor.
+              * @return {!Array} The encountered branch of an <abbr title=
+              *     "abstract syntax tree">AST</abbr> with its nonterminal
+              *     MemberExpression traversed.
+              */
+             'dot': function(oExpression, sIdentifierName) {
+               fCountPrimaryExpression(
+                   EPrimaryExpressionCategories.N_IDENTIFIER_NAMES,
+                   EValuePrefixes.S_STRING + sIdentifierName);
+               return ['dot', oWalker.walk(oExpression), sIdentifierName];
+             },
+             /**
+              * Adds the optional identifier of the function and its formal
+              * parameters to the list of identifier names found.
+              * @param {?string} sIdentifier The optional identifier of the
+              *     function.
+              * @param {!Array.<string>} aFormalParameterList Formal parameters.
+              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
+              */
+             'function': function(
+                 sIdentifier,
+                 aFormalParameterList,
+                 oFunctionBody) {
+               if ('string' === typeof sIdentifier) {
+                 fAddIdentifier(sIdentifier);
+               }
+               aFormalParameterList.forEach(fAddIdentifier);
+             },
+             /**
+              * Either increments the count of the number of occurrences of the
+              * encountered null or Boolean value or classifies a source element
+              * as containing the {@code eval} identifier name.
+              * @param {string} sIdentifier The identifier encountered.
+              */
+             'name': function(sIdentifier) {
+               if (-1 !== A_OTHER_SUBSTITUTABLE_LITERALS.indexOf(sIdentifier)) {
+                 fCountPrimaryExpression(
+                     EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS,
+                     EValuePrefixes.S_SYMBOLIC + sIdentifier);
+               } else {
+                 if ('eval' === sIdentifier) {
+                   oSourceElementData.nCategory =
+                       ESourceElementCategories.N_EVAL;
+                 }
+                 fAddIdentifier(sIdentifier);
+               }
+             },
+             /**
+              * Classifies the source element as excludable if it does not
+              * contain a {@code with} statement or the {@code eval} identifier
+              * name.
+              * @param {TSyntacticCodeUnit} oExpression The expression whose
+              *     value is to be returned.
+              */
+             'return': function(oExpression) {
+               fClassifyAsExcludable();
+             },
+             /**
+              * Increments the count of the number of occurrences of the
+              * encountered String value.
+              * @param {string} sStringValue The String value of the string
+              *     literal encountered.
+              */
+             'string': function(sStringValue) {
+               if (sStringValue.length > 0) {
+                 fCountPrimaryExpression(
+                     EPrimaryExpressionCategories.N_STRING_LITERALS,
+                     EValuePrefixes.S_STRING + sStringValue);
+               }
+             },
+             /**
+              * Adds the identifier reserved for an exception to the list of
+              * identifier names found.
+              * @param {!TSyntacticCodeUnit} oTry A block of code in which an
+              *     exception can occur.
+              * @param {Array} aCatch The identifier reserved for an exception
+              *     and a block of code to handle the exception.
+              * @param {TSyntacticCodeUnit} oFinally An optional block of code
+              *     to be evaluated regardless of whether an exception occurs.
+              */
+             'try': function(oTry, aCatch, oFinally) {
+               if (Array.isArray(aCatch)) {
+                 fAddIdentifier(aCatch[0]);
+               }
+             },
+             /**
+              * Classifies the source element as excludable if it does not
+              * contain a {@code with} statement or the {@code eval} identifier
+              * name. Adds the identifier of each declared variable to the list
+              * of identifier names found.
+              * @param {!Array.<!Array>} aVariableDeclarationList Variable
+              *     declarations.
+              */
+             'var': function(aVariableDeclarationList) {
+               fClassifyAsExcludable();
+               aVariableDeclarationList.forEach(fAddVariable);
+             },
+             /**
+              * Classifies a source element as containing the {@code with}
+              * statement.
+              * @param {!TSyntacticCodeUnit} oExpression An expression whose
+              *     value is to be converted to a value of type Object and
+              *     become the binding object of a new object environment
+              *     record of a new lexical environment in which the statement
+              *     is to be executed.
+              * @param {!TSyntacticCodeUnit} oStatement The statement to be
+              *     executed in the augmented lexical environment.
+              * @return {!Array} An empty array to stop the traversal.
+              */
+             'with': function(oExpression, oStatement) {
+               oSourceElementData.nCategory = ESourceElementCategories.N_WITH;
+               return [];
+             }
+             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
+           },
+           /**
+            * A collection of functions used while looking for nested functions.
+            * @namespace
+            * @type {!Object.<string, function(...[*])>}
+            */
+           oExamineFunctions: {
+             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
+             /**
+              * Orders an examination of a nested function declaration.
+              * @this {!TSyntacticCodeUnit} An array-like object representing
+              *     the branch of an <abbr title="abstract syntax tree"
+              *     >AST</abbr> representing the syntactic code unit along with
+              *     its scope.
+              * @return {!Array} An empty array to stop the traversal.
+              */
+             'defun': function() {
+               fExamineSyntacticCodeUnit(this);
+               return [];
+             },
+             /**
+              * Orders an examination of a nested function expression.
+              * @this {!TSyntacticCodeUnit} An array-like object representing
+              *     the branch of an <abbr title="abstract syntax tree"
+              *     >AST</abbr> representing the syntactic code unit along with
+              *     its scope.
+              * @return {!Array} An empty array to stop the traversal.
+              */
+             'function': function() {
+               fExamineSyntacticCodeUnit(this);
+               return [];
+             }
+             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
+           }
+         },
+         /**
+          * Records containing data about source elements.
+          * @type {Array.<TSourceElementsData>}
+          */
+         aSourceElementsData = [],
+         /**
+          * The index (in the source text order) of the source element
+          * immediately following a <a href="http://es5.github.com/#x14.1"
+          * >Directive Prologue</a>.
+          * @type {number}
+          */
+         nAfterDirectivePrologue = 0,
+         /**
+          * The index (in the source text order) of the source element that is
+          * currently being considered.
+          * @type {number}
+          */
+         nPosition,
+         /**
+          * The index (in the source text order) of the source element that is
+          * the last element of the range of source elements that is currently
+          * being considered.
+          * @type {(undefined|number)}
+          */
+         nTo,
+         /**
+          * Initiates the traversal of a source element.
+          * @param {!TWalker} oWalker An instance of an object that allows the
+          *     traversal of an abstract syntax tree.
+          * @param {!TSyntacticCodeUnit} oSourceElement A source element from
+          *     which the traversal should commence.
+          * @return {function(): !TSyntacticCodeUnit} A function that is able to
+          *     initiate the traversal from a given source element.
+          */
+         cContext = function(oWalker, oSourceElement) {
+           /**
+            * @return {!TSyntacticCodeUnit} A function that is able to
+            *     initiate the traversal from a given source element.
+            */
+           var fLambda = function() {
+             return oWalker.walk(oSourceElement);
+           };
+
+           return fLambda;
+         },
+         /**
+          * Classifies the source element as excludable if it does not
+          * contain a {@code with} statement or the {@code eval} identifier
+          * name.
+          */
+         fClassifyAsExcludable = function() {
+           if (oSourceElementData.nCategory ===
+               ESourceElementCategories.N_OTHER) {
+             oSourceElementData.nCategory =
+                 ESourceElementCategories.N_EXCLUDABLE;
+           }
+         },
+         /**
+          * Adds an identifier to the list of identifier names found.
+          * @param {string} sIdentifier The identifier to be added.
+          */
+         fAddIdentifier = function(sIdentifier) {
+           if (-1 === oSourceElementData.aIdentifiers.indexOf(sIdentifier)) {
+             oSourceElementData.aIdentifiers.push(sIdentifier);
+           }
+         },
+         /**
+          * Adds the identifier of a variable to the list of identifier names
+          * found.
+          * @param {!Array} aVariableDeclaration A variable declaration.
+          */
+         fAddVariable = function(aVariableDeclaration) {
+           fAddIdentifier(/** @type {string} */ aVariableDeclaration[0]);
+         },
+         /**
+          * Increments the count of the number of occurrences of the prefixed
+          * String representation attributed to the primary expression.
+          * @param {number} nCategory The category of the primary expression.
+          * @param {string} sName The prefixed String representation attributed
+          *     to the primary expression.
+          */
+         fCountPrimaryExpression = function(nCategory, sName) {
+           if (!oSourceElementData.aCount[nCategory].hasOwnProperty(sName)) {
+             oSourceElementData.aCount[nCategory][sName] = 0;
+             if (-1 === oSourceElementData.aPrimitiveValues.indexOf(sName)) {
+               oSourceElementData.aPrimitiveValues.push(sName);
+             }
+           }
+           oSourceElementData.aCount[nCategory][sName] += 1;
+         },
+         /**
+          * Consolidates all worthwhile primitive values in a range of source
+          *     elements.
+          * @param {number} nFrom The index (in the source text order) of the
+          *     source element that is the first element of the range.
+          * @param {number} nTo The index (in the source text order) of the
+          *     source element that is the last element of the range.
+          * @param {boolean} bEnclose Indicates whether the range should be
+          *     enclosed within a function call with no argument values to a
+          *     function with an empty parameter list if any primitive values
+          *     are consolidated.
+          * @see TPrimitiveValue#nSaving
+          */
+         fExamineSourceElements = function(nFrom, nTo, bEnclose) {
+           var _,
+               /**
+                * The index of the last mangled name.
+                * @type {number}
+                */
+               nIndex = oScope.cname,
+               /**
+                * The index of the source element that is currently being
+                * considered.
+                * @type {number}
+                */
+               nPosition,
+               /**
+                * A collection of functions used during the consolidation of
+                * primitive values and identifier names used as property
+                * accessors.
+                * @namespace
+                * @type {!Object.<string, function(...[*])>}
+                */
+               oWalkersTransformers = {
+                 /**
+                  * If the String value that is equivalent to the sequence of
+                  * terminal symbols that constitute the encountered identifier
+                  * name is worthwhile, a syntactic conversion from the dot
+                  * notation to the bracket notation ensues with that sequence
+                  * being substituted by an identifier name to which the value
+                  * is assigned.
+                  * Applies to property accessors that use the dot notation.
+                  * @param {!TSyntacticCodeUnit} oExpression The nonterminal
+                  *     MemberExpression.
+                  * @param {string} sIdentifierName The identifier name used as
+                  *     the property accessor.
+                  * @return {!Array} A syntactic code unit that is equivalent to
+                  *     the one encountered.
+                  * @see TPrimitiveValue#nSaving
+                  */
+                 'dot': function(oExpression, sIdentifierName) {
+                   /**
+                    * The prefixed String value that is equivalent to the
+                    * sequence of terminal symbols that constitute the
+                    * encountered identifier name.
+                    * @type {string}
+                    */
+                   var sPrefixed = EValuePrefixes.S_STRING + sIdentifierName;
+
+                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
+                       sPrefixed) &&
+                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
+                       ['sub',
+                        oWalker.walk(oExpression),
+                        ['name',
+                         oSolutionBest.oPrimitiveValues[sPrefixed].sName]] :
+                       ['dot', oWalker.walk(oExpression), sIdentifierName];
+                 },
+                 /**
+                  * If the encountered identifier is a null or Boolean literal
+                  * and its value is worthwhile, the identifier is substituted
+                  * by an identifier name to which that value is assigned.
+                  * Applies to identifier names.
+                  * @param {string} sIdentifier The identifier encountered.
+                  * @return {!Array} A syntactic code unit that is equivalent to
+                  *     the one encountered.
+                  * @see TPrimitiveValue#nSaving
+                  */
+                 'name': function(sIdentifier) {
+                   /**
+                    * The prefixed representation String of the identifier.
+                    * @type {string}
+                    */
+                   var sPrefixed = EValuePrefixes.S_SYMBOLIC + sIdentifier;
+
+                   return [
+                     'name',
+                     oSolutionBest.oPrimitiveValues.hasOwnProperty(sPrefixed) &&
+                     oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
+                     oSolutionBest.oPrimitiveValues[sPrefixed].sName :
+                     sIdentifier
+                   ];
+                 },
+                 /**
+                  * If the encountered String value is worthwhile, it is
+                  * substituted by an identifier name to which that value is
+                  * assigned.
+                  * Applies to String values.
+                  * @param {string} sStringValue The String value of the string
+                  *     literal encountered.
+                  * @return {!Array} A syntactic code unit that is equivalent to
+                  *     the one encountered.
+                  * @see TPrimitiveValue#nSaving
+                  */
+                 'string': function(sStringValue) {
+                   /**
+                    * The prefixed representation String of the primitive value
+                    * of the literal.
+                    * @type {string}
+                    */
+                   var sPrefixed =
+                       EValuePrefixes.S_STRING + sStringValue;
+
+                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
+                       sPrefixed) &&
+                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
+                       ['name',
+                        oSolutionBest.oPrimitiveValues[sPrefixed].sName] :
+                       ['string', sStringValue];
+                 }
+               },
+               /**
+                * Such data on what to consolidate within the range of source
+                * elements that is currently being considered that lead to the
+                * greatest known reduction of the number of the terminal symbols
+                * in comparison to the original source text.
+                * @type {!TSolution}
+                */
+               oSolutionBest = new TSolution(),
+               /**
+                * Data representing an ongoing attempt to find a better
+                * reduction of the number of the terminal symbols in comparison
+                * to the original source text than the best one that is
+                * currently known.
+                * @type {!TSolution}
+                * @see oSolutionBest
+                */
+               oSolutionCandidate = new TSolution(),
+               /**
+                * A record consisting of data about the range of source elements
+                * that is currently being examined.
+                * @type {!TSourceElementsData}
+                */
+               oSourceElementsData = new TSourceElementsData(),
+               /**
+                * Variable declarations for each primitive value that is to be
+                * consolidated within the elements.
+                * @type {!Array.<!Array>}
+                */
+               aVariableDeclarations = [],
+               /**
+                * Augments a list with a prefixed representation String.
+                * @param {!Array.<string>} aList A list that is to be augmented.
+                * @return {function(string)} A function that augments a list
+                *     with a prefixed representation String.
+                */
+               cAugmentList = function(aList) {
+                 /**
+                  * @param {string} sPrefixed Prefixed representation String of
+                  *     a primitive value that could be consolidated within the
+                  *     elements.
+                  */
+                 var fLambda = function(sPrefixed) {
+                   if (-1 === aList.indexOf(sPrefixed)) {
+                     aList.push(sPrefixed);
+                   }
+                 };
+
+                 return fLambda;
+               },
+               /**
+                * Adds the number of occurrences of a primitive value of a given
+                * category that could be consolidated in the source element with
+                * a given index to the count of occurrences of that primitive
+                * value within the range of source elements that is currently
+                * being considered.
+                * @param {number} nPosition The index (in the source text order)
+                *     of a source element.
+                * @param {number} nCategory The category of the primary
+                *     expression from which the primitive value is derived.
+                * @return {function(string)} A function that performs the
+                *     addition.
+                * @see cAddOccurrencesInCategory
+                */
+               cAddOccurrences = function(nPosition, nCategory) {
+                 /**
+                  * @param {string} sPrefixed The prefixed representation String
+                  *     of a primitive value.
+                  */
+                 var fLambda = function(sPrefixed) {
+                   if (!oSourceElementsData.aCount[nCategory].hasOwnProperty(
+                           sPrefixed)) {
+                     oSourceElementsData.aCount[nCategory][sPrefixed] = 0;
+                   }
+                   oSourceElementsData.aCount[nCategory][sPrefixed] +=
+                       aSourceElementsData[nPosition].aCount[nCategory][
+                           sPrefixed];
+                 };
+
+                 return fLambda;
+               },
+               /**
+                * Adds the number of occurrences of each primitive value of a
+                * given category that could be consolidated in the source
+                * element with a given index to the count of occurrences of that
+                * primitive values within the range of source elements that is
+                * currently being considered.
+                * @param {number} nPosition The index (in the source text order)
+                *     of a source element.
+                * @return {function(number)} A function that performs the
+                *     addition.
+                * @see fAddOccurrences
+                */
+               cAddOccurrencesInCategory = function(nPosition) {
+                 /**
+                  * @param {number} nCategory The category of the primary
+                  *     expression from which the primitive value is derived.
+                  */
+                 var fLambda = function(nCategory) {
+                   Object.keys(
+                       aSourceElementsData[nPosition].aCount[nCategory]
+                   ).forEach(cAddOccurrences(nPosition, nCategory));
+                 };
+
+                 return fLambda;
+               },
+               /**
+                * Adds the number of occurrences of each primitive value that
+                * could be consolidated in the source element with a given index
+                * to the count of occurrences of that primitive values within
+                * the range of source elements that is currently being
+                * considered.
+                * @param {number} nPosition The index (in the source text order)
+                *     of a source element.
+                */
+               fAddOccurrences = function(nPosition) {
+                 Object.keys(aSourceElementsData[nPosition].aCount).forEach(
+                     cAddOccurrencesInCategory(nPosition));
+               },
+               /**
+                * Creates a variable declaration for a primitive value if that
+                * primitive value is to be consolidated within the elements.
+                * @param {string} sPrefixed Prefixed representation String of a
+                *     primitive value that could be consolidated within the
+                *     elements.
+                * @see aVariableDeclarations
+                */
+               cAugmentVariableDeclarations = function(sPrefixed) {
+                 if (oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0) {
+                   aVariableDeclarations.push([
+                     oSolutionBest.oPrimitiveValues[sPrefixed].sName,
+                     [0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC) ?
+                      'name' : 'string',
+                      sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length)]
+                   ]);
+                 }
+               },
+               /**
+                * Sorts primitive values with regard to the difference in the
+                * number of terminal symbols between the original source text
+                * and the one with those primitive values consolidated.
+                * @param {string} sPrefixed0 The prefixed representation String
+                *     of the first of the two primitive values that are being
+                *     compared.
+                * @param {string} sPrefixed1 The prefixed representation String
+                *     of the second of the two primitive values that are being
+                *     compared.
+                * @return {number}
+                *     <dl>
+                *         <dt>-1</dt>
+                *         <dd>if the first primitive value must be placed before
+                *              the other one,</dd>
+                *         <dt>0</dt>
+                *         <dd>if the first primitive value may be placed before
+                *              the other one,</dd>
+                *         <dt>1</dt>
+                *         <dd>if the first primitive value must not be placed
+                *              before the other one.</dd>
+                *     </dl>
+                * @see TSolution.oPrimitiveValues
+                */
+               cSortPrimitiveValues = function(sPrefixed0, sPrefixed1) {
+                 /**
+                  * The difference between:
+                  * <ol>
+                  * <li>the difference in the number of terminal symbols
+                  *     between the original source text and the one with the
+                  *     first primitive value consolidated, and</li>
+                  * <li>the difference in the number of terminal symbols
+                  *     between the original source text and the one with the
+                  *     second primitive value consolidated.</li>
+                  * </ol>
+                  * @type {number}
+                  */
+                 var nDifference =
+                     oSolutionCandidate.oPrimitiveValues[sPrefixed0].nSaving -
+                     oSolutionCandidate.oPrimitiveValues[sPrefixed1].nSaving;
+
+                 return nDifference > 0 ? -1 : nDifference < 0 ? 1 : 0;
+               },
+               /**
+                * Assigns an identifier name to a primitive value and calculates
+                * whether instances of that primitive value are worth
+                * consolidating.
+                * @param {string} sPrefixed The prefixed representation String
+                *     of a primitive value that is being evaluated.
+                */
+               fEvaluatePrimitiveValue = function(sPrefixed) {
+                 var _,
+                     /**
+                      * The index of the last mangled name.
+                      * @type {number}
+                      */
+                     nIndex,
+                     /**
+                      * The representation String of the primitive value that is
+                      * being evaluated.
+                      * @type {string}
+                      */
+                     sName =
+                         sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length),
+                     /**
+                      * The number of source characters taken up by the
+                      * representation String of the primitive value that is
+                      * being evaluated.
+                      * @type {number}
+                      */
+                     nLengthOriginal = sName.length,
+                     /**
+                      * The number of source characters taken up by the
+                      * identifier name that could substitute the primitive
+                      * value that is being evaluated.
+                      * substituted.
+                      * @type {number}
+                      */
+                     nLengthSubstitution,
+                     /**
+                      * The number of source characters taken up by by the
+                      * representation String of the primitive value that is
+                      * being evaluated when it is represented by a string
+                      * literal.
+                      * @type {number}
+                      */
+                     nLengthString = oProcessor.make_string(sName).length;
+
+                 oSolutionCandidate.oPrimitiveValues[sPrefixed] =
+                     new TPrimitiveValue();
+                 do {  // Find an identifier unused in this or any nested scope.
+                   nIndex = oScope.cname;
+                   oSolutionCandidate.oPrimitiveValues[sPrefixed].sName =
+                       oScope.next_mangled();
+                 } while (-1 !== oSourceElementsData.aIdentifiers.indexOf(
+                     oSolutionCandidate.oPrimitiveValues[sPrefixed].sName));
+                 nLengthSubstitution = oSolutionCandidate.oPrimitiveValues[
+                     sPrefixed].sName.length;
+                 if (0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC)) {
+                   // foo:null, or foo:null;
+                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
+                       nLengthSubstitution + nLengthOriginal +
+                       oWeights.N_VARIABLE_DECLARATION;
+                   // null vs foo
+                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
+                       oSourceElementsData.aCount[
+                           EPrimaryExpressionCategories.
+                               N_NULL_AND_BOOLEAN_LITERALS][sPrefixed] *
+                       (nLengthOriginal - nLengthSubstitution);
+                 } else {
+                   // foo:'fromCharCode';
+                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
+                       nLengthSubstitution + nLengthString +
+                       oWeights.N_VARIABLE_DECLARATION;
+                   // .fromCharCode vs [foo]
+                   if (oSourceElementsData.aCount[
+                           EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
+                       ].hasOwnProperty(sPrefixed)) {
+                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
+                         oSourceElementsData.aCount[
+                             EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
+                         ][sPrefixed] *
+                         (nLengthOriginal - nLengthSubstitution -
+                          oWeights.N_PROPERTY_ACCESSOR);
+                   }
+                   // 'fromCharCode' vs foo
+                   if (oSourceElementsData.aCount[
+                           EPrimaryExpressionCategories.N_STRING_LITERALS
+                       ].hasOwnProperty(sPrefixed)) {
+                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
+                         oSourceElementsData.aCount[
+                             EPrimaryExpressionCategories.N_STRING_LITERALS
+                         ][sPrefixed] *
+                         (nLengthString - nLengthSubstitution);
+                   }
+                 }
+                 if (oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving >
+                     0) {
+                   oSolutionCandidate.nSavings +=
+                       oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving;
+                 } else {
+                   oScope.cname = nIndex; // Free the identifier name.
+                 }
+               },
+               /**
+                * Adds a variable declaration to an existing variable statement.
+                * @param {!Array} aVariableDeclaration A variable declaration
+                *     with an initialiser.
+                */
+               cAddVariableDeclaration = function(aVariableDeclaration) {
+                 (/** @type {!Array} */ oSourceElements[nFrom][1]).unshift(
+                     aVariableDeclaration);
+               };
+
+           if (nFrom > nTo) {
+             return;
+           }
+           // If the range is a closure, reuse the closure.
+           if (nFrom === nTo &&
+               'stat' === oSourceElements[nFrom][0] &&
+               'call' === oSourceElements[nFrom][1][0] &&
+               'function' === oSourceElements[nFrom][1][1][0]) {
+             fExamineSyntacticCodeUnit(oSourceElements[nFrom][1][1]);
+             return;
+           }
+           // Create a list of all derived primitive values within the range.
+           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
+             aSourceElementsData[nPosition].aPrimitiveValues.forEach(
+                 cAugmentList(oSourceElementsData.aPrimitiveValues));
+           }
+           if (0 === oSourceElementsData.aPrimitiveValues.length) {
+             return;
+           }
+           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
+             // Add the number of occurrences to the total count.
+             fAddOccurrences(nPosition);
+             // Add identifiers of this or any nested scope to the list.
+             aSourceElementsData[nPosition].aIdentifiers.forEach(
+                 cAugmentList(oSourceElementsData.aIdentifiers));
+           }
+           // Distribute identifier names among derived primitive values.
+           do {  // If there was any progress, find a better distribution.
+             oSolutionBest = oSolutionCandidate;
+             if (Object.keys(oSolutionCandidate.oPrimitiveValues).length > 0) {
+               // Sort primitive values descending by their worthwhileness.
+               oSourceElementsData.aPrimitiveValues.sort(cSortPrimitiveValues);
+             }
+             oSolutionCandidate = new TSolution();
+             oSourceElementsData.aPrimitiveValues.forEach(
+                 fEvaluatePrimitiveValue);
+             oScope.cname = nIndex;
+           } while (oSolutionCandidate.nSavings > oSolutionBest.nSavings);
+           // Take the necessity of adding a variable statement into account.
+           if ('var' !== oSourceElements[nFrom][0]) {
+             oSolutionBest.nSavings -= oWeights.N_VARIABLE_STATEMENT_AFFIXATION;
+           }
+           if (bEnclose) {
+             // Take the necessity of forming a closure into account.
+             oSolutionBest.nSavings -= oWeights.N_CLOSURE;
+           }
+           if (oSolutionBest.nSavings > 0) {
+             // Create variable declarations suitable for UglifyJS.
+             Object.keys(oSolutionBest.oPrimitiveValues).forEach(
+                 cAugmentVariableDeclarations);
+             // Rewrite expressions that contain worthwhile primitive values.
+             for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
+               oWalker = oProcessor.ast_walker();
+               oSourceElements[nPosition] =
+                   oWalker.with_walkers(
+                       oWalkersTransformers,
+                       cContext(oWalker, oSourceElements[nPosition]));
+             }
+             if ('var' === oSourceElements[nFrom][0]) {  // Reuse the statement.
+               (/** @type {!Array.<!Array>} */ aVariableDeclarations.reverse(
+                   )).forEach(cAddVariableDeclaration);
+             } else {  // Add a variable statement.
+               Array.prototype.splice.call(
+                   oSourceElements,
+                   nFrom,
+                   0,
+                   ['var', aVariableDeclarations]);
+               nTo += 1;
+             }
+             if (bEnclose) {
+               // Add a closure.
+               Array.prototype.splice.call(
+                   oSourceElements,
+                   nFrom,
+                   0,
+                   ['stat', ['call', ['function', null, [], []], []]]);
+               // Copy source elements into the closure.
+               for (nPosition = nTo + 1; nPosition > nFrom; nPosition -= 1) {
+                 Array.prototype.unshift.call(
+                     oSourceElements[nFrom][1][1][3],
+                     oSourceElements[nPosition]);
+               }
+               // Remove source elements outside the closure.
+               Array.prototype.splice.call(
+                   oSourceElements,
+                   nFrom + 1,
+                   nTo - nFrom + 1);
+             }
+           }
+           if (bEnclose) {
+             // Restore the availability of identifier names.
+             oScope.cname = nIndex;
+           }
+         };
+
+     oSourceElements = (/** @type {!TSyntacticCodeUnit} */
+         oSyntacticCodeUnit[bIsGlobal ? 1 : 3]);
+     if (0 === oSourceElements.length) {
+       return;
+     }
+     oScope = bIsGlobal ? oSyntacticCodeUnit.scope : oSourceElements.scope;
+     // Skip a Directive Prologue.
+     while (nAfterDirectivePrologue < oSourceElements.length &&
+            'directive' === oSourceElements[nAfterDirectivePrologue][0]) {
+       nAfterDirectivePrologue += 1;
+       aSourceElementsData.push(null);
+     }
+     if (oSourceElements.length === nAfterDirectivePrologue) {
+       return;
+     }
+     for (nPosition = nAfterDirectivePrologue;
+          nPosition < oSourceElements.length;
+          nPosition += 1) {
+       oSourceElementData = new TSourceElementsData();
+       oWalker = oProcessor.ast_walker();
+       // Classify a source element.
+       // Find its derived primitive values and count their occurrences.
+       // Find all identifiers used (including nested scopes).
+       oWalker.with_walkers(
+           oWalkers.oSurveySourceElement,
+           cContext(oWalker, oSourceElements[nPosition]));
+       // Establish whether the scope is still wholly examinable.
+       bIsWhollyExaminable = bIsWhollyExaminable &&
+           ESourceElementCategories.N_WITH !== oSourceElementData.nCategory &&
+           ESourceElementCategories.N_EVAL !== oSourceElementData.nCategory;
+       aSourceElementsData.push(oSourceElementData);
+     }
+     if (bIsWhollyExaminable) {  // Examine the whole scope.
+       fExamineSourceElements(
+           nAfterDirectivePrologue,
+           oSourceElements.length - 1,
+           false);
+     } else {  // Examine unexcluded ranges of source elements.
+       for (nPosition = oSourceElements.length - 1;
+            nPosition >= nAfterDirectivePrologue;
+            nPosition -= 1) {
+         oSourceElementData = (/** @type {!TSourceElementsData} */
+             aSourceElementsData[nPosition]);
+         if (ESourceElementCategories.N_OTHER ===
+             oSourceElementData.nCategory) {
+           if ('undefined' === typeof nTo) {
+             nTo = nPosition;  // Indicate the end of a range.
+           }
+           // Examine the range if it immediately follows a Directive Prologue.
+           if (nPosition === nAfterDirectivePrologue) {
+             fExamineSourceElements(nPosition, nTo, true);
+           }
+         } else {
+           if ('undefined' !== typeof nTo) {
+             // Examine the range that immediately follows this source element.
+             fExamineSourceElements(nPosition + 1, nTo, true);
+             nTo = void 0;  // Obliterate the range.
+           }
+           // Examine nested functions.
+           oWalker = oProcessor.ast_walker();
+           oWalker.with_walkers(
+               oWalkers.oExamineFunctions,
+               cContext(oWalker, oSourceElements[nPosition]));
+         }
+       }
+     }
+   }(oAbstractSyntaxTree = oProcessor.ast_add_scope(oAbstractSyntaxTree)));
+  return oAbstractSyntaxTree;
+};
+/*jshint sub:false */
+
+/* Local Variables:      */
+/* mode: js              */
+/* coding: utf-8         */
+/* indent-tabs-mode: nil */
+/* tab-width: 2          */
+/* End:                  */
+/* vim: set ft=javascript fenc=utf-8 et ts=2 sts=2 sw=2: */
+/* :mode=javascript:noTabs=true:tabSize=2:indentSize=2:deepIndent=true: */
+});
+define('uglifyjs/parse-js', ["exports"], function(exports) {
+/***********************************************************************
+
+  A JavaScript tokenizer / parser / beautifier / compressor.
+
+  This version is suitable for Node.js.  With minimal changes (the
+  exports stuff) it should work on any JS platform.
+
+  This file contains the tokenizer/parser.  It is a port to JavaScript
+  of parse-js [1], a JavaScript parser library written in Common Lisp
+  by Marijn Haverbeke.  Thank you Marijn!
+
+  [1] http://marijn.haverbeke.nl/parse-js/
+
+  Exported functions:
+
+    - tokenizer(code) -- returns a function.  Call the returned
+      function to fetch the next token.
+
+    - parse(code) -- returns an AST of the given JavaScript code.
+
+  -------------------------------- (C) ---------------------------------
+
+                           Author: Mihai Bazon
+                         <mihai.bazon@gmail.com>
+                       http://mihai.bazon.net/blog
+
+  Distributed under the BSD license:
+
+    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>
+    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions
+    are met:
+
+        * Redistributions of source code must retain the above
+          copyright notice, this list of conditions and the following
+          disclaimer.
+
+        * Redistributions in binary form must reproduce the above
+          copyright notice, this list of conditions and the following
+          disclaimer in the documentation and/or other materials
+          provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
+    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
+    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+    SUCH DAMAGE.
+
+ ***********************************************************************/
+
+/* -----[ Tokenizer (constants) ]----- */
+
+var KEYWORDS = array_to_hash([
+    "break",
+    "case",
+    "catch",
+    "const",
+    "continue",
+    "debugger",
+    "default",
+    "delete",
+    "do",
+    "else",
+    "finally",
+    "for",
+    "function",
+    "if",
+    "in",
+    "instanceof",
+    "new",
+    "return",
+    "switch",
+    "throw",
+    "try",
+    "typeof",
+    "var",
+    "void",
+    "while",
+    "with"
+]);
+
+var RESERVED_WORDS = array_to_hash([
+    "abstract",
+    "boolean",
+    "byte",
+    "char",
+    "class",
+    "double",
+    "enum",
+    "export",
+    "extends",
+    "final",
+    "float",
+    "goto",
+    "implements",
+    "import",
+    "int",
+    "interface",
+    "long",
+    "native",
+    "package",
+    "private",
+    "protected",
+    "public",
+    "short",
+    "static",
+    "super",
+    "synchronized",
+    "throws",
+    "transient",
+    "volatile"
+]);
+
+var KEYWORDS_BEFORE_EXPRESSION = array_to_hash([
+    "return",
+    "new",
+    "delete",
+    "throw",
+    "else",
+    "case"
+]);
+
+var KEYWORDS_ATOM = array_to_hash([
+    "false",
+    "null",
+    "true",
+    "undefined"
+]);
+
+var OPERATOR_CHARS = array_to_hash(characters("+-*&%=<>!?|~^"));
+
+var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
+var RE_OCT_NUMBER = /^0[0-7]+$/;
+var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
+
+var OPERATORS = array_to_hash([
+    "in",
+    "instanceof",
+    "typeof",
+    "new",
+    "void",
+    "delete",
+    "++",
+    "--",
+    "+",
+    "-",
+    "!",
+    "~",
+    "&",
+    "|",
+    "^",
+    "*",
+    "/",
+    "%",
+    ">>",
+    "<<",
+    ">>>",
+    "<",
+    ">",
+    "<=",
+    ">=",
+    "==",
+    "===",
+    "!=",
+    "!==",
+    "?",
+    "=",
+    "+=",
+    "-=",
+    "/=",
+    "*=",
+    "%=",
+    ">>=",
+    "<<=",
+    ">>>=",
+    "|=",
+    "^=",
+    "&=",
+    "&&",
+    "||"
+]);
+
+var WHITESPACE_CHARS = array_to_hash(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\uFEFF"));
+
+var PUNC_BEFORE_EXPRESSION = array_to_hash(characters("[{(,.;:"));
+
+var PUNC_CHARS = array_to_hash(characters("[]{}(),;:"));
+
+var REGEXP_MODIFIERS = array_to_hash(characters("gmsiy"));
+
+/* -----[ Tokenizer ]----- */
+
+var UNICODE = {  // Unicode 6.1
+    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
+    combining_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D02\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
+    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]"),
+    digit: new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]")
+};
+
+function is_letter(ch) {
+    return UNICODE.letter.test(ch);
+};
+
+function is_digit(ch) {
+    ch = ch.charCodeAt(0);
+    return ch >= 48 && ch <= 57;
+};
+
+function is_unicode_digit(ch) {
+    return UNICODE.digit.test(ch);
+}
+
+function is_alphanumeric_char(ch) {
+    return is_digit(ch) || is_letter(ch);
+};
+
+function is_unicode_combining_mark(ch) {
+    return UNICODE.combining_mark.test(ch);
+};
+
+function is_unicode_connector_punctuation(ch) {
+    return UNICODE.connector_punctuation.test(ch);
+};
+
+function is_identifier_start(ch) {
+    return ch == "$" || ch == "_" || is_letter(ch);
+};
+
+function is_identifier_char(ch) {
+    return is_identifier_start(ch)
+        || is_unicode_combining_mark(ch)
+        || is_unicode_digit(ch)
+        || is_unicode_connector_punctuation(ch)
+        || ch == "\u200c" // zero-width non-joiner <ZWNJ>
+        || ch == "\u200d" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
+    ;
+};
+
+function parse_js_number(num) {
+    if (RE_HEX_NUMBER.test(num)) {
+        return parseInt(num.substr(2), 16);
+    } else if (RE_OCT_NUMBER.test(num)) {
+        return parseInt(num.substr(1), 8);
+    } else if (RE_DEC_NUMBER.test(num)) {
+        return parseFloat(num);
+    }
+};
+
+function JS_Parse_Error(message, line, col, pos) {
+    this.message = message;
+    this.line = line + 1;
+    this.col = col + 1;
+    this.pos = pos + 1;
+    this.stack = new Error().stack;
+};
+
+JS_Parse_Error.prototype.toString = function() {
+    return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
+};
+
+function js_error(message, line, col, pos) {
+    throw new JS_Parse_Error(message, line, col, pos);
+};
+
+function is_token(token, type, val) {
+    return token.type == type && (val == null || token.value == val);
+};
+
+var EX_EOF = {};
+
+function tokenizer($TEXT) {
+
+    var S = {
+        text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, ''),
+        pos             : 0,
+        tokpos          : 0,
+        line            : 0,
+        tokline         : 0,
+        col             : 0,
+        tokcol          : 0,
+        newline_before  : false,
+        regex_allowed   : false,
+        comments_before : []
+    };
+
+    function peek() { return S.text.charAt(S.pos); };
+
+    function next(signal_eof, in_string) {
+        var ch = S.text.charAt(S.pos++);
+        if (signal_eof && !ch)
+            throw EX_EOF;
+        if (ch == "\n") {
+            S.newline_before = S.newline_before || !in_string;
+            ++S.line;
+            S.col = 0;
+        } else {
+            ++S.col;
+        }
+        return ch;
+    };
+
+    function eof() {
+        return !S.peek();
+    };
+
+    function find(what, signal_eof) {
+        var pos = S.text.indexOf(what, S.pos);
+        if (signal_eof && pos == -1) throw EX_EOF;
+        return pos;
+    };
+
+    function start_token() {
+        S.tokline = S.line;
+        S.tokcol = S.col;
+        S.tokpos = S.pos;
+    };
+
+    function token(type, value, is_comment) {
+        S.regex_allowed = ((type == "operator" && !HOP(UNARY_POSTFIX, value)) ||
+                           (type == "keyword" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||
+                           (type == "punc" && HOP(PUNC_BEFORE_EXPRESSION, value)));
+        var ret = {
+            type   : type,
+            value  : value,
+            line   : S.tokline,
+            col    : S.tokcol,
+            pos    : S.tokpos,
+            endpos : S.pos,
+            nlb    : S.newline_before
+        };
+        if (!is_comment) {
+            ret.comments_before = S.comments_before;
+            S.comments_before = [];
+            // make note of any newlines in the comments that came before
+            for (var i = 0, len = ret.comments_before.length; i < len; i++) {
+                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
+            }
+        }
+        S.newline_before = false;
+        return ret;
+    };
+
+    function skip_whitespace() {
+        while (HOP(WHITESPACE_CHARS, peek()))
+            next();
+    };
+
+    function read_while(pred) {
+        var ret = "", ch = peek(), i = 0;
+        while (ch && pred(ch, i++)) {
+            ret += next();
+            ch = peek();
+        }
+        return ret;
+    };
+
+    function parse_error(err) {
+        js_error(err, S.tokline, S.tokcol, S.tokpos);
+    };
+
+    function read_num(prefix) {
+        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
+        var num = read_while(function(ch, i){
+            if (ch == "x" || ch == "X") {
+                if (has_x) return false;
+                return has_x = true;
+            }
+            if (!has_x && (ch == "E" || ch == "e")) {
+                if (has_e) return false;
+                return has_e = after_e = true;
+            }
+            if (ch == "-") {
+                if (after_e || (i == 0 && !prefix)) return true;
+                return false;
+            }
+            if (ch == "+") return after_e;
+            after_e = false;
+            if (ch == ".") {
+                if (!has_dot && !has_x && !has_e)
+                    return has_dot = true;
+                return false;
+            }
+            return is_alphanumeric_char(ch);
+        });
+        if (prefix)
+            num = prefix + num;
+        var valid = parse_js_number(num);
+        if (!isNaN(valid)) {
+            return token("num", valid);
+        } else {
+            parse_error("Invalid syntax: " + num);
+        }
+    };
+
+    function read_escaped_char(in_string) {
+        var ch = next(true, in_string);
+        switch (ch) {
+          case "n" : return "\n";
+          case "r" : return "\r";
+          case "t" : return "\t";
+          case "b" : return "\b";
+          case "v" : return "\u000b";
+          case "f" : return "\f";
+          case "0" : return "\0";
+          case "x" : return String.fromCharCode(hex_bytes(2));
+          case "u" : return String.fromCharCode(hex_bytes(4));
+          case "\n": return "";
+          default  : return ch;
+        }
+    };
+
+    function hex_bytes(n) {
+        var num = 0;
+        for (; n > 0; --n) {
+            var digit = parseInt(next(true), 16);
+            if (isNaN(digit))
+                parse_error("Invalid hex-character pattern in string");
+            num = (num << 4) | digit;
+        }
+        return num;
+    };
+
+    function read_string() {
+        return with_eof_error("Unterminated string constant", function(){
+            var quote = next(), ret = "";
+            for (;;) {
+                var ch = next(true);
+                if (ch == "\\") {
+                    // read OctalEscapeSequence (XXX: deprecated if "strict mode")
+                    // https://github.com/mishoo/UglifyJS/issues/178
+                    var octal_len = 0, first = null;
+                    ch = read_while(function(ch){
+                        if (ch >= "0" && ch <= "7") {
+                            if (!first) {
+                                first = ch;
+                                return ++octal_len;
+                            }
+                            else if (first <= "3" && octal_len <= 2) return ++octal_len;
+                            else if (first >= "4" && octal_len <= 1) return ++octal_len;
+                        }
+                        return false;
+                    });
+                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
+                    else ch = read_escaped_char(true);
+                }
+                else if (ch == quote) break;
+                else if (ch == "\n") throw EX_EOF;
+                ret += ch;
+            }
+            return token("string", ret);
+        });
+    };
+
+    function read_line_comment() {
+        next();
+        var i = find("\n"), ret;
+        if (i == -1) {
+            ret = S.text.substr(S.pos);
+            S.pos = S.text.length;
+        } else {
+            ret = S.text.substring(S.pos, i);
+            S.pos = i;
+        }
+        return token("comment1", ret, true);
+    };
+
+    function read_multiline_comment() {
+        next();
+        return with_eof_error("Unterminated multiline comment", function(){
+            var i = find("*/", true),
+            text = S.text.substring(S.pos, i);
+            S.pos = i + 2;
+            S.line += text.split("\n").length - 1;
+            S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
+
+            // https://github.com/mishoo/UglifyJS/issues/#issue/100
+            if (/^@cc_on/i.test(text)) {
+                warn("WARNING: at line " + S.line);
+                warn("*** Found \"conditional comment\": " + text);
+                warn("*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.");
+            }
+
+            return token("comment2", text, true);
+        });
+    };
+
+    function read_name() {
+        var backslash = false, name = "", ch, escaped = false, hex;
+        while ((ch = peek()) != null) {
+            if (!backslash) {
+                if (ch == "\\") escaped = backslash = true, next();
+                else if (is_identifier_char(ch)) name += next();
+                else break;
+            }
+            else {
+                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
+                ch = read_escaped_char();
+                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
+                name += ch;
+                backslash = false;
+            }
+        }
+        if (HOP(KEYWORDS, name) && escaped) {
+            hex = name.charCodeAt(0).toString(16).toUpperCase();
+            name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
+        }
+        return name;
+    };
+
+    function read_regexp(regexp) {
+        return with_eof_error("Unterminated regular expression", function(){
+            var prev_backslash = false, ch, in_class = false;
+            while ((ch = next(true))) if (prev_backslash) {
+                regexp += "\\" + ch;
+                prev_backslash = false;
+            } else if (ch == "[") {
+                in_class = true;
+                regexp += ch;
+            } else if (ch == "]" && in_class) {
+                in_class = false;
+                regexp += ch;
+            } else if (ch == "/" && !in_class) {
+                break;
+            } else if (ch == "\\") {
+                prev_backslash = true;
+            } else {
+                regexp += ch;
+            }
+            var mods = read_name();
+            return token("regexp", [ regexp, mods ]);
+        });
+    };
+
+    function read_operator(prefix) {
+        function grow(op) {
+            if (!peek()) return op;
+            var bigger = op + peek();
+            if (HOP(OPERATORS, bigger)) {
+                next();
+                return grow(bigger);
+            } else {
+                return op;
+            }
+        };
+        return token("operator", grow(prefix || next()));
+    };
+
+    function handle_slash() {
+        next();
+        var regex_allowed = S.regex_allowed;
+        switch (peek()) {
+          case "/":
+            S.comments_before.push(read_line_comment());
+            S.regex_allowed = regex_allowed;
+            return next_token();
+          case "*":
+            S.comments_before.push(read_multiline_comment());
+            S.regex_allowed = regex_allowed;
+            return next_token();
+        }
+        return S.regex_allowed ? read_regexp("") : read_operator("/");
+    };
+
+    function handle_dot() {
+        next();
+        return is_digit(peek())
+            ? read_num(".")
+            : token("punc", ".");
+    };
+
+    function read_word() {
+        var word = read_name();
+        return !HOP(KEYWORDS, word)
+            ? token("name", word)
+            : HOP(OPERATORS, word)
+            ? token("operator", word)
+            : HOP(KEYWORDS_ATOM, word)
+            ? token("atom", word)
+            : token("keyword", word);
+    };
+
+    function with_eof_error(eof_error, cont) {
+        try {
+            return cont();
+        } catch(ex) {
+            if (ex === EX_EOF) parse_error(eof_error);
+            else throw ex;
+        }
+    };
+
+    function next_token(force_regexp) {
+        if (force_regexp != null)
+            return read_regexp(force_regexp);
+        skip_whitespace();
+        start_token();
+        var ch = peek();
+        if (!ch) return token("eof");
+        if (is_digit(ch)) return read_num();
+        if (ch == '"' || ch == "'") return read_string();
+        if (HOP(PUNC_CHARS, ch)) return token("punc", next());
+        if (ch == ".") return handle_dot();
+        if (ch == "/") return handle_slash();
+        if (HOP(OPERATOR_CHARS, ch)) return read_operator();
+        if (ch == "\\" || is_identifier_start(ch)) return read_word();
+        parse_error("Unexpected character '" + ch + "'");
+    };
+
+    next_token.context = function(nc) {
+        if (nc) S = nc;
+        return S;
+    };
+
+    return next_token;
+
+};
+
+/* -----[ Parser (constants) ]----- */
+
+var UNARY_PREFIX = array_to_hash([
+    "typeof",
+    "void",
+    "delete",
+    "--",
+    "++",
+    "!",
+    "~",
+    "-",
+    "+"
+]);
+
+var UNARY_POSTFIX = array_to_hash([ "--", "++" ]);
+
+var ASSIGNMENT = (function(a, ret, i){
+    while (i < a.length) {
+        ret[a[i]] = a[i].substr(0, a[i].length - 1);
+        i++;
+    }
+    return ret;
+})(
+    ["+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="],
+    { "=": true },
+    0
+);
+
+var PRECEDENCE = (function(a, ret){
+    for (var i = 0, n = 1; i < a.length; ++i, ++n) {
+        var b = a[i];
+        for (var j = 0; j < b.length; ++j) {
+            ret[b[j]] = n;
+        }
+    }
+    return ret;
+})(
+    [
+        ["||"],
+        ["&&"],
+        ["|"],
+        ["^"],
+        ["&"],
+        ["==", "===", "!=", "!=="],
+        ["<", ">", "<=", ">=", "in", "instanceof"],
+        [">>", "<<", ">>>"],
+        ["+", "-"],
+        ["*", "/", "%"]
+    ],
+    {}
+);
+
+var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);
+
+var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);
+
+/* -----[ Parser ]----- */
+
+function NodeWithToken(str, start, end) {
+    this.name = str;
+    this.start = start;
+    this.end = end;
+};
+
+NodeWithToken.prototype.toString = function() { return this.name; };
+
+function parse($TEXT, exigent_mode, embed_tokens) {
+
+    var S = {
+        input         : typeof $TEXT == "string" ? tokenizer($TEXT, true) : $TEXT,
+        token         : null,
+        prev          : null,
+        peeked        : null,
+        in_function   : 0,
+        in_directives : true,
+        in_loop       : 0,
+        labels        : []
+    };
+
+    S.token = next();
+
+    function is(type, value) {
+        return is_token(S.token, type, value);
+    };
+
+    function peek() { return S.peeked || (S.peeked = S.input()); };
+
+    function next() {
+        S.prev = S.token;
+        if (S.peeked) {
+            S.token = S.peeked;
+            S.peeked = null;
+        } else {
+            S.token = S.input();
+        }
+        S.in_directives = S.in_directives && (
+            S.token.type == "string" || is("punc", ";")
+        );
+        return S.token;
+    };
+
+    function prev() {
+        return S.prev;
+    };
+
+    function croak(msg, line, col, pos) {
+        var ctx = S.input.context();
+        js_error(msg,
+                 line != null ? line : ctx.tokline,
+                 col != null ? col : ctx.tokcol,
+                 pos != null ? pos : ctx.tokpos);
+    };
+
+    function token_error(token, msg) {
+        croak(msg, token.line, token.col);
+    };
+
+    function unexpected(token) {
+        if (token == null)
+            token = S.token;
+        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
+    };
+
+    function expect_token(type, val) {
+        if (is(type, val)) {
+            return next();
+        }
+        token_error(S.token, "Unexpected token " + S.token.type + ", expected " + type);
+    };
+
+    function expect(punc) { return expect_token("punc", punc); };
+
+    function can_insert_semicolon() {
+        return !exigent_mode && (
+            S.token.nlb || is("eof") || is("punc", "}")
+        );
+    };
+
+    function semicolon() {
+        if (is("punc", ";")) next();
+        else if (!can_insert_semicolon()) unexpected();
+    };
+
+    function as() {
+        return slice(arguments);
+    };
+
+    function parenthesised() {
+        expect("(");
+        var ex = expression();
+        expect(")");
+        return ex;
+    };
+
+    function add_tokens(str, start, end) {
+        return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);
+    };
+
+    function maybe_embed_tokens(parser) {
+        if (embed_tokens) return function() {
+            var start = S.token;
+            var ast = parser.apply(this, arguments);
+            ast[0] = add_tokens(ast[0], start, prev());
+            return ast;
+        };
+        else return parser;
+    };
+
+    var statement = maybe_embed_tokens(function() {
+        if (is("operator", "/") || is("operator", "/=")) {
+            S.peeked = null;
+            S.token = S.input(S.token.value.substr(1)); // force regexp
+        }
+        switch (S.token.type) {
+          case "string":
+            var dir = S.in_directives, stat = simple_statement();
+            if (dir && stat[1][0] == "string" && !is("punc", ","))
+                return as("directive", stat[1][1]);
+            return stat;
+          case "num":
+          case "regexp":
+          case "operator":
+          case "atom":
+            return simple_statement();
+
+          case "name":
+            return is_token(peek(), "punc", ":")
+                ? labeled_statement(prog1(S.token.value, next, next))
+                : simple_statement();
+
+          case "punc":
+            switch (S.token.value) {
+              case "{":
+                return as("block", block_());
+              case "[":
+              case "(":
+                return simple_statement();
+              case ";":
+                next();
+                return as("block");
+              default:
+                unexpected();
+            }
+
+          case "keyword":
+            switch (prog1(S.token.value, next)) {
+              case "break":
+                return break_cont("break");
+
+              case "continue":
+                return break_cont("continue");
+
+              case "debugger":
+                semicolon();
+                return as("debugger");
+
+              case "do":
+                return (function(body){
+                    expect_token("keyword", "while");
+                    return as("do", prog1(parenthesised, semicolon), body);
+                })(in_loop(statement));
+
+              case "for":
+                return for_();
+
+              case "function":
+                return function_(true);
+
+              case "if":
+                return if_();
+
+              case "return":
+                if (S.in_function == 0)
+                    croak("'return' outside of function");
+                return as("return",
+                          is("punc", ";")
+                          ? (next(), null)
+                          : can_insert_semicolon()
+                          ? null
+                          : prog1(expression, semicolon));
+
+              case "switch":
+                return as("switch", parenthesised(), switch_block_());
+
+              case "throw":
+                if (S.token.nlb)
+                    croak("Illegal newline after 'throw'");
+                return as("throw", prog1(expression, semicolon));
+
+              case "try":
+                return try_();
+
+              case "var":
+                return prog1(var_, semicolon);
+
+              case "const":
+                return prog1(const_, semicolon);
+
+              case "while":
+                return as("while", parenthesised(), in_loop(statement));
+
+              case "with":
+                return as("with", parenthesised(), statement());
+
+              default:
+                unexpected();
+            }
+        }
+    });
+
+    function labeled_statement(label) {
+        S.labels.push(label);
+        var start = S.token, stat = statement();
+        if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))
+            unexpected(start);
+        S.labels.pop();
+        return as("label", label, stat);
+    };
+
+    function simple_statement() {
+        return as("stat", prog1(expression, semicolon));
+    };
+
+    function break_cont(type) {
+        var name;
+        if (!can_insert_semicolon()) {
+            name = is("name") ? S.token.value : null;
+        }
+        if (name != null) {
+            next();
+            if (!member(name, S.labels))
+                croak("Label " + name + " without matching loop or statement");
+        }
+        else if (S.in_loop == 0)
+            croak(type + " not inside a loop or switch");
+        semicolon();
+        return as(type, name);
+    };
+
+    function for_() {
+        expect("(");
+        var init = null;
+        if (!is("punc", ";")) {
+            init = is("keyword", "var")
+                ? (next(), var_(true))
+                : expression(true, true);
+            if (is("operator", "in")) {
+                if (init[0] == "var" && init[1].length > 1)
+                    croak("Only one variable declaration allowed in for..in loop");
+                return for_in(init);
+            }
+        }
+        return regular_for(init);
+    };
+
+    function regular_for(init) {
+        expect(";");
+        var test = is("punc", ";") ? null : expression();
+        expect(";");
+        var step = is("punc", ")") ? null : expression();
+        expect(")");
+        return as("for", init, test, step, in_loop(statement));
+    };
+
+    function for_in(init) {
+        var lhs = init[0] == "var" ? as("name", init[1][0]) : init;
+        next();
+        var obj = expression();
+        expect(")");
+        return as("for-in", init, lhs, obj, in_loop(statement));
+    };
+
+    var function_ = function(in_statement) {
+        var name = is("name") ? prog1(S.token.value, next) : null;
+        if (in_statement && !name)
+            unexpected();
+        expect("(");
+        return as(in_statement ? "defun" : "function",
+                  name,
+                  // arguments
+                  (function(first, a){
+                      while (!is("punc", ")")) {
+                          if (first) first = false; else expect(",");
+                          if (!is("name")) unexpected();
+                          a.push(S.token.value);
+                          next();
+                      }
+                      next();
+                      return a;
+                  })(true, []),
+                  // body
+                  (function(){
+                      ++S.in_function;
+                      var loop = S.in_loop;
+                      S.in_directives = true;
+                      S.in_loop = 0;
+                      var a = block_();
+                      --S.in_function;
+                      S.in_loop = loop;
+                      return a;
+                  })());
+    };
+
+    function if_() {
+        var cond = parenthesised(), body = statement(), belse;
+        if (is("keyword", "else")) {
+            next();
+            belse = statement();
+        }
+        return as("if", cond, body, belse);
+    };
+
+    function block_() {
+        expect("{");
+        var a = [];
+        while (!is("punc", "}")) {
+            if (is("eof")) unexpected();
+            a.push(statement());
+        }
+        next();
+        return a;
+    };
+
+    var switch_block_ = curry(in_loop, function(){
+        expect("{");
+        var a = [], cur = null;
+        while (!is("punc", "}")) {
+            if (is("eof")) unexpected();
+            if (is("keyword", "case")) {
+                next();
+                cur = [];
+                a.push([ expression(), cur ]);
+                expect(":");
+            }
+            else if (is("keyword", "default")) {
+                next();
+                expect(":");
+                cur = [];
+                a.push([ null, cur ]);
+            }
+            else {
+                if (!cur) unexpected();
+                cur.push(statement());
+            }
+        }
+        next();
+        return a;
+    });
+
+    function try_() {
+        var body = block_(), bcatch, bfinally;
+        if (is("keyword", "catch")) {
+            next();
+            expect("(");
+            if (!is("name"))
+                croak("Name expected");
+            var name = S.token.value;
+            next();
+            expect(")");
+            bcatch = [ name, block_() ];
+        }
+        if (is("keyword", "finally")) {
+            next();
+            bfinally = block_();
+        }
+        if (!bcatch && !bfinally)
+            croak("Missing catch/finally blocks");
+        return as("try", body, bcatch, bfinally);
+    };
+
+    function vardefs(no_in) {
+        var a = [];
+        for (;;) {
+            if (!is("name"))
+                unexpected();
+            var name = S.token.value;
+            next();
+            if (is("operator", "=")) {
+                next();
+                a.push([ name, expression(false, no_in) ]);
+            } else {
+                a.push([ name ]);
+            }
+            if (!is("punc", ","))
+                break;
+            next();
+        }
+        return a;
+    };
+
+    function var_(no_in) {
+        return as("var", vardefs(no_in));
+    };
+
+    function const_() {
+        return as("const", vardefs());
+    };
+
+    function new_() {
+        var newexp = expr_atom(false), args;
+        if (is("punc", "(")) {
+            next();
+            args = expr_list(")");
+        } else {
+            args = [];
+        }
+        return subscripts(as("new", newexp, args), true);
+    };
+
+    var expr_atom = maybe_embed_tokens(function(allow_calls) {
+        if (is("operator", "new")) {
+            next();
+            return new_();
+        }
+        if (is("punc")) {
+            switch (S.token.value) {
+              case "(":
+                next();
+                return subscripts(prog1(expression, curry(expect, ")")), allow_calls);
+              case "[":
+                next();
+                return subscripts(array_(), allow_calls);
+              case "{":
+                next();
+                return subscripts(object_(), allow_calls);
+            }
+            unexpected();
+        }
+        if (is("keyword", "function")) {
+            next();
+            return subscripts(function_(false), allow_calls);
+        }
+        if (HOP(ATOMIC_START_TOKEN, S.token.type)) {
+            var atom = S.token.type == "regexp"
+                ? as("regexp", S.token.value[0], S.token.value[1])
+                : as(S.token.type, S.token.value);
+            return subscripts(prog1(atom, next), allow_calls);
+        }
+        unexpected();
+    });
+
+    function expr_list(closing, allow_trailing_comma, allow_empty) {
+        var first = true, a = [];
+        while (!is("punc", closing)) {
+            if (first) first = false; else expect(",");
+            if (allow_trailing_comma && is("punc", closing)) break;
+            if (is("punc", ",") && allow_empty) {
+                a.push([ "atom", "undefined" ]);
+            } else {
+                a.push(expression(false));
+            }
+        }
+        next();
+        return a;
+    };
+
+    function array_() {
+        return as("array", expr_list("]", !exigent_mode, true));
+    };
+
+    function object_() {
+        var first = true, a = [];
+        while (!is("punc", "}")) {
+            if (first) first = false; else expect(",");
+            if (!exigent_mode && is("punc", "}"))
+                // allow trailing comma
+                break;
+            var type = S.token.type;
+            var name = as_property_name();
+            if (type == "name" && (name == "get" || name == "set") && !is("punc", ":")) {
+                a.push([ as_name(), function_(false), name ]);
+            } else {
+                expect(":");
+                a.push([ name, expression(false) ]);
+            }
+        }
+        next();
+        return as("object", a);
+    };
+
+    function as_property_name() {
+        switch (S.token.type) {
+          case "num":
+          case "string":
+            return prog1(S.token.value, next);
+        }
+        return as_name();
+    };
+
+    function as_name() {
+        switch (S.token.type) {
+          case "name":
+          case "operator":
+          case "keyword":
+          case "atom":
+            return prog1(S.token.value, next);
+          default:
+            unexpected();
+        }
+    };
+
+    function subscripts(expr, allow_calls) {
+        if (is("punc", ".")) {
+            next();
+            return subscripts(as("dot", expr, as_name()), allow_calls);
+        }
+        if (is("punc", "[")) {
+            next();
+            return subscripts(as("sub", expr, prog1(expression, curry(expect, "]"))), allow_calls);
+        }
+        if (allow_calls && is("punc", "(")) {
+            next();
+            return subscripts(as("call", expr, expr_list(")")), true);
+        }
+        return expr;
+    };
+
+    function maybe_unary(allow_calls) {
+        if (is("operator") && HOP(UNARY_PREFIX, S.token.value)) {
+            return make_unary("unary-prefix",
+                              prog1(S.token.value, next),
+                              maybe_unary(allow_calls));
+        }
+        var val = expr_atom(allow_calls);
+        while (is("operator") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {
+            val = make_unary("unary-postfix", S.token.value, val);
+            next();
+        }
+        return val;
+    };
+
+    function make_unary(tag, op, expr) {
+        if ((op == "++" || op == "--") && !is_assignable(expr))
+            croak("Invalid use of " + op + " operator");
+        return as(tag, op, expr);
+    };
+
+    function expr_op(left, min_prec, no_in) {
+        var op = is("operator") ? S.token.value : null;
+        if (op && op == "in" && no_in) op = null;
+        var prec = op != null ? PRECEDENCE[op] : null;
+        if (prec != null && prec > min_prec) {
+            next();
+            var right = expr_op(maybe_unary(true), prec, no_in);
+            return expr_op(as("binary", op, left, right), min_prec, no_in);
+        }
+        return left;
+    };
+
+    function expr_ops(no_in) {
+        return expr_op(maybe_unary(true), 0, no_in);
+    };
+
+    function maybe_conditional(no_in) {
+        var expr = expr_ops(no_in);
+        if (is("operator", "?")) {
+            next();
+            var yes = expression(false);
+            expect(":");
+            return as("conditional", expr, yes, expression(false, no_in));
+        }
+        return expr;
+    };
+
+    function is_assignable(expr) {
+        if (!exigent_mode) return true;
+        switch (expr[0]+"") {
+          case "dot":
+          case "sub":
+          case "new":
+          case "call":
+            return true;
+          case "name":
+            return expr[1] != "this";
+        }
+    };
+
+    function maybe_assign(no_in) {
+        var left = maybe_conditional(no_in), val = S.token.value;
+        if (is("operator") && HOP(ASSIGNMENT, val)) {
+            if (is_assignable(left)) {
+                next();
+                return as("assign", ASSIGNMENT[val], left, maybe_assign(no_in));
+            }
+            croak("Invalid assignment");
+        }
+        return left;
+    };
+
+    var expression = maybe_embed_tokens(function(commas, no_in) {
+        if (arguments.length == 0)
+            commas = true;
+        var expr = maybe_assign(no_in);
+        if (commas && is("punc", ",")) {
+            next();
+            return as("seq", expr, expression(true, no_in));
+        }
+        return expr;
+    });
+
+    function in_loop(cont) {
+        try {
+            ++S.in_loop;
+            return cont();
+        } finally {
+            --S.in_loop;
+        }
+    };
+
+    return as("toplevel", (function(a){
+        while (!is("eof"))
+            a.push(statement());
+        return a;
+    })([]));
+
+};
+
+/* -----[ Utilities ]----- */
+
+function curry(f) {
+    var args = slice(arguments, 1);
+    return function() { return f.apply(this, args.concat(slice(arguments))); };
+};
+
+function prog1(ret) {
+    if (ret instanceof Function)
+        ret = ret();
+    for (var i = 1, n = arguments.length; --n > 0; ++i)
+        arguments[i]();
+    return ret;
+};
+
+function array_to_hash(a) {
+    var ret = {};
+    for (var i = 0; i < a.length; ++i)
+        ret[a[i]] = true;
+    return ret;
+};
+
+function slice(a, start) {
+    return Array.prototype.slice.call(a, start || 0);
+};
+
+function characters(str) {
+    return str.split("");
+};
+
+function member(name, array) {
+    for (var i = array.length; --i >= 0;)
+        if (array[i] == name)
+            return true;
+    return false;
+};
+
+function HOP(obj, prop) {
+    return Object.prototype.hasOwnProperty.call(obj, prop);
+};
+
+var warn = function() {};
+
+/* -----[ Exports ]----- */
+
+exports.tokenizer = tokenizer;
+exports.parse = parse;
+exports.slice = slice;
+exports.curry = curry;
+exports.member = member;
+exports.array_to_hash = array_to_hash;
+exports.PRECEDENCE = PRECEDENCE;
+exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
+exports.RESERVED_WORDS = RESERVED_WORDS;
+exports.KEYWORDS = KEYWORDS;
+exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
+exports.OPERATORS = OPERATORS;
+exports.is_alphanumeric_char = is_alphanumeric_char;
+exports.is_identifier_start = is_identifier_start;
+exports.is_identifier_char = is_identifier_char;
+exports.set_logger = function(logger) {
+    warn = logger;
+};
+
+// Local variables:
+// js-indent-level: 4
+// End:
+});define('uglifyjs/squeeze-more', ["require", "exports", "module", "./parse-js", "./squeeze-more"], function(require, exports, module) {
+var jsp = require("./parse-js"),
+    pro = require("./process"),
+    slice = jsp.slice,
+    member = jsp.member,
+    curry = jsp.curry,
+    MAP = pro.MAP,
+    PRECEDENCE = jsp.PRECEDENCE,
+    OPERATORS = jsp.OPERATORS;
+
+function ast_squeeze_more(ast) {
+    var w = pro.ast_walker(), walk = w.walk, scope;
+    function with_scope(s, cont) {
+        var save = scope, ret;
+        scope = s;
+        ret = cont();
+        scope = save;
+        return ret;
+    };
+    function _lambda(name, args, body) {
+        return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
+    };
+    return w.with_walkers({
+        "toplevel": function(body) {
+            return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
+        },
+        "function": _lambda,
+        "defun": _lambda,
+        "new": function(ctor, args) {
+            if (ctor[0] == "name") {
+                if (ctor[1] == "Array" && !scope.has("Array")) {
+                    if (args.length != 1) {
+                        return [ "array", args ];
+                    } else {
+                        return walk([ "call", [ "name", "Array" ], args ]);
+                    }
+                } else if (ctor[1] == "Object" && !scope.has("Object")) {
+                    if (!args.length) {
+                        return [ "object", [] ];
+                    } else {
+                        return walk([ "call", [ "name", "Object" ], args ]);
+                    }
+                } else if ((ctor[1] == "RegExp" || ctor[1] == "Function" || ctor[1] == "Error") && !scope.has(ctor[1])) {
+                    return walk([ "call", [ "name", ctor[1] ], args]);
+                }
+            }
+        },
+        "call": function(expr, args) {
+            if (expr[0] == "dot" && expr[1][0] == "string" && args.length == 1
+                && (args[0][1] > 0 && expr[2] == "substring" || expr[2] == "substr")) {
+                return [ "call", [ "dot", expr[1], "slice"], args];
+            }
+            if (expr[0] == "dot" && expr[2] == "toString" && args.length == 0) {
+                // foo.toString()  ==>  foo+""
+                if (expr[1][0] == "string") return expr[1];
+                return [ "binary", "+", expr[1], [ "string", "" ]];
+            }
+            if (expr[0] == "name") {
+                if (expr[1] == "Array" && args.length != 1 && !scope.has("Array")) {
+                    return [ "array", args ];
+                }
+                if (expr[1] == "Object" && !args.length && !scope.has("Object")) {
+                    return [ "object", [] ];
+                }
+                if (expr[1] == "String" && !scope.has("String")) {
+                    return [ "binary", "+", args[0], [ "string", "" ]];
+                }
+            }
+        }
+    }, function() {
+        return walk(pro.ast_add_scope(ast));
+    });
+};
+
+exports.ast_squeeze_more = ast_squeeze_more;
+
+// Local variables:
+// js-indent-level: 4
+// End:
+});
+define('uglifyjs/process', ["require", "exports", "module", "./parse-js", "./squeeze-more"], function(require, exports, module) {
+/***********************************************************************
+
+  A JavaScript tokenizer / parser / beautifier / compressor.
+
+  This version is suitable for Node.js.  With minimal changes (the
+  exports stuff) it should work on any JS platform.
+
+  This file implements some AST processors.  They work on data built
+  by parse-js.
+
+  Exported functions:
+
+    - ast_mangle(ast, options) -- mangles the variable/function names
+      in the AST.  Returns an AST.
+
+    - ast_squeeze(ast) -- employs various optimizations to make the
+      final generated code even smaller.  Returns an AST.
+
+    - gen_code(ast, options) -- generates JS code from the AST.  Pass
+      true (or an object, see the code for some options) as second
+      argument to get "pretty" (indented) code.
+
+  -------------------------------- (C) ---------------------------------
+
+                           Author: Mihai Bazon
+                         <mihai.bazon@gmail.com>
+                       http://mihai.bazon.net/blog
+
+  Distributed under the BSD license:
+
+    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions
+    are met:
+
+        * Redistributions of source code must retain the above
+          copyright notice, this list of conditions and the following
+          disclaimer.
+
+        * Redistributions in binary form must reproduce the above
+          copyright notice, this list of conditions and the following
+          disclaimer in the documentation and/or other materials
+          provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
+    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
+    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+    SUCH DAMAGE.
+
+ ***********************************************************************/
+
+var jsp = require("./parse-js"),
+    curry = jsp.curry,
+    slice = jsp.slice,
+    member = jsp.member,
+    is_identifier_char = jsp.is_identifier_char,
+    PRECEDENCE = jsp.PRECEDENCE,
+    OPERATORS = jsp.OPERATORS;
+
+/* -----[ helper for AST traversal ]----- */
+
+function ast_walker() {
+    function _vardefs(defs) {
+        return [ this[0], MAP(defs, function(def){
+            var a = [ def[0] ];
+            if (def.length > 1)
+                a[1] = walk(def[1]);
+            return a;
+        }) ];
+    };
+    function _block(statements) {
+        var out = [ this[0] ];
+        if (statements != null)
+            out.push(MAP(statements, walk));
+        return out;
+    };
+    var walkers = {
+        "string": function(str) {
+            return [ this[0], str ];
+        },
+        "num": function(num) {
+            return [ this[0], num ];
+        },
+        "name": function(name) {
+            return [ this[0], name ];
+        },
+        "toplevel": function(statements) {
+            return [ this[0], MAP(statements, walk) ];
+        },
+        "block": _block,
+        "splice": _block,
+        "var": _vardefs,
+        "const": _vardefs,
+        "try": function(t, c, f) {
+            return [
+                this[0],
+                MAP(t, walk),
+                c != null ? [ c[0], MAP(c[1], walk) ] : null,
+                f != null ? MAP(f, walk) : null
+            ];
+        },
+        "throw": function(expr) {
+            return [ this[0], walk(expr) ];
+        },
+        "new": function(ctor, args) {
+            return [ this[0], walk(ctor), MAP(args, walk) ];
+        },
+        "switch": function(expr, body) {
+            return [ this[0], walk(expr), MAP(body, function(branch){
+                return [ branch[0] ? walk(branch[0]) : null,
+                         MAP(branch[1], walk) ];
+            }) ];
+        },
+        "break": function(label) {
+            return [ this[0], label ];
+        },
+        "continue": function(label) {
+            return [ this[0], label ];
+        },
+        "conditional": function(cond, t, e) {
+            return [ this[0], walk(cond), walk(t), walk(e) ];
+        },
+        "assign": function(op, lvalue, rvalue) {
+            return [ this[0], op, walk(lvalue), walk(rvalue) ];
+        },
+        "dot": function(expr) {
+            return [ this[0], walk(expr) ].concat(slice(arguments, 1));
+        },
+        "call": function(expr, args) {
+            return [ this[0], walk(expr), MAP(args, walk) ];
+        },
+        "function": function(name, args, body) {
+            return [ this[0], name, args.slice(), MAP(body, walk) ];
+        },
+        "debugger": function() {
+            return [ this[0] ];
+        },
+        "defun": function(name, args, body) {
+            return [ this[0], name, args.slice(), MAP(body, walk) ];
+        },
+        "if": function(conditional, t, e) {
+            return [ this[0], walk(conditional), walk(t), walk(e) ];
+        },
+        "for": function(init, cond, step, block) {
+            return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];
+        },
+        "for-in": function(vvar, key, hash, block) {
+            return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];
+        },
+        "while": function(cond, block) {
+            return [ this[0], walk(cond), walk(block) ];
+        },
+        "do": function(cond, block) {
+            return [ this[0], walk(cond), walk(block) ];
+        },
+        "return": function(expr) {
+            return [ this[0], walk(expr) ];
+        },
+        "binary": function(op, left, right) {
+            return [ this[0], op, walk(left), walk(right) ];
+        },
+        "unary-prefix": function(op, expr) {
+            return [ this[0], op, walk(expr) ];
+        },
+        "unary-postfix": function(op, expr) {
+            return [ this[0], op, walk(expr) ];
+        },
+        "sub": function(expr, subscript) {
+            return [ this[0], walk(expr), walk(subscript) ];
+        },
+        "object": function(props) {
+            return [ this[0], MAP(props, function(p){
+                return p.length == 2
+                    ? [ p[0], walk(p[1]) ]
+                    : [ p[0], walk(p[1]), p[2] ]; // get/set-ter
+            }) ];
+        },
+        "regexp": function(rx, mods) {
+            return [ this[0], rx, mods ];
+        },
+        "array": function(elements) {
+            return [ this[0], MAP(elements, walk) ];
+        },
+        "stat": function(stat) {
+            return [ this[0], walk(stat) ];
+        },
+        "seq": function() {
+            return [ this[0] ].concat(MAP(slice(arguments), walk));
+        },
+        "label": function(name, block) {
+            return [ this[0], name, walk(block) ];
+        },
+        "with": function(expr, block) {
+            return [ this[0], walk(expr), walk(block) ];
+        },
+        "atom": function(name) {
+            return [ this[0], name ];
+        },
+        "directive": function(dir) {
+            return [ this[0], dir ];
+        }
+    };
+
+    var user = {};
+    var stack = [];
+    function walk(ast) {
+        if (ast == null)
+            return null;
+        try {
+            stack.push(ast);
+            var type = ast[0];
+            var gen = user[type];
+            if (gen) {
+                var ret = gen.apply(ast, ast.slice(1));
+                if (ret != null)
+                    return ret;
+            }
+            gen = walkers[type];
+            return gen.apply(ast, ast.slice(1));
+        } finally {
+            stack.pop();
+        }
+    };
+
+    function dive(ast) {
+        if (ast == null)
+            return null;
+        try {
+            stack.push(ast);
+            return walkers[ast[0]].apply(ast, ast.slice(1));
+        } finally {
+            stack.pop();
+        }
+    };
+
+    function with_walkers(walkers, cont){
+        var save = {}, i;
+        for (i in walkers) if (HOP(walkers, i)) {
+            save[i] = user[i];
+            user[i] = walkers[i];
+        }
+        var ret = cont();
+        for (i in save) if (HOP(save, i)) {
+            if (!save[i]) delete user[i];
+            else user[i] = save[i];
+        }
+        return ret;
+    };
+
+    return {
+        walk: walk,
+        dive: dive,
+        with_walkers: with_walkers,
+        parent: function() {
+            return stack[stack.length - 2]; // last one is current node
+        },
+        stack: function() {
+            return stack;
+        }
+    };
+};
+
+/* -----[ Scope and mangling ]----- */
+
+function Scope(parent) {
+    this.names = {};        // names defined in this scope
+    this.mangled = {};      // mangled names (orig.name => mangled)
+    this.rev_mangled = {};  // reverse lookup (mangled => orig.name)
+    this.cname = -1;        // current mangled name
+    this.refs = {};         // names referenced from this scope
+    this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes
+    this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes
+    this.directives = [];   // directives activated from this scope
+    this.parent = parent;   // parent scope
+    this.children = [];     // sub-scopes
+    if (parent) {
+        this.level = parent.level + 1;
+        parent.children.push(this);
+    } else {
+        this.level = 0;
+    }
+};
+
+function base54_digits() {
+    if (typeof DIGITS_OVERRIDE_FOR_TESTING != "undefined")
+        return DIGITS_OVERRIDE_FOR_TESTING;
+    else
+        return "etnrisouaflchpdvmgybwESxTNCkLAOM_DPHBjFIqRUzWXV$JKQGYZ0516372984";
+}
+
+var base54 = (function(){
+    var DIGITS = base54_digits();
+    return function(num) {
+        var ret = "", base = 54;
+        do {
+            ret += DIGITS.charAt(num % base);
+            num = Math.floor(num / base);
+            base = 64;
+        } while (num > 0);
+        return ret;
+    };
+})();
+
+Scope.prototype = {
+    has: function(name) {
+        for (var s = this; s; s = s.parent)
+            if (HOP(s.names, name))
+                return s;
+    },
+    has_mangled: function(mname) {
+        for (var s = this; s; s = s.parent)
+            if (HOP(s.rev_mangled, mname))
+                return s;
+    },
+    toJSON: function() {
+        return {
+            names: this.names,
+            uses_eval: this.uses_eval,
+            uses_with: this.uses_with
+        };
+    },
+
+    next_mangled: function() {
+        // we must be careful that the new mangled name:
+        //
+        // 1. doesn't shadow a mangled name from a parent
+        //    scope, unless we don't reference the original
+        //    name from this scope OR from any sub-scopes!
+        //    This will get slow.
+        //
+        // 2. doesn't shadow an original name from a parent
+        //    scope, in the event that the name is not mangled
+        //    in the parent scope and we reference that name
+        //    here OR IN ANY SUBSCOPES!
+        //
+        // 3. doesn't shadow a name that is referenced but not
+        //    defined (possibly global defined elsewhere).
+        for (;;) {
+            var m = base54(++this.cname), prior;
+
+            // case 1.
+            prior = this.has_mangled(m);
+            if (prior && this.refs[prior.rev_mangled[m]] === prior)
+                continue;
+
+            // case 2.
+            prior = this.has(m);
+            if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))
+                continue;
+
+            // case 3.
+            if (HOP(this.refs, m) && this.refs[m] == null)
+                continue;
+
+            // I got "do" once. :-/
+            if (!is_identifier(m))
+                continue;
+
+            return m;
+        }
+    },
+    set_mangle: function(name, m) {
+        this.rev_mangled[m] = name;
+        return this.mangled[name] = m;
+    },
+    get_mangled: function(name, newMangle) {
+        if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use
+        var s = this.has(name);
+        if (!s) return name; // not in visible scope, no mangle
+        if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope
+        if (!newMangle) return name;                      // not found and no mangling requested
+        return s.set_mangle(name, s.next_mangled());
+    },
+    references: function(name) {
+        return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];
+    },
+    define: function(name, type) {
+        if (name != null) {
+            if (type == "var" || !HOP(this.names, name))
+                this.names[name] = type || "var";
+            return name;
+        }
+    },
+    active_directive: function(dir) {
+        return member(dir, this.directives) || this.parent && this.parent.active_directive(dir);
+    }
+};
+
+function ast_add_scope(ast) {
+
+    var current_scope = null;
+    var w = ast_walker(), walk = w.walk;
+    var having_eval = [];
+
+    function with_new_scope(cont) {
+        current_scope = new Scope(current_scope);
+        current_scope.labels = new Scope();
+        var ret = current_scope.body = cont();
+        ret.scope = current_scope;
+        current_scope = current_scope.parent;
+        return ret;
+    };
+
+    function define(name, type) {
+        return current_scope.define(name, type);
+    };
+
+    function reference(name) {
+        current_scope.refs[name] = true;
+    };
+
+    function _lambda(name, args, body) {
+        var is_defun = this[0] == "defun";
+        return [ this[0], is_defun ? define(name, "defun") : name, args, with_new_scope(function(){
+            if (!is_defun) define(name, "lambda");
+            MAP(args, function(name){ define(name, "arg") });
+            return MAP(body, walk);
+        })];
+    };
+
+    function _vardefs(type) {
+        return function(defs) {
+            MAP(defs, function(d){
+                define(d[0], type);
+                if (d[1]) reference(d[0]);
+            });
+        };
+    };
+
+    function _breacont(label) {
+        if (label)
+            current_scope.labels.refs[label] = true;
+    };
+
+    return with_new_scope(function(){
+        // process AST
+        var ret = w.with_walkers({
+            "function": _lambda,
+            "defun": _lambda,
+            "label": function(name, stat) { current_scope.labels.define(name) },
+            "break": _breacont,
+            "continue": _breacont,
+            "with": function(expr, block) {
+                for (var s = current_scope; s; s = s.parent)
+                    s.uses_with = true;
+            },
+            "var": _vardefs("var"),
+            "const": _vardefs("const"),
+            "try": function(t, c, f) {
+                if (c != null) return [
+                    this[0],
+                    MAP(t, walk),
+                    [ define(c[0], "catch"), MAP(c[1], walk) ],
+                    f != null ? MAP(f, walk) : null
+                ];
+            },
+            "name": function(name) {
+                if (name == "eval")
+                    having_eval.push(current_scope);
+                reference(name);
+            }
+        }, function(){
+            return walk(ast);
+        });
+
+        // the reason why we need an additional pass here is
+        // that names can be used prior to their definition.
+
+        // scopes where eval was detected and their parents
+        // are marked with uses_eval, unless they define the
+        // "eval" name.
+        MAP(having_eval, function(scope){
+            if (!scope.has("eval")) while (scope) {
+                scope.uses_eval = true;
+                scope = scope.parent;
+            }
+        });
+
+        // for referenced names it might be useful to know
+        // their origin scope.  current_scope here is the
+        // toplevel one.
+        function fixrefs(scope, i) {
+            // do children first; order shouldn't matter
+            for (i = scope.children.length; --i >= 0;)
+                fixrefs(scope.children[i]);
+            for (i in scope.refs) if (HOP(scope.refs, i)) {
+                // find origin scope and propagate the reference to origin
+                for (var origin = scope.has(i), s = scope; s; s = s.parent) {
+                    s.refs[i] = origin;
+                    if (s === origin) break;
+                }
+            }
+        };
+        fixrefs(current_scope);
+
+        return ret;
+    });
+
+};
+
+/* -----[ mangle names ]----- */
+
+function ast_mangle(ast, options) {
+    var w = ast_walker(), walk = w.walk, scope;
+    options = defaults(options, {
+        mangle       : true,
+        toplevel     : false,
+        defines      : null,
+        except       : null,
+        no_functions : false
+    });
+
+    function get_mangled(name, newMangle) {
+        if (!options.mangle) return name;
+        if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel
+        if (options.except && member(name, options.except))
+            return name;
+        if (options.no_functions && HOP(scope.names, name) &&
+            (scope.names[name] == 'defun' || scope.names[name] == 'lambda'))
+            return name;
+        return scope.get_mangled(name, newMangle);
+    };
+
+    function get_define(name) {
+        if (options.defines) {
+            // we always lookup a defined symbol for the current scope FIRST, so declared
+            // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value
+            if (!scope.has(name)) {
+                if (HOP(options.defines, name)) {
+                    return options.defines[name];
+                }
+            }
+            return null;
+        }
+    };
+
+    function _lambda(name, args, body) {
+        if (!options.no_functions && options.mangle) {
+            var is_defun = this[0] == "defun", extra;
+            if (name) {
+                if (is_defun) name = get_mangled(name);
+                else if (body.scope.references(name)) {
+                    extra = {};
+                    if (!(scope.uses_eval || scope.uses_with))
+                        name = extra[name] = scope.next_mangled();
+                    else
+                        extra[name] = name;
+                }
+                else name = null;
+            }
+        }
+        body = with_scope(body.scope, function(){
+            args = MAP(args, function(name){ return get_mangled(name) });
+            return MAP(body, walk);
+        }, extra);
+        return [ this[0], name, args, body ];
+    };
+
+    function with_scope(s, cont, extra) {
+        var _scope = scope;
+        scope = s;
+        if (extra) for (var i in extra) if (HOP(extra, i)) {
+            s.set_mangle(i, extra[i]);
+        }
+        for (var i in s.names) if (HOP(s.names, i)) {
+            get_mangled(i, true);
+        }
+        var ret = cont();
+        ret.scope = s;
+        scope = _scope;
+        return ret;
+    };
+
+    function _vardefs(defs) {
+        return [ this[0], MAP(defs, function(d){
+            return [ get_mangled(d[0]), walk(d[1]) ];
+        }) ];
+    };
+
+    function _breacont(label) {
+        if (label) return [ this[0], scope.labels.get_mangled(label) ];
+    };
+
+    return w.with_walkers({
+        "function": _lambda,
+        "defun": function() {
+            // move function declarations to the top when
+            // they are not in some block.
+            var ast = _lambda.apply(this, arguments);
+            switch (w.parent()[0]) {
+              case "toplevel":
+              case "function":
+              case "defun":
+                return MAP.at_top(ast);
+            }
+            return ast;
+        },
+        "label": function(label, stat) {
+            if (scope.labels.refs[label]) return [
+                this[0],
+                scope.labels.get_mangled(label, true),
+                walk(stat)
+            ];
+            return walk(stat);
+        },
+        "break": _breacont,
+        "continue": _breacont,
+        "var": _vardefs,
+        "const": _vardefs,
+        "name": function(name) {
+            return get_define(name) || [ this[0], get_mangled(name) ];
+        },
+        "try": function(t, c, f) {
+            return [ this[0],
+                     MAP(t, walk),
+                     c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,
+                     f != null ? MAP(f, walk) : null ];
+        },
+        "toplevel": function(body) {
+            var self = this;
+            return with_scope(self.scope, function(){
+                return [ self[0], MAP(body, walk) ];
+            });
+        },
+        "directive": function() {
+            return MAP.at_top(this);
+        }
+    }, function() {
+        return walk(ast_add_scope(ast));
+    });
+};
+
+/* -----[
+   - compress foo["bar"] into foo.bar,
+   - remove block brackets {} where possible
+   - join consecutive var declarations
+   - various optimizations for IFs:
+   - if (cond) foo(); else bar();  ==>  cond?foo():bar();
+   - if (cond) foo();  ==>  cond&&foo();
+   - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw
+   - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}
+   ]----- */
+
+var warn = function(){};
+
+function best_of(ast1, ast2) {
+    return gen_code(ast1).length > gen_code(ast2[0] == "stat" ? ast2[1] : ast2).length ? ast2 : ast1;
+};
+
+function last_stat(b) {
+    if (b[0] == "block" && b[1] && b[1].length > 0)
+        return b[1][b[1].length - 1];
+    return b;
+}
+
+function aborts(t) {
+    if (t) switch (last_stat(t)[0]) {
+      case "return":
+      case "break":
+      case "continue":
+      case "throw":
+        return true;
+    }
+};
+
+function boolean_expr(expr) {
+    return ( (expr[0] == "unary-prefix"
+              && member(expr[1], [ "!", "delete" ])) ||
+
+             (expr[0] == "binary"
+              && member(expr[1], [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ])) ||
+
+             (expr[0] == "binary"
+              && member(expr[1], [ "&&", "||" ])
+              && boolean_expr(expr[2])
+              && boolean_expr(expr[3])) ||
+
+             (expr[0] == "conditional"
+              && boolean_expr(expr[2])
+              && boolean_expr(expr[3])) ||
+
+             (expr[0] == "assign"
+              && expr[1] === true
+              && boolean_expr(expr[3])) ||
+
+             (expr[0] == "seq"
+              && boolean_expr(expr[expr.length - 1]))
+           );
+};
+
+function empty(b) {
+    return !b || (b[0] == "block" && (!b[1] || b[1].length == 0));
+};
+
+function is_string(node) {
+    return (node[0] == "string" ||
+            node[0] == "unary-prefix" && node[1] == "typeof" ||
+            node[0] == "binary" && node[1] == "+" &&
+            (is_string(node[2]) || is_string(node[3])));
+};
+
+var when_constant = (function(){
+
+    var $NOT_CONSTANT = {};
+
+    // this can only evaluate constant expressions.  If it finds anything
+    // not constant, it throws $NOT_CONSTANT.
+    function evaluate(expr) {
+        switch (expr[0]) {
+          case "string":
+          case "num":
+            return expr[1];
+          case "name":
+          case "atom":
+            switch (expr[1]) {
+              case "true": return true;
+              case "false": return false;
+              case "null": return null;
+            }
+            break;
+          case "unary-prefix":
+            switch (expr[1]) {
+              case "!": return !evaluate(expr[2]);
+              case "typeof": return typeof evaluate(expr[2]);
+              case "~": return ~evaluate(expr[2]);
+              case "-": return -evaluate(expr[2]);
+              case "+": return +evaluate(expr[2]);
+            }
+            break;
+          case "binary":
+            var left = expr[2], right = expr[3];
+            switch (expr[1]) {
+              case "&&"         : return evaluate(left) &&         evaluate(right);
+              case "||"         : return evaluate(left) ||         evaluate(right);
+              case "|"          : return evaluate(left) |          evaluate(right);
+              case "&"          : return evaluate(left) &          evaluate(right);
+              case "^"          : return evaluate(left) ^          evaluate(right);
+              case "+"          : return evaluate(left) +          evaluate(right);
+              case "*"          : return evaluate(left) *          evaluate(right);
+              case "/"          : return evaluate(left) /          evaluate(right);
+              case "%"          : return evaluate(left) %          evaluate(right);
+              case "-"          : return evaluate(left) -          evaluate(right);
+              case "<<"         : return evaluate(left) <<         evaluate(right);
+              case ">>"         : return evaluate(left) >>         evaluate(right);
+              case ">>>"        : return evaluate(left) >>>        evaluate(right);
+              case "=="         : return evaluate(left) ==         evaluate(right);
+              case "==="        : return evaluate(left) ===        evaluate(right);
+              case "!="         : return evaluate(left) !=         evaluate(right);
+              case "!=="        : return evaluate(left) !==        evaluate(right);
+              case "<"          : return evaluate(left) <          evaluate(right);
+              case "<="         : return evaluate(left) <=         evaluate(right);
+              case ">"          : return evaluate(left) >          evaluate(right);
+              case ">="         : return evaluate(left) >=         evaluate(right);
+              case "in"         : return evaluate(left) in         evaluate(right);
+              case "instanceof" : return evaluate(left) instanceof evaluate(right);
+            }
+        }
+        throw $NOT_CONSTANT;
+    };
+
+    return function(expr, yes, no) {
+        try {
+            var val = evaluate(expr), ast;
+            switch (typeof val) {
+              case "string": ast =  [ "string", val ]; break;
+              case "number": ast =  [ "num", val ]; break;
+              case "boolean": ast =  [ "name", String(val) ]; break;
+              default:
+                if (val === null) { ast = [ "atom", "null" ]; break; }
+                throw new Error("Can't handle constant of type: " + (typeof val));
+            }
+            return yes.call(expr, ast, val);
+        } catch(ex) {
+            if (ex === $NOT_CONSTANT) {
+                if (expr[0] == "binary"
+                    && (expr[1] == "===" || expr[1] == "!==")
+                    && ((is_string(expr[2]) && is_string(expr[3]))
+                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {
+                    expr[1] = expr[1].substr(0, 2);
+                }
+                else if (no && expr[0] == "binary"
+                         && (expr[1] == "||" || expr[1] == "&&")) {
+                    // the whole expression is not constant but the lval may be...
+                    try {
+                        var lval = evaluate(expr[2]);
+                        expr = ((expr[1] == "&&" && (lval ? expr[3] : lval))    ||
+                                (expr[1] == "||" && (lval ? lval    : expr[3])) ||
+                                expr);
+                    } catch(ex2) {
+                        // IGNORE... lval is not constant
+                    }
+                }
+                return no ? no.call(expr, expr) : null;
+            }
+            else throw ex;
+        }
+    };
+
+})();
+
+function warn_unreachable(ast) {
+    if (!empty(ast))
+        warn("Dropping unreachable code: " + gen_code(ast, true));
+};
+
+function prepare_ifs(ast) {
+    var w = ast_walker(), walk = w.walk;
+    // In this first pass, we rewrite ifs which abort with no else with an
+    // if-else.  For example:
+    //
+    // if (x) {
+    //     blah();
+    //     return y;
+    // }
+    // foobar();
+    //
+    // is rewritten into:
+    //
+    // if (x) {
+    //     blah();
+    //     return y;
+    // } else {
+    //     foobar();
+    // }
+    function redo_if(statements) {
+        statements = MAP(statements, walk);
+
+        for (var i = 0; i < statements.length; ++i) {
+            var fi = statements[i];
+            if (fi[0] != "if") continue;
+
+            if (fi[3]) continue;
+
+            var t = fi[2];
+            if (!aborts(t)) continue;
+
+            var conditional = walk(fi[1]);
+
+            var e_body = redo_if(statements.slice(i + 1));
+            var e = e_body.length == 1 ? e_body[0] : [ "block", e_body ];
+
+            return statements.slice(0, i).concat([ [
+                fi[0],          // "if"
+                conditional,    // conditional
+                t,              // then
+                e               // else
+            ] ]);
+        }
+
+        return statements;
+    };
+
+    function redo_if_lambda(name, args, body) {
+        body = redo_if(body);
+        return [ this[0], name, args, body ];
+    };
+
+    function redo_if_block(statements) {
+        return [ this[0], statements != null ? redo_if(statements) : null ];
+    };
+
+    return w.with_walkers({
+        "defun": redo_if_lambda,
+        "function": redo_if_lambda,
+        "block": redo_if_block,
+        "splice": redo_if_block,
+        "toplevel": function(statements) {
+            return [ this[0], redo_if(statements) ];
+        },
+        "try": function(t, c, f) {
+            return [
+                this[0],
+                redo_if(t),
+                c != null ? [ c[0], redo_if(c[1]) ] : null,
+                f != null ? redo_if(f) : null
+            ];
+        }
+    }, function() {
+        return walk(ast);
+    });
+};
+
+function for_side_effects(ast, handler) {
+    var w = ast_walker(), walk = w.walk;
+    var $stop = {}, $restart = {};
+    function stop() { throw $stop };
+    function restart() { throw $restart };
+    function found(){ return handler.call(this, this, w, stop, restart) };
+    function unary(op) {
+        if (op == "++" || op == "--")
+            return found.apply(this, arguments);
+    };
+    function binary(op) {
+        if (op == "&&" || op == "||")
+            return found.apply(this, arguments);
+    };
+    return w.with_walkers({
+        "try": found,
+        "throw": found,
+        "return": found,
+        "new": found,
+        "switch": found,
+        "break": found,
+        "continue": found,
+        "assign": found,
+        "call": found,
+        "if": found,
+        "for": found,
+        "for-in": found,
+        "while": found,
+        "do": found,
+        "return": found,
+        "unary-prefix": unary,
+        "unary-postfix": unary,
+        "conditional": found,
+        "binary": binary,
+        "defun": found
+    }, function(){
+        while (true) try {
+            walk(ast);
+            break;
+        } catch(ex) {
+            if (ex === $stop) break;
+            if (ex === $restart) continue;
+            throw ex;
+        }
+    });
+};
+
+function ast_lift_variables(ast) {
+    var w = ast_walker(), walk = w.walk, scope;
+    function do_body(body, env) {
+        var _scope = scope;
+        scope = env;
+        body = MAP(body, walk);
+        var hash = {}, names = MAP(env.names, function(type, name){
+            if (type != "var") return MAP.skip;
+            if (!env.references(name)) return MAP.skip;
+            hash[name] = true;
+            return [ name ];
+        });
+        if (names.length > 0) {
+            // looking for assignments to any of these variables.
+            // we can save considerable space by moving the definitions
+            // in the var declaration.
+            for_side_effects([ "block", body ], function(ast, walker, stop, restart) {
+                if (ast[0] == "assign"
+                    && ast[1] === true
+                    && ast[2][0] == "name"
+                    && HOP(hash, ast[2][1])) {
+                    // insert the definition into the var declaration
+                    for (var i = names.length; --i >= 0;) {
+                        if (names[i][0] == ast[2][1]) {
+                            if (names[i][1]) // this name already defined, we must stop
+                                stop();
+                            names[i][1] = ast[3]; // definition
+                            names.push(names.splice(i, 1)[0]);
+                            break;
+                        }
+                    }
+                    // remove this assignment from the AST.
+                    var p = walker.parent();
+                    if (p[0] == "seq") {
+                        var a = p[2];
+                        a.unshift(0, p.length);
+                        p.splice.apply(p, a);
+                    }
+                    else if (p[0] == "stat") {
+                        p.splice(0, p.length, "block"); // empty statement
+                    }
+                    else {
+                        stop();
+                    }
+                    restart();
+                }
+                stop();
+            });
+            body.unshift([ "var", names ]);
+        }
+        scope = _scope;
+        return body;
+    };
+    function _vardefs(defs) {
+        var ret = null;
+        for (var i = defs.length; --i >= 0;) {
+            var d = defs[i];
+            if (!d[1]) continue;
+            d = [ "assign", true, [ "name", d[0] ], d[1] ];
+            if (ret == null) ret = d;
+            else ret = [ "seq", d, ret ];
+        }
+        if (ret == null && w.parent()[0] != "for") {
+            if (w.parent()[0] == "for-in")
+                return [ "name", defs[0][0] ];
+            return MAP.skip;
+        }
+        return [ "stat", ret ];
+    };
+    function _toplevel(body) {
+        return [ this[0], do_body(body, this.scope) ];
+    };
+    return w.with_walkers({
+        "function": function(name, args, body){
+            for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
+                args.pop();
+            if (!body.scope.references(name)) name = null;
+            return [ this[0], name, args, do_body(body, body.scope) ];
+        },
+        "defun": function(name, args, body){
+            if (!scope.references(name)) return MAP.skip;
+            for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
+                args.pop();
+            return [ this[0], name, args, do_body(body, body.scope) ];
+        },
+        "var": _vardefs,
+        "toplevel": _toplevel
+    }, function(){
+        return walk(ast_add_scope(ast));
+    });
+};
+
+function ast_squeeze(ast, options) {
+    ast = squeeze_1(ast, options);
+    ast = squeeze_2(ast, options);
+    return ast;
+};
+
+function squeeze_1(ast, options) {
+    options = defaults(options, {
+        make_seqs   : true,
+        dead_code   : true,
+        no_warnings : false,
+        keep_comps  : true,
+        unsafe      : false
+    });
+
+    var w = ast_walker(), walk = w.walk, scope;
+
+    function negate(c) {
+        var not_c = [ "unary-prefix", "!", c ];
+        switch (c[0]) {
+          case "unary-prefix":
+            return c[1] == "!" && boolean_expr(c[2]) ? c[2] : not_c;
+          case "seq":
+            c = slice(c);
+            c[c.length - 1] = negate(c[c.length - 1]);
+            return c;
+          case "conditional":
+            return best_of(not_c, [ "conditional", c[1], negate(c[2]), negate(c[3]) ]);
+          case "binary":
+            var op = c[1], left = c[2], right = c[3];
+            if (!options.keep_comps) switch (op) {
+              case "<="  : return [ "binary", ">", left, right ];
+              case "<"   : return [ "binary", ">=", left, right ];
+              case ">="  : return [ "binary", "<", left, right ];
+              case ">"   : return [ "binary", "<=", left, right ];
+            }
+            switch (op) {
+              case "=="  : return [ "binary", "!=", left, right ];
+              case "!="  : return [ "binary", "==", left, right ];
+              case "===" : return [ "binary", "!==", left, right ];
+              case "!==" : return [ "binary", "===", left, right ];
+              case "&&"  : return best_of(not_c, [ "binary", "||", negate(left), negate(right) ]);
+              case "||"  : return best_of(not_c, [ "binary", "&&", negate(left), negate(right) ]);
+            }
+            break;
+        }
+        return not_c;
+    };
+
+    function make_conditional(c, t, e) {
+        var make_real_conditional = function() {
+            if (c[0] == "unary-prefix" && c[1] == "!") {
+                return e ? [ "conditional", c[2], e, t ] : [ "binary", "||", c[2], t ];
+            } else {
+                return e ? best_of(
+                    [ "conditional", c, t, e ],
+                    [ "conditional", negate(c), e, t ]
+                ) : [ "binary", "&&", c, t ];
+            }
+        };
+        // shortcut the conditional if the expression has a constant value
+        return when_constant(c, function(ast, val){
+            warn_unreachable(val ? e : t);
+            return          (val ? t : e);
+        }, make_real_conditional);
+    };
+
+    function rmblock(block) {
+        if (block != null && block[0] == "block" && block[1]) {
+            if (block[1].length == 1)
+                block = block[1][0];
+            else if (block[1].length == 0)
+                block = [ "block" ];
+        }
+        return block;
+    };
+
+    function _lambda(name, args, body) {
+        return [ this[0], name, args, tighten(body, "lambda") ];
+    };
+
+    // this function does a few things:
+    // 1. discard useless blocks
+    // 2. join consecutive var declarations
+    // 3. remove obviously dead code
+    // 4. transform consecutive statements using the comma operator
+    // 5. if block_type == "lambda" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }
+    function tighten(statements, block_type) {
+        statements = MAP(statements, walk);
+
+        statements = statements.reduce(function(a, stat){
+            if (stat[0] == "block") {
+                if (stat[1]) {
+                    a.push.apply(a, stat[1]);
+                }
+            } else {
+                a.push(stat);
+            }
+            return a;
+        }, []);
+
+        statements = (function(a, prev){
+            statements.forEach(function(cur){
+                if (prev && ((cur[0] == "var" && prev[0] == "var") ||
+                             (cur[0] == "const" && prev[0] == "const"))) {
+                    prev[1] = prev[1].concat(cur[1]);
+                } else {
+                    a.push(cur);
+                    prev = cur;
+                }
+            });
+            return a;
+        })([]);
+
+        if (options.dead_code) statements = (function(a, has_quit){
+            statements.forEach(function(st){
+                if (has_quit) {
+                    if (st[0] == "function" || st[0] == "defun") {
+                        a.push(st);
+                    }
+                    else if (st[0] == "var" || st[0] == "const") {
+                        if (!options.no_warnings)
+                            warn("Variables declared in unreachable code");
+                        st[1] = MAP(st[1], function(def){
+                            if (def[1] && !options.no_warnings)
+                                warn_unreachable([ "assign", true, [ "name", def[0] ], def[1] ]);
+                            return [ def[0] ];
+                        });
+                        a.push(st);
+                    }
+                    else if (!options.no_warnings)
+                        warn_unreachable(st);
+                }
+                else {
+                    a.push(st);
+                    if (member(st[0], [ "return", "throw", "break", "continue" ]))
+                        has_quit = true;
+                }
+            });
+            return a;
+        })([]);
+
+        if (options.make_seqs) statements = (function(a, prev) {
+            statements.forEach(function(cur){
+                if (prev && prev[0] == "stat" && cur[0] == "stat") {
+                    prev[1] = [ "seq", prev[1], cur[1] ];
+                } else {
+                    a.push(cur);
+                    prev = cur;
+                }
+            });
+            if (a.length >= 2
+                && a[a.length-2][0] == "stat"
+                && (a[a.length-1][0] == "return" || a[a.length-1][0] == "throw")
+                && a[a.length-1][1])
+            {
+                a.splice(a.length - 2, 2,
+                         [ a[a.length-1][0],
+                           [ "seq", a[a.length-2][1], a[a.length-1][1] ]]);
+            }
+            return a;
+        })([]);
+
+        // this increases jQuery by 1K.  Probably not such a good idea after all..
+        // part of this is done in prepare_ifs anyway.
+        // if (block_type == "lambda") statements = (function(i, a, stat){
+        //         while (i < statements.length) {
+        //                 stat = statements[i++];
+        //                 if (stat[0] == "if" && !stat[3]) {
+        //                         if (stat[2][0] == "return" && stat[2][1] == null) {
+        //                                 a.push(make_if(negate(stat[1]), [ "block", statements.slice(i) ]));
+        //                                 break;
+        //                         }
+        //                         var last = last_stat(stat[2]);
+        //                         if (last[0] == "return" && last[1] == null) {
+        //                                 a.push(make_if(stat[1], [ "block", stat[2][1].slice(0, -1) ], [ "block", statements.slice(i) ]));
+        //                                 break;
+        //                         }
+        //                 }
+        //                 a.push(stat);
+        //         }
+        //         return a;
+        // })(0, []);
+
+        return statements;
+    };
+
+    function make_if(c, t, e) {
+        return when_constant(c, function(ast, val){
+            if (val) {
+                t = walk(t);
+                warn_unreachable(e);
+                return t || [ "block" ];
+            } else {
+                e = walk(e);
+                warn_unreachable(t);
+                return e || [ "block" ];
+            }
+        }, function() {
+            return make_real_if(c, t, e);
+        });
+    };
+
+    function abort_else(c, t, e) {
+        var ret = [ [ "if", negate(c), e ] ];
+        if (t[0] == "block") {
+            if (t[1]) ret = ret.concat(t[1]);
+        } else {
+            ret.push(t);
+        }
+        return walk([ "block", ret ]);
+    };
+
+    function make_real_if(c, t, e) {
+        c = walk(c);
+        t = walk(t);
+        e = walk(e);
+
+        if (empty(e) && empty(t))
+            return [ "stat", c ];
+
+        if (empty(t)) {
+            c = negate(c);
+            t = e;
+            e = null;
+        } else if (empty(e)) {
+            e = null;
+        } else {
+            // if we have both else and then, maybe it makes sense to switch them?
+            (function(){
+                var a = gen_code(c);
+                var n = negate(c);
+                var b = gen_code(n);
+                if (b.length < a.length) {
+                    var tmp = t;
+                    t = e;
+                    e = tmp;
+                    c = n;
+                }
+            })();
+        }
+        var ret = [ "if", c, t, e ];
+        if (t[0] == "if" && empty(t[3]) && empty(e)) {
+            ret = best_of(ret, walk([ "if", [ "binary", "&&", c, t[1] ], t[2] ]));
+        }
+        else if (t[0] == "stat") {
+            if (e) {
+                if (e[0] == "stat")
+                    ret = best_of(ret, [ "stat", make_conditional(c, t[1], e[1]) ]);
+                else if (aborts(e))
+                    ret = abort_else(c, t, e);
+            }
+            else {
+                ret = best_of(ret, [ "stat", make_conditional(c, t[1]) ]);
+            }
+        }
+        else if (e && t[0] == e[0] && (t[0] == "return" || t[0] == "throw") && t[1] && e[1]) {
+            ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);
+        }
+        else if (e && aborts(t)) {
+            ret = [ [ "if", c, t ] ];
+            if (e[0] == "block") {
+                if (e[1]) ret = ret.concat(e[1]);
+            }
+            else {
+                ret.push(e);
+            }
+            ret = walk([ "block", ret ]);
+        }
+        else if (t && aborts(e)) {
+            ret = abort_else(c, t, e);
+        }
+        return ret;
+    };
+
+    function _do_while(cond, body) {
+        return when_constant(cond, function(cond, val){
+            if (!val) {
+                warn_unreachable(body);
+                return [ "block" ];
+            } else {
+                return [ "for", null, null, null, walk(body) ];
+            }
+        });
+    };
+
+    return w.with_walkers({
+        "sub": function(expr, subscript) {
+            if (subscript[0] == "string") {
+                var name = subscript[1];
+                if (is_identifier(name))
+                    return [ "dot", walk(expr), name ];
+                else if (/^[1-9][0-9]*$/.test(name) || name === "0")
+                    return [ "sub", walk(expr), [ "num", parseInt(name, 10) ] ];
+            }
+        },
+        "if": make_if,
+        "toplevel": function(body) {
+            return [ "toplevel", tighten(body) ];
+        },
+        "switch": function(expr, body) {
+            var last = body.length - 1;
+            return [ "switch", walk(expr), MAP(body, function(branch, i){
+                var block = tighten(branch[1]);
+                if (i == last && block.length > 0) {
+                    var node = block[block.length - 1];
+                    if (node[0] == "break" && !node[1])
+                        block.pop();
+                }
+                return [ branch[0] ? walk(branch[0]) : null, block ];
+            }) ];
+        },
+        "function": _lambda,
+        "defun": _lambda,
+        "block": function(body) {
+            if (body) return rmblock([ "block", tighten(body) ]);
+        },
+        "binary": function(op, left, right) {
+            return when_constant([ "binary", op, walk(left), walk(right) ], function yes(c){
+                return best_of(walk(c), this);
+            }, function no() {
+                return function(){
+                    if(op != "==" && op != "!=") return;
+                    var l = walk(left), r = walk(right);
+                    if(l && l[0] == "unary-prefix" && l[1] == "!" && l[2][0] == "num")
+                        left = ['num', +!l[2][1]];
+                    else if (r && r[0] == "unary-prefix" && r[1] == "!" && r[2][0] == "num")
+                        right = ['num', +!r[2][1]];
+                    return ["binary", op, left, right];
+                }() || this;
+            });
+        },
+        "conditional": function(c, t, e) {
+            return make_conditional(walk(c), walk(t), walk(e));
+        },
+        "try": function(t, c, f) {
+            return [
+                "try",
+                tighten(t),
+                c != null ? [ c[0], tighten(c[1]) ] : null,
+                f != null ? tighten(f) : null
+            ];
+        },
+        "unary-prefix": function(op, expr) {
+            expr = walk(expr);
+            var ret = [ "unary-prefix", op, expr ];
+            if (op == "!")
+                ret = best_of(ret, negate(expr));
+            return when_constant(ret, function(ast, val){
+                return walk(ast); // it's either true or false, so minifies to !0 or !1
+            }, function() { return ret });
+        },
+        "name": function(name) {
+            switch (name) {
+              case "true": return [ "unary-prefix", "!", [ "num", 0 ]];
+              case "false": return [ "unary-prefix", "!", [ "num", 1 ]];
+            }
+        },
+        "while": _do_while,
+        "assign": function(op, lvalue, rvalue) {
+            lvalue = walk(lvalue);
+            rvalue = walk(rvalue);
+            var okOps = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
+            if (op === true && lvalue[0] === "name" && rvalue[0] === "binary" &&
+                ~okOps.indexOf(rvalue[1]) && rvalue[2][0] === "name" &&
+                rvalue[2][1] === lvalue[1]) {
+                return [ this[0], rvalue[1], lvalue, rvalue[3] ]
+            }
+            return [ this[0], op, lvalue, rvalue ];
+        },
+        "call": function(expr, args) {
+            expr = walk(expr);
+            if (options.unsafe && expr[0] == "dot" && expr[1][0] == "string" && expr[2] == "toString") {
+                return expr[1];
+            }
+            return [ this[0], expr,  MAP(args, walk) ];
+        },
+        "num": function (num) {
+            if (!isFinite(num))
+                return [ "binary", "/", num === 1 / 0
+                         ? [ "num", 1 ] : num === -1 / 0
+                         ? [ "unary-prefix", "-", [ "num", 1 ] ]
+                         : [ "num", 0 ], [ "num", 0 ] ];
+
+            return [ this[0], num ];
+        }
+    }, function() {
+        return walk(prepare_ifs(walk(prepare_ifs(ast))));
+    });
+};
+
+function squeeze_2(ast, options) {
+    var w = ast_walker(), walk = w.walk, scope;
+    function with_scope(s, cont) {
+        var save = scope, ret;
+        scope = s;
+        ret = cont();
+        scope = save;
+        return ret;
+    };
+    function lambda(name, args, body) {
+        return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
+    };
+    return w.with_walkers({
+        "directive": function(dir) {
+            if (scope.active_directive(dir))
+                return [ "block" ];
+            scope.directives.push(dir);
+        },
+        "toplevel": function(body) {
+            return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
+        },
+        "function": lambda,
+        "defun": lambda
+    }, function(){
+        return walk(ast_add_scope(ast));
+    });
+};
+
+/* -----[ re-generate code from the AST ]----- */
+
+var DOT_CALL_NO_PARENS = jsp.array_to_hash([
+    "name",
+    "array",
+    "object",
+    "string",
+    "dot",
+    "sub",
+    "call",
+    "regexp",
+    "defun"
+]);
+
+function make_string(str, ascii_only) {
+    var dq = 0, sq = 0;
+    str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
+        switch (s) {
+          case "\\": return "\\\\";
+          case "\b": return "\\b";
+          case "\f": return "\\f";
+          case "\n": return "\\n";
+          case "\r": return "\\r";
+          case "\u2028": return "\\u2028";
+          case "\u2029": return "\\u2029";
+          case '"': ++dq; return '"';
+          case "'": ++sq; return "'";
+          case "\0": return "\\0";
+        }
+        return s;
+    });
+    if (ascii_only) str = to_ascii(str);
+    if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
+    else return '"' + str.replace(/\x22/g, '\\"') + '"';
+};
+
+function to_ascii(str) {
+    return str.replace(/[\u0080-\uffff]/g, function(ch) {
+        var code = ch.charCodeAt(0).toString(16);
+        while (code.length < 4) code = "0" + code;
+        return "\\u" + code;
+    });
+};
+
+var SPLICE_NEEDS_BRACKETS = jsp.array_to_hash([ "if", "while", "do", "for", "for-in", "with" ]);
+
+function gen_code(ast, options) {
+    options = defaults(options, {
+        indent_start : 0,
+        indent_level : 4,
+        quote_keys   : false,
+        space_colon  : false,
+        beautify     : false,
+        ascii_only   : false,
+        inline_script: false
+    });
+    var beautify = !!options.beautify;
+    var indentation = 0,
+    newline = beautify ? "\n" : "",
+    space = beautify ? " " : "";
+
+    function encode_string(str) {
+        var ret = make_string(str, options.ascii_only);
+        if (options.inline_script)
+            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
+        return ret;
+    };
+
+    function make_name(name) {
+        name = name.toString();
+        if (options.ascii_only)
+            name = to_ascii(name);
+        return name;
+    };
+
+    function indent(line) {
+        if (line == null)
+            line = "";
+        if (beautify)
+            line = repeat_string(" ", options.indent_start + indentation * options.indent_level) + line;
+        return line;
+    };
+
+    function with_indent(cont, incr) {
+        if (incr == null) incr = 1;
+        indentation += incr;
+        try { return cont.apply(null, slice(arguments, 1)); }
+        finally { indentation -= incr; }
+    };
+
+    function last_char(str) {
+        str = str.toString();
+        return str.charAt(str.length - 1);
+    };
+
+    function first_char(str) {
+        return str.toString().charAt(0);
+    };
+
+    function add_spaces(a) {
+        if (beautify)
+            return a.join(" ");
+        var b = [];
+        for (var i = 0; i < a.length; ++i) {
+            var next = a[i + 1];
+            b.push(a[i]);
+            if (next &&
+                ((is_identifier_char(last_char(a[i])) && (is_identifier_char(first_char(next))
+                                                          || first_char(next) == "\\")) ||
+                 (/[\+\-]$/.test(a[i].toString()) && /^[\+\-]/.test(next.toString()) ||
+                 last_char(a[i]) == "/" && first_char(next) == "/"))) {
+                b.push(" ");
+            }
+        }
+        return b.join("");
+    };
+
+    function add_commas(a) {
+        return a.join("," + space);
+    };
+
+    function parenthesize(expr) {
+        var gen = make(expr);
+        for (var i = 1; i < arguments.length; ++i) {
+            var el = arguments[i];
+            if ((el instanceof Function && el(expr)) || expr[0] == el)
+                return "(" + gen + ")";
+        }
+        return gen;
+    };
+
+    function best_of(a) {
+        if (a.length == 1) {
+            return a[0];
+        }
+        if (a.length == 2) {
+            var b = a[1];
+            a = a[0];
+            return a.length <= b.length ? a : b;
+        }
+        return best_of([ a[0], best_of(a.slice(1)) ]);
+    };
+
+    function needs_parens(expr) {
+        if (expr[0] == "function" || expr[0] == "object") {
+            // dot/call on a literal function requires the
+            // function literal itself to be parenthesized
+            // only if it's the first "thing" in a
+            // statement.  This means that the parent is
+            // "stat", but it could also be a "seq" and
+            // we're the first in this "seq" and the
+            // parent is "stat", and so on.  Messy stuff,
+            // but it worths the trouble.
+            var a = slice(w.stack()), self = a.pop(), p = a.pop();
+            while (p) {
+                if (p[0] == "stat") return true;
+                if (((p[0] == "seq" || p[0] == "call" || p[0] == "dot" || p[0] == "sub" || p[0] == "conditional") && p[1] === self) ||
+                    ((p[0] == "binary" || p[0] == "assign" || p[0] == "unary-postfix") && p[2] === self)) {
+                    self = p;
+                    p = a.pop();
+                } else {
+                    return false;
+                }
+            }
+        }
+        return !HOP(DOT_CALL_NO_PARENS, expr[0]);
+    };
+
+    function make_num(num) {
+        var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
+        if (Math.floor(num) === num) {
+            if (num >= 0) {
+                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
+                       "0" + num.toString(8)); // same.
+            } else {
+                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
+                       "-0" + (-num).toString(8)); // same.
+            }
+            if ((m = /^(.*?)(0+)$/.exec(num))) {
+                a.push(m[1] + "e" + m[2].length);
+            }
+        } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
+            a.push(m[2] + "e-" + (m[1].length + m[2].length),
+                   str.substr(str.indexOf(".")));
+        }
+        return best_of(a);
+    };
+
+    var w = ast_walker();
+    var make = w.walk;
+    return w.with_walkers({
+        "string": encode_string,
+        "num": make_num,
+        "name": make_name,
+        "debugger": function(){ return "debugger;" },
+        "toplevel": function(statements) {
+            return make_block_statements(statements)
+                .join(newline + newline);
+        },
+        "splice": function(statements) {
+            var parent = w.parent();
+            if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {
+                // we need block brackets in this case
+                return make_block.apply(this, arguments);
+            } else {
+                return MAP(make_block_statements(statements, true),
+                           function(line, i) {
+                               // the first line is already indented
+                               return i > 0 ? indent(line) : line;
+                           }).join(newline);
+            }
+        },
+        "block": make_block,
+        "var": function(defs) {
+            return "var " + add_commas(MAP(defs, make_1vardef)) + ";";
+        },
+        "const": function(defs) {
+            return "const " + add_commas(MAP(defs, make_1vardef)) + ";";
+        },
+        "try": function(tr, ca, fi) {
+            var out = [ "try", make_block(tr) ];
+            if (ca) out.push("catch", "(" + ca[0] + ")", make_block(ca[1]));
+            if (fi) out.push("finally", make_block(fi));
+            return add_spaces(out);
+        },
+        "throw": function(expr) {
+            return add_spaces([ "throw", make(expr) ]) + ";";
+        },
+        "new": function(ctor, args) {
+            args = args.length > 0 ? "(" + add_commas(MAP(args, function(expr){
+                return parenthesize(expr, "seq");
+            })) + ")" : "";
+            return add_spaces([ "new", parenthesize(ctor, "seq", "binary", "conditional", "assign", function(expr){
+                var w = ast_walker(), has_call = {};
+                try {
+                    w.with_walkers({
+                        "call": function() { throw has_call },
+                        "function": function() { return this }
+                    }, function(){
+                        w.walk(expr);
+                    });
+                } catch(ex) {
+                    if (ex === has_call)
+                        return true;
+                    throw ex;
+                }
+            }) + args ]);
+        },
+        "switch": function(expr, body) {
+            return add_spaces([ "switch", "(" + make(expr) + ")", make_switch_block(body) ]);
+        },
+        "break": function(label) {
+            var out = "break";
+            if (label != null)
+                out += " " + make_name(label);
+            return out + ";";
+        },
+        "continue": function(label) {
+            var out = "continue";
+            if (label != null)
+                out += " " + make_name(label);
+            return out + ";";
+        },
+        "conditional": function(co, th, el) {
+            return add_spaces([ parenthesize(co, "assign", "seq", "conditional"), "?",
+                                parenthesize(th, "seq"), ":",
+                                parenthesize(el, "seq") ]);
+        },
+        "assign": function(op, lvalue, rvalue) {
+            if (op && op !== true) op += "=";
+            else op = "=";
+            return add_spaces([ make(lvalue), op, parenthesize(rvalue, "seq") ]);
+        },
+        "dot": function(expr) {
+            var out = make(expr), i = 1;
+            if (expr[0] == "num") {
+                if (!/[a-f.]/i.test(out))
+                    out += ".";
+            } else if (expr[0] != "function" && needs_parens(expr))
+                out = "(" + out + ")";
+            while (i < arguments.length)
+                out += "." + make_name(arguments[i++]);
+            return out;
+        },
+        "call": function(func, args) {
+            var f = make(func);
+            if (f.charAt(0) != "(" && needs_parens(func))
+                f = "(" + f + ")";
+            return f + "(" + add_commas(MAP(args, function(expr){
+                return parenthesize(expr, "seq");
+            })) + ")";
+        },
+        "function": make_function,
+        "defun": make_function,
+        "if": function(co, th, el) {
+            var out = [ "if", "(" + make(co) + ")", el ? make_then(th) : make(th) ];
+            if (el) {
+                out.push("else", make(el));
+            }
+            return add_spaces(out);
+        },
+        "for": function(init, cond, step, block) {
+            var out = [ "for" ];
+            init = (init != null ? make(init) : "").replace(/;*\s*$/, ";" + space);
+            cond = (cond != null ? make(cond) : "").replace(/;*\s*$/, ";" + space);
+            step = (step != null ? make(step) : "").replace(/;*\s*$/, "");
+            var args = init + cond + step;
+            if (args == "; ; ") args = ";;";
+            out.push("(" + args + ")", make(block));
+            return add_spaces(out);
+        },
+        "for-in": function(vvar, key, hash, block) {
+            return add_spaces([ "for", "(" +
+                                (vvar ? make(vvar).replace(/;+$/, "") : make(key)),
+                                "in",
+                                make(hash) + ")", make(block) ]);
+        },
+        "while": function(condition, block) {
+            return add_spaces([ "while", "(" + make(condition) + ")", make(block) ]);
+        },
+        "do": function(condition, block) {
+            return add_spaces([ "do", make(block), "while", "(" + make(condition) + ")" ]) + ";";
+        },
+        "return": function(expr) {
+            var out = [ "return" ];
+            if (expr != null) out.push(make(expr));
+            return add_spaces(out) + ";";
+        },
+        "binary": function(operator, lvalue, rvalue) {
+            var left = make(lvalue), right = make(rvalue);
+            // XXX: I'm pretty sure other cases will bite here.
+            //      we need to be smarter.
+            //      adding parens all the time is the safest bet.
+            if (member(lvalue[0], [ "assign", "conditional", "seq" ]) ||
+                lvalue[0] == "binary" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]] ||
+                lvalue[0] == "function" && needs_parens(this)) {
+                left = "(" + left + ")";
+            }
+            if (member(rvalue[0], [ "assign", "conditional", "seq" ]) ||
+                rvalue[0] == "binary" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&
+                !(rvalue[1] == operator && member(operator, [ "&&", "||", "*" ]))) {
+                right = "(" + right + ")";
+            }
+            else if (!beautify && options.inline_script && (operator == "<" || operator == "<<")
+                     && rvalue[0] == "regexp" && /^script/i.test(rvalue[1])) {
+                right = " " + right;
+            }
+            return add_spaces([ left, operator, right ]);
+        },
+        "unary-prefix": function(operator, expr) {
+            var val = make(expr);
+            if (!(expr[0] == "num" || (expr[0] == "unary-prefix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
+                val = "(" + val + ")";
+            return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? " " : "") + val;
+        },
+        "unary-postfix": function(operator, expr) {
+            var val = make(expr);
+            if (!(expr[0] == "num" || (expr[0] == "unary-postfix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
+                val = "(" + val + ")";
+            return val + operator;
+        },
+        "sub": function(expr, subscript) {
+            var hash = make(expr);
+            if (needs_parens(expr))
+                hash = "(" + hash + ")";
+            return hash + "[" + make(subscript) + "]";
+        },
+        "object": function(props) {
+            var obj_needs_parens = needs_parens(this);
+            if (props.length == 0)
+                return obj_needs_parens ? "({})" : "{}";
+            var out = "{" + newline + with_indent(function(){
+                return MAP(props, function(p){
+                    if (p.length == 3) {
+                        // getter/setter.  The name is in p[0], the arg.list in p[1][2], the
+                        // body in p[1][3] and type ("get" / "set") in p[2].
+                        return indent(make_function(p[0], p[1][2], p[1][3], p[2], true));
+                    }
+                    var key = p[0], val = parenthesize(p[1], "seq");
+                    if (options.quote_keys) {
+                        key = encode_string(key);
+                    } else if ((typeof key == "number" || !beautify && +key + "" == key)
+                               && parseFloat(key) >= 0) {
+                        key = make_num(+key);
+                    } else if (!is_identifier(key)) {
+                        key = encode_string(key);
+                    }
+                    return indent(add_spaces(beautify && options.space_colon
+                                             ? [ key, ":", val ]
+                                             : [ key + ":", val ]));
+                }).join("," + newline);
+            }) + newline + indent("}");
+            return obj_needs_parens ? "(" + out + ")" : out;
+        },
+        "regexp": function(rx, mods) {
+            if (options.ascii_only) rx = to_ascii(rx);
+            return "/" + rx + "/" + mods;
+        },
+        "array": function(elements) {
+            if (elements.length == 0) return "[]";
+            return add_spaces([ "[", add_commas(MAP(elements, function(el, i){
+                if (!beautify && el[0] == "atom" && el[1] == "undefined") return i === elements.length - 1 ? "," : "";
+                return parenthesize(el, "seq");
+            })), "]" ]);
+        },
+        "stat": function(stmt) {
+            return stmt != null
+                ? make(stmt).replace(/;*\s*$/, ";")
+                : ";";
+        },
+        "seq": function() {
+            return add_commas(MAP(slice(arguments), make));
+        },
+        "label": function(name, block) {
+            return add_spaces([ make_name(name), ":", make(block) ]);
+        },
+        "with": function(expr, block) {
+            return add_spaces([ "with", "(" + make(expr) + ")", make(block) ]);
+        },
+        "atom": function(name) {
+            return make_name(name);
+        },
+        "directive": function(dir) {
+            return make_string(dir) + ";";
+        }
+    }, function(){ return make(ast) });
+
+    // The squeezer replaces "block"-s that contain only a single
+    // statement with the statement itself; technically, the AST
+    // is correct, but this can create problems when we output an
+    // IF having an ELSE clause where the THEN clause ends in an
+    // IF *without* an ELSE block (then the outer ELSE would refer
+    // to the inner IF).  This function checks for this case and
+    // adds the block brackets if needed.
+    function make_then(th) {
+        if (th == null) return ";";
+        if (th[0] == "do") {
+            // https://github.com/mishoo/UglifyJS/issues/#issue/57
+            // IE croaks with "syntax error" on code like this:
+            //     if (foo) do ... while(cond); else ...
+            // we need block brackets around do/while
+            return make_block([ th ]);
+        }
+        var b = th;
+        while (true) {
+            var type = b[0];
+            if (type == "if") {
+                if (!b[3])
+                    // no else, we must add the block
+                    return make([ "block", [ th ]]);
+                b = b[3];
+            }
+            else if (type == "while" || type == "do") b = b[2];
+            else if (type == "for" || type == "for-in") b = b[4];
+            else break;
+        }
+        return make(th);
+    };
+
+    function make_function(name, args, body, keyword, no_parens) {
+        var out = keyword || "function";
+        if (name) {
+            out += " " + make_name(name);
+        }
+        out += "(" + add_commas(MAP(args, make_name)) + ")";
+        out = add_spaces([ out, make_block(body) ]);
+        return (!no_parens && needs_parens(this)) ? "(" + out + ")" : out;
+    };
+
+    function must_has_semicolon(node) {
+        switch (node[0]) {
+          case "with":
+          case "while":
+            return empty(node[2]) || must_has_semicolon(node[2]);
+          case "for":
+          case "for-in":
+            return empty(node[4]) || must_has_semicolon(node[4]);
+          case "if":
+            if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'
+            if (node[3]) {
+                if (empty(node[3])) return true; // `else' present but empty
+                return must_has_semicolon(node[3]); // dive into the `else' branch
+            }
+            return must_has_semicolon(node[2]); // dive into the `then' branch
+          case "directive":
+            return true;
+        }
+    };
+
+    function make_block_statements(statements, noindent) {
+        for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {
+            var stat = statements[i];
+            var code = make(stat);
+            if (code != ";") {
+                if (!beautify && i == last && !must_has_semicolon(stat)) {
+                    code = code.replace(/;+\s*$/, "");
+                }
+                a.push(code);
+            }
+        }
+        return noindent ? a : MAP(a, indent);
+    };
+
+    function make_switch_block(body) {
+        var n = body.length;
+        if (n == 0) return "{}";
+        return "{" + newline + MAP(body, function(branch, i){
+            var has_body = branch[1].length > 0, code = with_indent(function(){
+                return indent(branch[0]
+                              ? add_spaces([ "case", make(branch[0]) + ":" ])
+                              : "default:");
+            }, 0.5) + (has_body ? newline + with_indent(function(){
+                return make_block_statements(branch[1]).join(newline);
+            }) : "");
+            if (!beautify && has_body && i < n - 1)
+                code += ";";
+            return code;
+        }).join(newline) + newline + indent("}");
+    };
+
+    function make_block(statements) {
+        if (!statements) return ";";
+        if (statements.length == 0) return "{}";
+        return "{" + newline + with_indent(function(){
+            return make_block_statements(statements).join(newline);
+        }) + newline + indent("}");
+    };
+
+    function make_1vardef(def) {
+        var name = def[0], val = def[1];
+        if (val != null)
+            name = add_spaces([ make_name(name), "=", parenthesize(val, "seq") ]);
+        return name;
+    };
+
+};
+
+function split_lines(code, max_line_length) {
+    var splits = [ 0 ];
+    jsp.parse(function(){
+        var next_token = jsp.tokenizer(code);
+        var last_split = 0;
+        var prev_token;
+        function current_length(tok) {
+            return tok.pos - last_split;
+        };
+        function split_here(tok) {
+            last_split = tok.pos;
+            splits.push(last_split);
+        };
+        function custom(){
+            var tok = next_token.apply(this, arguments);
+            out: {
+                if (prev_token) {
+                    if (prev_token.type == "keyword") break out;
+                }
+                if (current_length(tok) > max_line_length) {
+                    switch (tok.type) {
+                      case "keyword":
+                      case "atom":
+                      case "name":
+                      case "punc":
+                        split_here(tok);
+                        break out;
+                    }
+                }
+            }
+            prev_token = tok;
+            return tok;
+        };
+        custom.context = function() {
+            return next_token.context.apply(this, arguments);
+        };
+        return custom;
+    }());
+    return splits.map(function(pos, i){
+        return code.substring(pos, splits[i + 1] || code.length);
+    }).join("\n");
+};
+
+/* -----[ Utilities ]----- */
+
+function repeat_string(str, i) {
+    if (i <= 0) return "";
+    if (i == 1) return str;
+    var d = repeat_string(str, i >> 1);
+    d += d;
+    if (i & 1) d += str;
+    return d;
+};
+
+function defaults(args, defs) {
+    var ret = {};
+    if (args === true)
+        args = {};
+    for (var i in defs) if (HOP(defs, i)) {
+        ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
+    }
+    return ret;
+};
+
+function is_identifier(name) {
+    return /^[a-z_$][a-z0-9_$]*$/i.test(name)
+        && name != "this"
+        && !HOP(jsp.KEYWORDS_ATOM, name)
+        && !HOP(jsp.RESERVED_WORDS, name)
+        && !HOP(jsp.KEYWORDS, name);
+};
+
+function HOP(obj, prop) {
+    return Object.prototype.hasOwnProperty.call(obj, prop);
+};
+
+// some utilities
+
+var MAP;
+
+(function(){
+    MAP = function(a, f, o) {
+        var ret = [], top = [], i;
+        function doit() {
+            var val = f.call(o, a[i], i);
+            if (val instanceof AtTop) {
+                val = val.v;
+                if (val instanceof Splice) {
+                    top.push.apply(top, val.v);
+                } else {
+                    top.push(val);
+                }
+            }
+            else if (val != skip) {
+                if (val instanceof Splice) {
+                    ret.push.apply(ret, val.v);
+                } else {
+                    ret.push(val);
+                }
+            }
+        };
+        if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();
+        else for (i in a) if (HOP(a, i)) doit();
+        return top.concat(ret);
+    };
+    MAP.at_top = function(val) { return new AtTop(val) };
+    MAP.splice = function(val) { return new Splice(val) };
+    var skip = MAP.skip = {};
+    function AtTop(val) { this.v = val };
+    function Splice(val) { this.v = val };
+})();
+
+/* -----[ Exports ]----- */
+
+exports.ast_walker = ast_walker;
+exports.ast_mangle = ast_mangle;
+exports.ast_squeeze = ast_squeeze;
+exports.ast_lift_variables = ast_lift_variables;
+exports.gen_code = gen_code;
+exports.ast_add_scope = ast_add_scope;
+exports.set_logger = function(logger) { warn = logger };
+exports.make_string = make_string;
+exports.split_lines = split_lines;
+exports.MAP = MAP;
+
+// keep this last!
+exports.ast_squeeze_more = require("./squeeze-more").ast_squeeze_more;
+
+// Local variables:
+// js-indent-level: 4
+// End:
+});
+define('uglifyjs/index', ["require", "exports", "module", "./parse-js", "./process", "./consolidator"], function(require, exports, module) {
+//convienence function(src, [options]);
+function uglify(orig_code, options){
+  options || (options = {});
+  var jsp = uglify.parser;
+  var pro = uglify.uglify;
+
+  var ast = jsp.parse(orig_code, options.strict_semicolons); // parse code and get the initial AST
+  ast = pro.ast_mangle(ast, options.mangle_options); // get a new AST with mangled names
+  ast = pro.ast_squeeze(ast, options.squeeze_options); // get an AST with compression optimizations
+  var final_code = pro.gen_code(ast, options.gen_options); // compressed code here
+  return final_code;
+};
+
+uglify.parser = require("./parse-js");
+uglify.uglify = require("./process");
+uglify.consolidator = require("./consolidator");
+
+module.exports = uglify
+});/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('source-map/array-set', function (require, exports, module) {
+
+  var util = require('./util');
+
+  /**
+   * A data structure which is a combination of an array and a set. Adding a new
+   * member is O(1), testing for membership is O(1), and finding the index of an
+   * element is O(1). Removing elements from the set is not supported. Only
+   * strings are supported for membership.
+   */
+  function ArraySet() {
+    this._array = [];
+    this._set = {};
+  }
+
+  /**
+   * Static method for creating ArraySet instances from an existing array.
+   */
+  ArraySet.fromArray = function ArraySet_fromArray(aArray) {
+    var set = new ArraySet();
+    for (var i = 0, len = aArray.length; i < len; i++) {
+      set.add(aArray[i]);
+    }
+    return set;
+  };
+
+  /**
+   * Add the given string to this set.
+   *
+   * @param String aStr
+   */
+  ArraySet.prototype.add = function ArraySet_add(aStr) {
+    if (this.has(aStr)) {
+      // Already a member; nothing to do.
+      return;
+    }
+    var idx = this._array.length;
+    this._array.push(aStr);
+    this._set[util.toSetString(aStr)] = idx;
+  };
+
+  /**
+   * Is the given string a member of this set?
+   *
+   * @param String aStr
+   */
+  ArraySet.prototype.has = function ArraySet_has(aStr) {
+    return Object.prototype.hasOwnProperty.call(this._set,
+                                                util.toSetString(aStr));
+  };
+
+  /**
+   * What is the index of the given string in the array?
+   *
+   * @param String aStr
+   */
+  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
+    if (this.has(aStr)) {
+      return this._set[util.toSetString(aStr)];
+    }
+    throw new Error('"' + aStr + '" is not in the set.');
+  };
+
+  /**
+   * What is the element at the given index?
+   *
+   * @param Number aIdx
+   */
+  ArraySet.prototype.at = function ArraySet_at(aIdx) {
+    if (aIdx >= 0 && aIdx < this._array.length) {
+      return this._array[aIdx];
+    }
+    throw new Error('No element indexed by ' + aIdx);
+  };
+
+  /**
+   * Returns the array representation of this set (which has the proper indices
+   * indicated by indexOf). Note that this is a copy of the internal array used
+   * for storing the members so that no one can mess with internal state.
+   */
+  ArraySet.prototype.toArray = function ArraySet_toArray() {
+    return this._array.slice();
+  };
+
+  exports.ArraySet = ArraySet;
+
+});
+/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ *
+ * Based on the Base 64 VLQ implementation in Closure Compiler:
+ * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
+ *
+ * Copyright 2011 The Closure Compiler Authors. All rights reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above
+ *    copyright notice, this list of conditions and the following
+ *    disclaimer in the documentation and/or other materials provided
+ *    with the distribution.
+ *  * Neither the name of Google Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+define('source-map/base64-vlq', function (require, exports, module) {
+
+  var base64 = require('./base64');
+
+  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
+  // length quantities we use in the source map spec, the first bit is the sign,
+  // the next four bits are the actual value, and the 6th bit is the
+  // continuation bit. The continuation bit tells us whether there are more
+  // digits in this value following this digit.
+  //
+  //   Continuation
+  //   |    Sign
+  //   |    |
+  //   V    V
+  //   101011
+
+  var VLQ_BASE_SHIFT = 5;
+
+  // binary: 100000
+  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
+
+  // binary: 011111
+  var VLQ_BASE_MASK = VLQ_BASE - 1;
+
+  // binary: 100000
+  var VLQ_CONTINUATION_BIT = VLQ_BASE;
+
+  /**
+   * Converts from a two-complement value to a value where the sign bit is
+   * is placed in the least significant bit.  For example, as decimals:
+   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
+   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
+   */
+  function toVLQSigned(aValue) {
+    return aValue < 0
+      ? ((-aValue) << 1) + 1
+      : (aValue << 1) + 0;
+  }
+
+  /**
+   * Converts to a two-complement value from a value where the sign bit is
+   * is placed in the least significant bit.  For example, as decimals:
+   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
+   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
+   */
+  function fromVLQSigned(aValue) {
+    var isNegative = (aValue & 1) === 1;
+    var shifted = aValue >> 1;
+    return isNegative
+      ? -shifted
+      : shifted;
+  }
+
+  /**
+   * Returns the base 64 VLQ encoded value.
+   */
+  exports.encode = function base64VLQ_encode(aValue) {
+    var encoded = "";
+    var digit;
+
+    var vlq = toVLQSigned(aValue);
+
+    do {
+      digit = vlq & VLQ_BASE_MASK;
+      vlq >>>= VLQ_BASE_SHIFT;
+      if (vlq > 0) {
+        // There are still more digits in this value, so we must make sure the
+        // continuation bit is marked.
+        digit |= VLQ_CONTINUATION_BIT;
+      }
+      encoded += base64.encode(digit);
+    } while (vlq > 0);
+
+    return encoded;
+  };
+
+  /**
+   * Decodes the next base 64 VLQ value from the given string and returns the
+   * value and the rest of the string.
+   */
+  exports.decode = function base64VLQ_decode(aStr) {
+    var i = 0;
+    var strLen = aStr.length;
+    var result = 0;
+    var shift = 0;
+    var continuation, digit;
+
+    do {
+      if (i >= strLen) {
+        throw new Error("Expected more digits in base 64 VLQ value.");
+      }
+      digit = base64.decode(aStr.charAt(i++));
+      continuation = !!(digit & VLQ_CONTINUATION_BIT);
+      digit &= VLQ_BASE_MASK;
+      result = result + (digit << shift);
+      shift += VLQ_BASE_SHIFT;
+    } while (continuation);
+
+    return {
+      value: fromVLQSigned(result),
+      rest: aStr.slice(i)
+    };
+  };
+
+});
+/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('source-map/base64', function (require, exports, module) {
+
+  var charToIntMap = {};
+  var intToCharMap = {};
+
+  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
+    .split('')
+    .forEach(function (ch, index) {
+      charToIntMap[ch] = index;
+      intToCharMap[index] = ch;
+    });
+
+  /**
+   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
+   */
+  exports.encode = function base64_encode(aNumber) {
+    if (aNumber in intToCharMap) {
+      return intToCharMap[aNumber];
+    }
+    throw new TypeError("Must be between 0 and 63: " + aNumber);
+  };
+
+  /**
+   * Decode a single base 64 digit to an integer.
+   */
+  exports.decode = function base64_decode(aChar) {
+    if (aChar in charToIntMap) {
+      return charToIntMap[aChar];
+    }
+    throw new TypeError("Not a valid base 64 digit: " + aChar);
+  };
+
+});
+/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('source-map/binary-search', function (require, exports, module) {
+
+  /**
+   * Recursive implementation of binary search.
+   *
+   * @param aLow Indices here and lower do not contain the needle.
+   * @param aHigh Indices here and higher do not contain the needle.
+   * @param aNeedle The element being searched for.
+   * @param aHaystack The non-empty array being searched.
+   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
+   */
+  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
+    // This function terminates when one of the following is true:
+    //
+    //   1. We find the exact element we are looking for.
+    //
+    //   2. We did not find the exact element, but we can return the next
+    //      closest element that is less than that element.
+    //
+    //   3. We did not find the exact element, and there is no next-closest
+    //      element which is less than the one we are searching for, so we
+    //      return null.
+    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
+    var cmp = aCompare(aNeedle, aHaystack[mid]);
+    if (cmp === 0) {
+      // Found the element we are looking for.
+      return aHaystack[mid];
+    }
+    else if (cmp > 0) {
+      // aHaystack[mid] is greater than our needle.
+      if (aHigh - mid > 1) {
+        // The element is in the upper half.
+        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
+      }
+      // We did not find an exact match, return the next closest one
+      // (termination case 2).
+      return aHaystack[mid];
+    }
+    else {
+      // aHaystack[mid] is less than our needle.
+      if (mid - aLow > 1) {
+        // The element is in the lower half.
+        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
+      }
+      // The exact needle element was not found in this haystack. Determine if
+      // we are in termination case (2) or (3) and return the appropriate thing.
+      return aLow < 0
+        ? null
+        : aHaystack[aLow];
+    }
+  }
+
+  /**
+   * This is an implementation of binary search which will always try and return
+   * the next lowest value checked if there is no exact hit. This is because
+   * mappings between original and generated line/col pairs are single points,
+   * and there is an implicit region between each of them, so a miss just means
+   * that you aren't on the very start of a region.
+   *
+   * @param aNeedle The element you are looking for.
+   * @param aHaystack The array that is being searched.
+   * @param aCompare A function which takes the needle and an element in the
+   *     array and returns -1, 0, or 1 depending on whether the needle is less
+   *     than, equal to, or greater than the element, respectively.
+   */
+  exports.search = function search(aNeedle, aHaystack, aCompare) {
+    return aHaystack.length > 0
+      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
+      : null;
+  };
+
+});
+/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('source-map/source-map-consumer', function (require, exports, module) {
+
+  var util = require('./util');
+  var binarySearch = require('./binary-search');
+  var ArraySet = require('./array-set').ArraySet;
+  var base64VLQ = require('./base64-vlq');
+
+  /**
+   * A SourceMapConsumer instance represents a parsed source map which we can
+   * query for information about the original file positions by giving it a file
+   * position in the generated source.
+   *
+   * The only parameter is the raw source map (either as a JSON string, or
+   * already parsed to an object). According to the spec, source maps have the
+   * following attributes:
+   *
+   *   - version: Which version of the source map spec this map is following.
+   *   - sources: An array of URLs to the original source files.
+   *   - names: An array of identifiers which can be referrenced by individual mappings.
+   *   - sourceRoot: Optional. The URL root from which all sources are relative.
+   *   - sourcesContent: Optional. An array of contents of the original source files.
+   *   - mappings: A string of base64 VLQs which contain the actual mappings.
+   *   - file: The generated file this source map is associated with.
+   *
+   * Here is an example source map, taken from the source map spec[0]:
+   *
+   *     {
+   *       version : 3,
+   *       file: "out.js",
+   *       sourceRoot : "",
+   *       sources: ["foo.js", "bar.js"],
+   *       names: ["src", "maps", "are", "fun"],
+   *       mappings: "AA,AB;;ABCDE;"
+   *     }
+   *
+   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
+   */
+  function SourceMapConsumer(aSourceMap) {
+    var sourceMap = aSourceMap;
+    if (typeof aSourceMap === 'string') {
+      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
+    }
+
+    var version = util.getArg(sourceMap, 'version');
+    var sources = util.getArg(sourceMap, 'sources');
+    var names = util.getArg(sourceMap, 'names');
+    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
+    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
+    var mappings = util.getArg(sourceMap, 'mappings');
+    var file = util.getArg(sourceMap, 'file');
+
+    if (version !== this._version) {
+      throw new Error('Unsupported version: ' + version);
+    }
+
+    this._names = ArraySet.fromArray(names);
+    this._sources = ArraySet.fromArray(sources);
+    this.sourceRoot = sourceRoot;
+    this.sourcesContent = sourcesContent;
+    this.file = file;
+
+    // `this._generatedMappings` and `this._originalMappings` hold the parsed
+    // mapping coordinates from the source map's "mappings" attribute. Each
+    // object in the array is of the form
+    //
+    //     {
+    //       generatedLine: The line number in the generated code,
+    //       generatedColumn: The column number in the generated code,
+    //       source: The path to the original source file that generated this
+    //               chunk of code,
+    //       originalLine: The line number in the original source that
+    //                     corresponds to this chunk of generated code,
+    //       originalColumn: The column number in the original source that
+    //                       corresponds to this chunk of generated code,
+    //       name: The name of the original symbol which generated this chunk of
+    //             code.
+    //     }
+    //
+    // All properties except for `generatedLine` and `generatedColumn` can be
+    // `null`.
+    //
+    // `this._generatedMappings` is ordered by the generated positions.
+    //
+    // `this._originalMappings` is ordered by the original positions.
+    this._generatedMappings = [];
+    this._originalMappings = [];
+    this._parseMappings(mappings, sourceRoot);
+  }
+
+  /**
+   * The version of the source mapping spec that we are consuming.
+   */
+  SourceMapConsumer.prototype._version = 3;
+
+  /**
+   * The list of original sources.
+   */
+  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
+    get: function () {
+      return this._sources.toArray().map(function (s) {
+        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
+      }, this);
+    }
+  });
+
+  /**
+   * Parse the mappings in a string in to a data structure which we can easily
+   * query (an ordered list in this._generatedMappings).
+   */
+  SourceMapConsumer.prototype._parseMappings =
+    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
+      var generatedLine = 1;
+      var previousGeneratedColumn = 0;
+      var previousOriginalLine = 0;
+      var previousOriginalColumn = 0;
+      var previousSource = 0;
+      var previousName = 0;
+      var mappingSeparator = /^[,;]/;
+      var str = aStr;
+      var mapping;
+      var temp;
+
+      while (str.length > 0) {
+        if (str.charAt(0) === ';') {
+          generatedLine++;
+          str = str.slice(1);
+          previousGeneratedColumn = 0;
+        }
+        else if (str.charAt(0) === ',') {
+          str = str.slice(1);
+        }
+        else {
+          mapping = {};
+          mapping.generatedLine = generatedLine;
+
+          // Generated column.
+          temp = base64VLQ.decode(str);
+          mapping.generatedColumn = previousGeneratedColumn + temp.value;
+          previousGeneratedColumn = mapping.generatedColumn;
+          str = temp.rest;
+
+          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
+            // Original source.
+            temp = base64VLQ.decode(str);
+            mapping.source = this._sources.at(previousSource + temp.value);
+            previousSource += temp.value;
+            str = temp.rest;
+            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
+              throw new Error('Found a source, but no line and column');
+            }
+
+            // Original line.
+            temp = base64VLQ.decode(str);
+            mapping.originalLine = previousOriginalLine + temp.value;
+            previousOriginalLine = mapping.originalLine;
+            // Lines are stored 0-based
+            mapping.originalLine += 1;
+            str = temp.rest;
+            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
+              throw new Error('Found a source and line, but no column');
+            }
+
+            // Original column.
+            temp = base64VLQ.decode(str);
+            mapping.originalColumn = previousOriginalColumn + temp.value;
+            previousOriginalColumn = mapping.originalColumn;
+            str = temp.rest;
+
+            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
+              // Original name.
+              temp = base64VLQ.decode(str);
+              mapping.name = this._names.at(previousName + temp.value);
+              previousName += temp.value;
+              str = temp.rest;
+            }
+          }
+
+          this._generatedMappings.push(mapping);
+          if (typeof mapping.originalLine === 'number') {
+            this._originalMappings.push(mapping);
+          }
+        }
+      }
+
+      this._originalMappings.sort(this._compareOriginalPositions);
+    };
+
+  /**
+   * Comparator between two mappings where the original positions are compared.
+   */
+  SourceMapConsumer.prototype._compareOriginalPositions =
+    function SourceMapConsumer_compareOriginalPositions(mappingA, mappingB) {
+      if (mappingA.source > mappingB.source) {
+        return 1;
+      }
+      else if (mappingA.source < mappingB.source) {
+        return -1;
+      }
+      else {
+        var cmp = mappingA.originalLine - mappingB.originalLine;
+        return cmp === 0
+          ? mappingA.originalColumn - mappingB.originalColumn
+          : cmp;
+      }
+    };
+
+  /**
+   * Comparator between two mappings where the generated positions are compared.
+   */
+  SourceMapConsumer.prototype._compareGeneratedPositions =
+    function SourceMapConsumer_compareGeneratedPositions(mappingA, mappingB) {
+      var cmp = mappingA.generatedLine - mappingB.generatedLine;
+      return cmp === 0
+        ? mappingA.generatedColumn - mappingB.generatedColumn
+        : cmp;
+    };
+
+  /**
+   * Find the mapping that best matches the hypothetical "needle" mapping that
+   * we are searching for in the given "haystack" of mappings.
+   */
+  SourceMapConsumer.prototype._findMapping =
+    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
+                                           aColumnName, aComparator) {
+      // To return the position we are searching for, we must first find the
+      // mapping for the given position and then return the opposite position it
+      // points to. Because the mappings are sorted, we can use binary search to
+      // find the best mapping.
+
+      if (aNeedle[aLineName] <= 0) {
+        throw new TypeError('Line must be greater than or equal to 1, got '
+                            + aNeedle[aLineName]);
+      }
+      if (aNeedle[aColumnName] < 0) {
+        throw new TypeError('Column must be greater than or equal to 0, got '
+                            + aNeedle[aColumnName]);
+      }
+
+      return binarySearch.search(aNeedle, aMappings, aComparator);
+    };
+
+  /**
+   * Returns the original source, line, and column information for the generated
+   * source's line and column positions provided. The only argument is an object
+   * with the following properties:
+   *
+   *   - line: The line number in the generated source.
+   *   - column: The column number in the generated source.
+   *
+   * and an object is returned with the following properties:
+   *
+   *   - source: The original source file, or null.
+   *   - line: The line number in the original source, or null.
+   *   - column: The column number in the original source, or null.
+   *   - name: The original identifier, or null.
+   */
+  SourceMapConsumer.prototype.originalPositionFor =
+    function SourceMapConsumer_originalPositionFor(aArgs) {
+      var needle = {
+        generatedLine: util.getArg(aArgs, 'line'),
+        generatedColumn: util.getArg(aArgs, 'column')
+      };
+
+      var mapping = this._findMapping(needle,
+                                      this._generatedMappings,
+                                      "generatedLine",
+                                      "generatedColumn",
+                                      this._compareGeneratedPositions);
+
+      if (mapping) {
+        var source = util.getArg(mapping, 'source', null);
+        if (source && this.sourceRoot) {
+          source = util.join(this.sourceRoot, source);
+        }
+        return {
+          source: source,
+          line: util.getArg(mapping, 'originalLine', null),
+          column: util.getArg(mapping, 'originalColumn', null),
+          name: util.getArg(mapping, 'name', null)
+        };
+      }
+
+      return {
+        source: null,
+        line: null,
+        column: null,
+        name: null
+      };
+    };
+
+  /**
+   * Returns the original source content. The only argument is
+   * the url of the original source file. Returns null if no
+   * original source content is availible.
+   */
+  SourceMapConsumer.prototype.sourceContentFor =
+    function SourceMapConsumer_sourceContentFor(aSource) {
+      if (!this.sourcesContent) {
+        return null;
+      }
+
+      if (this.sourceRoot) {
+        // Try to remove the sourceRoot
+        var relativeUrl = util.relative(this.sourceRoot, aSource);
+        if (this._sources.has(relativeUrl)) {
+          return this.sourcesContent[this._sources.indexOf(relativeUrl)];
+        }
+      }
+
+      if (this._sources.has(aSource)) {
+        return this.sourcesContent[this._sources.indexOf(aSource)];
+      }
+
+      throw new Error('"' + aSource + '" is not in the SourceMap.');
+    };
+
+  /**
+   * Returns the generated line and column information for the original source,
+   * line, and column positions provided. The only argument is an object with
+   * the following properties:
+   *
+   *   - source: The filename of the original source.
+   *   - line: The line number in the original source.
+   *   - column: The column number in the original source.
+   *
+   * and an object is returned with the following properties:
+   *
+   *   - line: The line number in the generated source, or null.
+   *   - column: The column number in the generated source, or null.
+   */
+  SourceMapConsumer.prototype.generatedPositionFor =
+    function SourceMapConsumer_generatedPositionFor(aArgs) {
+      var needle = {
+        source: util.getArg(aArgs, 'source'),
+        originalLine: util.getArg(aArgs, 'line'),
+        originalColumn: util.getArg(aArgs, 'column')
+      };
+
+      if (this.sourceRoot) {
+        needle.source = util.relative(this.sourceRoot, needle.source);
+      }
+
+      var mapping = this._findMapping(needle,
+                                      this._originalMappings,
+                                      "originalLine",
+                                      "originalColumn",
+                                      this._compareOriginalPositions);
+
+      if (mapping) {
+        return {
+          line: util.getArg(mapping, 'generatedLine', null),
+          column: util.getArg(mapping, 'generatedColumn', null)
+        };
+      }
+
+      return {
+        line: null,
+        column: null
+      };
+    };
+
+  SourceMapConsumer.GENERATED_ORDER = 1;
+  SourceMapConsumer.ORIGINAL_ORDER = 2;
+
+  /**
+   * Iterate over each mapping between an original source/line/column and a
+   * generated line/column in this source map.
+   *
+   * @param Function aCallback
+   *        The function that is called with each mapping.
+   * @param Object aContext
+   *        Optional. If specified, this object will be the value of `this` every
+   *        time that `aCallback` is called.
+   * @param aOrder
+   *        Either `SourceMapConsumer.GENERATED_ORDER` or
+   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
+   *        iterate over the mappings sorted by the generated file's line/column
+   *        order or the original's source/line/column order, respectively. Defaults to
+   *        `SourceMapConsumer.GENERATED_ORDER`.
+   */
+  SourceMapConsumer.prototype.eachMapping =
+    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
+      var context = aContext || null;
+      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
+
+      var mappings;
+      switch (order) {
+      case SourceMapConsumer.GENERATED_ORDER:
+        mappings = this._generatedMappings;
+        break;
+      case SourceMapConsumer.ORIGINAL_ORDER:
+        mappings = this._originalMappings;
+        break;
+      default:
+        throw new Error("Unknown order of iteration.");
+      }
+
+      var sourceRoot = this.sourceRoot;
+      mappings.map(function (mapping) {
+        var source = mapping.source;
+        if (source && sourceRoot) {
+          source = util.join(sourceRoot, source);
+        }
+        return {
+          source: source,
+          generatedLine: mapping.generatedLine,
+          generatedColumn: mapping.generatedColumn,
+          originalLine: mapping.originalLine,
+          originalColumn: mapping.originalColumn,
+          name: mapping.name
+        };
+      }).forEach(aCallback, context);
+    };
+
+  exports.SourceMapConsumer = SourceMapConsumer;
+
+});
+/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('source-map/source-map-generator', function (require, exports, module) {
+
+  var base64VLQ = require('./base64-vlq');
+  var util = require('./util');
+  var ArraySet = require('./array-set').ArraySet;
+
+  /**
+   * An instance of the SourceMapGenerator represents a source map which is
+   * being built incrementally. To create a new one, you must pass an object
+   * with the following properties:
+   *
+   *   - file: The filename of the generated source.
+   *   - sourceRoot: An optional root for all URLs in this source map.
+   */
+  function SourceMapGenerator(aArgs) {
+    this._file = util.getArg(aArgs, 'file');
+    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
+    this._sources = new ArraySet();
+    this._names = new ArraySet();
+    this._mappings = [];
+    this._sourcesContents = null;
+  }
+
+  SourceMapGenerator.prototype._version = 3;
+
+  /**
+   * Creates a new SourceMapGenerator based on a SourceMapConsumer
+   *
+   * @param aSourceMapConsumer The SourceMap.
+   */
+  SourceMapGenerator.fromSourceMap =
+    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
+      var sourceRoot = aSourceMapConsumer.sourceRoot;
+      var generator = new SourceMapGenerator({
+        file: aSourceMapConsumer.file,
+        sourceRoot: sourceRoot
+      });
+      aSourceMapConsumer.eachMapping(function (mapping) {
+        var newMapping = {
+          generated: {
+            line: mapping.generatedLine,
+            column: mapping.generatedColumn
+          }
+        };
+
+        if (mapping.source) {
+          newMapping.source = mapping.source;
+          if (sourceRoot) {
+            newMapping.source = util.relative(sourceRoot, newMapping.source);
+          }
+
+          newMapping.original = {
+            line: mapping.originalLine,
+            column: mapping.originalColumn
+          };
+
+          if (mapping.name) {
+            newMapping.name = mapping.name;
+          }
+        }
+
+        generator.addMapping(newMapping);
+      });
+      aSourceMapConsumer.sources.forEach(function (sourceFile) {
+        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
+        if (content) {
+          generator.setSourceContent(sourceFile, content);
+        }
+      });
+      return generator;
+    };
+
+  /**
+   * Add a single mapping from original source line and column to the generated
+   * source's line and column for this source map being created. The mapping
+   * object should have the following properties:
+   *
+   *   - generated: An object with the generated line and column positions.
+   *   - original: An object with the original line and column positions.
+   *   - source: The original source file (relative to the sourceRoot).
+   *   - name: An optional original token name for this mapping.
+   */
+  SourceMapGenerator.prototype.addMapping =
+    function SourceMapGenerator_addMapping(aArgs) {
+      var generated = util.getArg(aArgs, 'generated');
+      var original = util.getArg(aArgs, 'original', null);
+      var source = util.getArg(aArgs, 'source', null);
+      var name = util.getArg(aArgs, 'name', null);
+
+      this._validateMapping(generated, original, source, name);
+
+      if (source && !this._sources.has(source)) {
+        this._sources.add(source);
+      }
+
+      if (name && !this._names.has(name)) {
+        this._names.add(name);
+      }
+
+      this._mappings.push({
+        generated: generated,
+        original: original,
+        source: source,
+        name: name
+      });
+    };
+
+  /**
+   * Set the source content for a source file.
+   */
+  SourceMapGenerator.prototype.setSourceContent =
+    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
+      var source = aSourceFile;
+      if (this._sourceRoot) {
+        source = util.relative(this._sourceRoot, source);
+      }
+
+      if (aSourceContent !== null) {
+        // Add the source content to the _sourcesContents map.
+        // Create a new _sourcesContents map if the property is null.
+        if (!this._sourcesContents) {
+          this._sourcesContents = {};
+        }
+        this._sourcesContents[util.toSetString(source)] = aSourceContent;
+      } else {
+        // Remove the source file from the _sourcesContents map.
+        // If the _sourcesContents map is empty, set the property to null.
+        delete this._sourcesContents[util.toSetString(source)];
+        if (Object.keys(this._sourcesContents).length === 0) {
+          this._sourcesContents = null;
+        }
+      }
+    };
+
+  /**
+   * Applies the mappings of a sub-source-map for a specific source file to the
+   * source map being generated. Each mapping to the supplied source file is
+   * rewritten using the supplied source map. Note: The resolution for the
+   * resulting mappings is the minimium of this map and the supplied map.
+   *
+   * @param aSourceMapConsumer The source map to be applied.
+   * @param aSourceFile Optional. The filename of the source file.
+   *        If omitted, SourceMapConsumer's file property will be used.
+   */
+  SourceMapGenerator.prototype.applySourceMap =
+    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
+      // If aSourceFile is omitted, we will use the file property of the SourceMap
+      if (!aSourceFile) {
+        aSourceFile = aSourceMapConsumer.file;
+      }
+      var sourceRoot = this._sourceRoot;
+      // Make "aSourceFile" relative if an absolute Url is passed.
+      if (sourceRoot) {
+        aSourceFile = util.relative(sourceRoot, aSourceFile);
+      }
+      // Applying the SourceMap can add and remove items from the sources and
+      // the names array.
+      var newSources = new ArraySet();
+      var newNames = new ArraySet();
+
+      // Find mappings for the "aSourceFile"
+      this._mappings.forEach(function (mapping) {
+        if (mapping.source === aSourceFile && mapping.original) {
+          // Check if it can be mapped by the source map, then update the mapping.
+          var original = aSourceMapConsumer.originalPositionFor({
+            line: mapping.original.line,
+            column: mapping.original.column
+          });
+          if (original.source !== null) {
+            // Copy mapping
+            if (sourceRoot) {
+              mapping.source = util.relative(sourceRoot, original.source);
+            } else {
+              mapping.source = original.source;
+            }
+            mapping.original.line = original.line;
+            mapping.original.column = original.column;
+            if (original.name !== null && mapping.name !== null) {
+              // Only use the identifier name if it's an identifier
+              // in both SourceMaps
+              mapping.name = original.name;
+            }
+          }
+        }
+
+        var source = mapping.source;
+        if (source && !newSources.has(source)) {
+          newSources.add(source);
+        }
+
+        var name = mapping.name;
+        if (name && !newNames.has(name)) {
+          newNames.add(name);
+        }
+
+      }, this);
+      this._sources = newSources;
+      this._names = newNames;
+
+      // Copy sourcesContents of applied map.
+      aSourceMapConsumer.sources.forEach(function (sourceFile) {
+        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
+        if (content) {
+          if (sourceRoot) {
+            sourceFile = util.relative(sourceRoot, sourceFile);
+          }
+          this.setSourceContent(sourceFile, content);
+        }
+      }, this);
+    };
+
+  /**
+   * A mapping can have one of the three levels of data:
+   *
+   *   1. Just the generated position.
+   *   2. The Generated position, original position, and original source.
+   *   3. Generated and original position, original source, as well as a name
+   *      token.
+   *
+   * To maintain consistency, we validate that any new mapping being added falls
+   * in to one of these categories.
+   */
+  SourceMapGenerator.prototype._validateMapping =
+    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
+                                                aName) {
+      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
+          && aGenerated.line > 0 && aGenerated.column >= 0
+          && !aOriginal && !aSource && !aName) {
+        // Case 1.
+        return;
+      }
+      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
+               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
+               && aGenerated.line > 0 && aGenerated.column >= 0
+               && aOriginal.line > 0 && aOriginal.column >= 0
+               && aSource) {
+        // Cases 2 and 3.
+        return;
+      }
+      else {
+        throw new Error('Invalid mapping.');
+      }
+    };
+
+  function cmpLocation(loc1, loc2) {
+    var cmp = (loc1 && loc1.line) - (loc2 && loc2.line);
+    return cmp ? cmp : (loc1 && loc1.column) - (loc2 && loc2.column);
+  }
+
+  function strcmp(str1, str2) {
+    str1 = str1 || '';
+    str2 = str2 || '';
+    return (str1 > str2) - (str1 < str2);
+  }
+
+  function cmpMapping(mappingA, mappingB) {
+    return cmpLocation(mappingA.generated, mappingB.generated) ||
+      cmpLocation(mappingA.original, mappingB.original) ||
+      strcmp(mappingA.source, mappingB.source) ||
+      strcmp(mappingA.name, mappingB.name);
+  }
+
+  /**
+   * Serialize the accumulated mappings in to the stream of base 64 VLQs
+   * specified by the source map format.
+   */
+  SourceMapGenerator.prototype._serializeMappings =
+    function SourceMapGenerator_serializeMappings() {
+      var previousGeneratedColumn = 0;
+      var previousGeneratedLine = 1;
+      var previousOriginalColumn = 0;
+      var previousOriginalLine = 0;
+      var previousName = 0;
+      var previousSource = 0;
+      var result = '';
+      var mapping;
+
+      // The mappings must be guarenteed to be in sorted order before we start
+      // serializing them or else the generated line numbers (which are defined
+      // via the ';' separators) will be all messed up. Note: it might be more
+      // performant to maintain the sorting as we insert them, rather than as we
+      // serialize them, but the big O is the same either way.
+      this._mappings.sort(cmpMapping);
+
+      for (var i = 0, len = this._mappings.length; i < len; i++) {
+        mapping = this._mappings[i];
+
+        if (mapping.generated.line !== previousGeneratedLine) {
+          previousGeneratedColumn = 0;
+          while (mapping.generated.line !== previousGeneratedLine) {
+            result += ';';
+            previousGeneratedLine++;
+          }
+        }
+        else {
+          if (i > 0) {
+            if (!cmpMapping(mapping, this._mappings[i - 1])) {
+              continue;
+            }
+            result += ',';
+          }
+        }
+
+        result += base64VLQ.encode(mapping.generated.column
+                                   - previousGeneratedColumn);
+        previousGeneratedColumn = mapping.generated.column;
+
+        if (mapping.source && mapping.original) {
+          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
+                                     - previousSource);
+          previousSource = this._sources.indexOf(mapping.source);
+
+          // lines are stored 0-based in SourceMap spec version 3
+          result += base64VLQ.encode(mapping.original.line - 1
+                                     - previousOriginalLine);
+          previousOriginalLine = mapping.original.line - 1;
+
+          result += base64VLQ.encode(mapping.original.column
+                                     - previousOriginalColumn);
+          previousOriginalColumn = mapping.original.column;
+
+          if (mapping.name) {
+            result += base64VLQ.encode(this._names.indexOf(mapping.name)
+                                       - previousName);
+            previousName = this._names.indexOf(mapping.name);
+          }
+        }
+      }
+
+      return result;
+    };
+
+  /**
+   * Externalize the source map.
+   */
+  SourceMapGenerator.prototype.toJSON =
+    function SourceMapGenerator_toJSON() {
+      var map = {
+        version: this._version,
+        file: this._file,
+        sources: this._sources.toArray(),
+        names: this._names.toArray(),
+        mappings: this._serializeMappings()
+      };
+      if (this._sourceRoot) {
+        map.sourceRoot = this._sourceRoot;
+      }
+      if (this._sourcesContents) {
+        map.sourcesContent = map.sources.map(function (source) {
+          if (map.sourceRoot) {
+            source = util.relative(map.sourceRoot, source);
+          }
+          return Object.prototype.hasOwnProperty.call(
+            this._sourcesContents, util.toSetString(source))
+            ? this._sourcesContents[util.toSetString(source)]
+            : null;
+        }, this);
+      }
+      return map;
+    };
+
+  /**
+   * Render the source map being generated to a string.
+   */
+  SourceMapGenerator.prototype.toString =
+    function SourceMapGenerator_toString() {
+      return JSON.stringify(this);
+    };
+
+  exports.SourceMapGenerator = SourceMapGenerator;
+
+});
+/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('source-map/source-node', function (require, exports, module) {
+
+  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
+  var util = require('./util');
+
+  /**
+   * SourceNodes provide a way to abstract over interpolating/concatenating
+   * snippets of generated JavaScript source code while maintaining the line and
+   * column information associated with the original source code.
+   *
+   * @param aLine The original line number.
+   * @param aColumn The original column number.
+   * @param aSource The original source's filename.
+   * @param aChunks Optional. An array of strings which are snippets of
+   *        generated JS, or other SourceNodes.
+   * @param aName The original identifier.
+   */
+  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
+    this.children = [];
+    this.sourceContents = {};
+    this.line = aLine === undefined ? null : aLine;
+    this.column = aColumn === undefined ? null : aColumn;
+    this.source = aSource === undefined ? null : aSource;
+    this.name = aName === undefined ? null : aName;
+    if (aChunks != null) this.add(aChunks);
+  }
+
+  /**
+   * Creates a SourceNode from generated code and a SourceMapConsumer.
+   *
+   * @param aGeneratedCode The generated code
+   * @param aSourceMapConsumer The SourceMap for the generated code
+   */
+  SourceNode.fromStringWithSourceMap =
+    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
+      // The SourceNode we want to fill with the generated code
+      // and the SourceMap
+      var node = new SourceNode();
+
+      // The generated code
+      // Processed fragments are removed from this array.
+      var remainingLines = aGeneratedCode.split('\n');
+
+      // We need to remember the position of "remainingLines"
+      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
+
+      // The generate SourceNodes we need a code range.
+      // To extract it current and last mapping is used.
+      // Here we store the last mapping.
+      var lastMapping = null;
+
+      aSourceMapConsumer.eachMapping(function (mapping) {
+        if (lastMapping === null) {
+          // We add the generated code until the first mapping
+          // to the SourceNode without any mapping.
+          // Each line is added as separate string.
+          while (lastGeneratedLine < mapping.generatedLine) {
+            node.add(remainingLines.shift() + "\n");
+            lastGeneratedLine++;
+          }
+          if (lastGeneratedColumn < mapping.generatedColumn) {
+            var nextLine = remainingLines[0];
+            node.add(nextLine.substr(0, mapping.generatedColumn));
+            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
+            lastGeneratedColumn = mapping.generatedColumn;
+          }
+        } else {
+          // We add the code from "lastMapping" to "mapping":
+          // First check if there is a new line in between.
+          if (lastGeneratedLine < mapping.generatedLine) {
+            var code = "";
+            // Associate full lines with "lastMapping"
+            do {
+              code += remainingLines.shift() + "\n";
+              lastGeneratedLine++;
+              lastGeneratedColumn = 0;
+            } while (lastGeneratedLine < mapping.generatedLine);
+            // When we reached the correct line, we add code until we
+            // reach the correct column too.
+            if (lastGeneratedColumn < mapping.generatedColumn) {
+              var nextLine = remainingLines[0];
+              code += nextLine.substr(0, mapping.generatedColumn);
+              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
+              lastGeneratedColumn = mapping.generatedColumn;
+            }
+            // Create the SourceNode.
+            addMappingWithCode(lastMapping, code);
+          } else {
+            // There is no new line in between.
+            // Associate the code between "lastGeneratedColumn" and
+            // "mapping.generatedColumn" with "lastMapping"
+            var nextLine = remainingLines[0];
+            var code = nextLine.substr(0, mapping.generatedColumn -
+                                          lastGeneratedColumn);
+            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
+                                                lastGeneratedColumn);
+            lastGeneratedColumn = mapping.generatedColumn;
+            addMappingWithCode(lastMapping, code);
+          }
+        }
+        lastMapping = mapping;
+      }, this);
+      // We have processed all mappings.
+      // Associate the remaining code in the current line with "lastMapping"
+      // and add the remaining lines without any mapping
+      addMappingWithCode(lastMapping, remainingLines.join("\n"));
+
+      // Copy sourcesContent into SourceNode
+      aSourceMapConsumer.sources.forEach(function (sourceFile) {
+        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
+        if (content) {
+          node.setSourceContent(sourceFile, content);
+        }
+      });
+
+      return node;
+
+      function addMappingWithCode(mapping, code) {
+        if (mapping.source === undefined) {
+          node.add(code);
+        } else {
+          node.add(new SourceNode(mapping.originalLine,
+                                  mapping.originalColumn,
+                                  mapping.source,
+                                  code,
+                                  mapping.name));
+        }
+      }
+    };
+
+  /**
+   * Add a chunk of generated JS to this source node.
+   *
+   * @param aChunk A string snippet of generated JS code, another instance of
+   *        SourceNode, or an array where each member is one of those things.
+   */
+  SourceNode.prototype.add = function SourceNode_add(aChunk) {
+    if (Array.isArray(aChunk)) {
+      aChunk.forEach(function (chunk) {
+        this.add(chunk);
+      }, this);
+    }
+    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
+      if (aChunk) {
+        this.children.push(aChunk);
+      }
+    }
+    else {
+      throw new TypeError(
+        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
+      );
+    }
+    return this;
+  };
+
+  /**
+   * Add a chunk of generated JS to the beginning of this source node.
+   *
+   * @param aChunk A string snippet of generated JS code, another instance of
+   *        SourceNode, or an array where each member is one of those things.
+   */
+  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
+    if (Array.isArray(aChunk)) {
+      for (var i = aChunk.length-1; i >= 0; i--) {
+        this.prepend(aChunk[i]);
+      }
+    }
+    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
+      this.children.unshift(aChunk);
+    }
+    else {
+      throw new TypeError(
+        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
+      );
+    }
+    return this;
+  };
+
+  /**
+   * Walk over the tree of JS snippets in this node and its children. The
+   * walking function is called once for each snippet of JS and is passed that
+   * snippet and the its original associated source's line/column location.
+   *
+   * @param aFn The traversal function.
+   */
+  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
+    this.children.forEach(function (chunk) {
+      if (chunk instanceof SourceNode) {
+        chunk.walk(aFn);
+      }
+      else {
+        if (chunk !== '') {
+          aFn(chunk, { source: this.source,
+                       line: this.line,
+                       column: this.column,
+                       name: this.name });
+        }
+      }
+    }, this);
+  };
+
+  /**
+   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
+   * each of `this.children`.
+   *
+   * @param aSep The separator.
+   */
+  SourceNode.prototype.join = function SourceNode_join(aSep) {
+    var newChildren;
+    var i;
+    var len = this.children.length;
+    if (len > 0) {
+      newChildren = [];
+      for (i = 0; i < len-1; i++) {
+        newChildren.push(this.children[i]);
+        newChildren.push(aSep);
+      }
+      newChildren.push(this.children[i]);
+      this.children = newChildren;
+    }
+    return this;
+  };
+
+  /**
+   * Call String.prototype.replace on the very right-most source snippet. Useful
+   * for trimming whitespace from the end of a source node, etc.
+   *
+   * @param aPattern The pattern to replace.
+   * @param aReplacement The thing to replace the pattern with.
+   */
+  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
+    var lastChild = this.children[this.children.length - 1];
+    if (lastChild instanceof SourceNode) {
+      lastChild.replaceRight(aPattern, aReplacement);
+    }
+    else if (typeof lastChild === 'string') {
+      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
+    }
+    else {
+      this.children.push(''.replace(aPattern, aReplacement));
+    }
+    return this;
+  };
+
+  /**
+   * Set the source content for a source file. This will be added to the SourceMapGenerator
+   * in the sourcesContent field.
+   *
+   * @param aSourceFile The filename of the source file
+   * @param aSourceContent The content of the source file
+   */
+  SourceNode.prototype.setSourceContent =
+    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
+      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
+    };
+
+  /**
+   * Walk over the tree of SourceNodes. The walking function is called for each
+   * source file content and is passed the filename and source content.
+   *
+   * @param aFn The traversal function.
+   */
+  SourceNode.prototype.walkSourceContents =
+    function SourceNode_walkSourceContents(aFn) {
+      this.children.forEach(function (chunk) {
+        if (chunk instanceof SourceNode) {
+          chunk.walkSourceContents(aFn);
+        }
+      }, this);
+      Object.keys(this.sourceContents).forEach(function (sourceFileKey) {
+        aFn(util.fromSetString(sourceFileKey), this.sourceContents[sourceFileKey]);
+      }, this);
+    };
+
+  /**
+   * Return the string representation of this source node. Walks over the tree
+   * and concatenates all the various snippets together to one string.
+   */
+  SourceNode.prototype.toString = function SourceNode_toString() {
+    var str = "";
+    this.walk(function (chunk) {
+      str += chunk;
+    });
+    return str;
+  };
+
+  /**
+   * Returns the string representation of this source node along with a source
+   * map.
+   */
+  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
+    var generated = {
+      code: "",
+      line: 1,
+      column: 0
+    };
+    var map = new SourceMapGenerator(aArgs);
+    var sourceMappingActive = false;
+    this.walk(function (chunk, original) {
+      generated.code += chunk;
+      if (original.source !== null
+          && original.line !== null
+          && original.column !== null) {
+        map.addMapping({
+          source: original.source,
+          original: {
+            line: original.line,
+            column: original.column
+          },
+          generated: {
+            line: generated.line,
+            column: generated.column
+          },
+          name: original.name
+        });
+        sourceMappingActive = true;
+      } else if (sourceMappingActive) {
+        map.addMapping({
+          generated: {
+            line: generated.line,
+            column: generated.column
+          }
+        });
+        sourceMappingActive = false;
+      }
+      chunk.split('').forEach(function (ch) {
+        if (ch === '\n') {
+          generated.line++;
+          generated.column = 0;
+        } else {
+          generated.column++;
+        }
+      });
+    });
+    this.walkSourceContents(function (sourceFile, sourceContent) {
+      map.setSourceContent(sourceFile, sourceContent);
+    });
+
+    return { code: generated.code, map: map };
+  };
+
+  exports.SourceNode = SourceNode;
+
+});
+/* -*- Mode: js; js-indent-level: 2; -*- */
+/*
+ * Copyright 2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('source-map/util', function (require, exports, module) {
+
+  /**
+   * This is a helper function for getting values from parameter/options
+   * objects.
+   *
+   * @param args The object we are extracting values from
+   * @param name The name of the property we are getting.
+   * @param defaultValue An optional value to return if the property is missing
+   * from the object. If this is not specified and the property is missing, an
+   * error will be thrown.
+   */
+  function getArg(aArgs, aName, aDefaultValue) {
+    if (aName in aArgs) {
+      return aArgs[aName];
+    } else if (arguments.length === 3) {
+      return aDefaultValue;
+    } else {
+      throw new Error('"' + aName + '" is a required argument.');
+    }
+  }
+  exports.getArg = getArg;
+
+  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
+
+  function urlParse(aUrl) {
+    var match = aUrl.match(urlRegexp);
+    if (!match) {
+      return null;
+    }
+    return {
+      scheme: match[1],
+      auth: match[3],
+      host: match[4],
+      port: match[6],
+      path: match[7]
+    };
+  }
+
+  function join(aRoot, aPath) {
+    var url;
+
+    if (aPath.match(urlRegexp)) {
+      return aPath;
+    }
+
+    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
+      return aRoot.replace(url.path, '') + aPath;
+    }
+
+    return aRoot.replace(/\/$/, '') + '/' + aPath;
+  }
+  exports.join = join;
+
+  /**
+   * Because behavior goes wacky when you set `__proto__` on objects, we
+   * have to prefix all the strings in our set with an arbitrary character.
+   *
+   * See https://github.com/mozilla/source-map/pull/31 and
+   * https://github.com/mozilla/source-map/issues/30
+   *
+   * @param String aStr
+   */
+  function toSetString(aStr) {
+    return '$' + aStr;
+  }
+  exports.toSetString = toSetString;
+
+  function fromSetString(aStr) {
+    return aStr.substr(1);
+  }
+  exports.fromSetString = fromSetString;
+
+  function relative(aRoot, aPath) {
+    aRoot = aRoot.replace(/\/$/, '');
+    return aPath.indexOf(aRoot + '/') === 0
+      ? aPath.substr(aRoot.length + 1)
+      : aPath;
+  }
+  exports.relative = relative;
+
+});
+define('source-map', function (require, exports, module) {
+
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
+exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
+exports.SourceNode = require('./source-map/source-node').SourceNode;
+
+});
+
+//Distributed under the BSD license:
+//Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
+define('uglifyjs2', ['exports', 'source-map', 'logger', 'env!env/file'], function (exports, MOZ_SourceMap, logger, rjsFile) {
+(function(exports, global) {
+    global["UglifyJS"] = exports;
+    "use strict";
+    function array_to_hash(a) {
+        var ret = Object.create(null);
+        for (var i = 0; i < a.length; ++i) ret[a[i]] = true;
+        return ret;
+    }
+    function slice(a, start) {
+        return Array.prototype.slice.call(a, start || 0);
+    }
+    function characters(str) {
+        return str.split("");
+    }
+    function member(name, array) {
+        for (var i = array.length; --i >= 0; ) if (array[i] == name) return true;
+        return false;
+    }
+    function find_if(func, array) {
+        for (var i = 0, n = array.length; i < n; ++i) {
+            if (func(array[i])) return array[i];
+        }
+    }
+    function repeat_string(str, i) {
+        if (i <= 0) return "";
+        if (i == 1) return str;
+        var d = repeat_string(str, i >> 1);
+        d += d;
+        if (i & 1) d += str;
+        return d;
+    }
+    function DefaultsError(msg, defs) {
+        this.msg = msg;
+        this.defs = defs;
+    }
+    function defaults(args, defs, croak) {
+        if (args === true) args = {};
+        var ret = args || {};
+        if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i)) throw new DefaultsError("`" + i + "` is not a supported option", defs);
+        for (var i in defs) if (defs.hasOwnProperty(i)) {
+            ret[i] = args && args.hasOwnProperty(i) ? args[i] : defs[i];
+        }
+        return ret;
+    }
+    function merge(obj, ext) {
+        for (var i in ext) if (ext.hasOwnProperty(i)) {
+            obj[i] = ext[i];
+        }
+        return obj;
+    }
+    function noop() {}
+    var MAP = function() {
+        function MAP(a, f, backwards) {
+            var ret = [], top = [], i;
+            function doit() {
+                var val = f(a[i], i);
+                var is_last = val instanceof Last;
+                if (is_last) val = val.v;
+                if (val instanceof AtTop) {
+                    val = val.v;
+                    if (val instanceof Splice) {
+                        top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
+                    } else {
+                        top.push(val);
+                    }
+                } else if (val !== skip) {
+                    if (val instanceof Splice) {
+                        ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
+                    } else {
+                        ret.push(val);
+                    }
+                }
+                return is_last;
+            }
+            if (a instanceof Array) {
+                if (backwards) {
+                    for (i = a.length; --i >= 0; ) if (doit()) break;
+                    ret.reverse();
+                    top.reverse();
+                } else {
+                    for (i = 0; i < a.length; ++i) if (doit()) break;
+                }
+            } else {
+                for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;
+            }
+            return top.concat(ret);
+        }
+        MAP.at_top = function(val) {
+            return new AtTop(val);
+        };
+        MAP.splice = function(val) {
+            return new Splice(val);
+        };
+        MAP.last = function(val) {
+            return new Last(val);
+        };
+        var skip = MAP.skip = {};
+        function AtTop(val) {
+            this.v = val;
+        }
+        function Splice(val) {
+            this.v = val;
+        }
+        function Last(val) {
+            this.v = val;
+        }
+        return MAP;
+    }();
+    function push_uniq(array, el) {
+        if (array.indexOf(el) < 0) array.push(el);
+    }
+    function string_template(text, props) {
+        return text.replace(/\{(.+?)\}/g, function(str, p) {
+            return props[p];
+        });
+    }
+    function remove(array, el) {
+        for (var i = array.length; --i >= 0; ) {
+            if (array[i] === el) array.splice(i, 1);
+        }
+    }
+    function mergeSort(array, cmp) {
+        if (array.length < 2) return array.slice();
+        function merge(a, b) {
+            var r = [], ai = 0, bi = 0, i = 0;
+            while (ai < a.length && bi < b.length) {
+                cmp(a[ai], b[bi]) <= 0 ? r[i++] = a[ai++] : r[i++] = b[bi++];
+            }
+            if (ai < a.length) r.push.apply(r, a.slice(ai));
+            if (bi < b.length) r.push.apply(r, b.slice(bi));
+            return r;
+        }
+        function _ms(a) {
+            if (a.length <= 1) return a;
+            var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
+            left = _ms(left);
+            right = _ms(right);
+            return merge(left, right);
+        }
+        return _ms(array);
+    }
+    function set_difference(a, b) {
+        return a.filter(function(el) {
+            return b.indexOf(el) < 0;
+        });
+    }
+    function set_intersection(a, b) {
+        return a.filter(function(el) {
+            return b.indexOf(el) >= 0;
+        });
+    }
+    function makePredicate(words) {
+        if (!(words instanceof Array)) words = words.split(" ");
+        var f = "", cats = [];
+        out: for (var i = 0; i < words.length; ++i) {
+            for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
+                cats[j].push(words[i]);
+                continue out;
+            }
+            cats.push([ words[i] ]);
+        }
+        function compareTo(arr) {
+            if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
+            f += "switch(str){";
+            for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
+            f += "return true}return false;";
+        }
+        if (cats.length > 3) {
+            cats.sort(function(a, b) {
+                return b.length - a.length;
+            });
+            f += "switch(str.length){";
+            for (var i = 0; i < cats.length; ++i) {
+                var cat = cats[i];
+                f += "case " + cat[0].length + ":";
+                compareTo(cat);
+            }
+            f += "}";
+        } else {
+            compareTo(words);
+        }
+        return new Function("str", f);
+    }
+    function Dictionary() {
+        this._values = Object.create(null);
+        this._size = 0;
+    }
+    Dictionary.prototype = {
+        set: function(key, val) {
+            if (!this.has(key)) ++this._size;
+            this._values["$" + key] = val;
+            return this;
+        },
+        add: function(key, val) {
+            if (this.has(key)) {
+                this.get(key).push(val);
+            } else {
+                this.set(key, [ val ]);
+            }
+            return this;
+        },
+        get: function(key) {
+            return this._values["$" + key];
+        },
+        del: function(key) {
+            if (this.has(key)) {
+                --this._size;
+                delete this._values["$" + key];
+            }
+            return this;
+        },
+        has: function(key) {
+            return "$" + key in this._values;
+        },
+        each: function(f) {
+            for (var i in this._values) f(this._values[i], i.substr(1));
+        },
+        size: function() {
+            return this._size;
+        },
+        map: function(f) {
+            var ret = [];
+            for (var i in this._values) ret.push(f(this._values[i], i.substr(1)));
+            return ret;
+        }
+    };
+    "use strict";
+    function DEFNODE(type, props, methods, base) {
+        if (arguments.length < 4) base = AST_Node;
+        if (!props) props = []; else props = props.split(/\s+/);
+        var self_props = props;
+        if (base && base.PROPS) props = props.concat(base.PROPS);
+        var code = "return function AST_" + type + "(props){ if (props) { ";
+        for (var i = props.length; --i >= 0; ) {
+            code += "this." + props[i] + " = props." + props[i] + ";";
+        }
+        var proto = base && new base();
+        if (proto && proto.initialize || methods && methods.initialize) code += "this.initialize();";
+        code += "}}";
+        var ctor = new Function(code)();
+        if (proto) {
+            ctor.prototype = proto;
+            ctor.BASE = base;
+        }
+        if (base) base.SUBCLASSES.push(ctor);
+        ctor.prototype.CTOR = ctor;
+        ctor.PROPS = props || null;
+        ctor.SELF_PROPS = self_props;
+        ctor.SUBCLASSES = [];
+        if (type) {
+            ctor.prototype.TYPE = ctor.TYPE = type;
+        }
+        if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {
+            if (/^\$/.test(i)) {
+                ctor[i.substr(1)] = methods[i];
+            } else {
+                ctor.prototype[i] = methods[i];
+            }
+        }
+        ctor.DEFMETHOD = function(name, method) {
+            this.prototype[name] = method;
+        };
+        return ctor;
+    }
+    var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {}, null);
+    var AST_Node = DEFNODE("Node", "start end", {
+        clone: function() {
+            return new this.CTOR(this);
+        },
+        $documentation: "Base class of all AST nodes",
+        $propdoc: {
+            start: "[AST_Token] The first token of this node",
+            end: "[AST_Token] The last token of this node"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this);
+        },
+        walk: function(visitor) {
+            return this._walk(visitor);
+        }
+    }, null);
+    AST_Node.warn_function = null;
+    AST_Node.warn = function(txt, props) {
+        if (AST_Node.warn_function) AST_Node.warn_function(string_template(txt, props));
+    };
+    var AST_Statement = DEFNODE("Statement", null, {
+        $documentation: "Base class of all statements"
+    });
+    var AST_Debugger = DEFNODE("Debugger", null, {
+        $documentation: "Represents a debugger statement"
+    }, AST_Statement);
+    var AST_Directive = DEFNODE("Directive", "value scope", {
+        $documentation: 'Represents a directive, like "use strict";',
+        $propdoc: {
+            value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
+            scope: "[AST_Scope/S] The scope that this directive affects"
+        }
+    }, AST_Statement);
+    var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
+        $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
+        $propdoc: {
+            body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.body._walk(visitor);
+            });
+        }
+    }, AST_Statement);
+    function walk_body(node, visitor) {
+        if (node.body instanceof AST_Statement) {
+            node.body._walk(visitor);
+        } else node.body.forEach(function(stat) {
+            stat._walk(visitor);
+        });
+    }
+    var AST_Block = DEFNODE("Block", "body", {
+        $documentation: "A body of statements (usually bracketed)",
+        $propdoc: {
+            body: "[AST_Statement*] an array of statements"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                walk_body(this, visitor);
+            });
+        }
+    }, AST_Statement);
+    var AST_BlockStatement = DEFNODE("BlockStatement", null, {
+        $documentation: "A block statement"
+    }, AST_Block);
+    var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
+        $documentation: "The empty statement (empty block or simply a semicolon)",
+        _walk: function(visitor) {
+            return visitor._visit(this);
+        }
+    }, AST_Statement);
+    var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
+        $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
+        $propdoc: {
+            body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.body._walk(visitor);
+            });
+        }
+    }, AST_Statement);
+    var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
+        $documentation: "Statement with a label",
+        $propdoc: {
+            label: "[AST_Label] a label definition"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.label._walk(visitor);
+                this.body._walk(visitor);
+            });
+        }
+    }, AST_StatementWithBody);
+    var AST_DWLoop = DEFNODE("DWLoop", "condition", {
+        $documentation: "Base class for do/while statements",
+        $propdoc: {
+            condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.condition._walk(visitor);
+                this.body._walk(visitor);
+            });
+        }
+    }, AST_StatementWithBody);
+    var AST_Do = DEFNODE("Do", null, {
+        $documentation: "A `do` statement"
+    }, AST_DWLoop);
+    var AST_While = DEFNODE("While", null, {
+        $documentation: "A `while` statement"
+    }, AST_DWLoop);
+    var AST_For = DEFNODE("For", "init condition step", {
+        $documentation: "A `for` statement",
+        $propdoc: {
+            init: "[AST_Node?] the `for` initialization code, or null if empty",
+            condition: "[AST_Node?] the `for` termination clause, or null if empty",
+            step: "[AST_Node?] the `for` update clause, or null if empty"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                if (this.init) this.init._walk(visitor);
+                if (this.condition) this.condition._walk(visitor);
+                if (this.step) this.step._walk(visitor);
+                this.body._walk(visitor);
+            });
+        }
+    }, AST_StatementWithBody);
+    var AST_ForIn = DEFNODE("ForIn", "init name object", {
+        $documentation: "A `for ... in` statement",
+        $propdoc: {
+            init: "[AST_Node] the `for/in` initialization code",
+            name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
+            object: "[AST_Node] the object that we're looping through"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.init._walk(visitor);
+                this.object._walk(visitor);
+                this.body._walk(visitor);
+            });
+        }
+    }, AST_StatementWithBody);
+    var AST_With = DEFNODE("With", "expression", {
+        $documentation: "A `with` statement",
+        $propdoc: {
+            expression: "[AST_Node] the `with` expression"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.expression._walk(visitor);
+                this.body._walk(visitor);
+            });
+        }
+    }, AST_StatementWithBody);
+    var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
+        $documentation: "Base class for all statements introducing a lexical scope",
+        $propdoc: {
+            directives: "[string*/S] an array of directives declared in this scope",
+            variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
+            functions: "[Object/S] like `variables`, but only lists function declarations",
+            uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
+            uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
+            parent_scope: "[AST_Scope?/S] link to the parent scope",
+            enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
+            cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
+        }
+    }, AST_Block);
+    var AST_Toplevel = DEFNODE("Toplevel", "globals", {
+        $documentation: "The toplevel scope",
+        $propdoc: {
+            globals: "[Object/S] a map of name -> SymbolDef for all undeclared names"
+        },
+        wrap_enclose: function(arg_parameter_pairs) {
+            var self = this;
+            var args = [];
+            var parameters = [];
+            arg_parameter_pairs.forEach(function(pair) {
+                var split = pair.split(":");
+                args.push(split[0]);
+                parameters.push(split[1]);
+            });
+            var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
+            wrapped_tl = parse(wrapped_tl);
+            wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
+                if (node instanceof AST_Directive && node.value == "$ORIG") {
+                    return MAP.splice(self.body);
+                }
+            }));
+            return wrapped_tl;
+        },
+        wrap_commonjs: function(name, export_all) {
+            var self = this;
+            var to_export = [];
+            if (export_all) {
+                self.figure_out_scope();
+                self.walk(new TreeWalker(function(node) {
+                    if (node instanceof AST_SymbolDeclaration && node.definition().global) {
+                        if (!find_if(function(n) {
+                            return n.name == node.name;
+                        }, to_export)) to_export.push(node);
+                    }
+                }));
+            }
+            var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
+            wrapped_tl = parse(wrapped_tl);
+            wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
+                if (node instanceof AST_SimpleStatement) {
+                    node = node.body;
+                    if (node instanceof AST_String) switch (node.getValue()) {
+                      case "$ORIG":
+                        return MAP.splice(self.body);
+
+                      case "$EXPORTS":
+                        var body = [];
+                        to_export.forEach(function(sym) {
+                            body.push(new AST_SimpleStatement({
+                                body: new AST_Assign({
+                                    left: new AST_Sub({
+                                        expression: new AST_SymbolRef({
+                                            name: "exports"
+                                        }),
+                                        property: new AST_String({
+                                            value: sym.name
+                                        })
+                                    }),
+                                    operator: "=",
+                                    right: new AST_SymbolRef(sym)
+                                })
+                            }));
+                        });
+                        return MAP.splice(body);
+                    }
+                }
+            }));
+            return wrapped_tl;
+        }
+    }, AST_Scope);
+    var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
+        $documentation: "Base class for functions",
+        $propdoc: {
+            name: "[AST_SymbolDeclaration?] the name of this function",
+            argnames: "[AST_SymbolFunarg*] array of function arguments",
+            uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                if (this.name) this.name._walk(visitor);
+                this.argnames.forEach(function(arg) {
+                    arg._walk(visitor);
+                });
+                walk_body(this, visitor);
+            });
+        }
+    }, AST_Scope);
+    var AST_Accessor = DEFNODE("Accessor", null, {
+        $documentation: "A setter/getter function"
+    }, AST_Lambda);
+    var AST_Function = DEFNODE("Function", null, {
+        $documentation: "A function expression"
+    }, AST_Lambda);
+    var AST_Defun = DEFNODE("Defun", null, {
+        $documentation: "A function definition"
+    }, AST_Lambda);
+    var AST_Jump = DEFNODE("Jump", null, {
+        $documentation: "Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)"
+    }, AST_Statement);
+    var AST_Exit = DEFNODE("Exit", "value", {
+        $documentation: "Base class for exits (`return` and `throw`)",
+        $propdoc: {
+            value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, this.value && function() {
+                this.value._walk(visitor);
+            });
+        }
+    }, AST_Jump);
+    var AST_Return = DEFNODE("Return", null, {
+        $documentation: "A `return` statement"
+    }, AST_Exit);
+    var AST_Throw = DEFNODE("Throw", null, {
+        $documentation: "A `throw` statement"
+    }, AST_Exit);
+    var AST_LoopControl = DEFNODE("LoopControl", "label", {
+        $documentation: "Base class for loop control statements (`break` and `continue`)",
+        $propdoc: {
+            label: "[AST_LabelRef?] the label, or null if none"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, this.label && function() {
+                this.label._walk(visitor);
+            });
+        }
+    }, AST_Jump);
+    var AST_Break = DEFNODE("Break", null, {
+        $documentation: "A `break` statement"
+    }, AST_LoopControl);
+    var AST_Continue = DEFNODE("Continue", null, {
+        $documentation: "A `continue` statement"
+    }, AST_LoopControl);
+    var AST_If = DEFNODE("If", "condition alternative", {
+        $documentation: "A `if` statement",
+        $propdoc: {
+            condition: "[AST_Node] the `if` condition",
+            alternative: "[AST_Statement?] the `else` part, or null if not present"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.condition._walk(visitor);
+                this.body._walk(visitor);
+                if (this.alternative) this.alternative._walk(visitor);
+            });
+        }
+    }, AST_StatementWithBody);
+    var AST_Switch = DEFNODE("Switch", "expression", {
+        $documentation: "A `switch` statement",
+        $propdoc: {
+            expression: "[AST_Node] the `switch` discriminant"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.expression._walk(visitor);
+                walk_body(this, visitor);
+            });
+        }
+    }, AST_Block);
+    var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
+        $documentation: "Base class for `switch` branches"
+    }, AST_Block);
+    var AST_Default = DEFNODE("Default", null, {
+        $documentation: "A `default` switch branch"
+    }, AST_SwitchBranch);
+    var AST_Case = DEFNODE("Case", "expression", {
+        $documentation: "A `case` switch branch",
+        $propdoc: {
+            expression: "[AST_Node] the `case` expression"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.expression._walk(visitor);
+                walk_body(this, visitor);
+            });
+        }
+    }, AST_SwitchBranch);
+    var AST_Try = DEFNODE("Try", "bcatch bfinally", {
+        $documentation: "A `try` statement",
+        $propdoc: {
+            bcatch: "[AST_Catch?] the catch block, or null if not present",
+            bfinally: "[AST_Finally?] the finally block, or null if not present"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                walk_body(this, visitor);
+                if (this.bcatch) this.bcatch._walk(visitor);
+                if (this.bfinally) this.bfinally._walk(visitor);
+            });
+        }
+    }, AST_Block);
+    var AST_Catch = DEFNODE("Catch", "argname", {
+        $documentation: "A `catch` node; only makes sense as part of a `try` statement",
+        $propdoc: {
+            argname: "[AST_SymbolCatch] symbol for the exception"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.argname._walk(visitor);
+                walk_body(this, visitor);
+            });
+        }
+    }, AST_Block);
+    var AST_Finally = DEFNODE("Finally", null, {
+        $documentation: "A `finally` node; only makes sense as part of a `try` statement"
+    }, AST_Block);
+    var AST_Definitions = DEFNODE("Definitions", "definitions", {
+        $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
+        $propdoc: {
+            definitions: "[AST_VarDef*] array of variable definitions"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.definitions.forEach(function(def) {
+                    def._walk(visitor);
+                });
+            });
+        }
+    }, AST_Statement);
+    var AST_Var = DEFNODE("Var", null, {
+        $documentation: "A `var` statement"
+    }, AST_Definitions);
+    var AST_Const = DEFNODE("Const", null, {
+        $documentation: "A `const` statement"
+    }, AST_Definitions);
+    var AST_VarDef = DEFNODE("VarDef", "name value", {
+        $documentation: "A variable declaration; only appears in a AST_Definitions node",
+        $propdoc: {
+            name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
+            value: "[AST_Node?] initializer, or null of there's no initializer"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.name._walk(visitor);
+                if (this.value) this.value._walk(visitor);
+            });
+        }
+    });
+    var AST_Call = DEFNODE("Call", "expression args", {
+        $documentation: "A function call expression",
+        $propdoc: {
+            expression: "[AST_Node] expression to invoke as function",
+            args: "[AST_Node*] array of arguments"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.expression._walk(visitor);
+                this.args.forEach(function(arg) {
+                    arg._walk(visitor);
+                });
+            });
+        }
+    });
+    var AST_New = DEFNODE("New", null, {
+        $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
+    }, AST_Call);
+    var AST_Seq = DEFNODE("Seq", "car cdr", {
+        $documentation: "A sequence expression (two comma-separated expressions)",
+        $propdoc: {
+            car: "[AST_Node] first element in sequence",
+            cdr: "[AST_Node] second element in sequence"
+        },
+        $cons: function(x, y) {
+            var seq = new AST_Seq(x);
+            seq.car = x;
+            seq.cdr = y;
+            return seq;
+        },
+        $from_array: function(array) {
+            if (array.length == 0) return null;
+            if (array.length == 1) return array[0].clone();
+            var list = null;
+            for (var i = array.length; --i >= 0; ) {
+                list = AST_Seq.cons(array[i], list);
+            }
+            var p = list;
+            while (p) {
+                if (p.cdr && !p.cdr.cdr) {
+                    p.cdr = p.cdr.car;
+                    break;
+                }
+                p = p.cdr;
+            }
+            return list;
+        },
+        to_array: function() {
+            var p = this, a = [];
+            while (p) {
+                a.push(p.car);
+                if (p.cdr && !(p.cdr instanceof AST_Seq)) {
+                    a.push(p.cdr);
+                    break;
+                }
+                p = p.cdr;
+            }
+            return a;
+        },
+        add: function(node) {
+            var p = this;
+            while (p) {
+                if (!(p.cdr instanceof AST_Seq)) {
+                    var cell = AST_Seq.cons(p.cdr, node);
+                    return p.cdr = cell;
+                }
+                p = p.cdr;
+            }
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.car._walk(visitor);
+                if (this.cdr) this.cdr._walk(visitor);
+            });
+        }
+    });
+    var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
+        $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
+        $propdoc: {
+            expression: "[AST_Node] the container expression",
+            property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
+        }
+    });
+    var AST_Dot = DEFNODE("Dot", null, {
+        $documentation: "A dotted property access expression",
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.expression._walk(visitor);
+            });
+        }
+    }, AST_PropAccess);
+    var AST_Sub = DEFNODE("Sub", null, {
+        $documentation: 'Index-style property access, i.e. `a["foo"]`',
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.expression._walk(visitor);
+                this.property._walk(visitor);
+            });
+        }
+    }, AST_PropAccess);
+    var AST_Unary = DEFNODE("Unary", "operator expression", {
+        $documentation: "Base class for unary expressions",
+        $propdoc: {
+            operator: "[string] the operator",
+            expression: "[AST_Node] expression that this unary operator applies to"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.expression._walk(visitor);
+            });
+        }
+    });
+    var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
+        $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
+    }, AST_Unary);
+    var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
+        $documentation: "Unary postfix expression, i.e. `i++`"
+    }, AST_Unary);
+    var AST_Binary = DEFNODE("Binary", "left operator right", {
+        $documentation: "Binary expression, i.e. `a + b`",
+        $propdoc: {
+            left: "[AST_Node] left-hand side expression",
+            operator: "[string] the operator",
+            right: "[AST_Node] right-hand side expression"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.left._walk(visitor);
+                this.right._walk(visitor);
+            });
+        }
+    });
+    var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
+        $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
+        $propdoc: {
+            condition: "[AST_Node]",
+            consequent: "[AST_Node]",
+            alternative: "[AST_Node]"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.condition._walk(visitor);
+                this.consequent._walk(visitor);
+                this.alternative._walk(visitor);
+            });
+        }
+    });
+    var AST_Assign = DEFNODE("Assign", null, {
+        $documentation: "An assignment expression  `a = b + 5`"
+    }, AST_Binary);
+    var AST_Array = DEFNODE("Array", "elements", {
+        $documentation: "An array literal",
+        $propdoc: {
+            elements: "[AST_Node*] array of elements"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.elements.forEach(function(el) {
+                    el._walk(visitor);
+                });
+            });
+        }
+    });
+    var AST_Object = DEFNODE("Object", "properties", {
+        $documentation: "An object literal",
+        $propdoc: {
+            properties: "[AST_ObjectProperty*] array of properties"
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.properties.forEach(function(prop) {
+                    prop._walk(visitor);
+                });
+            });
+        }
+    });
+    var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
+        $documentation: "Base class for literal object properties",
+        $propdoc: {
+            key: "[string] the property name; it's always a plain string in our AST, no matter if it was a string, number or identifier in original code",
+            value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
+        },
+        _walk: function(visitor) {
+            return visitor._visit(this, function() {
+                this.value._walk(visitor);
+            });
+        }
+    });
+    var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
+        $documentation: "A key: value object property"
+    }, AST_ObjectProperty);
+    var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
+        $documentation: "An object setter property"
+    }, AST_ObjectProperty);
+    var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
+        $documentation: "An object getter property"
+    }, AST_ObjectProperty);
+    var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
+        $propdoc: {
+            name: "[string] name of this symbol",
+            scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
+            thedef: "[SymbolDef/S] the definition of this symbol"
+        },
+        $documentation: "Base class for all symbols"
+    });
+    var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
+        $documentation: "The name of a property accessor (setter/getter function)"
+    }, AST_Symbol);
+    var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
+        $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
+        $propdoc: {
+            init: "[AST_Node*/S] array of initializers for this declaration."
+        }
+    }, AST_Symbol);
+    var AST_SymbolVar = DEFNODE("SymbolVar", null, {
+        $documentation: "Symbol defining a variable"
+    }, AST_SymbolDeclaration);
+    var AST_SymbolConst = DEFNODE("SymbolConst", null, {
+        $documentation: "A constant declaration"
+    }, AST_SymbolDeclaration);
+    var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
+        $documentation: "Symbol naming a function argument"
+    }, AST_SymbolVar);
+    var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
+        $documentation: "Symbol defining a function"
+    }, AST_SymbolDeclaration);
+    var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
+        $documentation: "Symbol naming a function expression"
+    }, AST_SymbolDeclaration);
+    var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
+        $documentation: "Symbol naming the exception in catch"
+    }, AST_SymbolDeclaration);
+    var AST_Label = DEFNODE("Label", "references", {
+        $documentation: "Symbol naming a label (declaration)",
+        $propdoc: {
+            references: "[AST_LabelRef*] a list of nodes referring to this label"
+        }
+    }, AST_Symbol);
+    var AST_SymbolRef = DEFNODE("SymbolRef", null, {
+        $documentation: "Reference to some symbol (not definition/declaration)"
+    }, AST_Symbol);
+    var AST_LabelRef = DEFNODE("LabelRef", null, {
+        $documentation: "Reference to a label symbol"
+    }, AST_Symbol);
+    var AST_This = DEFNODE("This", null, {
+        $documentation: "The `this` symbol"
+    }, AST_Symbol);
+    var AST_Constant = DEFNODE("Constant", null, {
+        $documentation: "Base class for all constants",
+        getValue: function() {
+            return this.value;
+        }
+    });
+    var AST_String = DEFNODE("String", "value", {
+        $documentation: "A string literal",
+        $propdoc: {
+            value: "[string] the contents of this string"
+        }
+    }, AST_Constant);
+    var AST_Number = DEFNODE("Number", "value", {
+        $documentation: "A number literal",
+        $propdoc: {
+            value: "[number] the numeric value"
+        }
+    }, AST_Constant);
+    var AST_RegExp = DEFNODE("RegExp", "value", {
+        $documentation: "A regexp literal",
+        $propdoc: {
+            value: "[RegExp] the actual regexp"
+        }
+    }, AST_Constant);
+    var AST_Atom = DEFNODE("Atom", null, {
+        $documentation: "Base class for atoms"
+    }, AST_Constant);
+    var AST_Null = DEFNODE("Null", null, {
+        $documentation: "The `null` atom",
+        value: null
+    }, AST_Atom);
+    var AST_NaN = DEFNODE("NaN", null, {
+        $documentation: "The impossible value",
+        value: 0 / 0
+    }, AST_Atom);
+    var AST_Undefined = DEFNODE("Undefined", null, {
+        $documentation: "The `undefined` value",
+        value: function() {}()
+    }, AST_Atom);
+    var AST_Hole = DEFNODE("Hole", null, {
+        $documentation: "A hole in an array",
+        value: function() {}()
+    }, AST_Atom);
+    var AST_Infinity = DEFNODE("Infinity", null, {
+        $documentation: "The `Infinity` value",
+        value: 1 / 0
+    }, AST_Atom);
+    var AST_Boolean = DEFNODE("Boolean", null, {
+        $documentation: "Base class for booleans"
+    }, AST_Atom);
+    var AST_False = DEFNODE("False", null, {
+        $documentation: "The `false` atom",
+        value: false
+    }, AST_Boolean);
+    var AST_True = DEFNODE("True", null, {
+        $documentation: "The `true` atom",
+        value: true
+    }, AST_Boolean);
+    function TreeWalker(callback) {
+        this.visit = callback;
+        this.stack = [];
+    }
+    TreeWalker.prototype = {
+        _visit: function(node, descend) {
+            this.stack.push(node);
+            var ret = this.visit(node, descend ? function() {
+                descend.call(node);
+            } : noop);
+            if (!ret && descend) {
+                descend.call(node);
+            }
+            this.stack.pop();
+            return ret;
+        },
+        parent: function(n) {
+            return this.stack[this.stack.length - 2 - (n || 0)];
+        },
+        push: function(node) {
+            this.stack.push(node);
+        },
+        pop: function() {
+            return this.stack.pop();
+        },
+        self: function() {
+            return this.stack[this.stack.length - 1];
+        },
+        find_parent: function(type) {
+            var stack = this.stack;
+            for (var i = stack.length; --i >= 0; ) {
+                var x = stack[i];
+                if (x instanceof type) return x;
+            }
+        },
+        in_boolean_context: function() {
+            var stack = this.stack;
+            var i = stack.length, self = stack[--i];
+            while (i > 0) {
+                var p = stack[--i];
+                if (p instanceof AST_If && p.condition === self || p instanceof AST_Conditional && p.condition === self || p instanceof AST_DWLoop && p.condition === self || p instanceof AST_For && p.condition === self || p instanceof AST_UnaryPrefix && p.operator == "!" && p.expression === self) {
+                    return true;
+                }
+                if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||"))) return false;
+                self = p;
+            }
+        },
+        loopcontrol_target: function(label) {
+            var stack = this.stack;
+            if (label) {
+                for (var i = stack.length; --i >= 0; ) {
+                    var x = stack[i];
+                    if (x instanceof AST_LabeledStatement && x.label.name == label.name) {
+                        return x.body;
+                    }
+                }
+            } else {
+                for (var i = stack.length; --i >= 0; ) {
+                    var x = stack[i];
+                    if (x instanceof AST_Switch || x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) return x;
+                }
+            }
+        }
+    };
+    "use strict";
+    var KEYWORDS = "break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with";
+    var KEYWORDS_ATOM = "false null true";
+    var RESERVED_WORDS = "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile" + " " + KEYWORDS_ATOM + " " + KEYWORDS;
+    var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case";
+    KEYWORDS = makePredicate(KEYWORDS);
+    RESERVED_WORDS = makePredicate(RESERVED_WORDS);
+    KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
+    KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
+    var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
+    var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
+    var RE_OCT_NUMBER = /^0[0-7]+$/;
+    var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
+    var OPERATORS = makePredicate([ "in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||" ]);
+    var WHITESPACE_CHARS = makePredicate(characters("  \n\r	\f "));
+    var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));
+    var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
+    var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));
+    var UNICODE = {
+        letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
+        non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
+        space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
+        connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
+    };
+    function is_letter(code) {
+        return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));
+    }
+    function is_digit(code) {
+        return code >= 48 && code <= 57;
+    }
+    function is_alphanumeric_char(code) {
+        return is_digit(code) || is_letter(code);
+    }
+    function is_unicode_combining_mark(ch) {
+        return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
+    }
+    function is_unicode_connector_punctuation(ch) {
+        return UNICODE.connector_punctuation.test(ch);
+    }
+    function is_identifier(name) {
+        return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
+    }
+    function is_identifier_start(code) {
+        return code == 36 || code == 95 || is_letter(code);
+    }
+    function is_identifier_char(ch) {
+        var code = ch.charCodeAt(0);
+        return is_identifier_start(code) || is_digit(code) || code == 8204 || code == 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);
+    }
+    function is_identifier_string(str) {
+        var i = str.length;
+        if (i == 0) return false;
+        while (--i >= 0) {
+            if (!is_identifier_char(str.charAt(i))) return false;
+        }
+        return true;
+    }
+    function parse_js_number(num) {
+        if (RE_HEX_NUMBER.test(num)) {
+            return parseInt(num.substr(2), 16);
+        } else if (RE_OCT_NUMBER.test(num)) {
+            return parseInt(num.substr(1), 8);
+        } else if (RE_DEC_NUMBER.test(num)) {
+            return parseFloat(num);
+        }
+    }
+    function JS_Parse_Error(message, line, col, pos) {
+        this.message = message;
+        this.line = line;
+        this.col = col;
+        this.pos = pos;
+        this.stack = new Error().stack;
+    }
+    JS_Parse_Error.prototype.toString = function() {
+        return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
+    };
+    function js_error(message, filename, line, col, pos) {
+        throw new JS_Parse_Error(message, line, col, pos);
+    }
+    function is_token(token, type, val) {
+        return token.type == type && (val == null || token.value == val);
+    }
+    var EX_EOF = {};
+    function tokenizer($TEXT, filename) {
+        var S = {
+            text: $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""),
+            filename: filename,
+            pos: 0,
+            tokpos: 0,
+            line: 1,
+            tokline: 0,
+            col: 0,
+            tokcol: 0,
+            newline_before: false,
+            regex_allowed: false,
+            comments_before: []
+        };
+        function peek() {
+            return S.text.charAt(S.pos);
+        }
+        function next(signal_eof, in_string) {
+            var ch = S.text.charAt(S.pos++);
+            if (signal_eof && !ch) throw EX_EOF;
+            if (ch == "\n") {
+                S.newline_before = S.newline_before || !in_string;
+                ++S.line;
+                S.col = 0;
+            } else {
+                ++S.col;
+            }
+            return ch;
+        }
+        function find(what, signal_eof) {
+            var pos = S.text.indexOf(what, S.pos);
+            if (signal_eof && pos == -1) throw EX_EOF;
+            return pos;
+        }
+        function start_token() {
+            S.tokline = S.line;
+            S.tokcol = S.col;
+            S.tokpos = S.pos;
+        }
+        function token(type, value, is_comment) {
+            S.regex_allowed = type == "operator" && !UNARY_POSTFIX[value] || type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value) || type == "punc" && PUNC_BEFORE_EXPRESSION(value);
+            var ret = {
+                type: type,
+                value: value,
+                line: S.tokline,
+                col: S.tokcol,
+                pos: S.tokpos,
+                endpos: S.pos,
+                nlb: S.newline_before,
+                file: filename
+            };
+            if (!is_comment) {
+                ret.comments_before = S.comments_before;
+                S.comments_before = [];
+                for (var i = 0, len = ret.comments_before.length; i < len; i++) {
+                    ret.nlb = ret.nlb || ret.comments_before[i].nlb;
+                }
+            }
+            S.newline_before = false;
+            return new AST_Token(ret);
+        }
+        function skip_whitespace() {
+            while (WHITESPACE_CHARS(peek())) next();
+        }
+        function read_while(pred) {
+            var ret = "", ch, i = 0;
+            while ((ch = peek()) && pred(ch, i++)) ret += next();
+            return ret;
+        }
+        function parse_error(err) {
+            js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
+        }
+        function read_num(prefix) {
+            var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
+            var num = read_while(function(ch, i) {
+                var code = ch.charCodeAt(0);
+                switch (code) {
+                  case 120:
+                  case 88:
+                    return has_x ? false : has_x = true;
+
+                  case 101:
+                  case 69:
+                    return has_x ? true : has_e ? false : has_e = after_e = true;
+
+                  case 45:
+                    return after_e || i == 0 && !prefix;
+
+                  case 43:
+                    return after_e;
+
+                  case after_e = false, 46:
+                    return !has_dot && !has_x && !has_e ? has_dot = true : false;
+                }
+                return is_alphanumeric_char(code);
+            });
+            if (prefix) num = prefix + num;
+            var valid = parse_js_number(num);
+            if (!isNaN(valid)) {
+                return token("num", valid);
+            } else {
+                parse_error("Invalid syntax: " + num);
+            }
+        }
+        function read_escaped_char(in_string) {
+            var ch = next(true, in_string);
+            switch (ch.charCodeAt(0)) {
+              case 110:
+                return "\n";
+
+              case 114:
+                return "\r";
+
+              case 116:
+                return "	";
+
+              case 98:
+                return "\b";
+
+              case 118:
+                return "";
+
+              case 102:
+                return "\f";
+
+              case 48:
+                return "\0";
+
+              case 120:
+                return String.fromCharCode(hex_bytes(2));
+
+              case 117:
+                return String.fromCharCode(hex_bytes(4));
+
+              case 10:
+                return "";
+
+              default:
+                return ch;
+            }
+        }
+        function hex_bytes(n) {
+            var num = 0;
+            for (;n > 0; --n) {
+                var digit = parseInt(next(true), 16);
+                if (isNaN(digit)) parse_error("Invalid hex-character pattern in string");
+                num = num << 4 | digit;
+            }
+            return num;
+        }
+        var read_string = with_eof_error("Unterminated string constant", function() {
+            var quote = next(), ret = "";
+            for (;;) {
+                var ch = next(true);
+                if (ch == "\\") {
+                    var octal_len = 0, first = null;
+                    ch = read_while(function(ch) {
+                        if (ch >= "0" && ch <= "7") {
+                            if (!first) {
+                                first = ch;
+                                return ++octal_len;
+                            } else if (first <= "3" && octal_len <= 2) return ++octal_len; else if (first >= "4" && octal_len <= 1) return ++octal_len;
+                        }
+                        return false;
+                    });
+                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8)); else ch = read_escaped_char(true);
+                } else if (ch == quote) break;
+                ret += ch;
+            }
+            return token("string", ret);
+        });
+        function read_line_comment() {
+            next();
+            var i = find("\n"), ret;
+            if (i == -1) {
+                ret = S.text.substr(S.pos);
+                S.pos = S.text.length;
+            } else {
+                ret = S.text.substring(S.pos, i);
+                S.pos = i;
+            }
+            return token("comment1", ret, true);
+        }
+        var read_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
+            next();
+            var i = find("*/", true);
+            var text = S.text.substring(S.pos, i);
+            var a = text.split("\n"), n = a.length;
+            S.pos = i + 2;
+            S.line += n - 1;
+            if (n > 1) S.col = a[n - 1].length; else S.col += a[n - 1].length;
+            S.col += 2;
+            S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
+            return token("comment2", text, true);
+        });
+        function read_name() {
+            var backslash = false, name = "", ch, escaped = false, hex;
+            while ((ch = peek()) != null) {
+                if (!backslash) {
+                    if (ch == "\\") escaped = backslash = true, next(); else if (is_identifier_char(ch)) name += next(); else break;
+                } else {
+                    if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
+                    ch = read_escaped_char();
+                    if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
+                    name += ch;
+                    backslash = false;
+                }
+            }
+            if (KEYWORDS(name) && escaped) {
+                hex = name.charCodeAt(0).toString(16).toUpperCase();
+                name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
+            }
+            return name;
+        }
+        var read_regexp = with_eof_error("Unterminated regular expression", function(regexp) {
+            var prev_backslash = false, ch, in_class = false;
+            while (ch = next(true)) if (prev_backslash) {
+                regexp += "\\" + ch;
+                prev_backslash = false;
+            } else if (ch == "[") {
+                in_class = true;
+                regexp += ch;
+            } else if (ch == "]" && in_class) {
+                in_class = false;
+                regexp += ch;
+            } else if (ch == "/" && !in_class) {
+                break;
+            } else if (ch == "\\") {
+                prev_backslash = true;
+            } else {
+                regexp += ch;
+            }
+            var mods = read_name();
+            return token("regexp", new RegExp(regexp, mods));
+        });
+        function read_operator(prefix) {
+            function grow(op) {
+                if (!peek()) return op;
+                var bigger = op + peek();
+                if (OPERATORS(bigger)) {
+                    next();
+                    return grow(bigger);
+                } else {
+                    return op;
+                }
+            }
+            return token("operator", grow(prefix || next()));
+        }
+        function handle_slash() {
+            next();
+            var regex_allowed = S.regex_allowed;
+            switch (peek()) {
+              case "/":
+                S.comments_before.push(read_line_comment());
+                S.regex_allowed = regex_allowed;
+                return next_token();
+
+              case "*":
+                S.comments_before.push(read_multiline_comment());
+                S.regex_allowed = regex_allowed;
+                return next_token();
+            }
+            return S.regex_allowed ? read_regexp("") : read_operator("/");
+        }
+        function handle_dot() {
+            next();
+            return is_digit(peek().charCodeAt(0)) ? read_num(".") : token("punc", ".");
+        }
+        function read_word() {
+            var word = read_name();
+            return KEYWORDS_ATOM(word) ? token("atom", word) : !KEYWORDS(word) ? token("name", word) : OPERATORS(word) ? token("operator", word) : token("keyword", word);
+        }
+        function with_eof_error(eof_error, cont) {
+            return function(x) {
+                try {
+                    return cont(x);
+                } catch (ex) {
+                    if (ex === EX_EOF) parse_error(eof_error); else throw ex;
+                }
+            };
+        }
+        function next_token(force_regexp) {
+            if (force_regexp != null) return read_regexp(force_regexp);
+            skip_whitespace();
+            start_token();
+            var ch = peek();
+            if (!ch) return token("eof");
+            var code = ch.charCodeAt(0);
+            switch (code) {
+              case 34:
+              case 39:
+                return read_string();
+
+              case 46:
+                return handle_dot();
+
+              case 47:
+                return handle_slash();
+            }
+            if (is_digit(code)) return read_num();
+            if (PUNC_CHARS(ch)) return token("punc", next());
+            if (OPERATOR_CHARS(ch)) return read_operator();
+            if (code == 92 || is_identifier_start(code)) return read_word();
+            parse_error("Unexpected character '" + ch + "'");
+        }
+        next_token.context = function(nc) {
+            if (nc) S = nc;
+            return S;
+        };
+        return next_token;
+    }
+    var UNARY_PREFIX = makePredicate([ "typeof", "void", "delete", "--", "++", "!", "~", "-", "+" ]);
+    var UNARY_POSTFIX = makePredicate([ "--", "++" ]);
+    var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);
+    var PRECEDENCE = function(a, ret) {
+        for (var i = 0, n = 1; i < a.length; ++i, ++n) {
+            var b = a[i];
+            for (var j = 0; j < b.length; ++j) {
+                ret[b[j]] = n;
+            }
+        }
+        return ret;
+    }([ [ "||" ], [ "&&" ], [ "|" ], [ "^" ], [ "&" ], [ "==", "===", "!=", "!==" ], [ "<", ">", "<=", ">=", "in", "instanceof" ], [ ">>", "<<", ">>>" ], [ "+", "-" ], [ "*", "/", "%" ] ], {});
+    var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);
+    var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);
+    function parse($TEXT, options) {
+        options = defaults(options, {
+            strict: false,
+            filename: null,
+            toplevel: null
+        });
+        var S = {
+            input: typeof $TEXT == "string" ? tokenizer($TEXT, options.filename) : $TEXT,
+            token: null,
+            prev: null,
+            peeked: null,
+            in_function: 0,
+            in_directives: true,
+            in_loop: 0,
+            labels: []
+        };
+        S.token = next();
+        function is(type, value) {
+            return is_token(S.token, type, value);
+        }
+        function peek() {
+            return S.peeked || (S.peeked = S.input());
+        }
+        function next() {
+            S.prev = S.token;
+            if (S.peeked) {
+                S.token = S.peeked;
+                S.peeked = null;
+            } else {
+                S.token = S.input();
+            }
+            S.in_directives = S.in_directives && (S.token.type == "string" || is("punc", ";"));
+            return S.token;
+        }
+        function prev() {
+            return S.prev;
+        }
+        function croak(msg, line, col, pos) {
+            var ctx = S.input.context();
+            js_error(msg, ctx.filename, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos != null ? pos : ctx.tokpos);
+        }
+        function token_error(token, msg) {
+            croak(msg, token.line, token.col);
+        }
+        function unexpected(token) {
+            if (token == null) token = S.token;
+            token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
+        }
+        function expect_token(type, val) {
+            if (is(type, val)) {
+                return next();
+            }
+            token_error(S.token, "Unexpected token " + S.token.type + " " + S.token.value + "" + ", expected " + type + " " + val + "");
+        }
+        function expect(punc) {
+            return expect_token("punc", punc);
+        }
+        function can_insert_semicolon() {
+            return !options.strict && (S.token.nlb || is("eof") || is("punc", "}"));
+        }
+        function semicolon() {
+            if (is("punc", ";")) next(); else if (!can_insert_semicolon()) unexpected();
+        }
+        function parenthesised() {
+            expect("(");
+            var exp = expression(true);
+            expect(")");
+            return exp;
+        }
+        function embed_tokens(parser) {
+            return function() {
+                var start = S.token;
+                var expr = parser();
+                var end = prev();
+                expr.start = start;
+                expr.end = end;
+                return expr;
+            };
+        }
+        var statement = embed_tokens(function() {
+            var tmp;
+            if (is("operator", "/") || is("operator", "/=")) {
+                S.peeked = null;
+                S.token = S.input(S.token.value.substr(1));
+            }
+            switch (S.token.type) {
+              case "string":
+                var dir = S.in_directives, stat = simple_statement();
+                if (dir && stat.body instanceof AST_String && !is("punc", ",")) return new AST_Directive({
+                    value: stat.body.value
+                });
+                return stat;
+
+              case "num":
+              case "regexp":
+              case "operator":
+              case "atom":
+                return simple_statement();
+
+              case "name":
+                return is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement();
+
+              case "punc":
+                switch (S.token.value) {
+                  case "{":
+                    return new AST_BlockStatement({
+                        start: S.token,
+                        body: block_(),
+                        end: prev()
+                    });
+
+                  case "[":
+                  case "(":
+                    return simple_statement();
+
+                  case ";":
+                    next();
+                    return new AST_EmptyStatement();
+
+                  default:
+                    unexpected();
+                }
+
+              case "keyword":
+                switch (tmp = S.token.value, next(), tmp) {
+                  case "break":
+                    return break_cont(AST_Break);
+
+                  case "continue":
+                    return break_cont(AST_Continue);
+
+                  case "debugger":
+                    semicolon();
+                    return new AST_Debugger();
+
+                  case "do":
+                    return new AST_Do({
+                        body: in_loop(statement),
+                        condition: (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(), 
+                        tmp)
+                    });
+
+                  case "while":
+                    return new AST_While({
+                        condition: parenthesised(),
+                        body: in_loop(statement)
+                    });
+
+                  case "for":
+                    return for_();
+
+                  case "function":
+                    return function_(true);
+
+                  case "if":
+                    return if_();
+
+                  case "return":
+                    if (S.in_function == 0) croak("'return' outside of function");
+                    return new AST_Return({
+                        value: is("punc", ";") ? (next(), null) : can_insert_semicolon() ? null : (tmp = expression(true), 
+                        semicolon(), tmp)
+                    });
+
+                  case "switch":
+                    return new AST_Switch({
+                        expression: parenthesised(),
+                        body: in_loop(switch_body_)
+                    });
+
+                  case "throw":
+                    if (S.token.nlb) croak("Illegal newline after 'throw'");
+                    return new AST_Throw({
+                        value: (tmp = expression(true), semicolon(), tmp)
+                    });
+
+                  case "try":
+                    return try_();
+
+                  case "var":
+                    return tmp = var_(), semicolon(), tmp;
+
+                  case "const":
+                    return tmp = const_(), semicolon(), tmp;
+
+                  case "with":
+                    return new AST_With({
+                        expression: parenthesised(),
+                        body: statement()
+                    });
+
+                  default:
+                    unexpected();
+                }
+            }
+        });
+        function labeled_statement() {
+            var label = as_symbol(AST_Label);
+            if (find_if(function(l) {
+                return l.name == label.name;
+            }, S.labels)) {
+                croak("Label " + label.name + " defined twice");
+            }
+            expect(":");
+            S.labels.push(label);
+            var stat = statement();
+            S.labels.pop();
+            return new AST_LabeledStatement({
+                body: stat,
+                label: label
+            });
+        }
+        function simple_statement(tmp) {
+            return new AST_SimpleStatement({
+                body: (tmp = expression(true), semicolon(), tmp)
+            });
+        }
+        function break_cont(type) {
+            var label = null;
+            if (!can_insert_semicolon()) {
+                label = as_symbol(AST_LabelRef, true);
+            }
+            if (label != null) {
+                if (!find_if(function(l) {
+                    return l.name == label.name;
+                }, S.labels)) croak("Undefined label " + label.name);
+            } else if (S.in_loop == 0) croak(type.TYPE + " not inside a loop or switch");
+            semicolon();
+            return new type({
+                label: label
+            });
+        }
+        function for_() {
+            expect("(");
+            var init = null;
+            if (!is("punc", ";")) {
+                init = is("keyword", "var") ? (next(), var_(true)) : expression(true, true);
+                if (is("operator", "in")) {
+                    if (init instanceof AST_Var && init.definitions.length > 1) croak("Only one variable declaration allowed in for..in loop");
+                    next();
+                    return for_in(init);
+                }
+            }
+            return regular_for(init);
+        }
+        function regular_for(init) {
+            expect(";");
+            var test = is("punc", ";") ? null : expression(true);
+            expect(";");
+            var step = is("punc", ")") ? null : expression(true);
+            expect(")");
+            return new AST_For({
+                init: init,
+                condition: test,
+                step: step,
+                body: in_loop(statement)
+            });
+        }
+        function for_in(init) {
+            var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
+            var obj = expression(true);
+            expect(")");
+            return new AST_ForIn({
+                init: init,
+                name: lhs,
+                object: obj,
+                body: in_loop(statement)
+            });
+        }
+        var function_ = function(in_statement, ctor) {
+            var is_accessor = ctor === AST_Accessor;
+            var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : is_accessor ? AST_SymbolAccessor : AST_SymbolLambda) : is_accessor && (is("string") || is("num")) ? as_atom_node() : null;
+            if (in_statement && !name) unexpected();
+            expect("(");
+            if (!ctor) ctor = in_statement ? AST_Defun : AST_Function;
+            return new ctor({
+                name: name,
+                argnames: function(first, a) {
+                    while (!is("punc", ")")) {
+                        if (first) first = false; else expect(",");
+                        a.push(as_symbol(AST_SymbolFunarg));
+                    }
+                    next();
+                    return a;
+                }(true, []),
+                body: function(loop, labels) {
+                    ++S.in_function;
+                    S.in_directives = true;
+                    S.in_loop = 0;
+                    S.labels = [];
+                    var a = block_();
+                    --S.in_function;
+                    S.in_loop = loop;
+                    S.labels = labels;
+                    return a;
+                }(S.in_loop, S.labels)
+            });
+        };
+        function if_() {
+            var cond = parenthesised(), body = statement(), belse = null;
+            if (is("keyword", "else")) {
+                next();
+                belse = statement();
+            }
+            return new AST_If({
+                condition: cond,
+                body: body,
+                alternative: belse
+            });
+        }
+        function block_() {
+            expect("{");
+            var a = [];
+            while (!is("punc", "}")) {
+                if (is("eof")) unexpected();
+                a.push(statement());
+            }
+            next();
+            return a;
+        }
+        function switch_body_() {
+            expect("{");
+            var a = [], cur = null, branch = null, tmp;
+            while (!is("punc", "}")) {
+                if (is("eof")) unexpected();
+                if (is("keyword", "case")) {
+                    if (branch) branch.end = prev();
+                    cur = [];
+                    branch = new AST_Case({
+                        start: (tmp = S.token, next(), tmp),
+                        expression: expression(true),
+                        body: cur
+                    });
+                    a.push(branch);
+                    expect(":");
+                } else if (is("keyword", "default")) {
+                    if (branch) branch.end = prev();
+                    cur = [];
+                    branch = new AST_Default({
+                        start: (tmp = S.token, next(), expect(":"), tmp),
+                        body: cur
+                    });
+                    a.push(branch);
+                } else {
+                    if (!cur) unexpected();
+                    cur.push(statement());
+                }
+            }
+            if (branch) branch.end = prev();
+            next();
+            return a;
+        }
+        function try_() {
+            var body = block_(), bcatch = null, bfinally = null;
+            if (is("keyword", "catch")) {
+                var start = S.token;
+                next();
+                expect("(");
+                var name = as_symbol(AST_SymbolCatch);
+                expect(")");
+                bcatch = new AST_Catch({
+                    start: start,
+                    argname: name,
+                    body: block_(),
+                    end: prev()
+                });
+            }
+            if (is("keyword", "finally")) {
+                var start = S.token;
+                next();
+                bfinally = new AST_Finally({
+                    start: start,
+                    body: block_(),
+                    end: prev()
+                });
+            }
+            if (!bcatch && !bfinally) croak("Missing catch/finally blocks");
+            return new AST_Try({
+                body: body,
+                bcatch: bcatch,
+                bfinally: bfinally
+            });
+        }
+        function vardefs(no_in, in_const) {
+            var a = [];
+            for (;;) {
+                a.push(new AST_VarDef({
+                    start: S.token,
+                    name: as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
+                    value: is("operator", "=") ? (next(), expression(false, no_in)) : null,
+                    end: prev()
+                }));
+                if (!is("punc", ",")) break;
+                next();
+            }
+            return a;
+        }
+        var var_ = function(no_in) {
+            return new AST_Var({
+                start: prev(),
+                definitions: vardefs(no_in, false),
+                end: prev()
+            });
+        };
+        var const_ = function() {
+            return new AST_Const({
+                start: prev(),
+                definitions: vardefs(false, true),
+                end: prev()
+            });
+        };
+        var new_ = function() {
+            var start = S.token;
+            expect_token("operator", "new");
+            var newexp = expr_atom(false), args;
+            if (is("punc", "(")) {
+                next();
+                args = expr_list(")");
+            } else {
+                args = [];
+            }
+            return subscripts(new AST_New({
+                start: start,
+                expression: newexp,
+                args: args,
+                end: prev()
+            }), true);
+        };
+        function as_atom_node() {
+            var tok = S.token, ret;
+            switch (tok.type) {
+              case "name":
+                return as_symbol(AST_SymbolRef);
+
+              case "num":
+                ret = new AST_Number({
+                    start: tok,
+                    end: tok,
+                    value: tok.value
+                });
+                break;
+
+              case "string":
+                ret = new AST_String({
+                    start: tok,
+                    end: tok,
+                    value: tok.value
+                });
+                break;
+
+              case "regexp":
+                ret = new AST_RegExp({
+                    start: tok,
+                    end: tok,
+                    value: tok.value
+                });
+                break;
+
+              case "atom":
+                switch (tok.value) {
+                  case "false":
+                    ret = new AST_False({
+                        start: tok,
+                        end: tok
+                    });
+                    break;
+
+                  case "true":
+                    ret = new AST_True({
+                        start: tok,
+                        end: tok
+                    });
+                    break;
+
+                  case "null":
+                    ret = new AST_Null({
+                        start: tok,
+                        end: tok
+                    });
+                    break;
+                }
+                break;
+            }
+            next();
+            return ret;
+        }
+        var expr_atom = function(allow_calls) {
+            if (is("operator", "new")) {
+                return new_();
+            }
+            var start = S.token;
+            if (is("punc")) {
+                switch (start.value) {
+                  case "(":
+                    next();
+                    var ex = expression(true);
+                    ex.start = start;
+                    ex.end = S.token;
+                    expect(")");
+                    return subscripts(ex, allow_calls);
+
+                  case "[":
+                    return subscripts(array_(), allow_calls);
+
+                  case "{":
+                    return subscripts(object_(), allow_calls);
+                }
+                unexpected();
+            }
+            if (is("keyword", "function")) {
+                next();
+                var func = function_(false);
+                func.start = start;
+                func.end = prev();
+                return subscripts(func, allow_calls);
+            }
+            if (ATOMIC_START_TOKEN[S.token.type]) {
+                return subscripts(as_atom_node(), allow_calls);
+            }
+            unexpected();
+        };
+        function expr_list(closing, allow_trailing_comma, allow_empty) {
+            var first = true, a = [];
+            while (!is("punc", closing)) {
+                if (first) first = false; else expect(",");
+                if (allow_trailing_comma && is("punc", closing)) break;
+                if (is("punc", ",") && allow_empty) {
+                    a.push(new AST_Hole({
+                        start: S.token,
+                        end: S.token
+                    }));
+                } else {
+                    a.push(expression(false));
+                }
+            }
+            next();
+            return a;
+        }
+        var array_ = embed_tokens(function() {
+            expect("[");
+            return new AST_Array({
+                elements: expr_list("]", !options.strict, true)
+            });
+        });
+        var object_ = embed_tokens(function() {
+            expect("{");
+            var first = true, a = [];
+            while (!is("punc", "}")) {
+                if (first) first = false; else expect(",");
+                if (!options.strict && is("punc", "}")) break;
+                var start = S.token;
+                var type = start.type;
+                var name = as_property_name();
+                if (type == "name" && !is("punc", ":")) {
+                    if (name == "get") {
+                        a.push(new AST_ObjectGetter({
+                            start: start,
+                            key: name,
+                            value: function_(false, AST_Accessor),
+                            end: prev()
+                        }));
+                        continue;
+                    }
+                    if (name == "set") {
+                        a.push(new AST_ObjectSetter({
+                            start: start,
+                            key: name,
+                            value: function_(false, AST_Accessor),
+                            end: prev()
+                        }));
+                        continue;
+                    }
+                }
+                expect(":");
+                a.push(new AST_ObjectKeyVal({
+                    start: start,
+                    key: name,
+                    value: expression(false),
+                    end: prev()
+                }));
+            }
+            next();
+            return new AST_Object({
+                properties: a
+            });
+        });
+        function as_property_name() {
+            var tmp = S.token;
+            next();
+            switch (tmp.type) {
+              case "num":
+              case "string":
+              case "name":
+              case "operator":
+              case "keyword":
+              case "atom":
+                return tmp.value;
+
+              default:
+                unexpected();
+            }
+        }
+        function as_name() {
+            var tmp = S.token;
+            next();
+            switch (tmp.type) {
+              case "name":
+              case "operator":
+              case "keyword":
+              case "atom":
+                return tmp.value;
+
+              default:
+                unexpected();
+            }
+        }
+        function as_symbol(type, noerror) {
+            if (!is("name")) {
+                if (!noerror) croak("Name expected");
+                return null;
+            }
+            var name = S.token.value;
+            var sym = new (name == "this" ? AST_This : type)({
+                name: String(S.token.value),
+                start: S.token,
+                end: S.token
+            });
+            next();
+            return sym;
+        }
+        var subscripts = function(expr, allow_calls) {
+            var start = expr.start;
+            if (is("punc", ".")) {
+                next();
+                return subscripts(new AST_Dot({
+                    start: start,
+                    expression: expr,
+                    property: as_name(),
+                    end: prev()
+                }), allow_calls);
+            }
+            if (is("punc", "[")) {
+                next();
+                var prop = expression(true);
+                expect("]");
+                return subscripts(new AST_Sub({
+                    start: start,
+                    expression: expr,
+                    property: prop,
+                    end: prev()
+                }), allow_calls);
+            }
+            if (allow_calls && is("punc", "(")) {
+                next();
+                return subscripts(new AST_Call({
+                    start: start,
+                    expression: expr,
+                    args: expr_list(")"),
+                    end: prev()
+                }), true);
+            }
+            return expr;
+        };
+        var maybe_unary = function(allow_calls) {
+            var start = S.token;
+            if (is("operator") && UNARY_PREFIX(start.value)) {
+                next();
+                var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
+                ex.start = start;
+                ex.end = prev();
+                return ex;
+            }
+            var val = expr_atom(allow_calls);
+            while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
+                val = make_unary(AST_UnaryPostfix, S.token.value, val);
+                val.start = start;
+                val.end = S.token;
+                next();
+            }
+            return val;
+        };
+        function make_unary(ctor, op, expr) {
+            if ((op == "++" || op == "--") && !is_assignable(expr)) croak("Invalid use of " + op + " operator");
+            return new ctor({
+                operator: op,
+                expression: expr
+            });
+        }
+        var expr_op = function(left, min_prec, no_in) {
+            var op = is("operator") ? S.token.value : null;
+            if (op == "in" && no_in) op = null;
+            var prec = op != null ? PRECEDENCE[op] : null;
+            if (prec != null && prec > min_prec) {
+                next();
+                var right = expr_op(maybe_unary(true), prec, no_in);
+                return expr_op(new AST_Binary({
+                    start: left.start,
+                    left: left,
+                    operator: op,
+                    right: right,
+                    end: right.end
+                }), min_prec, no_in);
+            }
+            return left;
+        };
+        function expr_ops(no_in) {
+            return expr_op(maybe_unary(true), 0, no_in);
+        }
+        var maybe_conditional = function(no_in) {
+            var start = S.token;
+            var expr = expr_ops(no_in);
+            if (is("operator", "?")) {
+                next();
+                var yes = expression(false);
+                expect(":");
+                return new AST_Conditional({
+                    start: start,
+                    condition: expr,
+                    consequent: yes,
+                    alternative: expression(false, no_in),
+                    end: peek()
+                });
+            }
+            return expr;
+        };
+        function is_assignable(expr) {
+            if (!options.strict) return true;
+            if (expr instanceof AST_This) return false;
+            return expr instanceof AST_PropAccess || expr instanceof AST_Symbol;
+        }
+        var maybe_assign = function(no_in) {
+            var start = S.token;
+            var left = maybe_conditional(no_in), val = S.token.value;
+            if (is("operator") && ASSIGNMENT(val)) {
+                if (is_assignable(left)) {
+                    next();
+                    return new AST_Assign({
+                        start: start,
+                        left: left,
+                        operator: val,
+                        right: maybe_assign(no_in),
+                        end: prev()
+                    });
+                }
+                croak("Invalid assignment");
+            }
+            return left;
+        };
+        var expression = function(commas, no_in) {
+            var start = S.token;
+            var expr = maybe_assign(no_in);
+            if (commas && is("punc", ",")) {
+                next();
+                return new AST_Seq({
+                    start: start,
+                    car: expr,
+                    cdr: expression(true, no_in),
+                    end: peek()
+                });
+            }
+            return expr;
+        };
+        function in_loop(cont) {
+            ++S.in_loop;
+            var ret = cont();
+            --S.in_loop;
+            return ret;
+        }
+        return function() {
+            var start = S.token;
+            var body = [];
+            while (!is("eof")) body.push(statement());
+            var end = prev();
+            var toplevel = options.toplevel;
+            if (toplevel) {
+                toplevel.body = toplevel.body.concat(body);
+                toplevel.end = end;
+            } else {
+                toplevel = new AST_Toplevel({
+                    start: start,
+                    body: body,
+                    end: end
+                });
+            }
+            return toplevel;
+        }();
+    }
+    "use strict";
+    function TreeTransformer(before, after) {
+        TreeWalker.call(this);
+        this.before = before;
+        this.after = after;
+    }
+    TreeTransformer.prototype = new TreeWalker();
+    (function(undefined) {
+        function _(node, descend) {
+            node.DEFMETHOD("transform", function(tw, in_list) {
+                var x, y;
+                tw.push(this);
+                if (tw.before) x = tw.before(this, descend, in_list);
+                if (x === undefined) {
+                    if (!tw.after) {
+                        x = this;
+                        descend(x, tw);
+                    } else {
+                        tw.stack[tw.stack.length - 1] = x = this.clone();
+                        descend(x, tw);
+                        y = tw.after(x, in_list);
+                        if (y !== undefined) x = y;
+                    }
+                }
+                tw.pop();
+                return x;
+            });
+        }
+        function do_list(list, tw) {
+            return MAP(list, function(node) {
+                return node.transform(tw, true);
+            });
+        }
+        _(AST_Node, noop);
+        _(AST_LabeledStatement, function(self, tw) {
+            self.label = self.label.transform(tw);
+            self.body = self.body.transform(tw);
+        });
+        _(AST_SimpleStatement, function(self, tw) {
+            self.body = self.body.transform(tw);
+        });
+        _(AST_Block, function(self, tw) {
+            self.body = do_list(self.body, tw);
+        });
+        _(AST_DWLoop, function(self, tw) {
+            self.condition = self.condition.transform(tw);
+            self.body = self.body.transform(tw);
+        });
+        _(AST_For, function(self, tw) {
+            if (self.init) self.init = self.init.transform(tw);
+            if (self.condition) self.condition = self.condition.transform(tw);
+            if (self.step) self.step = self.step.transform(tw);
+            self.body = self.body.transform(tw);
+        });
+        _(AST_ForIn, function(self, tw) {
+            self.init = self.init.transform(tw);
+            self.object = self.object.transform(tw);
+            self.body = self.body.transform(tw);
+        });
+        _(AST_With, function(self, tw) {
+            self.expression = self.expression.transform(tw);
+            self.body = self.body.transform(tw);
+        });
+        _(AST_Exit, function(self, tw) {
+            if (self.value) self.value = self.value.transform(tw);
+        });
+        _(AST_LoopControl, function(self, tw) {
+            if (self.label) self.label = self.label.transform(tw);
+        });
+        _(AST_If, function(self, tw) {
+            self.condition = self.condition.transform(tw);
+            self.body = self.body.transform(tw);
+            if (self.alternative) self.alternative = self.alternative.transform(tw);
+        });
+        _(AST_Switch, function(self, tw) {
+            self.expression = self.expression.transform(tw);
+            self.body = do_list(self.body, tw);
+        });
+        _(AST_Case, function(self, tw) {
+            self.expression = self.expression.transform(tw);
+            self.body = do_list(self.body, tw);
+        });
+        _(AST_Try, function(self, tw) {
+            self.body = do_list(self.body, tw);
+            if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
+            if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
+        });
+        _(AST_Catch, function(self, tw) {
+            self.argname = self.argname.transform(tw);
+            self.body = do_list(self.body, tw);
+        });
+        _(AST_Definitions, function(self, tw) {
+            self.definitions = do_list(self.definitions, tw);
+        });
+        _(AST_VarDef, function(self, tw) {
+            if (self.value) self.value = self.value.transform(tw);
+        });
+        _(AST_Lambda, function(self, tw) {
+            if (self.name) self.name = self.name.transform(tw);
+            self.argnames = do_list(self.argnames, tw);
+            self.body = do_list(self.body, tw);
+        });
+        _(AST_Call, function(self, tw) {
+            self.expression = self.expression.transform(tw);
+            self.args = do_list(self.args, tw);
+        });
+        _(AST_Seq, function(self, tw) {
+            self.car = self.car.transform(tw);
+            self.cdr = self.cdr.transform(tw);
+        });
+        _(AST_Dot, function(self, tw) {
+            self.expression = self.expression.transform(tw);
+        });
+        _(AST_Sub, function(self, tw) {
+            self.expression = self.expression.transform(tw);
+            self.property = self.property.transform(tw);
+        });
+        _(AST_Unary, function(self, tw) {
+            self.expression = self.expression.transform(tw);
+        });
+        _(AST_Binary, function(self, tw) {
+            self.left = self.left.transform(tw);
+            self.right = self.right.transform(tw);
+        });
+        _(AST_Conditional, function(self, tw) {
+            self.condition = self.condition.transform(tw);
+            self.consequent = self.consequent.transform(tw);
+            self.alternative = self.alternative.transform(tw);
+        });
+        _(AST_Array, function(self, tw) {
+            self.elements = do_list(self.elements, tw);
+        });
+        _(AST_Object, function(self, tw) {
+            self.properties = do_list(self.properties, tw);
+        });
+        _(AST_ObjectProperty, function(self, tw) {
+            self.value = self.value.transform(tw);
+        });
+    })();
+    "use strict";
+    function SymbolDef(scope, index, orig) {
+        this.name = orig.name;
+        this.orig = [ orig ];
+        this.scope = scope;
+        this.references = [];
+        this.global = false;
+        this.mangled_name = null;
+        this.undeclared = false;
+        this.constant = false;
+        this.index = index;
+    }
+    SymbolDef.prototype = {
+        unmangleable: function(options) {
+            return this.global && !(options && options.toplevel) || this.undeclared || !(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with);
+        },
+        mangle: function(options) {
+            if (!this.mangled_name && !this.unmangleable(options)) {
+                var s = this.scope;
+                if (this.orig[0] instanceof AST_SymbolLambda && !options.screw_ie8) s = s.parent_scope;
+                this.mangled_name = s.next_mangled(options);
+            }
+        }
+    };
+    AST_Toplevel.DEFMETHOD("figure_out_scope", function() {
+        var self = this;
+        var scope = self.parent_scope = null;
+        var labels = new Dictionary();
+        var nesting = 0;
+        var tw = new TreeWalker(function(node, descend) {
+            if (node instanceof AST_Scope) {
+                node.init_scope_vars(nesting);
+                var save_scope = node.parent_scope = scope;
+                var save_labels = labels;
+                ++nesting;
+                scope = node;
+                labels = new Dictionary();
+                descend();
+                labels = save_labels;
+                scope = save_scope;
+                --nesting;
+                return true;
+            }
+            if (node instanceof AST_Directive) {
+                node.scope = scope;
+                push_uniq(scope.directives, node.value);
+                return true;
+            }
+            if (node instanceof AST_With) {
+                for (var s = scope; s; s = s.parent_scope) s.uses_with = true;
+                return;
+            }
+            if (node instanceof AST_LabeledStatement) {
+                var l = node.label;
+                if (labels.has(l.name)) throw new Error(string_template("Label {name} defined twice", l));
+                labels.set(l.name, l);
+                descend();
+                labels.del(l.name);
+                return true;
+            }
+            if (node instanceof AST_Symbol) {
+                node.scope = scope;
+            }
+            if (node instanceof AST_Label) {
+                node.thedef = node;
+                node.init_scope_vars();
+            }
+            if (node instanceof AST_SymbolLambda) {
+                scope.def_function(node);
+            } else if (node instanceof AST_SymbolDefun) {
+                (node.scope = scope.parent_scope).def_function(node);
+            } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolConst) {
+                var def = scope.def_variable(node);
+                def.constant = node instanceof AST_SymbolConst;
+                def.init = tw.parent().value;
+            } else if (node instanceof AST_SymbolCatch) {
+                scope.def_variable(node);
+            }
+            if (node instanceof AST_LabelRef) {
+                var sym = labels.get(node.name);
+                if (!sym) throw new Error(string_template("Undefined label {name} [{line},{col}]", {
+                    name: node.name,
+                    line: node.start.line,
+                    col: node.start.col
+                }));
+                node.thedef = sym;
+            }
+        });
+        self.walk(tw);
+        var func = null;
+        var globals = self.globals = new Dictionary();
+        var tw = new TreeWalker(function(node, descend) {
+            if (node instanceof AST_Lambda) {
+                var prev_func = func;
+                func = node;
+                descend();
+                func = prev_func;
+                return true;
+            }
+            if (node instanceof AST_LabelRef) {
+                node.reference();
+                return true;
+            }
+            if (node instanceof AST_SymbolRef) {
+                var name = node.name;
+                var sym = node.scope.find_variable(name);
+                if (!sym) {
+                    var g;
+                    if (globals.has(name)) {
+                        g = globals.get(name);
+                    } else {
+                        g = new SymbolDef(self, globals.size(), node);
+                        g.undeclared = true;
+                        globals.set(name, g);
+                    }
+                    node.thedef = g;
+                    if (name == "eval" && tw.parent() instanceof AST_Call) {
+                        for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) s.uses_eval = true;
+                    }
+                    if (name == "arguments") {
+                        func.uses_arguments = true;
+                    }
+                } else {
+                    node.thedef = sym;
+                }
+                node.reference();
+                return true;
+            }
+        });
+        self.walk(tw);
+    });
+    AST_Scope.DEFMETHOD("init_scope_vars", function(nesting) {
+        this.directives = [];
+        this.variables = new Dictionary();
+        this.functions = new Dictionary();
+        this.uses_with = false;
+        this.uses_eval = false;
+        this.parent_scope = null;
+        this.enclosed = [];
+        this.cname = -1;
+        this.nesting = nesting;
+    });
+    AST_Scope.DEFMETHOD("strict", function() {
+        return this.has_directive("use strict");
+    });
+    AST_Lambda.DEFMETHOD("init_scope_vars", function() {
+        AST_Scope.prototype.init_scope_vars.apply(this, arguments);
+        this.uses_arguments = false;
+    });
+    AST_SymbolRef.DEFMETHOD("reference", function() {
+        var def = this.definition();
+        def.references.push(this);
+        var s = this.scope;
+        while (s) {
+            push_uniq(s.enclosed, def);
+            if (s === def.scope) break;
+            s = s.parent_scope;
+        }
+        this.frame = this.scope.nesting - def.scope.nesting;
+    });
+    AST_Label.DEFMETHOD("init_scope_vars", function() {
+        this.references = [];
+    });
+    AST_LabelRef.DEFMETHOD("reference", function() {
+        this.thedef.references.push(this);
+    });
+    AST_Scope.DEFMETHOD("find_variable", function(name) {
+        if (name instanceof AST_Symbol) name = name.name;
+        return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
+    });
+    AST_Scope.DEFMETHOD("has_directive", function(value) {
+        return this.parent_scope && this.parent_scope.has_directive(value) || (this.directives.indexOf(value) >= 0 ? this : null);
+    });
+    AST_Scope.DEFMETHOD("def_function", function(symbol) {
+        this.functions.set(symbol.name, this.def_variable(symbol));
+    });
+    AST_Scope.DEFMETHOD("def_variable", function(symbol) {
+        var def;
+        if (!this.variables.has(symbol.name)) {
+            def = new SymbolDef(this, this.variables.size(), symbol);
+            this.variables.set(symbol.name, def);
+            def.global = !this.parent_scope;
+        } else {
+            def = this.variables.get(symbol.name);
+            def.orig.push(symbol);
+        }
+        return symbol.thedef = def;
+    });
+    AST_Scope.DEFMETHOD("next_mangled", function(options) {
+        var ext = this.enclosed;
+        out: while (true) {
+            var m = base54(++this.cname);
+            if (!is_identifier(m)) continue;
+            for (var i = ext.length; --i >= 0; ) {
+                var sym = ext[i];
+                var name = sym.mangled_name || sym.unmangleable(options) && sym.name;
+                if (m == name) continue out;
+            }
+            return m;
+        }
+    });
+    AST_Scope.DEFMETHOD("references", function(sym) {
+        if (sym instanceof AST_Symbol) sym = sym.definition();
+        return this.enclosed.indexOf(sym) < 0 ? null : sym;
+    });
+    AST_Symbol.DEFMETHOD("unmangleable", function(options) {
+        return this.definition().unmangleable(options);
+    });
+    AST_SymbolAccessor.DEFMETHOD("unmangleable", function() {
+        return true;
+    });
+    AST_Label.DEFMETHOD("unmangleable", function() {
+        return false;
+    });
+    AST_Symbol.DEFMETHOD("unreferenced", function() {
+        return this.definition().references.length == 0 && !(this.scope.uses_eval || this.scope.uses_with);
+    });
+    AST_Symbol.DEFMETHOD("undeclared", function() {
+        return this.definition().undeclared;
+    });
+    AST_LabelRef.DEFMETHOD("undeclared", function() {
+        return false;
+    });
+    AST_Label.DEFMETHOD("undeclared", function() {
+        return false;
+    });
+    AST_Symbol.DEFMETHOD("definition", function() {
+        return this.thedef;
+    });
+    AST_Symbol.DEFMETHOD("global", function() {
+        return this.definition().global;
+    });
+    AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options) {
+        return defaults(options, {
+            except: [],
+            eval: false,
+            sort: false,
+            toplevel: false,
+            screw_ie8: false
+        });
+    });
+    AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
+        options = this._default_mangler_options(options);
+        var lname = -1;
+        var to_mangle = [];
+        var tw = new TreeWalker(function(node, descend) {
+            if (node instanceof AST_LabeledStatement) {
+                var save_nesting = lname;
+                descend();
+                lname = save_nesting;
+                return true;
+            }
+            if (node instanceof AST_Scope) {
+                var p = tw.parent(), a = [];
+                node.variables.each(function(symbol) {
+                    if (options.except.indexOf(symbol.name) < 0) {
+                        a.push(symbol);
+                    }
+                });
+                if (options.sort) a.sort(function(a, b) {
+                    return b.references.length - a.references.length;
+                });
+                to_mangle.push.apply(to_mangle, a);
+                return;
+            }
+            if (node instanceof AST_Label) {
+                var name;
+                do name = base54(++lname); while (!is_identifier(name));
+                node.mangled_name = name;
+                return true;
+            }
+        });
+        this.walk(tw);
+        to_mangle.forEach(function(def) {
+            def.mangle(options);
+        });
+    });
+    AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
+        options = this._default_mangler_options(options);
+        var tw = new TreeWalker(function(node) {
+            if (node instanceof AST_Constant) base54.consider(node.print_to_string()); else if (node instanceof AST_Return) base54.consider("return"); else if (node instanceof AST_Throw) base54.consider("throw"); else if (node instanceof AST_Continue) base54.consider("continue"); else if (node instanceof AST_Break) base54.consider("break"); else if (node instanceof AST_Debugger) base54.consider("debugger"); else if (node instanceof AST_Directive) base54.consider(node.value); else if (node instanceof AST_While) base54.consider("while"); else if (node instanceof AST_Do) base54.consider("do while"); else if (node instanceof AST_If) {
+                base54.consider("if");
+                if (node.alternative) base54.consider("else");
+            } else if (node instanceof AST_Var) base54.consider("var"); else if (node instanceof AST_Const) base54.consider("const"); else if (node instanceof AST_Lambda) base54.consider("function"); else if (node instanceof AST_For) base54.consider("for"); else if (node instanceof AST_ForIn) base54.consider("for in"); else if (node instanceof AST_Switch) base54.consider("switch"); else if (node instanceof AST_Case) base54.consider("case"); else if (node instanceof AST_Default) base54.consider("default"); else if (node instanceof AST_With) base54.consider("with"); else if (node instanceof AST_ObjectSetter) base54.consider("set" + node.key); else if (node instanceof AST_ObjectGetter) base54.consider("get" + node.key); else if (node instanceof AST_ObjectKeyVal) base54.consider(node.key); else if (node instanceof AST_New) base54.consider("new"); else if (node instanceof AST_This) base54.consider("this"); else if (node instanceof AST_Try) base54.consider("try"); else if (node instanceof AST_Catch) base54.consider("catch"); else if (node instanceof AST_Finally) base54.consider("finally"); else if (node instanceof AST_Symbol && node.unmangleable(options)) base54.consider(node.name); else if (node instanceof AST_Unary || node instanceof AST_Binary) base54.consider(node.operator); else if (node instanceof AST_Dot) base54.consider(node.property);
+        });
+        this.walk(tw);
+        base54.sort();
+    });
+    var base54 = function() {
+        var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
+        var chars, frequency;
+        function reset() {
+            frequency = Object.create(null);
+            chars = string.split("").map(function(ch) {
+                return ch.charCodeAt(0);
+            });
+            chars.forEach(function(ch) {
+                frequency[ch] = 0;
+            });
+        }
+        base54.consider = function(str) {
+            for (var i = str.length; --i >= 0; ) {
+                var code = str.charCodeAt(i);
+                if (code in frequency) ++frequency[code];
+            }
+        };
+        base54.sort = function() {
+            chars = mergeSort(chars, function(a, b) {
+                if (is_digit(a) && !is_digit(b)) return 1;
+                if (is_digit(b) && !is_digit(a)) return -1;
+                return frequency[b] - frequency[a];
+            });
+        };
+        base54.reset = reset;
+        reset();
+        base54.get = function() {
+            return chars;
+        };
+        base54.freq = function() {
+            return frequency;
+        };
+        function base54(num) {
+            var ret = "", base = 54;
+            do {
+                ret += String.fromCharCode(chars[num % base]);
+                num = Math.floor(num / base);
+                base = 64;
+            } while (num > 0);
+            return ret;
+        }
+        return base54;
+    }();
+    AST_Toplevel.DEFMETHOD("scope_warnings", function(options) {
+        options = defaults(options, {
+            undeclared: false,
+            unreferenced: true,
+            assign_to_global: true,
+            func_arguments: true,
+            nested_defuns: true,
+            eval: true
+        });
+        var tw = new TreeWalker(function(node) {
+            if (options.undeclared && node instanceof AST_SymbolRef && node.undeclared()) {
+                AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
+                    name: node.name,
+                    file: node.start.file,
+                    line: node.start.line,
+                    col: node.start.col
+                });
+            }
+            if (options.assign_to_global) {
+                var sym = null;
+                if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) sym = node.left; else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef) sym = node.init;
+                if (sym && (sym.undeclared() || sym.global() && sym.scope !== sym.definition().scope)) {
+                    AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
+                        msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
+                        name: sym.name,
+                        file: sym.start.file,
+                        line: sym.start.line,
+                        col: sym.start.col
+                    });
+                }
+            }
+            if (options.eval && node instanceof AST_SymbolRef && node.undeclared() && node.name == "eval") {
+                AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
+            }
+            if (options.unreferenced && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label) && node.unreferenced()) {
+                AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
+                    type: node instanceof AST_Label ? "Label" : "Symbol",
+                    name: node.name,
+                    file: node.start.file,
+                    line: node.start.line,
+                    col: node.start.col
+                });
+            }
+            if (options.func_arguments && node instanceof AST_Lambda && node.uses_arguments) {
+                AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
+                    name: node.name ? node.name.name : "anonymous",
+                    file: node.start.file,
+                    line: node.start.line,
+                    col: node.start.col
+                });
+            }
+            if (options.nested_defuns && node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {
+                AST_Node.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]', {
+                    name: node.name.name,
+                    type: tw.parent().TYPE,
+                    file: node.start.file,
+                    line: node.start.line,
+                    col: node.start.col
+                });
+            }
+        });
+        this.walk(tw);
+    });
+    "use strict";
+    function OutputStream(options) {
+        options = defaults(options, {
+            indent_start: 0,
+            indent_level: 4,
+            quote_keys: false,
+            space_colon: true,
+            ascii_only: false,
+            inline_script: false,
+            width: 80,
+            max_line_len: 32e3,
+            ie_proof: true,
+            beautify: false,
+            source_map: null,
+            bracketize: false,
+            semicolons: true,
+            comments: false,
+            preserve_line: false
+        }, true);
+        var indentation = 0;
+        var current_col = 0;
+        var current_line = 1;
+        var current_pos = 0;
+        var OUTPUT = "";
+        function to_ascii(str, identifier) {
+            return str.replace(/[\u0080-\uffff]/g, function(ch) {
+                var code = ch.charCodeAt(0).toString(16);
+                if (code.length <= 2 && !identifier) {
+                    while (code.length < 2) code = "0" + code;
+                    return "\\x" + code;
+                } else {
+                    while (code.length < 4) code = "0" + code;
+                    return "\\u" + code;
+                }
+            });
+        }
+        function make_string(str) {
+            var dq = 0, sq = 0;
+            str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s) {
+                switch (s) {
+                  case "\\":
+                    return "\\\\";
+
+                  case "\b":
+                    return "\\b";
+
+                  case "\f":
+                    return "\\f";
+
+                  case "\n":
+                    return "\\n";
+
+                  case "\r":
+                    return "\\r";
+
+                  case "\u2028":
+                    return "\\u2028";
+
+                  case "\u2029":
+                    return "\\u2029";
+
+                  case '"':
+                    ++dq;
+                    return '"';
+
+                  case "'":
+                    ++sq;
+                    return "'";
+
+                  case "\0":
+                    return "\\0";
+                }
+                return s;
+            });
+            if (options.ascii_only) str = to_ascii(str);
+            if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'"; else return '"' + str.replace(/\x22/g, '\\"') + '"';
+        }
+        function encode_string(str) {
+            var ret = make_string(str);
+            if (options.inline_script) ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
+            return ret;
+        }
+        function make_name(name) {
+            name = name.toString();
+            if (options.ascii_only) name = to_ascii(name, true);
+            return name;
+        }
+        function make_indent(back) {
+            return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
+        }
+        var might_need_space = false;
+        var might_need_semicolon = false;
+        var last = null;
+        function last_char() {
+            return last.charAt(last.length - 1);
+        }
+        function maybe_newline() {
+            if (options.max_line_len && current_col > options.max_line_len) print("\n");
+        }
+        var requireSemicolonChars = makePredicate("( [ + * / - , .");
+        function print(str) {
+            str = String(str);
+            var ch = str.charAt(0);
+            if (might_need_semicolon) {
+                if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
+                    if (options.semicolons || requireSemicolonChars(ch)) {
+                        OUTPUT += ";";
+                        current_col++;
+                        current_pos++;
+                    } else {
+                        OUTPUT += "\n";
+                        current_pos++;
+                        current_line++;
+                        current_col = 0;
+                    }
+                    if (!options.beautify) might_need_space = false;
+                }
+                might_need_semicolon = false;
+                maybe_newline();
+            }
+            if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
+                var target_line = stack[stack.length - 1].start.line;
+                while (current_line < target_line) {
+                    OUTPUT += "\n";
+                    current_pos++;
+                    current_line++;
+                    current_col = 0;
+                    might_need_space = false;
+                }
+            }
+            if (might_need_space) {
+                var prev = last_char();
+                if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || /^[\+\-\/]$/.test(ch) && ch == prev) {
+                    OUTPUT += " ";
+                    current_col++;
+                    current_pos++;
+                }
+                might_need_space = false;
+            }
+            var a = str.split(/\r?\n/), n = a.length - 1;
+            current_line += n;
+            if (n == 0) {
+                current_col += a[n].length;
+            } else {
+                current_col = a[n].length;
+            }
+            current_pos += str.length;
+            last = str;
+            OUTPUT += str;
+        }
+        var space = options.beautify ? function() {
+            print(" ");
+        } : function() {
+            might_need_space = true;
+        };
+        var indent = options.beautify ? function(half) {
+            if (options.beautify) {
+                print(make_indent(half ? .5 : 0));
+            }
+        } : noop;
+        var with_indent = options.beautify ? function(col, cont) {
+            if (col === true) col = next_indent();
+            var save_indentation = indentation;
+            indentation = col;
+            var ret = cont();
+            indentation = save_indentation;
+            return ret;
+        } : function(col, cont) {
+            return cont();
+        };
+        var newline = options.beautify ? function() {
+            print("\n");
+        } : noop;
+        var semicolon = options.beautify ? function() {
+            print(";");
+        } : function() {
+            might_need_semicolon = true;
+        };
+        function force_semicolon() {
+            might_need_semicolon = false;
+            print(";");
+        }
+        function next_indent() {
+            return indentation + options.indent_level;
+        }
+        function with_block(cont) {
+            var ret;
+            print("{");
+            newline();
+            with_indent(next_indent(), function() {
+                ret = cont();
+            });
+            indent();
+            print("}");
+            return ret;
+        }
+        function with_parens(cont) {
+            print("(");
+            var ret = cont();
+            print(")");
+            return ret;
+        }
+        function with_square(cont) {
+            print("[");
+            var ret = cont();
+            print("]");
+            return ret;
+        }
+        function comma() {
+            print(",");
+            space();
+        }
+        function colon() {
+            print(":");
+            if (options.space_colon) space();
+        }
+        var add_mapping = options.source_map ? function(token, name) {
+            try {
+                if (token) options.source_map.add(token.file || "?", current_line, current_col, token.line, token.col, !name && token.type == "name" ? token.value : name);
+            } catch (ex) {
+                AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col}  {cline},{ccol} [{name}]", {
+                    file: token.file,
+                    line: token.line,
+                    col: token.col,
+                    cline: current_line,
+                    ccol: current_col,
+                    name: name || ""
+                });
+            }
+        } : noop;
+        function get() {
+            return OUTPUT;
+        }
+        var stack = [];
+        return {
+            get: get,
+            toString: get,
+            indent: indent,
+            indentation: function() {
+                return indentation;
+            },
+            current_width: function() {
+                return current_col - indentation;
+            },
+            should_break: function() {
+                return options.width && this.current_width() >= options.width;
+            },
+            newline: newline,
+            print: print,
+            space: space,
+            comma: comma,
+            colon: colon,
+            last: function() {
+                return last;
+            },
+            semicolon: semicolon,
+            force_semicolon: force_semicolon,
+            to_ascii: to_ascii,
+            print_name: function(name) {
+                print(make_name(name));
+            },
+            print_string: function(str) {
+                print(encode_string(str));
+            },
+            next_indent: next_indent,
+            with_indent: with_indent,
+            with_block: with_block,
+            with_parens: with_parens,
+            with_square: with_square,
+            add_mapping: add_mapping,
+            option: function(opt) {
+                return options[opt];
+            },
+            line: function() {
+                return current_line;
+            },
+            col: function() {
+                return current_col;
+            },
+            pos: function() {
+                return current_pos;
+            },
+            push_node: function(node) {
+                stack.push(node);
+            },
+            pop_node: function() {
+                return stack.pop();
+            },
+            stack: function() {
+                return stack;
+            },
+            parent: function(n) {
+                return stack[stack.length - 2 - (n || 0)];
+            }
+        };
+    }
+    (function() {
+        function DEFPRINT(nodetype, generator) {
+            nodetype.DEFMETHOD("_codegen", generator);
+        }
+        AST_Node.DEFMETHOD("print", function(stream, force_parens) {
+            var self = this, generator = self._codegen;
+            stream.push_node(self);
+            var needs_parens = self.needs_parens(stream);
+            var fc = self instanceof AST_Function && !stream.option("beautify");
+            if (force_parens || needs_parens && !fc) {
+                stream.with_parens(function() {
+                    self.add_comments(stream);
+                    self.add_source_map(stream);
+                    generator(self, stream);
+                });
+            } else {
+                self.add_comments(stream);
+                if (needs_parens && fc) stream.print("!");
+                self.add_source_map(stream);
+                generator(self, stream);
+            }
+            stream.pop_node();
+        });
+        AST_Node.DEFMETHOD("print_to_string", function(options) {
+            var s = OutputStream(options);
+            this.print(s);
+            return s.get();
+        });
+        AST_Node.DEFMETHOD("add_comments", function(output) {
+            var c = output.option("comments"), self = this;
+            if (c) {
+                var start = self.start;
+                if (start && !start._comments_dumped) {
+                    start._comments_dumped = true;
+                    var comments = start.comments_before;
+                    if (self instanceof AST_Exit && self.value && self.value.start.comments_before.length > 0) {
+                        comments = (comments || []).concat(self.value.start.comments_before);
+                        self.value.start.comments_before = [];
+                    }
+                    if (c.test) {
+                        comments = comments.filter(function(comment) {
+                            return c.test(comment.value);
+                        });
+                    } else if (typeof c == "function") {
+                        comments = comments.filter(function(comment) {
+                            return c(self, comment);
+                        });
+                    }
+                    comments.forEach(function(c) {
+                        if (c.type == "comment1") {
+                            output.print("//" + c.value + "\n");
+                            output.indent();
+                        } else if (c.type == "comment2") {
+                            output.print("/*" + c.value + "*/");
+                            if (start.nlb) {
+                                output.print("\n");
+                                output.indent();
+                            } else {
+                                output.space();
+                            }
+                        }
+                    });
+                }
+            }
+        });
+        function PARENS(nodetype, func) {
+            nodetype.DEFMETHOD("needs_parens", func);
+        }
+        PARENS(AST_Node, function() {
+            return false;
+        });
+        PARENS(AST_Function, function(output) {
+            return first_in_statement(output);
+        });
+        PARENS(AST_Object, function(output) {
+            return first_in_statement(output);
+        });
+        PARENS(AST_Unary, function(output) {
+            var p = output.parent();
+            return p instanceof AST_PropAccess && p.expression === this;
+        });
+        PARENS(AST_Seq, function(output) {
+            var p = output.parent();
+            return p instanceof AST_Call || p instanceof AST_Unary || p instanceof AST_Binary || p instanceof AST_VarDef || p instanceof AST_Dot || p instanceof AST_Array || p instanceof AST_ObjectProperty || p instanceof AST_Conditional;
+        });
+        PARENS(AST_Binary, function(output) {
+            var p = output.parent();
+            if (p instanceof AST_Call && p.expression === this) return true;
+            if (p instanceof AST_Unary) return true;
+            if (p instanceof AST_PropAccess && p.expression === this) return true;
+            if (p instanceof AST_Binary) {
+                var po = p.operator, pp = PRECEDENCE[po];
+                var so = this.operator, sp = PRECEDENCE[so];
+                if (pp > sp || pp == sp && this === p.right && !(so == po && (so == "*" || so == "&&" || so == "||"))) {
+                    return true;
+                }
+            }
+        });
+        PARENS(AST_PropAccess, function(output) {
+            var p = output.parent();
+            if (p instanceof AST_New && p.expression === this) {
+                try {
+                    this.walk(new TreeWalker(function(node) {
+                        if (node instanceof AST_Call) throw p;
+                    }));
+                } catch (ex) {
+                    if (ex !== p) throw ex;
+                    return true;
+                }
+            }
+        });
+        PARENS(AST_Call, function(output) {
+            var p = output.parent();
+            return p instanceof AST_New && p.expression === this;
+        });
+        PARENS(AST_New, function(output) {
+            var p = output.parent();
+            if (no_constructor_parens(this, output) && (p instanceof AST_PropAccess || p instanceof AST_Call && p.expression === this)) return true;
+        });
+        PARENS(AST_Number, function(output) {
+            var p = output.parent();
+            if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this) return true;
+        });
+        PARENS(AST_NaN, function(output) {
+            var p = output.parent();
+            if (p instanceof AST_PropAccess && p.expression === this) return true;
+        });
+        function assign_and_conditional_paren_rules(output) {
+            var p = output.parent();
+            if (p instanceof AST_Unary) return true;
+            if (p instanceof AST_Binary && !(p instanceof AST_Assign)) return true;
+            if (p instanceof AST_Call && p.expression === this) return true;
+            if (p instanceof AST_Conditional && p.condition === this) return true;
+            if (p instanceof AST_PropAccess && p.expression === this) return true;
+        }
+        PARENS(AST_Assign, assign_and_conditional_paren_rules);
+        PARENS(AST_Conditional, assign_and_conditional_paren_rules);
+        DEFPRINT(AST_Directive, function(self, output) {
+            output.print_string(self.value);
+            output.semicolon();
+        });
+        DEFPRINT(AST_Debugger, function(self, output) {
+            output.print("debugger");
+            output.semicolon();
+        });
+        function display_body(body, is_toplevel, output) {
+            var last = body.length - 1;
+            body.forEach(function(stmt, i) {
+                if (!(stmt instanceof AST_EmptyStatement)) {
+                    output.indent();
+                    stmt.print(output);
+                    if (!(i == last && is_toplevel)) {
+                        output.newline();
+                        if (is_toplevel) output.newline();
+                    }
+                }
+            });
+        }
+        AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
+            force_statement(this.body, output);
+        });
+        DEFPRINT(AST_Statement, function(self, output) {
+            self.body.print(output);
+            output.semicolon();
+        });
+        DEFPRINT(AST_Toplevel, function(self, output) {
+            display_body(self.body, true, output);
+            output.print("");
+        });
+        DEFPRINT(AST_LabeledStatement, function(self, output) {
+            self.label.print(output);
+            output.colon();
+            self.body.print(output);
+        });
+        DEFPRINT(AST_SimpleStatement, function(self, output) {
+            self.body.print(output);
+            output.semicolon();
+        });
+        function print_bracketed(body, output) {
+            if (body.length > 0) output.with_block(function() {
+                display_body(body, false, output);
+            }); else output.print("{}");
+        }
+        DEFPRINT(AST_BlockStatement, function(self, output) {
+            print_bracketed(self.body, output);
+        });
+        DEFPRINT(AST_EmptyStatement, function(self, output) {
+            output.semicolon();
+        });
+        DEFPRINT(AST_Do, function(self, output) {
+            output.print("do");
+            output.space();
+            self._do_print_body(output);
+            output.space();
+            output.print("while");
+            output.space();
+            output.with_parens(function() {
+                self.condition.print(output);
+            });
+            output.semicolon();
+        });
+        DEFPRINT(AST_While, function(self, output) {
+            output.print("while");
+            output.space();
+            output.with_parens(function() {
+                self.condition.print(output);
+            });
+            output.space();
+            self._do_print_body(output);
+        });
+        DEFPRINT(AST_For, function(self, output) {
+            output.print("for");
+            output.space();
+            output.with_parens(function() {
+                if (self.init) {
+                    if (self.init instanceof AST_Definitions) {
+                        self.init.print(output);
+                    } else {
+                        parenthesize_for_noin(self.init, output, true);
+                    }
+                    output.print(";");
+                    output.space();
+                } else {
+                    output.print(";");
+                }
+                if (self.condition) {
+                    self.condition.print(output);
+                    output.print(";");
+                    output.space();
+                } else {
+                    output.print(";");
+                }
+                if (self.step) {
+                    self.step.print(output);
+                }
+            });
+            output.space();
+            self._do_print_body(output);
+        });
+        DEFPRINT(AST_ForIn, function(self, output) {
+            output.print("for");
+            output.space();
+            output.with_parens(function() {
+                self.init.print(output);
+                output.space();
+                output.print("in");
+                output.space();
+                self.object.print(output);
+            });
+            output.space();
+            self._do_print_body(output);
+        });
+        DEFPRINT(AST_With, function(self, output) {
+            output.print("with");
+            output.space();
+            output.with_parens(function() {
+                self.expression.print(output);
+            });
+            output.space();
+            self._do_print_body(output);
+        });
+        AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
+            var self = this;
+            if (!nokeyword) {
+                output.print("function");
+            }
+            if (self.name) {
+                output.space();
+                self.name.print(output);
+            }
+            output.with_parens(function() {
+                self.argnames.forEach(function(arg, i) {
+                    if (i) output.comma();
+                    arg.print(output);
+                });
+            });
+            output.space();
+            print_bracketed(self.body, output);
+        });
+        DEFPRINT(AST_Lambda, function(self, output) {
+            self._do_print(output);
+        });
+        AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
+            output.print(kind);
+            if (this.value) {
+                output.space();
+                this.value.print(output);
+            }
+            output.semicolon();
+        });
+        DEFPRINT(AST_Return, function(self, output) {
+            self._do_print(output, "return");
+        });
+        DEFPRINT(AST_Throw, function(self, output) {
+            self._do_print(output, "throw");
+        });
+        AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
+            output.print(kind);
+            if (this.label) {
+                output.space();
+                this.label.print(output);
+            }
+            output.semicolon();
+        });
+        DEFPRINT(AST_Break, function(self, output) {
+            self._do_print(output, "break");
+        });
+        DEFPRINT(AST_Continue, function(self, output) {
+            self._do_print(output, "continue");
+        });
+        function make_then(self, output) {
+            if (output.option("bracketize")) {
+                make_block(self.body, output);
+                return;
+            }
+            if (!self.body) return output.force_semicolon();
+            if (self.body instanceof AST_Do && output.option("ie_proof")) {
+                make_block(self.body, output);
+                return;
+            }
+            var b = self.body;
+            while (true) {
+                if (b instanceof AST_If) {
+                    if (!b.alternative) {
+                        make_block(self.body, output);
+                        return;
+                    }
+                    b = b.alternative;
+                } else if (b instanceof AST_StatementWithBody) {
+                    b = b.body;
+                } else break;
+            }
+            force_statement(self.body, output);
+        }
+        DEFPRINT(AST_If, function(self, output) {
+            output.print("if");
+            output.space();
+            output.with_parens(function() {
+                self.condition.print(output);
+            });
+            output.space();
+            if (self.alternative) {
+                make_then(self, output);
+                output.space();
+                output.print("else");
+                output.space();
+                force_statement(self.alternative, output);
+            } else {
+                self._do_print_body(output);
+            }
+        });
+        DEFPRINT(AST_Switch, function(self, output) {
+            output.print("switch");
+            output.space();
+            output.with_parens(function() {
+                self.expression.print(output);
+            });
+            output.space();
+            if (self.body.length > 0) output.with_block(function() {
+                self.body.forEach(function(stmt, i) {
+                    if (i) output.newline();
+                    output.indent(true);
+                    stmt.print(output);
+                });
+            }); else output.print("{}");
+        });
+        AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
+            if (this.body.length > 0) {
+                output.newline();
+                this.body.forEach(function(stmt) {
+                    output.indent();
+                    stmt.print(output);
+                    output.newline();
+                });
+            }
+        });
+        DEFPRINT(AST_Default, function(self, output) {
+            output.print("default:");
+            self._do_print_body(output);
+        });
+        DEFPRINT(AST_Case, function(self, output) {
+            output.print("case");
+            output.space();
+            self.expression.print(output);
+            output.print(":");
+            self._do_print_body(output);
+        });
+        DEFPRINT(AST_Try, function(self, output) {
+            output.print("try");
+            output.space();
+            print_bracketed(self.body, output);
+            if (self.bcatch) {
+                output.space();
+                self.bcatch.print(output);
+            }
+            if (self.bfinally) {
+                output.space();
+                self.bfinally.print(output);
+            }
+        });
+        DEFPRINT(AST_Catch, function(self, output) {
+            output.print("catch");
+            output.space();
+            output.with_parens(function() {
+                self.argname.print(output);
+            });
+            output.space();
+            print_bracketed(self.body, output);
+        });
+        DEFPRINT(AST_Finally, function(self, output) {
+            output.print("finally");
+            output.space();
+            print_bracketed(self.body, output);
+        });
+        AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
+            output.print(kind);
+            output.space();
+            this.definitions.forEach(function(def, i) {
+                if (i) output.comma();
+                def.print(output);
+            });
+            var p = output.parent();
+            var in_for = p instanceof AST_For || p instanceof AST_ForIn;
+            var avoid_semicolon = in_for && p.init === this;
+            if (!avoid_semicolon) output.semicolon();
+        });
+        DEFPRINT(AST_Var, function(self, output) {
+            self._do_print(output, "var");
+        });
+        DEFPRINT(AST_Const, function(self, output) {
+            self._do_print(output, "const");
+        });
+        function parenthesize_for_noin(node, output, noin) {
+            if (!noin) node.print(output); else try {
+                node.walk(new TreeWalker(function(node) {
+                    if (node instanceof AST_Binary && node.operator == "in") throw output;
+                }));
+                node.print(output);
+            } catch (ex) {
+                if (ex !== output) throw ex;
+                node.print(output, true);
+            }
+        }
+        DEFPRINT(AST_VarDef, function(self, output) {
+            self.name.print(output);
+            if (self.value) {
+                output.space();
+                output.print("=");
+                output.space();
+                var p = output.parent(1);
+                var noin = p instanceof AST_For || p instanceof AST_ForIn;
+                parenthesize_for_noin(self.value, output, noin);
+            }
+        });
+        DEFPRINT(AST_Call, function(self, output) {
+            self.expression.print(output);
+            if (self instanceof AST_New && no_constructor_parens(self, output)) return;
+            output.with_parens(function() {
+                self.args.forEach(function(expr, i) {
+                    if (i) output.comma();
+                    expr.print(output);
+                });
+            });
+        });
+        DEFPRINT(AST_New, function(self, output) {
+            output.print("new");
+            output.space();
+            AST_Call.prototype._codegen(self, output);
+        });
+        AST_Seq.DEFMETHOD("_do_print", function(output) {
+            this.car.print(output);
+            if (this.cdr) {
+                output.comma();
+                if (output.should_break()) {
+                    output.newline();
+                    output.indent();
+                }
+                this.cdr.print(output);
+            }
+        });
+        DEFPRINT(AST_Seq, function(self, output) {
+            self._do_print(output);
+        });
+        DEFPRINT(AST_Dot, function(self, output) {
+            var expr = self.expression;
+            expr.print(output);
+            if (expr instanceof AST_Number && expr.getValue() >= 0) {
+                if (!/[xa-f.]/i.test(output.last())) {
+                    output.print(".");
+                }
+            }
+            output.print(".");
+            output.add_mapping(self.end);
+            output.print_name(self.property);
+        });
+        DEFPRINT(AST_Sub, function(self, output) {
+            self.expression.print(output);
+            output.print("[");
+            self.property.print(output);
+            output.print("]");
+        });
+        DEFPRINT(AST_UnaryPrefix, function(self, output) {
+            var op = self.operator;
+            output.print(op);
+            if (/^[a-z]/i.test(op)) output.space();
+            self.expression.print(output);
+        });
+        DEFPRINT(AST_UnaryPostfix, function(self, output) {
+            self.expression.print(output);
+            output.print(self.operator);
+        });
+        DEFPRINT(AST_Binary, function(self, output) {
+            self.left.print(output);
+            output.space();
+            output.print(self.operator);
+            output.space();
+            self.right.print(output);
+        });
+        DEFPRINT(AST_Conditional, function(self, output) {
+            self.condition.print(output);
+            output.space();
+            output.print("?");
+            output.space();
+            self.consequent.print(output);
+            output.space();
+            output.colon();
+            self.alternative.print(output);
+        });
+        DEFPRINT(AST_Array, function(self, output) {
+            output.with_square(function() {
+                var a = self.elements, len = a.length;
+                if (len > 0) output.space();
+                a.forEach(function(exp, i) {
+                    if (i) output.comma();
+                    exp.print(output);
+                });
+                if (len > 0) output.space();
+            });
+        });
+        DEFPRINT(AST_Object, function(self, output) {
+            if (self.properties.length > 0) output.with_block(function() {
+                self.properties.forEach(function(prop, i) {
+                    if (i) {
+                        output.print(",");
+                        output.newline();
+                    }
+                    output.indent();
+                    prop.print(output);
+                });
+                output.newline();
+            }); else output.print("{}");
+        });
+        DEFPRINT(AST_ObjectKeyVal, function(self, output) {
+            var key = self.key;
+            if (output.option("quote_keys")) {
+                output.print_string(key + "");
+            } else if ((typeof key == "number" || !output.option("beautify") && +key + "" == key) && parseFloat(key) >= 0) {
+                output.print(make_num(key));
+            } else if (!is_identifier(key)) {
+                output.print_string(key);
+            } else {
+                output.print_name(key);
+            }
+            output.colon();
+            self.value.print(output);
+        });
+        DEFPRINT(AST_ObjectSetter, function(self, output) {
+            output.print("set");
+            self.value._do_print(output, true);
+        });
+        DEFPRINT(AST_ObjectGetter, function(self, output) {
+            output.print("get");
+            self.value._do_print(output, true);
+        });
+        DEFPRINT(AST_Symbol, function(self, output) {
+            var def = self.definition();
+            output.print_name(def ? def.mangled_name || def.name : self.name);
+        });
+        DEFPRINT(AST_Undefined, function(self, output) {
+            output.print("void 0");
+        });
+        DEFPRINT(AST_Hole, noop);
+        DEFPRINT(AST_Infinity, function(self, output) {
+            output.print("1/0");
+        });
+        DEFPRINT(AST_NaN, function(self, output) {
+            output.print("0/0");
+        });
+        DEFPRINT(AST_This, function(self, output) {
+            output.print("this");
+        });
+        DEFPRINT(AST_Constant, function(self, output) {
+            output.print(self.getValue());
+        });
+        DEFPRINT(AST_String, function(self, output) {
+            output.print_string(self.getValue());
+        });
+        DEFPRINT(AST_Number, function(self, output) {
+            output.print(make_num(self.getValue()));
+        });
+        DEFPRINT(AST_RegExp, function(self, output) {
+            var str = self.getValue().toString();
+            if (output.option("ascii_only")) str = output.to_ascii(str);
+            output.print(str);
+            var p = output.parent();
+            if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self) output.print(" ");
+        });
+        function force_statement(stat, output) {
+            if (output.option("bracketize")) {
+                if (!stat || stat instanceof AST_EmptyStatement) output.print("{}"); else if (stat instanceof AST_BlockStatement) stat.print(output); else output.with_block(function() {
+                    output.indent();
+                    stat.print(output);
+                    output.newline();
+                });
+            } else {
+                if (!stat || stat instanceof AST_EmptyStatement) output.force_semicolon(); else stat.print(output);
+            }
+        }
+        function first_in_statement(output) {
+            var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
+            while (i > 0) {
+                if (p instanceof AST_Statement && p.body === node) return true;
+                if (p instanceof AST_Seq && p.car === node || p instanceof AST_Call && p.expression === node || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {
+                    node = p;
+                    p = a[--i];
+                } else {
+                    return false;
+                }
+            }
+        }
+        function no_constructor_parens(self, output) {
+            return self.args.length == 0 && !output.option("beautify");
+        }
+        function best_of(a) {
+            var best = a[0], len = best.length;
+            for (var i = 1; i < a.length; ++i) {
+                if (a[i].length < len) {
+                    best = a[i];
+                    len = best.length;
+                }
+            }
+            return best;
+        }
+        function make_num(num) {
+            var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace("e+", "e") ], m;
+            if (Math.floor(num) === num) {
+                if (num >= 0) {
+                    a.push("0x" + num.toString(16).toLowerCase(), "0" + num.toString(8));
+                } else {
+                    a.push("-0x" + (-num).toString(16).toLowerCase(), "-0" + (-num).toString(8));
+                }
+                if (m = /^(.*?)(0+)$/.exec(num)) {
+                    a.push(m[1] + "e" + m[2].length);
+                }
+            } else if (m = /^0?\.(0+)(.*)$/.exec(num)) {
+                a.push(m[2] + "e-" + (m[1].length + m[2].length), str.substr(str.indexOf(".")));
+            }
+            return best_of(a);
+        }
+        function make_block(stmt, output) {
+            if (stmt instanceof AST_BlockStatement) {
+                stmt.print(output);
+                return;
+            }
+            output.with_block(function() {
+                output.indent();
+                stmt.print(output);
+                output.newline();
+            });
+        }
+        function DEFMAP(nodetype, generator) {
+            nodetype.DEFMETHOD("add_source_map", function(stream) {
+                generator(this, stream);
+            });
+        }
+        DEFMAP(AST_Node, noop);
+        function basic_sourcemap_gen(self, output) {
+            output.add_mapping(self.start);
+        }
+        DEFMAP(AST_Directive, basic_sourcemap_gen);
+        DEFMAP(AST_Debugger, basic_sourcemap_gen);
+        DEFMAP(AST_Symbol, basic_sourcemap_gen);
+        DEFMAP(AST_Jump, basic_sourcemap_gen);
+        DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
+        DEFMAP(AST_LabeledStatement, noop);
+        DEFMAP(AST_Lambda, basic_sourcemap_gen);
+        DEFMAP(AST_Switch, basic_sourcemap_gen);
+        DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
+        DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
+        DEFMAP(AST_Toplevel, noop);
+        DEFMAP(AST_New, basic_sourcemap_gen);
+        DEFMAP(AST_Try, basic_sourcemap_gen);
+        DEFMAP(AST_Catch, basic_sourcemap_gen);
+        DEFMAP(AST_Finally, basic_sourcemap_gen);
+        DEFMAP(AST_Definitions, basic_sourcemap_gen);
+        DEFMAP(AST_Constant, basic_sourcemap_gen);
+        DEFMAP(AST_ObjectProperty, function(self, output) {
+            output.add_mapping(self.start, self.key);
+        });
+    })();
+    "use strict";
+    function Compressor(options, false_by_default) {
+        if (!(this instanceof Compressor)) return new Compressor(options, false_by_default);
+        TreeTransformer.call(this, this.before, this.after);
+        this.options = defaults(options, {
+            sequences: !false_by_default,
+            properties: !false_by_default,
+            dead_code: !false_by_default,
+            drop_debugger: !false_by_default,
+            unsafe: false,
+            unsafe_comps: false,
+            conditionals: !false_by_default,
+            comparisons: !false_by_default,
+            evaluate: !false_by_default,
+            booleans: !false_by_default,
+            loops: !false_by_default,
+            unused: !false_by_default,
+            hoist_funs: !false_by_default,
+            hoist_vars: false,
+            if_return: !false_by_default,
+            join_vars: !false_by_default,
+            cascade: !false_by_default,
+            side_effects: !false_by_default,
+            screw_ie8: false,
+            warnings: true,
+            global_defs: {}
+        }, true);
+    }
+    Compressor.prototype = new TreeTransformer();
+    merge(Compressor.prototype, {
+        option: function(key) {
+            return this.options[key];
+        },
+        warn: function() {
+            if (this.options.warnings) AST_Node.warn.apply(AST_Node, arguments);
+        },
+        before: function(node, descend, in_list) {
+            if (node._squeezed) return node;
+            if (node instanceof AST_Scope) {
+                node.drop_unused(this);
+                node = node.hoist_declarations(this);
+            }
+            descend(node, this);
+            node = node.optimize(this);
+            if (node instanceof AST_Scope) {
+                var save_warnings = this.options.warnings;
+                this.options.warnings = false;
+                node.drop_unused(this);
+                this.options.warnings = save_warnings;
+            }
+            node._squeezed = true;
+            return node;
+        }
+    });
+    (function() {
+        function OPT(node, optimizer) {
+            node.DEFMETHOD("optimize", function(compressor) {
+                var self = this;
+                if (self._optimized) return self;
+                var opt = optimizer(self, compressor);
+                opt._optimized = true;
+                if (opt === self) return opt;
+                return opt.transform(compressor);
+            });
+        }
+        OPT(AST_Node, function(self, compressor) {
+            return self;
+        });
+        AST_Node.DEFMETHOD("equivalent_to", function(node) {
+            return this.print_to_string() == node.print_to_string();
+        });
+        function make_node(ctor, orig, props) {
+            if (!props) props = {};
+            if (orig) {
+                if (!props.start) props.start = orig.start;
+                if (!props.end) props.end = orig.end;
+            }
+            return new ctor(props);
+        }
+        function make_node_from_constant(compressor, val, orig) {
+            if (val instanceof AST_Node) return val.transform(compressor);
+            switch (typeof val) {
+              case "string":
+                return make_node(AST_String, orig, {
+                    value: val
+                }).optimize(compressor);
+
+              case "number":
+                return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
+                    value: val
+                }).optimize(compressor);
+
+              case "boolean":
+                return make_node(val ? AST_True : AST_False, orig).optimize(compressor);
+
+              case "undefined":
+                return make_node(AST_Undefined, orig).optimize(compressor);
+
+              default:
+                if (val === null) {
+                    return make_node(AST_Null, orig).optimize(compressor);
+                }
+                if (val instanceof RegExp) {
+                    return make_node(AST_RegExp, orig).optimize(compressor);
+                }
+                throw new Error(string_template("Can't handle constant of type: {type}", {
+                    type: typeof val
+                }));
+            }
+        }
+        function as_statement_array(thing) {
+            if (thing === null) return [];
+            if (thing instanceof AST_BlockStatement) return thing.body;
+            if (thing instanceof AST_EmptyStatement) return [];
+            if (thing instanceof AST_Statement) return [ thing ];
+            throw new Error("Can't convert thing to statement array");
+        }
+        function is_empty(thing) {
+            if (thing === null) return true;
+            if (thing instanceof AST_EmptyStatement) return true;
+            if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
+            return false;
+        }
+        function loop_body(x) {
+            if (x instanceof AST_Switch) return x;
+            if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
+                return x.body instanceof AST_BlockStatement ? x.body : x;
+            }
+            return x;
+        }
+        function tighten_body(statements, compressor) {
+            var CHANGED;
+            do {
+                CHANGED = false;
+                statements = eliminate_spurious_blocks(statements);
+                if (compressor.option("dead_code")) {
+                    statements = eliminate_dead_code(statements, compressor);
+                }
+                if (compressor.option("if_return")) {
+                    statements = handle_if_return(statements, compressor);
+                }
+                if (compressor.option("sequences")) {
+                    statements = sequencesize(statements, compressor);
+                }
+                if (compressor.option("join_vars")) {
+                    statements = join_consecutive_vars(statements, compressor);
+                }
+            } while (CHANGED);
+            return statements;
+            function eliminate_spurious_blocks(statements) {
+                var seen_dirs = [];
+                return statements.reduce(function(a, stat) {
+                    if (stat instanceof AST_BlockStatement) {
+                        CHANGED = true;
+                        a.push.apply(a, eliminate_spurious_blocks(stat.body));
+                    } else if (stat instanceof AST_EmptyStatement) {
+                        CHANGED = true;
+                    } else if (stat instanceof AST_Directive) {
+                        if (seen_dirs.indexOf(stat.value) < 0) {
+                            a.push(stat);
+                            seen_dirs.push(stat.value);
+                        } else {
+                            CHANGED = true;
+                        }
+                    } else {
+                        a.push(stat);
+                    }
+                    return a;
+                }, []);
+            }
+            function handle_if_return(statements, compressor) {
+                var self = compressor.self();
+                var in_lambda = self instanceof AST_Lambda;
+                var ret = [];
+                loop: for (var i = statements.length; --i >= 0; ) {
+                    var stat = statements[i];
+                    switch (true) {
+                      case in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0:
+                        CHANGED = true;
+                        continue loop;
+
+                      case stat instanceof AST_If:
+                        if (stat.body instanceof AST_Return) {
+                            if ((in_lambda && ret.length == 0 || ret[0] instanceof AST_Return && !ret[0].value) && !stat.body.value && !stat.alternative) {
+                                CHANGED = true;
+                                var cond = make_node(AST_SimpleStatement, stat.condition, {
+                                    body: stat.condition
+                                });
+                                ret.unshift(cond);
+                                continue loop;
+                            }
+                            if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
+                                CHANGED = true;
+                                stat = stat.clone();
+                                stat.alternative = ret[0];
+                                ret[0] = stat.transform(compressor);
+                                continue loop;
+                            }
+                            if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
+                                CHANGED = true;
+                                stat = stat.clone();
+                                stat.alternative = ret[0] || make_node(AST_Return, stat, {
+                                    value: make_node(AST_Undefined, stat)
+                                });
+                                ret[0] = stat.transform(compressor);
+                                continue loop;
+                            }
+                            if (!stat.body.value && in_lambda) {
+                                CHANGED = true;
+                                stat = stat.clone();
+                                stat.condition = stat.condition.negate(compressor);
+                                stat.body = make_node(AST_BlockStatement, stat, {
+                                    body: as_statement_array(stat.alternative).concat(ret)
+                                });
+                                stat.alternative = null;
+                                ret = [ stat.transform(compressor) ];
+                                continue loop;
+                            }
+                            if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
+                                CHANGED = true;
+                                ret.push(make_node(AST_Return, ret[0], {
+                                    value: make_node(AST_Undefined, ret[0])
+                                }).transform(compressor));
+                                ret = as_statement_array(stat.alternative).concat(ret);
+                                ret.unshift(stat);
+                                continue loop;
+                            }
+                        }
+                        var ab = aborts(stat.body);
+                        var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
+                        if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
+                            if (ab.label) {
+                                remove(ab.label.thedef.references, ab.label);
+                            }
+                            CHANGED = true;
+                            var body = as_statement_array(stat.body).slice(0, -1);
+                            stat = stat.clone();
+                            stat.condition = stat.condition.negate(compressor);
+                            stat.body = make_node(AST_BlockStatement, stat, {
+                                body: ret
+                            });
+                            stat.alternative = make_node(AST_BlockStatement, stat, {
+                                body: body
+                            });
+                            ret = [ stat.transform(compressor) ];
+                            continue loop;
+                        }
+                        var ab = aborts(stat.alternative);
+                        var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
+                        if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
+                            if (ab.label) {
+                                remove(ab.label.thedef.references, ab.label);
+                            }
+                            CHANGED = true;
+                            stat = stat.clone();
+                            stat.body = make_node(AST_BlockStatement, stat.body, {
+                                body: as_statement_array(stat.body).concat(ret)
+                            });
+                            stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
+                                body: as_statement_array(stat.alternative).slice(0, -1)
+                            });
+                            ret = [ stat.transform(compressor) ];
+                            continue loop;
+                        }
+                        ret.unshift(stat);
+                        break;
+
+                      default:
+                        ret.unshift(stat);
+                        break;
+                    }
+                }
+                return ret;
+            }
+            function eliminate_dead_code(statements, compressor) {
+                var has_quit = false;
+                var orig = statements.length;
+                var self = compressor.self();
+                statements = statements.reduce(function(a, stat) {
+                    if (has_quit) {
+                        extract_declarations_from_unreachable_code(compressor, stat, a);
+                    } else {
+                        if (stat instanceof AST_LoopControl) {
+                            var lct = compressor.loopcontrol_target(stat.label);
+                            if (stat instanceof AST_Break && lct instanceof AST_BlockStatement && loop_body(lct) === self || stat instanceof AST_Continue && loop_body(lct) === self) {
+                                if (stat.label) {
+                                    remove(stat.label.thedef.references, stat.label);
+                                }
+                            } else {
+                                a.push(stat);
+                            }
+                        } else {
+                            a.push(stat);
+                        }
+                        if (aborts(stat)) has_quit = true;
+                    }
+                    return a;
+                }, []);
+                CHANGED = statements.length != orig;
+                return statements;
+            }
+            function sequencesize(statements, compressor) {
+                if (statements.length < 2) return statements;
+                var seq = [], ret = [];
+                function push_seq() {
+                    seq = AST_Seq.from_array(seq);
+                    if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
+                        body: seq
+                    }));
+                    seq = [];
+                }
+                statements.forEach(function(stat) {
+                    if (stat instanceof AST_SimpleStatement) seq.push(stat.body); else push_seq(), ret.push(stat);
+                });
+                push_seq();
+                ret = sequencesize_2(ret, compressor);
+                CHANGED = ret.length != statements.length;
+                return ret;
+            }
+            function sequencesize_2(statements, compressor) {
+                function cons_seq(right) {
+                    ret.pop();
+                    var left = prev.body;
+                    if (left instanceof AST_Seq) {
+                        left.add(right);
+                    } else {
+                        left = AST_Seq.cons(left, right);
+                    }
+                    return left.transform(compressor);
+                }
+                var ret = [], prev = null;
+                statements.forEach(function(stat) {
+                    if (prev) {
+                        if (stat instanceof AST_For) {
+                            var opera = {};
+                            try {
+                                prev.body.walk(new TreeWalker(function(node) {
+                                    if (node instanceof AST_Binary && node.operator == "in") throw opera;
+                                }));
+                                if (stat.init && !(stat.init instanceof AST_Definitions)) {
+                                    stat.init = cons_seq(stat.init);
+                                } else if (!stat.init) {
+                                    stat.init = prev.body;
+                                    ret.pop();
+                                }
+                            } catch (ex) {
+                                if (ex !== opera) throw ex;
+                            }
+                        } else if (stat instanceof AST_If) {
+                            stat.condition = cons_seq(stat.condition);
+                        } else if (stat instanceof AST_With) {
+                            stat.expression = cons_seq(stat.expression);
+                        } else if (stat instanceof AST_Exit && stat.value) {
+                            stat.value = cons_seq(stat.value);
+                        } else if (stat instanceof AST_Exit) {
+                            stat.value = cons_seq(make_node(AST_Undefined, stat));
+                        } else if (stat instanceof AST_Switch) {
+                            stat.expression = cons_seq(stat.expression);
+                        }
+                    }
+                    ret.push(stat);
+                    prev = stat instanceof AST_SimpleStatement ? stat : null;
+                });
+                return ret;
+            }
+            function join_consecutive_vars(statements, compressor) {
+                var prev = null;
+                return statements.reduce(function(a, stat) {
+                    if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
+                        prev.definitions = prev.definitions.concat(stat.definitions);
+                        CHANGED = true;
+                    } else if (stat instanceof AST_For && prev instanceof AST_Definitions && (!stat.init || stat.init.TYPE == prev.TYPE)) {
+                        CHANGED = true;
+                        a.pop();
+                        if (stat.init) {
+                            stat.init.definitions = prev.definitions.concat(stat.init.definitions);
+                        } else {
+                            stat.init = prev;
+                        }
+                        a.push(stat);
+                        prev = stat;
+                    } else {
+                        prev = stat;
+                        a.push(stat);
+                    }
+                    return a;
+                }, []);
+            }
+        }
+        function extract_declarations_from_unreachable_code(compressor, stat, target) {
+            compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
+            stat.walk(new TreeWalker(function(node) {
+                if (node instanceof AST_Definitions) {
+                    compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
+                    node.remove_initializers();
+                    target.push(node);
+                    return true;
+                }
+                if (node instanceof AST_Defun) {
+                    target.push(node);
+                    return true;
+                }
+                if (node instanceof AST_Scope) {
+                    return true;
+                }
+            }));
+        }
+        (function(def) {
+            var unary_bool = [ "!", "delete" ];
+            var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
+            def(AST_Node, function() {
+                return false;
+            });
+            def(AST_UnaryPrefix, function() {
+                return member(this.operator, unary_bool);
+            });
+            def(AST_Binary, function() {
+                return member(this.operator, binary_bool) || (this.operator == "&&" || this.operator == "||") && this.left.is_boolean() && this.right.is_boolean();
+            });
+            def(AST_Conditional, function() {
+                return this.consequent.is_boolean() && this.alternative.is_boolean();
+            });
+            def(AST_Assign, function() {
+                return this.operator == "=" && this.right.is_boolean();
+            });
+            def(AST_Seq, function() {
+                return this.cdr.is_boolean();
+            });
+            def(AST_True, function() {
+                return true;
+            });
+            def(AST_False, function() {
+                return true;
+            });
+        })(function(node, func) {
+            node.DEFMETHOD("is_boolean", func);
+        });
+        (function(def) {
+            def(AST_Node, function() {
+                return false;
+            });
+            def(AST_String, function() {
+                return true;
+            });
+            def(AST_UnaryPrefix, function() {
+                return this.operator == "typeof";
+            });
+            def(AST_Binary, function(compressor) {
+                return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
+            });
+            def(AST_Assign, function(compressor) {
+                return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
+            });
+            def(AST_Seq, function(compressor) {
+                return this.cdr.is_string(compressor);
+            });
+            def(AST_Conditional, function(compressor) {
+                return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
+            });
+            def(AST_Call, function(compressor) {
+                return compressor.option("unsafe") && this.expression instanceof AST_SymbolRef && this.expression.name == "String" && this.expression.undeclared();
+            });
+        })(function(node, func) {
+            node.DEFMETHOD("is_string", func);
+        });
+        function best_of(ast1, ast2) {
+            return ast1.print_to_string().length > ast2.print_to_string().length ? ast2 : ast1;
+        }
+        (function(def) {
+            AST_Node.DEFMETHOD("evaluate", function(compressor) {
+                if (!compressor.option("evaluate")) return [ this ];
+                try {
+                    var val = this._eval(), ast = make_node_from_constant(compressor, val, this);
+                    return [ best_of(ast, this), val ];
+                } catch (ex) {
+                    if (ex !== def) throw ex;
+                    return [ this ];
+                }
+            });
+            def(AST_Statement, function() {
+                throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
+            });
+            def(AST_Function, function() {
+                return [ this ];
+            });
+            function ev(node) {
+                return node._eval();
+            }
+            def(AST_Node, function() {
+                throw def;
+            });
+            def(AST_Constant, function() {
+                return this.getValue();
+            });
+            def(AST_UnaryPrefix, function() {
+                var e = this.expression;
+                switch (this.operator) {
+                  case "!":
+                    return !ev(e);
+
+                  case "typeof":
+                    if (e instanceof AST_Function) return typeof function() {};
+                    e = ev(e);
+                    if (e instanceof RegExp) throw def;
+                    return typeof e;
+
+                  case "void":
+                    return void ev(e);
+
+                  case "~":
+                    return ~ev(e);
+
+                  case "-":
+                    e = ev(e);
+                    if (e === 0) throw def;
+                    return -e;
+
+                  case "+":
+                    return +ev(e);
+                }
+                throw def;
+            });
+            def(AST_Binary, function() {
+                var left = this.left, right = this.right;
+                switch (this.operator) {
+                  case "&&":
+                    return ev(left) && ev(right);
+
+                  case "||":
+                    return ev(left) || ev(right);
+
+                  case "|":
+                    return ev(left) | ev(right);
+
+                  case "&":
+                    return ev(left) & ev(right);
+
+                  case "^":
+                    return ev(left) ^ ev(right);
+
+                  case "+":
+                    return ev(left) + ev(right);
+
+                  case "*":
+                    return ev(left) * ev(right);
+
+                  case "/":
+                    return ev(left) / ev(right);
+
+                  case "%":
+                    return ev(left) % ev(right);
+
+                  case "-":
+                    return ev(left) - ev(right);
+
+                  case "<<":
+                    return ev(left) << ev(right);
+
+                  case ">>":
+                    return ev(left) >> ev(right);
+
+                  case ">>>":
+                    return ev(left) >>> ev(right);
+
+                  case "==":
+                    return ev(left) == ev(right);
+
+                  case "===":
+                    return ev(left) === ev(right);
+
+                  case "!=":
+                    return ev(left) != ev(right);
+
+                  case "!==":
+                    return ev(left) !== ev(right);
+
+                  case "<":
+                    return ev(left) < ev(right);
+
+                  case "<=":
+                    return ev(left) <= ev(right);
+
+                  case ">":
+                    return ev(left) > ev(right);
+
+                  case ">=":
+                    return ev(left) >= ev(right);
+
+                  case "in":
+                    return ev(left) in ev(right);
+
+                  case "instanceof":
+                    return ev(left) instanceof ev(right);
+                }
+                throw def;
+            });
+            def(AST_Conditional, function() {
+                return ev(this.condition) ? ev(this.consequent) : ev(this.alternative);
+            });
+            def(AST_SymbolRef, function() {
+                var d = this.definition();
+                if (d && d.constant && d.init) return ev(d.init);
+                throw def;
+            });
+        })(function(node, func) {
+            node.DEFMETHOD("_eval", func);
+        });
+        (function(def) {
+            function basic_negation(exp) {
+                return make_node(AST_UnaryPrefix, exp, {
+                    operator: "!",
+                    expression: exp
+                });
+            }
+            def(AST_Node, function() {
+                return basic_negation(this);
+            });
+            def(AST_Statement, function() {
+                throw new Error("Cannot negate a statement");
+            });
+            def(AST_Function, function() {
+                return basic_negation(this);
+            });
+            def(AST_UnaryPrefix, function() {
+                if (this.operator == "!") return this.expression;
+                return basic_negation(this);
+            });
+            def(AST_Seq, function(compressor) {
+                var self = this.clone();
+                self.cdr = self.cdr.negate(compressor);
+                return self;
+            });
+            def(AST_Conditional, function(compressor) {
+                var self = this.clone();
+                self.consequent = self.consequent.negate(compressor);
+                self.alternative = self.alternative.negate(compressor);
+                return best_of(basic_negation(this), self);
+            });
+            def(AST_Binary, function(compressor) {
+                var self = this.clone(), op = this.operator;
+                if (compressor.option("unsafe_comps")) {
+                    switch (op) {
+                      case "<=":
+                        self.operator = ">";
+                        return self;
+
+                      case "<":
+                        self.operator = ">=";
+                        return self;
+
+                      case ">=":
+                        self.operator = "<";
+                        return self;
+
+                      case ">":
+                        self.operator = "<=";
+                        return self;
+                    }
+                }
+                switch (op) {
+                  case "==":
+                    self.operator = "!=";
+                    return self;
+
+                  case "!=":
+                    self.operator = "==";
+                    return self;
+
+                  case "===":
+                    self.operator = "!==";
+                    return self;
+
+                  case "!==":
+                    self.operator = "===";
+                    return self;
+
+                  case "&&":
+                    self.operator = "||";
+                    self.left = self.left.negate(compressor);
+                    self.right = self.right.negate(compressor);
+                    return best_of(basic_negation(this), self);
+
+                  case "||":
+                    self.operator = "&&";
+                    self.left = self.left.negate(compressor);
+                    self.right = self.right.negate(compressor);
+                    return best_of(basic_negation(this), self);
+                }
+                return basic_negation(this);
+            });
+        })(function(node, func) {
+            node.DEFMETHOD("negate", function(compressor) {
+                return func.call(this, compressor);
+            });
+        });
+        (function(def) {
+            def(AST_Node, function() {
+                return true;
+            });
+            def(AST_EmptyStatement, function() {
+                return false;
+            });
+            def(AST_Constant, function() {
+                return false;
+            });
+            def(AST_This, function() {
+                return false;
+            });
+            def(AST_Block, function() {
+                for (var i = this.body.length; --i >= 0; ) {
+                    if (this.body[i].has_side_effects()) return true;
+                }
+                return false;
+            });
+            def(AST_SimpleStatement, function() {
+                return this.body.has_side_effects();
+            });
+            def(AST_Defun, function() {
+                return true;
+            });
+            def(AST_Function, function() {
+                return false;
+            });
+            def(AST_Binary, function() {
+                return this.left.has_side_effects() || this.right.has_side_effects();
+            });
+            def(AST_Assign, function() {
+                return true;
+            });
+            def(AST_Conditional, function() {
+                return this.condition.has_side_effects() || this.consequent.has_side_effects() || this.alternative.has_side_effects();
+            });
+            def(AST_Unary, function() {
+                return this.operator == "delete" || this.operator == "++" || this.operator == "--" || this.expression.has_side_effects();
+            });
+            def(AST_SymbolRef, function() {
+                return false;
+            });
+            def(AST_Object, function() {
+                for (var i = this.properties.length; --i >= 0; ) if (this.properties[i].has_side_effects()) return true;
+                return false;
+            });
+            def(AST_ObjectProperty, function() {
+                return this.value.has_side_effects();
+            });
+            def(AST_Array, function() {
+                for (var i = this.elements.length; --i >= 0; ) if (this.elements[i].has_side_effects()) return true;
+                return false;
+            });
+            def(AST_PropAccess, function() {
+                return true;
+            });
+            def(AST_Seq, function() {
+                return this.car.has_side_effects() || this.cdr.has_side_effects();
+            });
+        })(function(node, func) {
+            node.DEFMETHOD("has_side_effects", func);
+        });
+        function aborts(thing) {
+            return thing && thing.aborts();
+        }
+        (function(def) {
+            def(AST_Statement, function() {
+                return null;
+            });
+            def(AST_Jump, function() {
+                return this;
+            });
+            function block_aborts() {
+                var n = this.body.length;
+                return n > 0 && aborts(this.body[n - 1]);
+            }
+            def(AST_BlockStatement, block_aborts);
+            def(AST_SwitchBranch, block_aborts);
+            def(AST_If, function() {
+                return this.alternative && aborts(this.body) && aborts(this.alternative);
+            });
+        })(function(node, func) {
+            node.DEFMETHOD("aborts", func);
+        });
+        OPT(AST_Directive, function(self, compressor) {
+            if (self.scope.has_directive(self.value) !== self.scope) {
+                return make_node(AST_EmptyStatement, self);
+            }
+            return self;
+        });
+        OPT(AST_Debugger, function(self, compressor) {
+            if (compressor.option("drop_debugger")) return make_node(AST_EmptyStatement, self);
+            return self;
+        });
+        OPT(AST_LabeledStatement, function(self, compressor) {
+            if (self.body instanceof AST_Break && compressor.loopcontrol_target(self.body.label) === self.body) {
+                return make_node(AST_EmptyStatement, self);
+            }
+            return self.label.references.length == 0 ? self.body : self;
+        });
+        OPT(AST_Block, function(self, compressor) {
+            self.body = tighten_body(self.body, compressor);
+            return self;
+        });
+        OPT(AST_BlockStatement, function(self, compressor) {
+            self.body = tighten_body(self.body, compressor);
+            switch (self.body.length) {
+              case 1:
+                return self.body[0];
+
+              case 0:
+                return make_node(AST_EmptyStatement, self);
+            }
+            return self;
+        });
+        AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
+            var self = this;
+            if (compressor.option("unused") && !(self instanceof AST_Toplevel) && !self.uses_eval) {
+                var in_use = [];
+                var initializations = new Dictionary();
+                var scope = this;
+                var tw = new TreeWalker(function(node, descend) {
+                    if (node !== self) {
+                        if (node instanceof AST_Defun) {
+                            initializations.add(node.name.name, node);
+                            return true;
+                        }
+                        if (node instanceof AST_Definitions && scope === self) {
+                            node.definitions.forEach(function(def) {
+                                if (def.value) {
+                                    initializations.add(def.name.name, def.value);
+                                    if (def.value.has_side_effects()) {
+                                        def.value.walk(tw);
+                                    }
+                                }
+                            });
+                            return true;
+                        }
+                        if (node instanceof AST_SymbolRef) {
+                            push_uniq(in_use, node.definition());
+                            return true;
+                        }
+                        if (node instanceof AST_Scope) {
+                            var save_scope = scope;
+                            scope = node;
+                            descend();
+                            scope = save_scope;
+                            return true;
+                        }
+                    }
+                });
+                self.walk(tw);
+                for (var i = 0; i < in_use.length; ++i) {
+                    in_use[i].orig.forEach(function(decl) {
+                        var init = initializations.get(decl.name);
+                        if (init) init.forEach(function(init) {
+                            var tw = new TreeWalker(function(node) {
+                                if (node instanceof AST_SymbolRef) {
+                                    push_uniq(in_use, node.definition());
+                                }
+                            });
+                            init.walk(tw);
+                        });
+                    });
+                }
+                var tt = new TreeTransformer(function before(node, descend, in_list) {
+                    if (node instanceof AST_Lambda) {
+                        for (var a = node.argnames, i = a.length; --i >= 0; ) {
+                            var sym = a[i];
+                            if (sym.unreferenced()) {
+                                a.pop();
+                                compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
+                                    name: sym.name,
+                                    file: sym.start.file,
+                                    line: sym.start.line,
+                                    col: sym.start.col
+                                });
+                            } else break;
+                        }
+                    }
+                    if (node instanceof AST_Defun && node !== self) {
+                        if (!member(node.name.definition(), in_use)) {
+                            compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
+                                name: node.name.name,
+                                file: node.name.start.file,
+                                line: node.name.start.line,
+                                col: node.name.start.col
+                            });
+                            return make_node(AST_EmptyStatement, node);
+                        }
+                        return node;
+                    }
+                    if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
+                        var def = node.definitions.filter(function(def) {
+                            if (member(def.name.definition(), in_use)) return true;
+                            var w = {
+                                name: def.name.name,
+                                file: def.name.start.file,
+                                line: def.name.start.line,
+                                col: def.name.start.col
+                            };
+                            if (def.value && def.value.has_side_effects()) {
+                                def._unused_side_effects = true;
+                                compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
+                                return true;
+                            }
+                            compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
+                            return false;
+                        });
+                        def = mergeSort(def, function(a, b) {
+                            if (!a.value && b.value) return -1;
+                            if (!b.value && a.value) return 1;
+                            return 0;
+                        });
+                        var side_effects = [];
+                        for (var i = 0; i < def.length; ) {
+                            var x = def[i];
+                            if (x._unused_side_effects) {
+                                side_effects.push(x.value);
+                                def.splice(i, 1);
+                            } else {
+                                if (side_effects.length > 0) {
+                                    side_effects.push(x.value);
+                                    x.value = AST_Seq.from_array(side_effects);
+                                    side_effects = [];
+                                }
+                                ++i;
+                            }
+                        }
+                        if (side_effects.length > 0) {
+                            side_effects = make_node(AST_BlockStatement, node, {
+                                body: [ make_node(AST_SimpleStatement, node, {
+                                    body: AST_Seq.from_array(side_effects)
+                                }) ]
+                            });
+                        } else {
+                            side_effects = null;
+                        }
+                        if (def.length == 0 && !side_effects) {
+                            return make_node(AST_EmptyStatement, node);
+                        }
+                        if (def.length == 0) {
+                            return side_effects;
+                        }
+                        node.definitions = def;
+                        if (side_effects) {
+                            side_effects.body.unshift(node);
+                            node = side_effects;
+                        }
+                        return node;
+                    }
+                    if (node instanceof AST_For && node.init instanceof AST_BlockStatement) {
+                        descend(node, this);
+                        var body = node.init.body.slice(0, -1);
+                        node.init = node.init.body.slice(-1)[0].body;
+                        body.push(node);
+                        return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
+                            body: body
+                        });
+                    }
+                    if (node instanceof AST_Scope && node !== self) return node;
+                });
+                self.transform(tt);
+            }
+        });
+        AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
+            var hoist_funs = compressor.option("hoist_funs");
+            var hoist_vars = compressor.option("hoist_vars");
+            var self = this;
+            if (hoist_funs || hoist_vars) {
+                var dirs = [];
+                var hoisted = [];
+                var vars = new Dictionary(), vars_found = 0, var_decl = 0;
+                self.walk(new TreeWalker(function(node) {
+                    if (node instanceof AST_Scope && node !== self) return true;
+                    if (node instanceof AST_Var) {
+                        ++var_decl;
+                        return true;
+                    }
+                }));
+                hoist_vars = hoist_vars && var_decl > 1;
+                var tt = new TreeTransformer(function before(node) {
+                    if (node !== self) {
+                        if (node instanceof AST_Directive) {
+                            dirs.push(node);
+                            return make_node(AST_EmptyStatement, node);
+                        }
+                        if (node instanceof AST_Defun && hoist_funs) {
+                            hoisted.push(node);
+                            return make_node(AST_EmptyStatement, node);
+                        }
+                        if (node instanceof AST_Var && hoist_vars) {
+                            node.definitions.forEach(function(def) {
+                                vars.set(def.name.name, def);
+                                ++vars_found;
+                            });
+                            var seq = node.to_assignments();
+                            var p = tt.parent();
+                            if (p instanceof AST_ForIn && p.init === node) {
+                                if (seq == null) return node.definitions[0].name;
+                                return seq;
+                            }
+                            if (p instanceof AST_For && p.init === node) {
+                                return seq;
+                            }
+                            if (!seq) return make_node(AST_EmptyStatement, node);
+                            return make_node(AST_SimpleStatement, node, {
+                                body: seq
+                            });
+                        }
+                        if (node instanceof AST_Scope) return node;
+                    }
+                });
+                self = self.transform(tt);
+                if (vars_found > 0) {
+                    var defs = [];
+                    vars.each(function(def, name) {
+                        if (self instanceof AST_Lambda && find_if(function(x) {
+                            return x.name == def.name.name;
+                        }, self.argnames)) {
+                            vars.del(name);
+                        } else {
+                            def = def.clone();
+                            def.value = null;
+                            defs.push(def);
+                            vars.set(name, def);
+                        }
+                    });
+                    if (defs.length > 0) {
+                        for (var i = 0; i < self.body.length; ) {
+                            if (self.body[i] instanceof AST_SimpleStatement) {
+                                var expr = self.body[i].body, sym, assign;
+                                if (expr instanceof AST_Assign && expr.operator == "=" && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
+                                    var def = vars.get(sym.name);
+                                    if (def.value) break;
+                                    def.value = expr.right;
+                                    remove(defs, def);
+                                    defs.push(def);
+                                    self.body.splice(i, 1);
+                                    continue;
+                                }
+                                if (expr instanceof AST_Seq && (assign = expr.car) instanceof AST_Assign && assign.operator == "=" && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
+                                    var def = vars.get(sym.name);
+                                    if (def.value) break;
+                                    def.value = assign.right;
+                                    remove(defs, def);
+                                    defs.push(def);
+                                    self.body[i].body = expr.cdr;
+                                    continue;
+                                }
+                            }
+                            if (self.body[i] instanceof AST_EmptyStatement) {
+                                self.body.splice(i, 1);
+                                continue;
+                            }
+                            if (self.body[i] instanceof AST_BlockStatement) {
+                                var tmp = [ i, 1 ].concat(self.body[i].body);
+                                self.body.splice.apply(self.body, tmp);
+                                continue;
+                            }
+                            break;
+                        }
+                        defs = make_node(AST_Var, self, {
+                            definitions: defs
+                        });
+                        hoisted.push(defs);
+                    }
+                }
+                self.body = dirs.concat(hoisted, self.body);
+            }
+            return self;
+        });
+        OPT(AST_SimpleStatement, function(self, compressor) {
+            if (compressor.option("side_effects")) {
+                if (!self.body.has_side_effects()) {
+                    compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
+                    return make_node(AST_EmptyStatement, self);
+                }
+            }
+            return self;
+        });
+        OPT(AST_DWLoop, function(self, compressor) {
+            var cond = self.condition.evaluate(compressor);
+            self.condition = cond[0];
+            if (!compressor.option("loops")) return self;
+            if (cond.length > 1) {
+                if (cond[1]) {
+                    return make_node(AST_For, self, {
+                        body: self.body
+                    });
+                } else if (self instanceof AST_While) {
+                    if (compressor.option("dead_code")) {
+                        var a = [];
+                        extract_declarations_from_unreachable_code(compressor, self.body, a);
+                        return make_node(AST_BlockStatement, self, {
+                            body: a
+                        });
+                    }
+                }
+            }
+            return self;
+        });
+        function if_break_in_loop(self, compressor) {
+            function drop_it(rest) {
+                rest = as_statement_array(rest);
+                if (self.body instanceof AST_BlockStatement) {
+                    self.body = self.body.clone();
+                    self.body.body = rest.concat(self.body.body.slice(1));
+                    self.body = self.body.transform(compressor);
+                } else {
+                    self.body = make_node(AST_BlockStatement, self.body, {
+                        body: rest
+                    }).transform(compressor);
+                }
+                if_break_in_loop(self, compressor);
+            }
+            var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
+            if (first instanceof AST_If) {
+                if (first.body instanceof AST_Break && compressor.loopcontrol_target(first.body.label) === self) {
+                    if (self.condition) {
+                        self.condition = make_node(AST_Binary, self.condition, {
+                            left: self.condition,
+                            operator: "&&",
+                            right: first.condition.negate(compressor)
+                        });
+                    } else {
+                        self.condition = first.condition.negate(compressor);
+                    }
+                    drop_it(first.alternative);
+                } else if (first.alternative instanceof AST_Break && compressor.loopcontrol_target(first.alternative.label) === self) {
+                    if (self.condition) {
+                        self.condition = make_node(AST_Binary, self.condition, {
+                            left: self.condition,
+                            operator: "&&",
+                            right: first.condition
+                        });
+                    } else {
+                        self.condition = first.condition;
+                    }
+                    drop_it(first.body);
+                }
+            }
+        }
+        OPT(AST_While, function(self, compressor) {
+            if (!compressor.option("loops")) return self;
+            self = AST_DWLoop.prototype.optimize.call(self, compressor);
+            if (self instanceof AST_While) {
+                if_break_in_loop(self, compressor);
+                self = make_node(AST_For, self, self).transform(compressor);
+            }
+            return self;
+        });
+        OPT(AST_For, function(self, compressor) {
+            var cond = self.condition;
+            if (cond) {
+                cond = cond.evaluate(compressor);
+                self.condition = cond[0];
+            }
+            if (!compressor.option("loops")) return self;
+            if (cond) {
+                if (cond.length > 1 && !cond[1]) {
+                    if (compressor.option("dead_code")) {
+                        var a = [];
+                        if (self.init instanceof AST_Statement) {
+                            a.push(self.init);
+                        } else if (self.init) {
+                            a.push(make_node(AST_SimpleStatement, self.init, {
+                                body: self.init
+                            }));
+                        }
+                        extract_declarations_from_unreachable_code(compressor, self.body, a);
+                        return make_node(AST_BlockStatement, self, {
+                            body: a
+                        });
+                    }
+                }
+            }
+            if_break_in_loop(self, compressor);
+            return self;
+        });
+        OPT(AST_If, function(self, compressor) {
+            if (!compressor.option("conditionals")) return self;
+            var cond = self.condition.evaluate(compressor);
+            self.condition = cond[0];
+            if (cond.length > 1) {
+                if (cond[1]) {
+                    compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
+                    if (compressor.option("dead_code")) {
+                        var a = [];
+                        if (self.alternative) {
+                            extract_declarations_from_unreachable_code(compressor, self.alternative, a);
+                        }
+                        a.push(self.body);
+                        return make_node(AST_BlockStatement, self, {
+                            body: a
+                        }).transform(compressor);
+                    }
+                } else {
+                    compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
+                    if (compressor.option("dead_code")) {
+                        var a = [];
+                        extract_declarations_from_unreachable_code(compressor, self.body, a);
+                        if (self.alternative) a.push(self.alternative);
+                        return make_node(AST_BlockStatement, self, {
+                            body: a
+                        }).transform(compressor);
+                    }
+                }
+            }
+            if (is_empty(self.alternative)) self.alternative = null;
+            var negated = self.condition.negate(compressor);
+            var negated_is_best = best_of(self.condition, negated) === negated;
+            if (self.alternative && negated_is_best) {
+                negated_is_best = false;
+                self.condition = negated;
+                var tmp = self.body;
+                self.body = self.alternative || make_node(AST_EmptyStatement);
+                self.alternative = tmp;
+            }
+            if (is_empty(self.body) && is_empty(self.alternative)) {
+                return make_node(AST_SimpleStatement, self.condition, {
+                    body: self.condition
+                }).transform(compressor);
+            }
+            if (self.body instanceof AST_SimpleStatement && self.alternative instanceof AST_SimpleStatement) {
+                return make_node(AST_SimpleStatement, self, {
+                    body: make_node(AST_Conditional, self, {
+                        condition: self.condition,
+                        consequent: self.body.body,
+                        alternative: self.alternative.body
+                    })
+                }).transform(compressor);
+            }
+            if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
+                if (negated_is_best) return make_node(AST_SimpleStatement, self, {
+                    body: make_node(AST_Binary, self, {
+                        operator: "||",
+                        left: negated,
+                        right: self.body.body
+                    })
+                }).transform(compressor);
+                return make_node(AST_SimpleStatement, self, {
+                    body: make_node(AST_Binary, self, {
+                        operator: "&&",
+                        left: self.condition,
+                        right: self.body.body
+                    })
+                }).transform(compressor);
+            }
+            if (self.body instanceof AST_EmptyStatement && self.alternative && self.alternative instanceof AST_SimpleStatement) {
+                return make_node(AST_SimpleStatement, self, {
+                    body: make_node(AST_Binary, self, {
+                        operator: "||",
+                        left: self.condition,
+                        right: self.alternative.body
+                    })
+                }).transform(compressor);
+            }
+            if (self.body instanceof AST_Exit && self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) {
+                return make_node(self.body.CTOR, self, {
+                    value: make_node(AST_Conditional, self, {
+                        condition: self.condition,
+                        consequent: self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
+                        alternative: self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
+                    })
+                }).transform(compressor);
+            }
+            if (self.body instanceof AST_If && !self.body.alternative && !self.alternative) {
+                self.condition = make_node(AST_Binary, self.condition, {
+                    operator: "&&",
+                    left: self.condition,
+                    right: self.body.condition
+                }).transform(compressor);
+                self.body = self.body.body;
+            }
+            if (aborts(self.body)) {
+                if (self.alternative) {
+                    var alt = self.alternative;
+                    self.alternative = null;
+                    return make_node(AST_BlockStatement, self, {
+                        body: [ self, alt ]
+                    }).transform(compressor);
+                }
+            }
+            if (aborts(self.alternative)) {
+                var body = self.body;
+                self.body = self.alternative;
+                self.condition = negated_is_best ? negated : self.condition.negate(compressor);
+                self.alternative = null;
+                return make_node(AST_BlockStatement, self, {
+                    body: [ self, body ]
+                }).transform(compressor);
+            }
+            return self;
+        });
+        OPT(AST_Switch, function(self, compressor) {
+            if (self.body.length == 0 && compressor.option("conditionals")) {
+                return make_node(AST_SimpleStatement, self, {
+                    body: self.expression
+                }).transform(compressor);
+            }
+            for (;;) {
+                var last_branch = self.body[self.body.length - 1];
+                if (last_branch) {
+                    var stat = last_branch.body[last_branch.body.length - 1];
+                    if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self) last_branch.body.pop();
+                    if (last_branch instanceof AST_Default && last_branch.body.length == 0) {
+                        self.body.pop();
+                        continue;
+                    }
+                }
+                break;
+            }
+            var exp = self.expression.evaluate(compressor);
+            out: if (exp.length == 2) try {
+                self.expression = exp[0];
+                if (!compressor.option("dead_code")) break out;
+                var value = exp[1];
+                var in_if = false;
+                var in_block = false;
+                var started = false;
+                var stopped = false;
+                var ruined = false;
+                var tt = new TreeTransformer(function(node, descend, in_list) {
+                    if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {
+                        return node;
+                    } else if (node instanceof AST_Switch && node === self) {
+                        node = node.clone();
+                        descend(node, this);
+                        return ruined ? node : make_node(AST_BlockStatement, node, {
+                            body: node.body.reduce(function(a, branch) {
+                                return a.concat(branch.body);
+                            }, [])
+                        }).transform(compressor);
+                    } else if (node instanceof AST_If || node instanceof AST_Try) {
+                        var save = in_if;
+                        in_if = !in_block;
+                        descend(node, this);
+                        in_if = save;
+                        return node;
+                    } else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
+                        var save = in_block;
+                        in_block = true;
+                        descend(node, this);
+                        in_block = save;
+                        return node;
+                    } else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {
+                        if (in_if) {
+                            ruined = true;
+                            return node;
+                        }
+                        if (in_block) return node;
+                        stopped = true;
+                        return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
+                    } else if (node instanceof AST_SwitchBranch && this.parent() === self) {
+                        if (stopped) return MAP.skip;
+                        if (node instanceof AST_Case) {
+                            var exp = node.expression.evaluate(compressor);
+                            if (exp.length < 2) {
+                                throw self;
+                            }
+                            if (exp[1] === value || started) {
+                                started = true;
+                                if (aborts(node)) stopped = true;
+                                descend(node, this);
+                                return node;
+                            }
+                            return MAP.skip;
+                        }
+                        descend(node, this);
+                        return node;
+                    }
+                });
+                tt.stack = compressor.stack.slice();
+                self = self.transform(tt);
+            } catch (ex) {
+                if (ex !== self) throw ex;
+            }
+            return self;
+        });
+        OPT(AST_Case, function(self, compressor) {
+            self.body = tighten_body(self.body, compressor);
+            return self;
+        });
+        OPT(AST_Try, function(self, compressor) {
+            self.body = tighten_body(self.body, compressor);
+            return self;
+        });
+        AST_Definitions.DEFMETHOD("remove_initializers", function() {
+            this.definitions.forEach(function(def) {
+                def.value = null;
+            });
+        });
+        AST_Definitions.DEFMETHOD("to_assignments", function() {
+            var assignments = this.definitions.reduce(function(a, def) {
+                if (def.value) {
+                    var name = make_node(AST_SymbolRef, def.name, def.name);
+                    a.push(make_node(AST_Assign, def, {
+                        operator: "=",
+                        left: name,
+                        right: def.value
+                    }));
+                }
+                return a;
+            }, []);
+            if (assignments.length == 0) return null;
+            return AST_Seq.from_array(assignments);
+        });
+        OPT(AST_Definitions, function(self, compressor) {
+            if (self.definitions.length == 0) return make_node(AST_EmptyStatement, self);
+            return self;
+        });
+        OPT(AST_Function, function(self, compressor) {
+            self = AST_Lambda.prototype.optimize.call(self, compressor);
+            if (compressor.option("unused")) {
+                if (self.name && self.name.unreferenced()) {
+                    self.name = null;
+                }
+            }
+            return self;
+        });
+        OPT(AST_Call, function(self, compressor) {
+            if (compressor.option("unsafe")) {
+                var exp = self.expression;
+                if (exp instanceof AST_SymbolRef && exp.undeclared()) {
+                    switch (exp.name) {
+                      case "Array":
+                        if (self.args.length != 1) {
+                            return make_node(AST_Array, self, {
+                                elements: self.args
+                            });
+                        }
+                        break;
+
+                      case "Object":
+                        if (self.args.length == 0) {
+                            return make_node(AST_Object, self, {
+                                properties: []
+                            });
+                        }
+                        break;
+
+                      case "String":
+                        if (self.args.length == 0) return make_node(AST_String, self, {
+                            value: ""
+                        });
+                        return make_node(AST_Binary, self, {
+                            left: self.args[0],
+                            operator: "+",
+                            right: make_node(AST_String, self, {
+                                value: ""
+                            })
+                        });
+                    }
+                } else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
+                    return make_node(AST_Binary, self, {
+                        left: make_node(AST_String, self, {
+                            value: ""
+                        }),
+                        operator: "+",
+                        right: exp.expression
+                    }).transform(compressor);
+                }
+            }
+            if (compressor.option("side_effects")) {
+                if (self.expression instanceof AST_Function && self.args.length == 0 && !AST_Block.prototype.has_side_effects.call(self.expression)) {
+                    return make_node(AST_Undefined, self).transform(compressor);
+                }
+            }
+            return self;
+        });
+        OPT(AST_New, function(self, compressor) {
+            if (compressor.option("unsafe")) {
+                var exp = self.expression;
+                if (exp instanceof AST_SymbolRef && exp.undeclared()) {
+                    switch (exp.name) {
+                      case "Object":
+                      case "RegExp":
+                      case "Function":
+                      case "Error":
+                      case "Array":
+                        return make_node(AST_Call, self, self).transform(compressor);
+                    }
+                }
+            }
+            return self;
+        });
+        OPT(AST_Seq, function(self, compressor) {
+            if (!compressor.option("side_effects")) return self;
+            if (!self.car.has_side_effects()) {
+                var p;
+                if (!(self.cdr instanceof AST_SymbolRef && self.cdr.name == "eval" && self.cdr.undeclared() && (p = compressor.parent()) instanceof AST_Call && p.expression === self)) {
+                    return self.cdr;
+                }
+            }
+            if (compressor.option("cascade")) {
+                if (self.car instanceof AST_Assign && !self.car.left.has_side_effects() && self.car.left.equivalent_to(self.cdr)) {
+                    return self.car;
+                }
+                if (!self.car.has_side_effects() && !self.cdr.has_side_effects() && self.car.equivalent_to(self.cdr)) {
+                    return self.car;
+                }
+            }
+            return self;
+        });
+        AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
+            if (compressor.option("sequences")) {
+                if (this.expression instanceof AST_Seq) {
+                    var seq = this.expression;
+                    var x = seq.to_array();
+                    this.expression = x.pop();
+                    x.push(this);
+                    seq = AST_Seq.from_array(x).transform(compressor);
+                    return seq;
+                }
+            }
+            return this;
+        });
+        OPT(AST_UnaryPostfix, function(self, compressor) {
+            return self.lift_sequences(compressor);
+        });
+        OPT(AST_UnaryPrefix, function(self, compressor) {
+            self = self.lift_sequences(compressor);
+            var e = self.expression;
+            if (compressor.option("booleans") && compressor.in_boolean_context()) {
+                switch (self.operator) {
+                  case "!":
+                    if (e instanceof AST_UnaryPrefix && e.operator == "!") {
+                        return e.expression;
+                    }
+                    break;
+
+                  case "typeof":
+                    compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
+                    return make_node(AST_True, self);
+                }
+                if (e instanceof AST_Binary && self.operator == "!") {
+                    self = best_of(self, e.negate(compressor));
+                }
+            }
+            return self.evaluate(compressor)[0];
+        });
+        AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
+            if (compressor.option("sequences")) {
+                if (this.left instanceof AST_Seq) {
+                    var seq = this.left;
+                    var x = seq.to_array();
+                    this.left = x.pop();
+                    x.push(this);
+                    seq = AST_Seq.from_array(x).transform(compressor);
+                    return seq;
+                }
+                if (this.right instanceof AST_Seq && !(this.operator == "||" || this.operator == "&&") && !this.left.has_side_effects()) {
+                    var seq = this.right;
+                    var x = seq.to_array();
+                    this.right = x.pop();
+                    x.push(this);
+                    seq = AST_Seq.from_array(x).transform(compressor);
+                    return seq;
+                }
+            }
+            return this;
+        });
+        var commutativeOperators = makePredicate("== === != !== * & | ^");
+        OPT(AST_Binary, function(self, compressor) {
+            function reverse(op, force) {
+                if (force || !(self.left.has_side_effects() || self.right.has_side_effects())) {
+                    if (op) self.operator = op;
+                    var tmp = self.left;
+                    self.left = self.right;
+                    self.right = tmp;
+                }
+            }
+            if (commutativeOperators(self.operator)) {
+                if (self.right instanceof AST_Constant && !(self.left instanceof AST_Constant)) {
+                    reverse(null, true);
+                }
+            }
+            self = self.lift_sequences(compressor);
+            if (compressor.option("comparisons")) switch (self.operator) {
+              case "===":
+              case "!==":
+                if (self.left.is_string(compressor) && self.right.is_string(compressor) || self.left.is_boolean() && self.right.is_boolean()) {
+                    self.operator = self.operator.substr(0, 2);
+                }
+
+              case "==":
+              case "!=":
+                if (self.left instanceof AST_String && self.left.value == "undefined" && self.right instanceof AST_UnaryPrefix && self.right.operator == "typeof" && compressor.option("unsafe")) {
+                    if (!(self.right.expression instanceof AST_SymbolRef) || !self.right.expression.undeclared()) {
+                        self.right = self.right.expression;
+                        self.left = make_node(AST_Undefined, self.left).optimize(compressor);
+                        if (self.operator.length == 2) self.operator += "=";
+                    }
+                }
+                break;
+            }
+            if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
+              case "&&":
+                var ll = self.left.evaluate(compressor);
+                var rr = self.right.evaluate(compressor);
+                if (ll.length > 1 && !ll[1] || rr.length > 1 && !rr[1]) {
+                    compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
+                    return make_node(AST_False, self);
+                }
+                if (ll.length > 1 && ll[1]) {
+                    return rr[0];
+                }
+                if (rr.length > 1 && rr[1]) {
+                    return ll[0];
+                }
+                break;
+
+              case "||":
+                var ll = self.left.evaluate(compressor);
+                var rr = self.right.evaluate(compressor);
+                if (ll.length > 1 && ll[1] || rr.length > 1 && rr[1]) {
+                    compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
+                    return make_node(AST_True, self);
+                }
+                if (ll.length > 1 && !ll[1]) {
+                    return rr[0];
+                }
+                if (rr.length > 1 && !rr[1]) {
+                    return ll[0];
+                }
+                break;
+
+              case "+":
+                var ll = self.left.evaluate(compressor);
+                var rr = self.right.evaluate(compressor);
+                if (ll.length > 1 && ll[0] instanceof AST_String && ll[1] || rr.length > 1 && rr[0] instanceof AST_String && rr[1]) {
+                    compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
+                    return make_node(AST_True, self);
+                }
+                break;
+            }
+            var exp = self.evaluate(compressor);
+            if (exp.length > 1) {
+                if (best_of(exp[0], self) !== self) return exp[0];
+            }
+            if (compressor.option("comparisons")) {
+                if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {
+                    var negated = make_node(AST_UnaryPrefix, self, {
+                        operator: "!",
+                        expression: self.negate(compressor)
+                    });
+                    self = best_of(self, negated);
+                }
+                switch (self.operator) {
+                  case "<":
+                    reverse(">");
+                    break;
+
+                  case "<=":
+                    reverse(">=");
+                    break;
+                }
+            }
+            if (self.operator == "+" && self.right instanceof AST_String && self.right.getValue() === "" && self.left instanceof AST_Binary && self.left.operator == "+" && self.left.is_string(compressor)) {
+                return self.left;
+            }
+            return self;
+        });
+        OPT(AST_SymbolRef, function(self, compressor) {
+            if (self.undeclared()) {
+                var defines = compressor.option("global_defs");
+                if (defines && defines.hasOwnProperty(self.name)) {
+                    return make_node_from_constant(compressor, defines[self.name], self);
+                }
+                switch (self.name) {
+                  case "undefined":
+                    return make_node(AST_Undefined, self);
+
+                  case "NaN":
+                    return make_node(AST_NaN, self);
+
+                  case "Infinity":
+                    return make_node(AST_Infinity, self);
+                }
+            }
+            return self;
+        });
+        OPT(AST_Undefined, function(self, compressor) {
+            if (compressor.option("unsafe")) {
+                var scope = compressor.find_parent(AST_Scope);
+                var undef = scope.find_variable("undefined");
+                if (undef) {
+                    var ref = make_node(AST_SymbolRef, self, {
+                        name: "undefined",
+                        scope: scope,
+                        thedef: undef
+                    });
+                    ref.reference();
+                    return ref;
+                }
+            }
+            return self;
+        });
+        var ASSIGN_OPS = [ "+", "-", "/", "*", "%", ">>", "<<", ">>>", "|", "^", "&" ];
+        OPT(AST_Assign, function(self, compressor) {
+            self = self.lift_sequences(compressor);
+            if (self.operator == "=" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary && self.right.left instanceof AST_SymbolRef && self.right.left.name == self.left.name && member(self.right.operator, ASSIGN_OPS)) {
+                self.operator = self.right.operator + "=";
+                self.right = self.right.right;
+            }
+            return self;
+        });
+        OPT(AST_Conditional, function(self, compressor) {
+            if (!compressor.option("conditionals")) return self;
+            if (self.condition instanceof AST_Seq) {
+                var car = self.condition.car;
+                self.condition = self.condition.cdr;
+                return AST_Seq.cons(car, self);
+            }
+            var cond = self.condition.evaluate(compressor);
+            if (cond.length > 1) {
+                if (cond[1]) {
+                    compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
+                    return self.consequent;
+                } else {
+                    compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
+                    return self.alternative;
+                }
+            }
+            var negated = cond[0].negate(compressor);
+            if (best_of(cond[0], negated) === negated) {
+                self = make_node(AST_Conditional, self, {
+                    condition: negated,
+                    consequent: self.alternative,
+                    alternative: self.consequent
+                });
+            }
+            var consequent = self.consequent;
+            var alternative = self.alternative;
+            if (consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator == alternative.operator && consequent.left.equivalent_to(alternative.left)) {
+                self = make_node(AST_Assign, self, {
+                    operator: consequent.operator,
+                    left: consequent.left,
+                    right: make_node(AST_Conditional, self, {
+                        condition: self.condition,
+                        consequent: consequent.right,
+                        alternative: alternative.right
+                    })
+                });
+            }
+            return self;
+        });
+        OPT(AST_Boolean, function(self, compressor) {
+            if (compressor.option("booleans")) {
+                var p = compressor.parent();
+                if (p instanceof AST_Binary && (p.operator == "==" || p.operator == "!=")) {
+                    compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
+                        operator: p.operator,
+                        value: self.value,
+                        file: p.start.file,
+                        line: p.start.line,
+                        col: p.start.col
+                    });
+                    return make_node(AST_Number, self, {
+                        value: +self.value
+                    });
+                }
+                return make_node(AST_UnaryPrefix, self, {
+                    operator: "!",
+                    expression: make_node(AST_Number, self, {
+                        value: 1 - self.value
+                    })
+                });
+            }
+            return self;
+        });
+        OPT(AST_Sub, function(self, compressor) {
+            var prop = self.property;
+            if (prop instanceof AST_String && compressor.option("properties")) {
+                prop = prop.getValue();
+                if (compressor.option("screw_ie8") && RESERVED_WORDS(prop) || !RESERVED_WORDS(prop) && is_identifier_string(prop)) {
+                    return make_node(AST_Dot, self, {
+                        expression: self.expression,
+                        property: prop
+                    });
+                }
+            }
+            return self;
+        });
+        function literals_in_boolean_context(self, compressor) {
+            if (compressor.option("booleans") && compressor.in_boolean_context()) {
+                return make_node(AST_True, self);
+            }
+            return self;
+        }
+        OPT(AST_Array, literals_in_boolean_context);
+        OPT(AST_Object, literals_in_boolean_context);
+        OPT(AST_RegExp, literals_in_boolean_context);
+    })();
+    "use strict";
+    function SourceMap(options) {
+        options = defaults(options, {
+            file: null,
+            root: null,
+            orig: null
+        });
+        var generator = new MOZ_SourceMap.SourceMapGenerator({
+            file: options.file,
+            sourceRoot: options.root
+        });
+        var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
+        function add(source, gen_line, gen_col, orig_line, orig_col, name) {
+            if (orig_map) {
+                var info = orig_map.originalPositionFor({
+                    line: orig_line,
+                    column: orig_col
+                });
+                source = info.source;
+                orig_line = info.line;
+                orig_col = info.column;
+                name = info.name;
+            }
+            generator.addMapping({
+                generated: {
+                    line: gen_line,
+                    column: gen_col
+                },
+                original: {
+                    line: orig_line,
+                    column: orig_col
+                },
+                source: source,
+                name: name
+            });
+        }
+        return {
+            add: add,
+            get: function() {
+                return generator;
+            },
+            toString: function() {
+                return generator.toString();
+            }
+        };
+    }
+    "use strict";
+    (function() {
+        var MOZ_TO_ME = {
+            TryStatement: function(M) {
+                return new AST_Try({
+                    start: my_start_token(M),
+                    end: my_end_token(M),
+                    body: from_moz(M.block).body,
+                    bcatch: from_moz(M.handlers[0]),
+                    bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
+                });
+            },
+            CatchClause: function(M) {
+                return new AST_Catch({
+                    start: my_start_token(M),
+                    end: my_end_token(M),
+                    argname: from_moz(M.param),
+                    body: from_moz(M.body).body
+                });
+            },
+            ObjectExpression: function(M) {
+                return new AST_Object({
+                    start: my_start_token(M),
+                    end: my_end_token(M),
+                    properties: M.properties.map(function(prop) {
+                        var key = prop.key;
+                        var name = key.type == "Identifier" ? key.name : key.value;
+                        var args = {
+                            start: my_start_token(key),
+                            end: my_end_token(prop.value),
+                            key: name,
+                            value: from_moz(prop.value)
+                        };
+                        switch (prop.kind) {
+                          case "init":
+                            return new AST_ObjectKeyVal(args);
+
+                          case "set":
+                            args.value.name = from_moz(key);
+                            return new AST_ObjectSetter(args);
+
+                          case "get":
+                            args.value.name = from_moz(key);
+                            return new AST_ObjectGetter(args);
+                        }
+                    })
+                });
+            },
+            SequenceExpression: function(M) {
+                return AST_Seq.from_array(M.expressions.map(from_moz));
+            },
+            MemberExpression: function(M) {
+                return new (M.computed ? AST_Sub : AST_Dot)({
+                    start: my_start_token(M),
+                    end: my_end_token(M),
+                    property: M.computed ? from_moz(M.property) : M.property.name,
+                    expression: from_moz(M.object)
+                });
+            },
+            SwitchCase: function(M) {
+                return new (M.test ? AST_Case : AST_Default)({
+                    start: my_start_token(M),
+                    end: my_end_token(M),
+                    expression: from_moz(M.test),
+                    body: M.consequent.map(from_moz)
+                });
+            },
+            Literal: function(M) {
+                var val = M.value, args = {
+                    start: my_start_token(M),
+                    end: my_end_token(M)
+                };
+                if (val === null) return new AST_Null(args);
+                switch (typeof val) {
+                  case "string":
+                    args.value = val;
+                    return new AST_String(args);
+
+                  case "number":
+                    args.value = val;
+                    return new AST_Number(args);
+
+                  case "boolean":
+                    return new (val ? AST_True : AST_False)(args);
+
+                  default:
+                    args.value = val;
+                    return new AST_RegExp(args);
+                }
+            },
+            UnaryExpression: From_Moz_Unary,
+            UpdateExpression: From_Moz_Unary,
+            Identifier: function(M) {
+                var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
+                return new (M.name == "this" ? AST_This : p.type == "LabeledStatement" ? AST_Label : p.type == "VariableDeclarator" && p.id === M ? p.kind == "const" ? AST_SymbolConst : AST_SymbolVar : p.type == "FunctionExpression" ? p.id === M ? AST_SymbolLambda : AST_SymbolFunarg : p.type == "FunctionDeclaration" ? p.id === M ? AST_SymbolDefun : AST_SymbolFunarg : p.type == "CatchClause" ? AST_SymbolCatch : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef : AST_SymbolRef)({
+                    start: my_start_token(M),
+                    end: my_end_token(M),
+                    name: M.name
+                });
+            }
+        };
+        function From_Moz_Unary(M) {
+            var prefix = "prefix" in M ? M.prefix : M.type == "UnaryExpression" ? true : false;
+            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
+                start: my_start_token(M),
+                end: my_end_token(M),
+                operator: M.operator,
+                expression: from_moz(M.argument)
+            });
+        }
+        var ME_TO_MOZ = {};
+        map("Node", AST_Node);
+        map("Program", AST_Toplevel, "body@body");
+        map("Function", AST_Function, "id>name, params@argnames, body%body");
+        map("EmptyStatement", AST_EmptyStatement);
+        map("BlockStatement", AST_BlockStatement, "body@body");
+        map("ExpressionStatement", AST_SimpleStatement, "expression>body");
+        map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
+        map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
+        map("BreakStatement", AST_Break, "label>label");
+        map("ContinueStatement", AST_Continue, "label>label");
+        map("WithStatement", AST_With, "object>expression, body>body");
+        map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
+        map("ReturnStatement", AST_Return, "argument>value");
+        map("ThrowStatement", AST_Throw, "argument>value");
+        map("WhileStatement", AST_While, "test>condition, body>body");
+        map("DoWhileStatement", AST_Do, "test>condition, body>body");
+        map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
+        map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
+        map("DebuggerStatement", AST_Debugger);
+        map("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body");
+        map("VariableDeclaration", AST_Var, "declarations@definitions");
+        map("VariableDeclarator", AST_VarDef, "id>name, init>value");
+        map("ThisExpression", AST_This);
+        map("ArrayExpression", AST_Array, "elements@elements");
+        map("FunctionExpression", AST_Function, "id>name, params@argnames, body%body");
+        map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
+        map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
+        map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
+        map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
+        map("NewExpression", AST_New, "callee>expression, arguments@args");
+        map("CallExpression", AST_Call, "callee>expression, arguments@args");
+        function my_start_token(moznode) {
+            return new AST_Token({
+                file: moznode.loc && moznode.loc.source,
+                line: moznode.loc && moznode.loc.start.line,
+                col: moznode.loc && moznode.loc.start.column,
+                pos: moznode.start,
+                endpos: moznode.start
+            });
+        }
+        function my_end_token(moznode) {
+            return new AST_Token({
+                file: moznode.loc && moznode.loc.source,
+                line: moznode.loc && moznode.loc.end.line,
+                col: moznode.loc && moznode.loc.end.column,
+                pos: moznode.end,
+                endpos: moznode.end
+            });
+        }
+        function map(moztype, mytype, propmap) {
+            var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
+            moz_to_me += "return new mytype({\n" + "start: my_start_token(M),\n" + "end: my_end_token(M)";
+            if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop) {
+                var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
+                if (!m) throw new Error("Can't understand property map: " + prop);
+                var moz = "M." + m[1], how = m[2], my = m[3];
+                moz_to_me += ",\n" + my + ": ";
+                if (how == "@") {
+                    moz_to_me += moz + ".map(from_moz)";
+                } else if (how == ">") {
+                    moz_to_me += "from_moz(" + moz + ")";
+                } else if (how == "=") {
+                    moz_to_me += moz;
+                } else if (how == "%") {
+                    moz_to_me += "from_moz(" + moz + ").body";
+                } else throw new Error("Can't understand operator in propmap: " + prop);
+            });
+            moz_to_me += "\n})}";
+            moz_to_me = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(mytype, my_start_token, my_end_token, from_moz);
+            return MOZ_TO_ME[moztype] = moz_to_me;
+        }
+        var FROM_MOZ_STACK = null;
+        function from_moz(node) {
+            FROM_MOZ_STACK.push(node);
+            var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
+            FROM_MOZ_STACK.pop();
+            return ret;
+        }
+        AST_Node.from_mozilla_ast = function(node) {
+            var save_stack = FROM_MOZ_STACK;
+            FROM_MOZ_STACK = [];
+            var ast = from_moz(node);
+            FROM_MOZ_STACK = save_stack;
+            return ast;
+        };
+    })();
+    exports["array_to_hash"] = array_to_hash;
+    exports["slice"] = slice;
+    exports["characters"] = characters;
+    exports["member"] = member;
+    exports["find_if"] = find_if;
+    exports["repeat_string"] = repeat_string;
+    exports["DefaultsError"] = DefaultsError;
+    exports["defaults"] = defaults;
+    exports["merge"] = merge;
+    exports["noop"] = noop;
+    exports["MAP"] = MAP;
+    exports["push_uniq"] = push_uniq;
+    exports["string_template"] = string_template;
+    exports["remove"] = remove;
+    exports["mergeSort"] = mergeSort;
+    exports["set_difference"] = set_difference;
+    exports["set_intersection"] = set_intersection;
+    exports["makePredicate"] = makePredicate;
+    exports["Dictionary"] = Dictionary;
+    exports["DEFNODE"] = DEFNODE;
+    exports["AST_Token"] = AST_Token;
+    exports["AST_Node"] = AST_Node;
+    exports["AST_Statement"] = AST_Statement;
+    exports["AST_Debugger"] = AST_Debugger;
+    exports["AST_Directive"] = AST_Directive;
+    exports["AST_SimpleStatement"] = AST_SimpleStatement;
+    exports["walk_body"] = walk_body;
+    exports["AST_Block"] = AST_Block;
+    exports["AST_BlockStatement"] = AST_BlockStatement;
+    exports["AST_EmptyStatement"] = AST_EmptyStatement;
+    exports["AST_StatementWithBody"] = AST_StatementWithBody;
+    exports["AST_LabeledStatement"] = AST_LabeledStatement;
+    exports["AST_DWLoop"] = AST_DWLoop;
+    exports["AST_Do"] = AST_Do;
+    exports["AST_While"] = AST_While;
+    exports["AST_For"] = AST_For;
+    exports["AST_ForIn"] = AST_ForIn;
+    exports["AST_With"] = AST_With;
+    exports["AST_Scope"] = AST_Scope;
+    exports["AST_Toplevel"] = AST_Toplevel;
+    exports["AST_Lambda"] = AST_Lambda;
+    exports["AST_Accessor"] = AST_Accessor;
+    exports["AST_Function"] = AST_Function;
+    exports["AST_Defun"] = AST_Defun;
+    exports["AST_Jump"] = AST_Jump;
+    exports["AST_Exit"] = AST_Exit;
+    exports["AST_Return"] = AST_Return;
+    exports["AST_Throw"] = AST_Throw;
+    exports["AST_LoopControl"] = AST_LoopControl;
+    exports["AST_Break"] = AST_Break;
+    exports["AST_Continue"] = AST_Continue;
+    exports["AST_If"] = AST_If;
+    exports["AST_Switch"] = AST_Switch;
+    exports["AST_SwitchBranch"] = AST_SwitchBranch;
+    exports["AST_Default"] = AST_Default;
+    exports["AST_Case"] = AST_Case;
+    exports["AST_Try"] = AST_Try;
+    exports["AST_Catch"] = AST_Catch;
+    exports["AST_Finally"] = AST_Finally;
+    exports["AST_Definitions"] = AST_Definitions;
+    exports["AST_Var"] = AST_Var;
+    exports["AST_Const"] = AST_Const;
+    exports["AST_VarDef"] = AST_VarDef;
+    exports["AST_Call"] = AST_Call;
+    exports["AST_New"] = AST_New;
+    exports["AST_Seq"] = AST_Seq;
+    exports["AST_PropAccess"] = AST_PropAccess;
+    exports["AST_Dot"] = AST_Dot;
+    exports["AST_Sub"] = AST_Sub;
+    exports["AST_Unary"] = AST_Unary;
+    exports["AST_UnaryPrefix"] = AST_UnaryPrefix;
+    exports["AST_UnaryPostfix"] = AST_UnaryPostfix;
+    exports["AST_Binary"] = AST_Binary;
+    exports["AST_Conditional"] = AST_Conditional;
+    exports["AST_Assign"] = AST_Assign;
+    exports["AST_Array"] = AST_Array;
+    exports["AST_Object"] = AST_Object;
+    exports["AST_ObjectProperty"] = AST_ObjectProperty;
+    exports["AST_ObjectKeyVal"] = AST_ObjectKeyVal;
+    exports["AST_ObjectSetter"] = AST_ObjectSetter;
+    exports["AST_ObjectGetter"] = AST_ObjectGetter;
+    exports["AST_Symbol"] = AST_Symbol;
+    exports["AST_SymbolAccessor"] = AST_SymbolAccessor;
+    exports["AST_SymbolDeclaration"] = AST_SymbolDeclaration;
+    exports["AST_SymbolVar"] = AST_SymbolVar;
+    exports["AST_SymbolConst"] = AST_SymbolConst;
+    exports["AST_SymbolFunarg"] = AST_SymbolFunarg;
+    exports["AST_SymbolDefun"] = AST_SymbolDefun;
+    exports["AST_SymbolLambda"] = AST_SymbolLambda;
+    exports["AST_SymbolCatch"] = AST_SymbolCatch;
+    exports["AST_Label"] = AST_Label;
+    exports["AST_SymbolRef"] = AST_SymbolRef;
+    exports["AST_LabelRef"] = AST_LabelRef;
+    exports["AST_This"] = AST_This;
+    exports["AST_Constant"] = AST_Constant;
+    exports["AST_String"] = AST_String;
+    exports["AST_Number"] = AST_Number;
+    exports["AST_RegExp"] = AST_RegExp;
+    exports["AST_Atom"] = AST_Atom;
+    exports["AST_Null"] = AST_Null;
+    exports["AST_NaN"] = AST_NaN;
+    exports["AST_Undefined"] = AST_Undefined;
+    exports["AST_Hole"] = AST_Hole;
+    exports["AST_Infinity"] = AST_Infinity;
+    exports["AST_Boolean"] = AST_Boolean;
+    exports["AST_False"] = AST_False;
+    exports["AST_True"] = AST_True;
+    exports["TreeWalker"] = TreeWalker;
+    exports["KEYWORDS"] = KEYWORDS;
+    exports["KEYWORDS_ATOM"] = KEYWORDS_ATOM;
+    exports["RESERVED_WORDS"] = RESERVED_WORDS;
+    exports["KEYWORDS_BEFORE_EXPRESSION"] = KEYWORDS_BEFORE_EXPRESSION;
+    exports["OPERATOR_CHARS"] = OPERATOR_CHARS;
+    exports["RE_HEX_NUMBER"] = RE_HEX_NUMBER;
+    exports["RE_OCT_NUMBER"] = RE_OCT_NUMBER;
+    exports["RE_DEC_NUMBER"] = RE_DEC_NUMBER;
+    exports["OPERATORS"] = OPERATORS;
+    exports["WHITESPACE_CHARS"] = WHITESPACE_CHARS;
+    exports["PUNC_BEFORE_EXPRESSION"] = PUNC_BEFORE_EXPRESSION;
+    exports["PUNC_CHARS"] = PUNC_CHARS;
+    exports["REGEXP_MODIFIERS"] = REGEXP_MODIFIERS;
+    exports["UNICODE"] = UNICODE;
+    exports["is_letter"] = is_letter;
+    exports["is_digit"] = is_digit;
+    exports["is_alphanumeric_char"] = is_alphanumeric_char;
+    exports["is_unicode_combining_mark"] = is_unicode_combining_mark;
+    exports["is_unicode_connector_punctuation"] = is_unicode_connector_punctuation;
+    exports["is_identifier"] = is_identifier;
+    exports["is_identifier_start"] = is_identifier_start;
+    exports["is_identifier_char"] = is_identifier_char;
+    exports["is_identifier_string"] = is_identifier_string;
+    exports["parse_js_number"] = parse_js_number;
+    exports["JS_Parse_Error"] = JS_Parse_Error;
+    exports["js_error"] = js_error;
+    exports["is_token"] = is_token;
+    exports["EX_EOF"] = EX_EOF;
+    exports["tokenizer"] = tokenizer;
+    exports["UNARY_PREFIX"] = UNARY_PREFIX;
+    exports["UNARY_POSTFIX"] = UNARY_POSTFIX;
+    exports["ASSIGNMENT"] = ASSIGNMENT;
+    exports["PRECEDENCE"] = PRECEDENCE;
+    exports["STATEMENTS_WITH_LABELS"] = STATEMENTS_WITH_LABELS;
+    exports["ATOMIC_START_TOKEN"] = ATOMIC_START_TOKEN;
+    exports["parse"] = parse;
+    exports["TreeTransformer"] = TreeTransformer;
+    exports["SymbolDef"] = SymbolDef;
+    exports["base54"] = base54;
+    exports["OutputStream"] = OutputStream;
+    exports["Compressor"] = Compressor;
+    exports["SourceMap"] = SourceMap;
+})({}, function() {
+    return exports;
+}());
+
+var UglifyJS = exports.UglifyJS;
+
+UglifyJS.AST_Node.warn_function = function(txt) {
+    logger.error("uglifyjs2 WARN: " + txt);
+};
+
+//JRB: MODIFIED FROM UGLIFY SOURCE
+//to take a name for the file, and then set toplevel.filename to be that name.
+exports.minify = function(files, options, name) {
+    options = UglifyJS.defaults(options, {
+        outSourceMap : null,
+        sourceRoot   : null,
+        inSourceMap  : null,
+        fromString   : false,
+        warnings     : false,
+        mangle       : {},
+        output       : null,
+        compress     : {}
+    });
+    if (typeof files == "string")
+        files = [ files ];
+
+    // 1. parse
+    var toplevel = null;
+    files.forEach(function(file){
+        var code = options.fromString
+            ? file
+            : rjsFile.readFile(file, "utf8");
+        toplevel = UglifyJS.parse(code, {
+            filename: options.fromString ? name : file,
+            toplevel: toplevel
+        });
+    });
+
+    // 2. compress
+    if (options.compress) {
+        var compress = { warnings: options.warnings };
+        UglifyJS.merge(compress, options.compress);
+        toplevel.figure_out_scope();
+        var sq = UglifyJS.Compressor(compress);
+        toplevel = toplevel.transform(sq);
+    }
+
+    // 3. mangle
+    if (options.mangle) {
+        toplevel.figure_out_scope();
+        toplevel.compute_char_frequency();
+        toplevel.mangle_names(options.mangle);
+    }
+
+    // 4. output
+    var map = null;
+    var inMap = null;
+    if (options.inSourceMap) {
+        inMap = rjsFile.readFile(options.inSourceMap, "utf8");
+    }
+    if (options.outSourceMap) map = UglifyJS.SourceMap({
+        file: options.outSourceMap,
+        orig: inMap,
+        root: options.sourceRoot
+    });
+    var output = { source_map: map };
+    if (options.output) {
+        UglifyJS.merge(output, options.output);
+    }
+    var stream = UglifyJS.OutputStream(output);
+    toplevel.print(stream);
+    return {
+        code : stream + "",
+        map  : map + ""
+    };
+};
+
+// exports.describe_ast = function() {
+//     function doitem(ctor) {
+//         var sub = {};
+//         ctor.SUBCLASSES.forEach(function(ctor){
+//             sub[ctor.TYPE] = doitem(ctor);
+//         });
+//         var ret = {};
+//         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
+//         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
+//         return ret;
+//     }
+//     return doitem(UglifyJS.AST_Node).sub;
+// }
+
+exports.describe_ast = function() {
+    var out = UglifyJS.OutputStream({ beautify: true });
+    function doitem(ctor) {
+        out.print("AST_" + ctor.TYPE);
+        var props = ctor.SELF_PROPS.filter(function(prop){
+            return !/^\$/.test(prop);
+        });
+        if (props.length > 0) {
+            out.space();
+            out.with_parens(function(){
+                props.forEach(function(prop, i){
+                    if (i) out.space();
+                    out.print(prop);
+                });
+            });
+        }
+        if (ctor.documentation) {
+            out.space();
+            out.print_string(ctor.documentation);
+        }
+        if (ctor.SUBCLASSES.length > 0) {
+            out.space();
+            out.with_block(function(){
+                ctor.SUBCLASSES.forEach(function(ctor, i){
+                    out.indent();
+                    doitem(ctor);
+                    out.newline();
+                });
+            });
+        }
+    };
+    doitem(UglifyJS.AST_Node);
+    return out + "";
+};
+
+});
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint plusplus: true */
+/*global define: false */
+
+define('parse', ['./esprima', 'lang'], function (esprima, lang) {
+    'use strict';
+
+    function arrayToString(ary) {
+        var output = '[';
+        if (ary) {
+            ary.forEach(function (item, i) {
+                output += (i > 0 ? ',' : '') + '"' + lang.jsEscape(item) + '"';
+            });
+        }
+        output += ']';
+
+        return output;
+    }
+
+    //This string is saved off because JSLint complains
+    //about obj.arguments use, as 'reserved word'
+    var argPropName = 'arguments';
+
+    //From an esprima example for traversing its ast.
+    function traverse(object, visitor) {
+        var key, child;
+
+        if (!object) {
+            return;
+        }
+
+        if (visitor.call(null, object) === false) {
+            return false;
+        }
+        for (key in object) {
+            if (object.hasOwnProperty(key)) {
+                child = object[key];
+                if (typeof child === 'object' && child !== null) {
+                    if (traverse(child, visitor) === false) {
+                        return false;
+                    }
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Pulls out dependencies from an array literal with just string members.
+     * If string literals, will just return those string values in an array,
+     * skipping other items in the array.
+     *
+     * @param {Node} node an AST node.
+     *
+     * @returns {Array} an array of strings.
+     * If null is returned, then it means the input node was not a valid
+     * dependency.
+     */
+    function getValidDeps(node) {
+        if (!node || node.type !== 'ArrayExpression' || !node.elements) {
+            return;
+        }
+
+        var deps = [];
+
+        node.elements.some(function (elem) {
+            if (elem.type === 'Literal') {
+                deps.push(elem.value);
+            }
+        });
+
+        return deps.length ? deps : undefined;
+    }
+
+    /**
+     * Main parse function. Returns a string of any valid require or
+     * define/require.def calls as part of one JavaScript source string.
+     * @param {String} moduleName the module name that represents this file.
+     * It is used to create a default define if there is not one already for the
+     * file. This allows properly tracing dependencies for builds. Otherwise, if
+     * the file just has a require() call, the file dependencies will not be
+     * properly reflected: the file will come before its dependencies.
+     * @param {String} moduleName
+     * @param {String} fileName
+     * @param {String} fileContents
+     * @param {Object} options optional options. insertNeedsDefine: true will
+     * add calls to require.needsDefine() if appropriate.
+     * @returns {String} JS source string or null, if no require or
+     * define/require.def calls are found.
+     */
+    function parse(moduleName, fileName, fileContents, options) {
+        options = options || {};
+
+        //Set up source input
+        var i, moduleCall, depString,
+            moduleDeps = [],
+            result = '',
+            moduleList = [],
+            needsDefine = true,
+            astRoot = esprima.parse(fileContents);
+
+        parse.recurse(astRoot, function (callName, config, name, deps) {
+            if (!deps) {
+                deps = [];
+            }
+
+            if (callName === 'define' && (!name || name === moduleName)) {
+                needsDefine = false;
+            }
+
+            if (!name) {
+                //If there is no module name, the dependencies are for
+                //this file/default module name.
+                moduleDeps = moduleDeps.concat(deps);
+            } else {
+                moduleList.push({
+                    name: name,
+                    deps: deps
+                });
+            }
+
+            //If define was found, no need to dive deeper, unless
+            //the config explicitly wants to dig deeper.
+            return !!options.findNestedDependencies;
+        }, options);
+
+        if (options.insertNeedsDefine && needsDefine) {
+            result += 'require.needsDefine("' + moduleName + '");';
+        }
+
+        if (moduleDeps.length || moduleList.length) {
+            for (i = 0; i < moduleList.length; i++) {
+                moduleCall = moduleList[i];
+                if (result) {
+                    result += '\n';
+                }
+
+                //If this is the main module for this file, combine any
+                //"anonymous" dependencies (could come from a nested require
+                //call) with this module.
+                if (moduleCall.name === moduleName) {
+                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);
+                    moduleDeps = [];
+                }
+
+                depString = arrayToString(moduleCall.deps);
+                result += 'define("' + moduleCall.name + '",' +
+                          depString + ');';
+            }
+            if (moduleDeps.length) {
+                if (result) {
+                    result += '\n';
+                }
+                depString = arrayToString(moduleDeps);
+                result += 'define("' + moduleName + '",' + depString + ');';
+            }
+        }
+
+        return result || null;
+    }
+
+    /**
+     * Handles parsing a file recursively for require calls.
+     * @param {Array} parentNode the AST node to start with.
+     * @param {Function} onMatch function to call on a parse match.
+     * @param {Object} [options] This is normally the build config options if
+     * it is passed.
+     */
+    parse.recurse = function (object, onMatch, options) {
+        //Like traverse, but skips if branches that would not be processed
+        //after has application that results in tests of true or false boolean
+        //literal values.
+        var key, child,
+            hasHas = options && options.has;
+
+        if (!object) {
+            return;
+        }
+
+        //If has replacement has resulted in if(true){} or if(false){}, take
+        //the appropriate branch and skip the other one.
+        if (hasHas && object.type === 'IfStatement' && object.test.type &&
+                object.test.type === 'Literal') {
+            if (object.test.value) {
+                //Take the if branch
+                this.recurse(object.consequent, onMatch, options);
+            } else {
+                //Take the else branch
+                this.recurse(object.alternate, onMatch, options);
+            }
+        } else {
+            if (this.parseNode(object, onMatch) === false) {
+                return;
+            }
+            for (key in object) {
+                if (object.hasOwnProperty(key)) {
+                    child = object[key];
+                    if (typeof child === 'object' && child !== null) {
+                        this.recurse(child, onMatch, options);
+                    }
+                }
+            }
+        }
+    };
+
+    /**
+     * Determines if the file defines the require/define module API.
+     * Specifically, it looks for the `define.amd = ` expression.
+     * @param {String} fileName
+     * @param {String} fileContents
+     * @returns {Boolean}
+     */
+    parse.definesRequire = function (fileName, fileContents) {
+        var found = false;
+
+        traverse(esprima.parse(fileContents), function (node) {
+            if (parse.hasDefineAmd(node)) {
+                found = true;
+
+                //Stop traversal
+                return false;
+            }
+        });
+
+        return found;
+    };
+
+    /**
+     * Finds require("") calls inside a CommonJS anonymous module wrapped in a
+     * define(function(require, exports, module){}) wrapper. These dependencies
+     * will be added to a modified define() call that lists the dependencies
+     * on the outside of the function.
+     * @param {String} fileName
+     * @param {String} fileContents
+     * @returns {Array} an array of module names that are dependencies. Always
+     * returns an array, but could be of length zero.
+     */
+    parse.getAnonDeps = function (fileName, fileContents) {
+        var astRoot = esprima.parse(fileContents),
+            defFunc = this.findAnonDefineFactory(astRoot);
+
+        return parse.getAnonDepsFromNode(defFunc);
+    };
+
+    /**
+     * Finds require("") calls inside a CommonJS anonymous module wrapped
+     * in a define function, given an AST node for the definition function.
+     * @param {Node} node the AST node for the definition function.
+     * @returns {Array} and array of dependency names. Can be of zero length.
+     */
+    parse.getAnonDepsFromNode = function (node) {
+        var deps = [],
+            funcArgLength;
+
+        if (node) {
+            this.findRequireDepNames(node, deps);
+
+            //If no deps, still add the standard CommonJS require, exports,
+            //module, in that order, to the deps, but only if specified as
+            //function args. In particular, if exports is used, it is favored
+            //over the return value of the function, so only add it if asked.
+            funcArgLength = node.params && node.params.length;
+            if (funcArgLength) {
+                deps = (funcArgLength > 1 ? ["require", "exports", "module"] :
+                        ["require"]).concat(deps);
+            }
+        }
+        return deps;
+    };
+
+    /**
+     * Finds the function in define(function (require, exports, module){});
+     * @param {Array} node
+     * @returns {Boolean}
+     */
+    parse.findAnonDefineFactory = function (node) {
+        var match;
+
+        traverse(node, function (node) {
+            var arg0, arg1;
+
+            if (node && node.type === 'CallExpression' &&
+                    node.callee && node.callee.type === 'Identifier' &&
+                    node.callee.name === 'define' && node[argPropName]) {
+
+                //Just the factory function passed to define
+                arg0 = node[argPropName][0];
+                if (arg0 && arg0.type === 'FunctionExpression') {
+                    match = arg0;
+                    return false;
+                }
+
+                //A string literal module ID followed by the factory function.
+                arg1 = node[argPropName][1];
+                if (arg0.type === 'Literal' &&
+                        arg1 && arg1.type === 'FunctionExpression') {
+                    match = arg1;
+                    return false;
+                }
+            }
+        });
+
+        return match;
+    };
+
+    /**
+     * Finds any config that is passed to requirejs. That includes calls to
+     * require/requirejs.config(), as well as require({}, ...) and
+     * requirejs({}, ...)
+     * @param {String} fileContents
+     *
+     * @returns {Object} a config details object with the following properties:
+     * - config: {Object} the config object found. Can be undefined if no
+     * config found.
+     * - range: {Array} the start index and end index in the contents where
+     * the config was found. Can be undefined if no config found.
+     * Can throw an error if the config in the file cannot be evaluated in
+     * a build context to valid JavaScript.
+     */
+    parse.findConfig = function (fileContents) {
+        /*jslint evil: true */
+        var jsConfig, foundRange, foundConfig, quote, quoteMatch,
+            quoteRegExp = /(:\s|\[\s*)(['"])/,
+            astRoot = esprima.parse(fileContents, {
+                range: true
+            });
+
+        traverse(astRoot, function (node) {
+            var arg,
+                requireType = parse.hasRequire(node);
+
+            if (requireType && (requireType === 'require' ||
+                    requireType === 'requirejs' ||
+                    requireType === 'requireConfig' ||
+                    requireType === 'requirejsConfig')) {
+
+                arg = node[argPropName] && node[argPropName][0];
+
+                if (arg && arg.type === 'ObjectExpression') {
+                    jsConfig = parse.nodeToString(fileContents, arg);
+                    foundRange = arg.range;
+                    return false;
+                }
+            } else {
+                arg = parse.getRequireObjectLiteral(node);
+                if (arg) {
+                    jsConfig = parse.nodeToString(fileContents, arg);
+                    foundRange = arg.range;
+                    return false;
+                }
+            }
+        });
+
+        if (jsConfig) {
+            quoteMatch = quoteRegExp.exec(jsConfig);
+            quote = (quoteMatch && quoteMatch[2]) || '"';
+            foundConfig = eval('(' + jsConfig + ')');
+        }
+
+        return {
+            config: foundConfig,
+            range: foundRange,
+            quote: quote
+        };
+    };
+
+    /** Returns the node for the object literal assigned to require/requirejs,
+     * for holding a declarative config.
+     */
+    parse.getRequireObjectLiteral = function (node) {
+        if (node.id && node.id.type === 'Identifier' &&
+                (node.id.name === 'require' || node.id.name === 'requirejs') &&
+                node.init && node.init.type === 'ObjectExpression') {
+            return node.init;
+        }
+    };
+
+    /**
+     * Renames require/requirejs/define calls to be ns + '.' + require/requirejs/define
+     * Does *not* do .config calls though. See pragma.namespace for the complete
+     * set of namespace transforms. This function is used because require calls
+     * inside a define() call should not be renamed, so a simple regexp is not
+     * good enough.
+     * @param  {String} fileContents the contents to transform.
+     * @param  {String} ns the namespace, *not* including trailing dot.
+     * @return {String} the fileContents with the namespace applied
+     */
+    parse.renameNamespace = function (fileContents, ns) {
+        var ranges = [],
+            astRoot = esprima.parse(fileContents, {
+                range: true
+            });
+
+        parse.recurse(astRoot, function (callName, config, name, deps, node) {
+            ranges.push(node.range);
+            //Do not recurse into define functions, they should be using
+            //local defines.
+            return callName !== 'define';
+        }, {});
+
+        //Go backwards through the found ranges, adding in the namespace name
+        //in front.
+        ranges.reverse();
+        ranges.forEach(function (range) {
+            fileContents = fileContents.substring(0, range[0]) +
+                           ns + '.' +
+                           fileContents.substring(range[0]);
+        });
+
+        return fileContents;
+    };
+
+    /**
+     * Finds all dependencies specified in dependency arrays and inside
+     * simplified commonjs wrappers.
+     * @param {String} fileName
+     * @param {String} fileContents
+     *
+     * @returns {Array} an array of dependency strings. The dependencies
+     * have not been normalized, they may be relative IDs.
+     */
+    parse.findDependencies = function (fileName, fileContents, options) {
+        var dependencies = [],
+            astRoot = esprima.parse(fileContents);
+
+        parse.recurse(astRoot, function (callName, config, name, deps) {
+            if (deps) {
+                dependencies = dependencies.concat(deps);
+            }
+        }, options);
+
+        return dependencies;
+    };
+
+    /**
+     * Finds only CJS dependencies, ones that are the form
+     * require('stringLiteral')
+     */
+    parse.findCjsDependencies = function (fileName, fileContents) {
+        var dependencies = [];
+
+        traverse(esprima.parse(fileContents), function (node) {
+            var arg;
+
+            if (node && node.type === 'CallExpression' && node.callee &&
+                    node.callee.type === 'Identifier' &&
+                    node.callee.name === 'require' && node[argPropName] &&
+                    node[argPropName].length === 1) {
+                arg = node[argPropName][0];
+                if (arg.type === 'Literal') {
+                    dependencies.push(arg.value);
+                }
+            }
+        });
+
+        return dependencies;
+    };
+
+    //function define() {}
+    parse.hasDefDefine = function (node) {
+        return node.type === 'FunctionDeclaration' && node.id &&
+                    node.id.type === 'Identifier' && node.id.name === 'define';
+    };
+
+    //define.amd = ...
+    parse.hasDefineAmd = function (node) {
+        return node && node.type === 'AssignmentExpression' &&
+            node.left && node.left.type === 'MemberExpression' &&
+            node.left.object && node.left.object.name === 'define' &&
+            node.left.property && node.left.property.name === 'amd';
+    };
+
+    //require(), requirejs(), require.config() and requirejs.config()
+    parse.hasRequire = function (node) {
+        var callName,
+            c = node && node.callee;
+
+        if (node && node.type === 'CallExpression' && c) {
+            if (c.type === 'Identifier' &&
+                    (c.name === 'require' ||
+                    c.name === 'requirejs')) {
+                //A require/requirejs({}, ...) call
+                callName = c.name;
+            } else if (c.type === 'MemberExpression' &&
+                    c.object &&
+                    c.object.type === 'Identifier' &&
+                    (c.object.name === 'require' ||
+                        c.object.name === 'requirejs') &&
+                    c.property && c.property.name === 'config') {
+                // require/requirejs.config({}) call
+                callName = c.object.name + 'Config';
+            }
+        }
+
+        return callName;
+    };
+
+    //define()
+    parse.hasDefine = function (node) {
+        return node && node.type === 'CallExpression' && node.callee &&
+            node.callee.type === 'Identifier' &&
+            node.callee.name === 'define';
+    };
+
+    /**
+     * If there is a named define in the file, returns the name. Does not
+     * scan for mulitple names, just the first one.
+     */
+    parse.getNamedDefine = function (fileContents) {
+        var name;
+        traverse(esprima.parse(fileContents), function (node) {
+            if (node && node.type === 'CallExpression' && node.callee &&
+            node.callee.type === 'Identifier' &&
+            node.callee.name === 'define' &&
+            node[argPropName] && node[argPropName][0] &&
+            node[argPropName][0].type === 'Literal') {
+                name = node[argPropName][0].value;
+                return false;
+            }
+        });
+
+        return name;
+    };
+
+    /**
+     * Determines if define(), require({}|[]) or requirejs was called in the
+     * file. Also finds out if define() is declared and if define.amd is called.
+     */
+    parse.usesAmdOrRequireJs = function (fileName, fileContents) {
+        var uses;
+
+        traverse(esprima.parse(fileContents), function (node) {
+            var type, callName, arg;
+
+            if (parse.hasDefDefine(node)) {
+                //function define() {}
+                type = 'declaresDefine';
+            } else if (parse.hasDefineAmd(node)) {
+                type = 'defineAmd';
+            } else {
+                callName = parse.hasRequire(node);
+                if (callName) {
+                    arg = node[argPropName] && node[argPropName][0];
+                    if (arg && (arg.type === 'ObjectExpression' ||
+                            arg.type === 'ArrayExpression')) {
+                        type = callName;
+                    }
+                } else if (parse.hasDefine(node)) {
+                    type = 'define';
+                }
+            }
+
+            if (type) {
+                if (!uses) {
+                    uses = {};
+                }
+                uses[type] = true;
+            }
+        });
+
+        return uses;
+    };
+
+    /**
+     * Determines if require(''), exports.x =, module.exports =,
+     * __dirname, __filename are used. So, not strictly traditional CommonJS,
+     * also checks for Node variants.
+     */
+    parse.usesCommonJs = function (fileName, fileContents) {
+        var uses = null,
+            assignsExports = false;
+
+
+        traverse(esprima.parse(fileContents), function (node) {
+            var type,
+                exp = node.expression;
+
+            if (node.type === 'Identifier' &&
+                    (node.name === '__dirname' || node.name === '__filename')) {
+                type = node.name.substring(2);
+            } else if (node.type === 'VariableDeclarator' && node.id &&
+                    node.id.type === 'Identifier' &&
+                        node.id.name === 'exports') {
+                //Hmm, a variable assignment for exports, so does not use cjs
+                //exports.
+                type = 'varExports';
+            } else if (exp && exp.type === 'AssignmentExpression' && exp.left &&
+                    exp.left.type === 'MemberExpression' && exp.left.object) {
+                if (exp.left.object.name === 'module' && exp.left.property &&
+                        exp.left.property.name === 'exports') {
+                    type = 'moduleExports';
+                } else if (exp.left.object.name === 'exports' &&
+                        exp.left.property) {
+                    type = 'exports';
+                }
+
+            } else if (node && node.type === 'CallExpression' && node.callee &&
+                    node.callee.type === 'Identifier' &&
+                    node.callee.name === 'require' && node[argPropName] &&
+                    node[argPropName].length === 1 &&
+                    node[argPropName][0].type === 'Literal') {
+                type = 'require';
+            }
+
+            if (type) {
+                if (type === 'varExports') {
+                    assignsExports = true;
+                } else if (type !== 'exports' || !assignsExports) {
+                    if (!uses) {
+                        uses = {};
+                    }
+                    uses[type] = true;
+                }
+            }
+        });
+
+        return uses;
+    };
+
+
+    parse.findRequireDepNames = function (node, deps) {
+        traverse(node, function (node) {
+            var arg;
+
+            if (node && node.type === 'CallExpression' && node.callee &&
+                    node.callee.type === 'Identifier' &&
+                    node.callee.name === 'require' &&
+                    node[argPropName] && node[argPropName].length === 1) {
+
+                arg = node[argPropName][0];
+                if (arg.type === 'Literal') {
+                    deps.push(arg.value);
+                }
+            }
+        });
+    };
+
+    /**
+     * Determines if a specific node is a valid require or define/require.def
+     * call.
+     * @param {Array} node
+     * @param {Function} onMatch a function to call when a match is found.
+     * It is passed the match name, and the config, name, deps possible args.
+     * The config, name and deps args are not normalized.
+     *
+     * @returns {String} a JS source string with the valid require/define call.
+     * Otherwise null.
+     */
+    parse.parseNode = function (node, onMatch) {
+        var name, deps, cjsDeps, arg, factory,
+            args = node && node[argPropName],
+            callName = parse.hasRequire(node);
+
+        if (callName === 'require' || callName === 'requirejs') {
+            //A plain require/requirejs call
+            arg = node[argPropName] && node[argPropName][0];
+            if (arg.type !== 'ArrayExpression') {
+                if (arg.type === 'ObjectExpression') {
+                    //A config call, try the second arg.
+                    arg = node[argPropName][1];
+                }
+            }
+
+            deps = getValidDeps(arg);
+            if (!deps) {
+                return;
+            }
+
+            return onMatch("require", null, null, deps, node);
+        } else if (parse.hasDefine(node) && args && args.length) {
+            name = args[0];
+            deps = args[1];
+            factory = args[2];
+
+            if (name.type === 'ArrayExpression') {
+                //No name, adjust args
+                factory = deps;
+                deps = name;
+                name = null;
+            } else if (name.type === 'FunctionExpression') {
+                //Just the factory, no name or deps
+                factory = name;
+                name = deps = null;
+            } else if (name.type !== 'Literal') {
+                 //An object literal, just null out
+                name = deps = factory = null;
+            }
+
+            if (name && name.type === 'Literal' && deps) {
+                if (deps.type === 'FunctionExpression') {
+                    //deps is the factory
+                    factory = deps;
+                    deps = null;
+                } else if (deps.type === 'ObjectExpression') {
+                    //deps is object literal, null out
+                    deps = factory = null;
+                } else if (deps.type === 'Identifier' && args.length === 2) {
+                    // define('id', factory)
+                    deps = factory = null;
+                }
+            }
+
+            if (deps && deps.type === 'ArrayExpression') {
+                deps = getValidDeps(deps);
+            } else if (factory && factory.type === 'FunctionExpression') {
+                //If no deps and a factory function, could be a commonjs sugar
+                //wrapper, scan the function for dependencies.
+                cjsDeps = parse.getAnonDepsFromNode(factory);
+                if (cjsDeps.length) {
+                    deps = cjsDeps;
+                }
+            } else if (deps || factory) {
+                //Does not match the shape of an AMD call.
+                return;
+            }
+
+            //Just save off the name as a string instead of an AST object.
+            if (name && name.type === 'Literal') {
+                name = name.value;
+            }
+
+            return onMatch("define", null, name, deps, node);
+        }
+    };
+
+    /**
+     * Converts an AST node into a JS source string by extracting
+     * the node's location from the given contents string. Assumes
+     * esprima.parse() with ranges was done.
+     * @param {String} contents
+     * @param {Object} node
+     * @returns {String} a JS source string.
+     */
+    parse.nodeToString = function (contents, node) {
+        var range = node.range;
+        return contents.substring(range[0], range[1]);
+    };
+
+    /**
+     * Extracts license comments from JS text.
+     * @param {String} fileName
+     * @param {String} contents
+     * @returns {String} a string of license comments.
+     */
+    parse.getLicenseComments = function (fileName, contents) {
+        var commentNode, refNode, subNode, value, i, j,
+            ast = esprima.parse(contents, {
+                comment: true
+            }),
+            result = '',
+            existsMap = {},
+            lineEnd = contents.indexOf('\r') === -1 ? '\n' : '\r\n';
+
+        if (ast.comments) {
+            for (i = 0; i < ast.comments.length; i++) {
+                commentNode = ast.comments[i];
+
+                if (commentNode.type === 'Line') {
+                    value = '//' + commentNode.value + lineEnd;
+                    refNode = commentNode;
+
+                    if (i + 1 >= ast.comments.length) {
+                        value += lineEnd;
+                    } else {
+                        //Look for immediately adjacent single line comments
+                        //since it could from a multiple line comment made out
+                        //of single line comments. Like this comment.
+                        for (j = i + 1; j < ast.comments.length; j++) {
+                            subNode = ast.comments[j];
+                            if (subNode.type === 'Line' &&
+                                    subNode.range[0] === refNode.range[1]) {
+                                //Adjacent single line comment. Collect it.
+                                value += '//' + subNode.value + lineEnd;
+                                refNode = subNode;
+                            } else {
+                                //No more single line comment blocks. Break out
+                                //and continue outer looping.
+                                break;
+                            }
+                        }
+                        value += lineEnd;
+                        i = j - 1;
+                    }
+                } else {
+                    value = '/*' + commentNode.value + '*/' + lineEnd + lineEnd;
+                }
+
+                if (!existsMap[value] && (value.indexOf('license') !== -1 ||
+                        (commentNode.type === 'Block' &&
+                            value.indexOf('/*!') === 0) ||
+                        value.indexOf('opyright') !== -1 ||
+                        value.indexOf('(c)') !== -1)) {
+
+                    result += value;
+                    existsMap[value] = true;
+                }
+
+            }
+        }
+
+        return result;
+    };
+
+    return parse;
+});
+/**
+ * @license Copyright (c) 2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint */
+/*global define */
+
+define('transform', [ './esprima', './parse', 'logger', 'lang'], function (esprima, parse, logger, lang) {
+    'use strict';
+    var transform,
+        baseIndentRegExp = /^([ \t]+)/,
+        indentRegExp = /\{[\r\n]+([ \t]+)/,
+        keyRegExp = /^[_A-Za-z]([A-Za-z\d_]*)$/,
+        bulkIndentRegExps = {
+            '\n': /\n/g,
+            '\r\n': /\r\n/g
+        };
+
+    function applyIndent(str, indent, lineReturn) {
+        var regExp = bulkIndentRegExps[lineReturn];
+        return str.replace(regExp, '$&' + indent);
+    }
+
+    return (transform = {
+        toTransport: function (namespace, moduleName, path, contents, onFound, options) {
+            options = options || {};
+
+            var tokens, foundAnon, deps, lastRange, parenCount, inDefine,
+                scanCount = 0,
+                scanReset = false,
+                defineRanges = [],
+                contentInsertion = '',
+                depString = '';
+
+            try {
+                tokens = esprima.parse(contents, {
+                    tokens: true,
+                    range: true
+                }).tokens;
+            } catch (e) {
+                logger.trace('toTransport skipping ' + path + ': ' +
+                             e.toString());
+                return contents;
+            }
+
+            //Find the define calls and their position in the files.
+            tokens.some(function (token, i) {
+                var prev, prev2, next, next2, next3, next4, next5,
+                    needsId, depAction, nameCommaRange, foundId,
+                    sourceUrlData, range,
+                    namespaceExists = false;
+
+                if (inDefine && token.type === 'Punctuator') {
+                    //Looking for the end of the define call.
+                    if (token.value === '(') {
+                        parenCount += 1;
+                    } else if (token.value === ')') {
+                        parenCount -= 1;
+                    }
+
+                    if (parenCount === 0) {
+                        inDefine = false;
+
+                        //Found the end of the define call. Hold onto
+                        //it.
+                        lastRange = defineRanges.length &&
+                            defineRanges[defineRanges.length - 1];
+                        if (lastRange && !lastRange.defineEndRange) {
+                            lastRange.defineEndRange = token.range;
+                        }
+                    }
+                }
+
+                if (token.type === 'Identifier' && token.value === 'define') {
+                    //Possible match. Do not want something.define calls
+                    //though, and only defines follow by a paren
+                    prev = tokens[i - 1];
+                    next = tokens[i + 1];
+
+                    if (prev && prev.type === 'Punctuator' &&
+                            prev.value === '.') {
+                        //a define on a sub-object, not a top level
+                        //define() call. If the sub object is the
+                        //namespace, then it is ok.
+                        prev2 = tokens[i - 2];
+                        if (!prev2) {
+                            return;
+                        }
+
+                        //If the prev2 does not match namespace, then bail.
+                        if (!namespace || prev2.type !== 'Identifier' ||
+                                prev2.value !== namespace) {
+                            return;
+                        } else if (namespace) {
+                            namespaceExists = true;
+                        }
+                    }
+
+                    if (!next || next.type !== 'Punctuator' ||
+                            next.value !== '(') {
+                       //Not a define() function call. Bail.
+                        return;
+                    }
+
+                    if (prev && prev.type === 'Keyword' &&
+                            prev.value === 'function') {
+                        //A declaration of a define function. Skip it.
+                        return;
+                    }
+
+                    next2 = tokens[i + 2];
+                    if (!next2) {
+                        return;
+                    }
+
+                    //Figure out if this needs a named define call.
+                    if (next2.type === 'Punctuator' && next2.value === '[') {
+                        //Dependency array
+                        needsId = true;
+                        depAction = 'skip';
+                    } else if (next2.type === 'Punctuator' &&
+                            next2.value === '{') {
+                        //Object literal
+                        needsId = true;
+                        depAction = 'skip';
+                    } else if (next2.type === 'Keyword' &&
+                               next2.value === 'function') {
+                        //function
+                        needsId = true;
+                        depAction = 'scan';
+                    } else if (next2.type === 'String') {
+                        //Named module
+                        needsId = false;
+
+                        //The value includes the quotes around the string,
+                        //so remove them.
+                        foundId = next2.value.substring(1,
+                                                        next2.value.length - 1);
+
+                        //assumed it does not need dependencies injected
+
+                        //If next argument is a function it means we need
+                        //dependency scanning.
+                        next3 = tokens[i + 3];
+                        next4 = tokens[i + 4];
+                        if (!next3 || !next4) {
+                            return;
+                        }
+
+                        if (next3.type === 'Punctuator' &&
+                                next3.value === ',' &&
+                                next4.type === 'Keyword' &&
+                                next4.value === 'function') {
+                            depAction = 'scan';
+                            nameCommaRange = next3.range;
+                        } else {
+                            depAction = 'skip';
+                        }
+                    } else if (next2.type === 'Identifier') {
+                        //May be the define(factory); type.
+                        next3 = tokens[i + 3];
+                        if (!next3) {
+                            return;
+                        }
+                        if (next3.type === 'Punctuator' &&
+                                next3.value === ')') {
+                            needsId = true;
+                            depAction = 'empty';
+                        } else {
+                            return;
+                        }
+                    } else if (next2.type === 'Numeric') {
+                        //May be the define(12345); type.
+                        next3 = tokens[i + 3];
+                        if (!next3) {
+                            return;
+                        }
+                        if (next3.type === 'Punctuator' &&
+                                next3.value === ')') {
+                            needsId = true;
+                            depAction = 'skip';
+                        } else {
+                            return;
+                        }
+                    } else if (next2.type === 'Punctuator' &&
+                               next2.value === '-') {
+                        //May be the define(-12345); type.
+                        next3 = tokens[i + 3];
+                        if (!next3) {
+                            return;
+                        }
+                        if (next3.type === 'Numeric') {
+                            next4 = tokens[i + 4];
+                            if (!next4) {
+                                return;
+                            }
+                            if (next4.type === 'Punctuator' &&
+                                    next4.value === ')') {
+                                needsId = true;
+                                depAction = 'skip';
+                            } else {
+                                return;
+                            }
+                        } else {
+                            return;
+                        }
+                    } else if (next2.type === 'Keyword' && next2.value === 'this') {
+                        //May be the define(this.key); type
+                        next3 = tokens[i + 3];
+                        next4 = tokens[i + 4];
+                        next5 = tokens[i + 5];
+                        if (!next3 || !next4 || !next5) {
+                            return;
+                        }
+
+                        if (next3.type === 'Punctuator' && next3.value === '.' &&
+                                next4.type === 'Identifier' &&
+                                next5.type === 'Punctuator' && next5.value === ')') {
+                            needsId = true;
+                            depAction = 'empty';
+                        } else {
+                            return;
+                        }
+                    } else {
+                        //Not a match, skip it.
+                        return;
+                    }
+
+                    //A valid define call. Need to find the end, start counting
+                    //parentheses.
+                    inDefine = true;
+                    parenCount = 0;
+
+                    range = {
+                        foundId: foundId,
+                        needsId: needsId,
+                        depAction: depAction,
+                        namespaceExists: namespaceExists,
+                        defineRange: token.range,
+                        parenRange: next.range,
+                        nameCommaRange: nameCommaRange,
+                        sourceUrlData: sourceUrlData
+                    };
+
+                    //Only transform ones that do not have IDs. If it has an
+                    //ID but no dependency array, assume it is something like
+                    //a phonegap implementation, that has its own internal
+                    //define that cannot handle dependency array constructs,
+                    //and if it is a named module, then it means it has been
+                    //set for transport form.
+                    if (range.needsId) {
+                        if (foundAnon) {
+                            logger.trace(path + ' has more than one anonymous ' +
+                                'define. May be a built file from another ' +
+                                'build system like, Ender. Skipping normalization.');
+                            defineRanges = [];
+                            return true;
+                        } else {
+                            foundAnon = range;
+                            defineRanges.push(range);
+                        }
+                    } else if (depAction === 'scan') {
+                        scanCount += 1;
+                        if (scanCount > 1) {
+                            //Just go back to an array that just has the
+                            //anon one, since this is an already optimized
+                            //file like the phonegap one.
+                            if (!scanReset) {
+                                defineRanges =  foundAnon ? [foundAnon] : [];
+                                scanReset = true;
+                            }
+                        } else {
+                            defineRanges.push(range);
+                        }
+                    }
+                }
+            });
+
+            if (!defineRanges.length) {
+                return contents;
+            }
+
+            //Reverse the matches, need to start from the bottom of
+            //the file to modify it, so that the ranges are still true
+            //further up.
+            defineRanges.reverse();
+
+            defineRanges.forEach(function (info) {
+                //Do the modifications "backwards", in other words, start with the
+                //one that is farthest down and work up, so that the ranges in the
+                //defineRanges still apply. So that means deps, id, then namespace.
+
+                if (info.needsId && moduleName) {
+                    contentInsertion += "'" + moduleName + "',";
+                }
+
+                if (info.depAction === 'scan') {
+                    deps = parse.getAnonDeps(path, contents.substring(info.defineRange[0], info.defineEndRange[1]));
+
+                    if (deps.length) {
+                        depString = '[' + deps.map(function (dep) {
+                            return "'" + dep + "'";
+                        }) + ']';
+                    } else {
+                        depString = '[]';
+                    }
+                    depString +=  ',';
+
+                    if (info.nameCommaRange) {
+                        //Already have a named module, need to insert the
+                        //dependencies after the name.
+                        contents = contents.substring(0, info.nameCommaRange[1]) +
+                                   depString +
+                                   contents.substring(info.nameCommaRange[1],
+                                                  contents.length);
+                    } else {
+                        contentInsertion +=  depString;
+                    }
+                }
+
+                if (contentInsertion) {
+                    contents = contents.substring(0, info.parenRange[1]) +
+                               contentInsertion +
+                               contents.substring(info.parenRange[1],
+                                                  contents.length);
+                }
+
+                //Do namespace last so that ui does not mess upthe parenRange
+                //used above.
+                if (namespace && !info.namespaceExists) {
+                    contents = contents.substring(0, info.defineRange[0]) +
+                               namespace + '.' +
+                               contents.substring(info.defineRange[0],
+                                                  contents.length);
+                }
+
+                //Notify any listener for the found info
+                if (onFound) {
+                    onFound(info);
+                }
+            });
+
+            if (options.useSourceUrl) {
+                contents = 'eval("' + lang.jsEscape(contents) +
+                    '\\n//@ sourceURL=' + (path.indexOf('/') === 0 ? '' : '/') +
+                    path +
+                    '");\n';
+            }
+
+            return contents;
+        },
+
+        /**
+         * Modify the contents of a require.config/requirejs.config call. This
+         * call will LOSE any existing comments that are in the config string.
+         *
+         * @param  {String} fileContents String that may contain a config call
+         * @param  {Function} onConfig Function called when the first config
+         * call is found. It will be passed an Object which is the current
+         * config, and the onConfig function should return an Object to use
+         * as the config.
+         * @return {String} the fileContents with the config changes applied.
+         */
+        modifyConfig: function (fileContents, onConfig) {
+            var details = parse.findConfig(fileContents),
+                config = details.config;
+
+            if (config) {
+                config = onConfig(config);
+                if (config) {
+                    return transform.serializeConfig(config,
+                                              fileContents,
+                                              details.range[0],
+                                              details.range[1],
+                                              {
+                                                quote: details.quote
+                                              });
+                }
+            }
+
+            return fileContents;
+        },
+
+        serializeConfig: function (config, fileContents, start, end, options) {
+            //Calculate base level of indent
+            var indent, match, configString, outDentRegExp,
+                baseIndent = '',
+                startString = fileContents.substring(0, start),
+                existingConfigString = fileContents.substring(start, end),
+                lineReturn = existingConfigString.indexOf('\r') === -1 ? '\n' : '\r\n',
+                lastReturnIndex = startString.lastIndexOf('\n');
+
+            //Get the basic amount of indent for the require config call.
+            if (lastReturnIndex === -1) {
+                lastReturnIndex = 0;
+            }
+
+            match = baseIndentRegExp.exec(startString.substring(lastReturnIndex + 1, start));
+            if (match && match[1]) {
+                baseIndent = match[1];
+            }
+
+            //Calculate internal indentation for config
+            match = indentRegExp.exec(existingConfigString);
+            if (match && match[1]) {
+                indent = match[1];
+            }
+
+            if (!indent || indent.length < baseIndent) {
+                indent = '  ';
+            } else {
+                indent = indent.substring(baseIndent.length);
+            }
+
+            outDentRegExp = new RegExp('(' + lineReturn + ')' + indent, 'g');
+
+            configString = transform.objectToString(config, {
+                                                    indent: indent,
+                                                    lineReturn: lineReturn,
+                                                    outDentRegExp: outDentRegExp,
+                                                    quote: options && options.quote
+                                                });
+
+            //Add in the base indenting level.
+            configString = applyIndent(configString, baseIndent, lineReturn);
+
+            return startString + configString + fileContents.substring(end);
+        },
+
+        /**
+         * Tries converting a JS object to a string. This will likely suck, and
+         * is tailored to the type of config expected in a loader config call.
+         * So, hasOwnProperty fields, strings, numbers, arrays and functions,
+         * no weird recursively referenced stuff.
+         * @param  {Object} obj        the object to convert
+         * @param  {Object} options    options object with the following values:
+         *         {String} indent     the indentation to use for each level
+         *         {String} lineReturn the type of line return to use
+         *         {outDentRegExp} outDentRegExp the regexp to use to outdent functions
+         *         {String} quote      the quote type to use, ' or ". Optional. Default is "
+         * @param  {String} totalIndent the total indent to print for this level
+         * @return {String}            a string representation of the object.
+         */
+        objectToString: function (obj, options, totalIndent) {
+            var startBrace, endBrace, nextIndent,
+                first = true,
+                value = '',
+                lineReturn = options.lineReturn,
+                indent = options.indent,
+                outDentRegExp = options.outDentRegExp,
+                quote = options.quote || '"';
+
+            totalIndent = totalIndent || '';
+            nextIndent = totalIndent + indent;
+
+            if (obj === null) {
+                value = 'null';
+            } else if (obj === undefined) {
+                value = 'undefined';
+            } else if (typeof obj === 'number') {
+                value = obj;
+            } else if (typeof obj === 'string') {
+                //Use double quotes in case the config may also work as JSON.
+                value = quote + lang.jsEscape(obj) + quote;
+            } else if (lang.isArray(obj)) {
+                lang.each(obj, function (item, i) {
+                    value += (i !== 0 ? ',' + lineReturn : '' ) +
+                        nextIndent +
+                        transform.objectToString(item,
+                                                 options,
+                                                 nextIndent);
+                });
+
+                startBrace = '[';
+                endBrace = ']';
+            } else if (lang.isFunction(obj) || lang.isRegExp(obj)) {
+                //The outdent regexp just helps pretty up the conversion
+                //just in node. Rhino strips comments and does a different
+                //indent scheme for Function toString, so not really helpful
+                //there.
+                value = obj.toString().replace(outDentRegExp, '$1');
+            } else {
+                //An object
+                lang.eachProp(obj, function (v, prop) {
+                    value += (first ? '': ',' + lineReturn) +
+                        nextIndent +
+                        (keyRegExp.test(prop) ? prop : quote + lang.jsEscape(prop) + quote )+
+                        ': ' +
+                        transform.objectToString(v,
+                                                 options,
+                                                 nextIndent);
+                    first = false;
+                });
+                startBrace = '{';
+                endBrace = '}';
+            }
+
+            if (startBrace) {
+                value = startBrace +
+                        lineReturn +
+                        value +
+                        lineReturn + totalIndent +
+                        endBrace;
+            }
+
+            return value;
+        }
+    });
+});/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint regexp: true, plusplus: true  */
+/*global define: false */
+
+define('pragma', ['parse', 'logger'], function (parse, logger) {
+    'use strict';
+    function Temp() {}
+
+    function create(obj, mixin) {
+        Temp.prototype = obj;
+        var temp = new Temp(), prop;
+
+        //Avoid any extra memory hanging around
+        Temp.prototype = null;
+
+        if (mixin) {
+            for (prop in mixin) {
+                if (mixin.hasOwnProperty(prop) && !temp.hasOwnProperty(prop)) {
+                    temp[prop] = mixin[prop];
+                }
+            }
+        }
+
+        return temp; // Object
+    }
+
+    var pragma = {
+        conditionalRegExp: /(exclude|include)Start\s*\(\s*["'](\w+)["']\s*,(.*)\)/,
+        useStrictRegExp: /['"]use strict['"];/g,
+        hasRegExp: /has\s*\(\s*['"]([^'"]+)['"]\s*\)/g,
+        configRegExp: /(^|[^\.])(requirejs|require)(\.config)\s*\(/g,
+        nsWrapRegExp: /\/\*requirejs namespace: true \*\//,
+        apiDefRegExp: /var requirejs, require, define;/,
+        defineCheckRegExp: /typeof\s+define\s*===\s*["']function["']\s*&&\s*define\s*\.\s*amd/g,
+        defineStringCheckRegExp: /typeof\s+define\s*===\s*["']function["']\s*&&\s*define\s*\[\s*["']amd["']\s*\]/g,
+        defineTypeFirstCheckRegExp: /\s*["']function["']\s*===\s*typeof\s+define\s*&&\s*define\s*\.\s*amd/g,
+        defineJQueryRegExp: /typeof\s+define\s*===\s*["']function["']\s*&&\s*define\s*\.\s*amd\s*&&\s*define\s*\.\s*amd\s*\.\s*jQuery/g,
+        defineHasRegExp: /typeof\s+define\s*==(=)?\s*['"]function['"]\s*&&\s*typeof\s+define\.amd\s*==(=)?\s*['"]object['"]\s*&&\s*define\.amd/g,
+        defineTernaryRegExp: /typeof\s+define\s*===\s*['"]function["']\s*&&\s*define\s*\.\s*amd\s*\?\s*define/,
+        amdefineRegExp: /if\s*\(\s*typeof define\s*\!==\s*'function'\s*\)\s*\{\s*[^\{\}]+amdefine[^\{\}]+\}/g,
+
+        removeStrict: function (contents, config) {
+            return config.useStrict ? contents : contents.replace(pragma.useStrictRegExp, '');
+        },
+
+        namespace: function (fileContents, ns, onLifecycleName) {
+            if (ns) {
+                //Namespace require/define calls
+                fileContents = fileContents.replace(pragma.configRegExp, '$1' + ns + '.$2$3(');
+
+
+                fileContents = parse.renameNamespace(fileContents, ns);
+
+                //Namespace define ternary use:
+                fileContents = fileContents.replace(pragma.defineTernaryRegExp,
+                                                    "typeof " + ns + ".define === 'function' && " + ns + ".define.amd ? " + ns + ".define");
+
+                //Namespace define jquery use:
+                fileContents = fileContents.replace(pragma.defineJQueryRegExp,
+                                                    "typeof " + ns + ".define === 'function' && " + ns + ".define.amd && " + ns + ".define.amd.jQuery");
+
+                //Namespace has.js define use:
+                fileContents = fileContents.replace(pragma.defineHasRegExp,
+                                                    "typeof " + ns + ".define === 'function' && typeof " + ns + ".define.amd === 'object' && " + ns + ".define.amd");
+
+                //Namespace define checks.
+                //Do these ones last, since they are a subset of the more specific
+                //checks above.
+                fileContents = fileContents.replace(pragma.defineCheckRegExp,
+                                                    "typeof " + ns + ".define === 'function' && " + ns + ".define.amd");
+                fileContents = fileContents.replace(pragma.defineStringCheckRegExp,
+                                                    "typeof " + ns + ".define === 'function' && " + ns + ".define['amd']");
+                fileContents = fileContents.replace(pragma.defineTypeFirstCheckRegExp,
+                                                    "'function' === typeof " + ns + ".define && " + ns + ".define.amd");
+
+                //Check for require.js with the require/define definitions
+                if (pragma.apiDefRegExp.test(fileContents) &&
+                    fileContents.indexOf("if (!" + ns + " || !" + ns + ".requirejs)") === -1) {
+                    //Wrap the file contents in a typeof check, and a function
+                    //to contain the API globals.
+                    fileContents = "var " + ns + ";(function () { if (!" + ns + " || !" + ns + ".requirejs) {\n" +
+                                    "if (!" + ns + ") { " + ns + ' = {}; } else { require = ' + ns + '; }\n' +
+                                    fileContents +
+                                    "\n" +
+                                    ns + ".requirejs = requirejs;" +
+                                    ns + ".require = require;" +
+                                    ns + ".define = define;\n" +
+                                    "}\n}());";
+                }
+
+                //Finally, if the file wants a special wrapper because it ties
+                //in to the requirejs internals in a way that would not fit
+                //the above matches, do that. Look for /*requirejs namespace: true*/
+                if (pragma.nsWrapRegExp.test(fileContents)) {
+                    //Remove the pragma.
+                    fileContents = fileContents.replace(pragma.nsWrapRegExp, '');
+
+                    //Alter the contents.
+                    fileContents = '(function () {\n' +
+                                   'var require = ' + ns + '.require,' +
+                                   'requirejs = ' + ns + '.requirejs,' +
+                                   'define = ' + ns + '.define;\n' +
+                                   fileContents +
+                                   '\n}());';
+                }
+            }
+
+            return fileContents;
+        },
+
+        /**
+         * processes the fileContents for some //>> conditional statements
+         */
+        process: function (fileName, fileContents, config, onLifecycleName, pluginCollector) {
+            /*jslint evil: true */
+            var foundIndex = -1, startIndex = 0, lineEndIndex, conditionLine,
+                matches, type, marker, condition, isTrue, endRegExp, endMatches,
+                endMarkerIndex, shouldInclude, startLength, lifecycleHas, deps,
+                i, dep, moduleName, collectorMod,
+                lifecyclePragmas, pragmas = config.pragmas, hasConfig = config.has,
+                //Legacy arg defined to help in dojo conversion script. Remove later
+                //when dojo no longer needs conversion:
+                kwArgs = pragmas;
+
+            //Mix in a specific lifecycle scoped object, to allow targeting
+            //some pragmas/has tests to only when files are saved, or at different
+            //lifecycle events. Do not bother with kwArgs in this section, since
+            //the old dojo kwArgs were for all points in the build lifecycle.
+            if (onLifecycleName) {
+                lifecyclePragmas = config['pragmas' + onLifecycleName];
+                lifecycleHas = config['has' + onLifecycleName];
+
+                if (lifecyclePragmas) {
+                    pragmas = create(pragmas || {}, lifecyclePragmas);
+                }
+
+                if (lifecycleHas) {
+                    hasConfig = create(hasConfig || {}, lifecycleHas);
+                }
+            }
+
+            //Replace has references if desired
+            if (hasConfig) {
+                fileContents = fileContents.replace(pragma.hasRegExp, function (match, test) {
+                    if (hasConfig.hasOwnProperty(test)) {
+                        return !!hasConfig[test];
+                    }
+                    return match;
+                });
+            }
+
+            if (!config.skipPragmas) {
+
+                while ((foundIndex = fileContents.indexOf("//>>", startIndex)) !== -1) {
+                    //Found a conditional. Get the conditional line.
+                    lineEndIndex = fileContents.indexOf("\n", foundIndex);
+                    if (lineEndIndex === -1) {
+                        lineEndIndex = fileContents.length - 1;
+                    }
+
+                    //Increment startIndex past the line so the next conditional search can be done.
+                    startIndex = lineEndIndex + 1;
+
+                    //Break apart the conditional.
+                    conditionLine = fileContents.substring(foundIndex, lineEndIndex + 1);
+                    matches = conditionLine.match(pragma.conditionalRegExp);
+                    if (matches) {
+                        type = matches[1];
+                        marker = matches[2];
+                        condition = matches[3];
+                        isTrue = false;
+                        //See if the condition is true.
+                        try {
+                            isTrue = !!eval("(" + condition + ")");
+                        } catch (e) {
+                            throw "Error in file: " +
+                                   fileName +
+                                   ". Conditional comment: " +
+                                   conditionLine +
+                                   " failed with this error: " + e;
+                        }
+
+                        //Find the endpoint marker.
+                        endRegExp = new RegExp('\\/\\/\\>\\>\\s*' + type + 'End\\(\\s*[\'"]' + marker + '[\'"]\\s*\\)', "g");
+                        endMatches = endRegExp.exec(fileContents.substring(startIndex, fileContents.length));
+                        if (endMatches) {
+                            endMarkerIndex = startIndex + endRegExp.lastIndex - endMatches[0].length;
+
+                            //Find the next line return based on the match position.
+                            lineEndIndex = fileContents.indexOf("\n", endMarkerIndex);
+                            if (lineEndIndex === -1) {
+                                lineEndIndex = fileContents.length - 1;
+                            }
+
+                            //Should we include the segment?
+                            shouldInclude = ((type === "exclude" && !isTrue) || (type === "include" && isTrue));
+
+                            //Remove the conditional comments, and optionally remove the content inside
+                            //the conditional comments.
+                            startLength = startIndex - foundIndex;
+                            fileContents = fileContents.substring(0, foundIndex) +
+                                (shouldInclude ? fileContents.substring(startIndex, endMarkerIndex) : "") +
+                                fileContents.substring(lineEndIndex + 1, fileContents.length);
+
+                            //Move startIndex to foundIndex, since that is the new position in the file
+                            //where we need to look for more conditionals in the next while loop pass.
+                            startIndex = foundIndex;
+                        } else {
+                            throw "Error in file: " +
+                                  fileName +
+                                  ". Cannot find end marker for conditional comment: " +
+                                  conditionLine;
+
+                        }
+                    }
+                }
+            }
+
+            //If need to find all plugin resources to optimize, do that now,
+            //before namespacing, since the namespacing will change the API
+            //names.
+            //If there is a plugin collector, scan the file for plugin resources.
+            if (config.optimizeAllPluginResources && pluginCollector) {
+                try {
+                    deps = parse.findDependencies(fileName, fileContents);
+                    if (deps.length) {
+                        for (i = 0; i < deps.length; i++) {
+                            dep = deps[i];
+                            if (dep.indexOf('!') !== -1) {
+                                moduleName = dep.split('!')[0];
+                                collectorMod = pluginCollector[moduleName];
+                                if (!collectorMod) {
+                                 collectorMod = pluginCollector[moduleName] = [];
+                                }
+                                collectorMod.push(dep);
+                            }
+                        }
+                    }
+                } catch (eDep) {
+                    logger.error('Parse error looking for plugin resources in ' +
+                                 fileName + ', skipping.');
+                }
+            }
+
+            //Strip amdefine use for node-shared modules.
+            fileContents = fileContents.replace(pragma.amdefineRegExp, '');
+
+            //Do namespacing
+            if (onLifecycleName === 'OnSave' && config.namespace) {
+                fileContents = pragma.namespace(fileContents, config.namespace, onLifecycleName);
+            }
+
+
+            return pragma.removeStrict(fileContents, config);
+        }
+    };
+
+    return pragma;
+});
+if(env === 'browser') {
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false */
+
+define('browser/optimize', {});
+
+}
+
+if(env === 'node') {
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint strict: false */
+/*global define: false */
+
+define('node/optimize', {});
+
+}
+
+if(env === 'rhino') {
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint sloppy: true, plusplus: true */
+/*global define, java, Packages, com */
+
+define('rhino/optimize', ['logger', 'env!env/file'], function (logger, file) {
+
+    //Add .reduce to Rhino so UglifyJS can run in Rhino,
+    //inspired by https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce
+    //but rewritten for brevity, and to be good enough for use by UglifyJS.
+    if (!Array.prototype.reduce) {
+        Array.prototype.reduce = function (fn /*, initialValue */) {
+            var i = 0,
+                length = this.length,
+                accumulator;
+
+            if (arguments.length >= 2) {
+                accumulator = arguments[1];
+            } else {
+                if (length) {
+                    while (!(i in this)) {
+                        i++;
+                    }
+                    accumulator = this[i++];
+                }
+            }
+
+            for (; i < length; i++) {
+                if (i in this) {
+                    accumulator = fn.call(undefined, accumulator, this[i], i, this);
+                }
+            }
+
+            return accumulator;
+        };
+    }
+
+    var JSSourceFilefromCode, optimize,
+        mapRegExp = /"file":"[^"]+"/;
+
+    //Bind to Closure compiler, but if it is not available, do not sweat it.
+    try {
+        JSSourceFilefromCode = java.lang.Class.forName('com.google.javascript.jscomp.JSSourceFile').getMethod('fromCode', [java.lang.String, java.lang.String]);
+    } catch (e) {}
+
+    //Helper for closure compiler, because of weird Java-JavaScript interactions.
+    function closurefromCode(filename, content) {
+        return JSSourceFilefromCode.invoke(null, [filename, content]);
+    }
+
+
+    function getFileWriter(fileName, encoding) {
+        var outFile = new java.io.File(fileName), outWriter, parentDir;
+
+        parentDir = outFile.getAbsoluteFile().getParentFile();
+        if (!parentDir.exists()) {
+            if (!parentDir.mkdirs()) {
+                throw "Could not create directory: " + parentDir.getAbsolutePath();
+            }
+        }
+
+        if (encoding) {
+            outWriter = new java.io.OutputStreamWriter(new java.io.FileOutputStream(outFile), encoding);
+        } else {
+            outWriter = new java.io.OutputStreamWriter(new java.io.FileOutputStream(outFile));
+        }
+
+        return new java.io.BufferedWriter(outWriter);
+    }
+
+    optimize = {
+        closure: function (fileName, fileContents, outFileName, keepLines, config) {
+            config = config || {};
+            var result, mappings, optimized, compressed, baseName, writer,
+                outBaseName, outFileNameMap, outFileNameMapContent,
+                jscomp = Packages.com.google.javascript.jscomp,
+                flags = Packages.com.google.common.flags,
+                //Fake extern
+                externSourceFile = closurefromCode("fakeextern.js", " "),
+                //Set up source input
+                jsSourceFile = closurefromCode(String(fileName), String(fileContents)),
+                options, option, FLAG_compilation_level, compiler,
+                Compiler = Packages.com.google.javascript.jscomp.Compiler;
+
+            logger.trace("Minifying file: " + fileName);
+
+            baseName = (new java.io.File(fileName)).getName();
+
+            //Set up options
+            options = new jscomp.CompilerOptions();
+            for (option in config.CompilerOptions) {
+                // options are false by default and jslint wanted an if statement in this for loop
+                if (config.CompilerOptions[option]) {
+                    options[option] = config.CompilerOptions[option];
+                }
+
+            }
+            options.prettyPrint = keepLines || options.prettyPrint;
+
+            FLAG_compilation_level = jscomp.CompilationLevel[config.CompilationLevel || 'SIMPLE_OPTIMIZATIONS'];
+            FLAG_compilation_level.setOptionsForCompilationLevel(options);
+
+            if (config.generateSourceMaps) {
+                mappings = new java.util.ArrayList();
+
+                mappings.add(new com.google.javascript.jscomp.SourceMap.LocationMapping(fileName, baseName + ".src"));
+                options.setSourceMapLocationMappings(mappings);
+                options.setSourceMapOutputPath(fileName + ".map");
+            }
+
+            //Trigger the compiler
+            Compiler.setLoggingLevel(Packages.java.util.logging.Level[config.loggingLevel || 'WARNING']);
+            compiler = new Compiler();
+
+            result = compiler.compile(externSourceFile, jsSourceFile, options);
+            if (result.success) {
+                optimized = String(compiler.toSource());
+
+                if (config.generateSourceMaps && result.sourceMap && outFileName) {
+                    outBaseName = (new java.io.File(outFileName)).getName();
+
+                    file.saveUtf8File(outFileName + ".src", fileContents);
+
+                    outFileNameMap = outFileName + ".map";
+                    writer = getFileWriter(outFileNameMap, "utf-8");
+                    result.sourceMap.appendTo(writer, outFileName);
+                    writer.close();
+
+                    //Not sure how better to do this, but right now the .map file
+                    //leaks the full OS path in the "file" property. Manually
+                    //modify it to not do that.
+                    file.saveFile(outFileNameMap,
+                        file.readFile(outFileNameMap).replace(mapRegExp, '"file":"' + baseName + '"'));
+
+                    fileContents = optimized + "\n//@ sourceMappingURL=" + outBaseName + ".map";
+                } else {
+                    fileContents = optimized;
+                }
+                return fileContents;
+            } else {
+                throw new Error('Cannot closure compile file: ' + fileName + '. Skipping it.');
+            }
+
+            return fileContents;
+        }
+    };
+
+    return optimize;
+});
+}
+
+if(env === 'xpconnect') {
+define('xpconnect/optimize', {});
+}
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint plusplus: true, nomen: true, regexp: true */
+/*global define: false */
+
+define('optimize', [ 'lang', 'logger', 'env!env/optimize', 'env!env/file', 'parse',
+         'pragma', 'uglifyjs/index', 'uglifyjs2',
+         'source-map'],
+function (lang,   logger,   envOptimize,        file,           parse,
+          pragma, uglify,             uglify2,
+          sourceMap) {
+    'use strict';
+
+    var optimize,
+        cssImportRegExp = /\@import\s+(url\()?\s*([^);]+)\s*(\))?([\w, ]*)(;)?/ig,
+        cssCommentImportRegExp = /\/\*[^\*]*@import[^\*]*\*\//g,
+        cssUrlRegExp = /\url\(\s*([^\)]+)\s*\)?/g,
+        SourceMapGenerator = sourceMap.SourceMapGenerator,
+        SourceMapConsumer =sourceMap.SourceMapConsumer;
+
+    /**
+     * If an URL from a CSS url value contains start/end quotes, remove them.
+     * This is not done in the regexp, since my regexp fu is not that strong,
+     * and the CSS spec allows for ' and " in the URL if they are backslash escaped.
+     * @param {String} url
+     */
+    function cleanCssUrlQuotes(url) {
+        //Make sure we are not ending in whitespace.
+        //Not very confident of the css regexps above that there will not be ending
+        //whitespace.
+        url = url.replace(/\s+$/, "");
+
+        if (url.charAt(0) === "'" || url.charAt(0) === "\"") {
+            url = url.substring(1, url.length - 1);
+        }
+
+        return url;
+    }
+
+    /**
+     * Inlines nested stylesheets that have @import calls in them.
+     * @param {String} fileName the file name
+     * @param {String} fileContents the file contents
+     * @param {String} cssImportIgnore comma delimited string of files to ignore
+     * @param {String} cssPrefix string to be prefixed before relative URLs
+     * @param {Object} included an object used to track the files already imported
+     */
+    function flattenCss(fileName, fileContents, cssImportIgnore, cssPrefix, included) {
+        //Find the last slash in the name.
+        fileName = fileName.replace(lang.backSlashRegExp, "/");
+        var endIndex = fileName.lastIndexOf("/"),
+            //Make a file path based on the last slash.
+            //If no slash, so must be just a file name. Use empty string then.
+            filePath = (endIndex !== -1) ? fileName.substring(0, endIndex + 1) : "",
+            //store a list of merged files
+            importList = [],
+            skippedList = [];
+
+        //First make a pass by removing an commented out @import calls.
+        fileContents = fileContents.replace(cssCommentImportRegExp, '');
+
+        //Make sure we have a delimited ignore list to make matching faster
+        if (cssImportIgnore && cssImportIgnore.charAt(cssImportIgnore.length - 1) !== ",") {
+            cssImportIgnore += ",";
+        }
+
+        fileContents = fileContents.replace(cssImportRegExp, function (fullMatch, urlStart, importFileName, urlEnd, mediaTypes) {
+            //Only process media type "all" or empty media type rules.
+            if (mediaTypes && ((mediaTypes.replace(/^\s\s*/, '').replace(/\s\s*$/, '')) !== "all")) {
+                skippedList.push(fileName);
+                return fullMatch;
+            }
+
+            importFileName = cleanCssUrlQuotes(importFileName);
+
+            //Ignore the file import if it is part of an ignore list.
+            if (cssImportIgnore && cssImportIgnore.indexOf(importFileName + ",") !== -1) {
+                return fullMatch;
+            }
+
+            //Make sure we have a unix path for the rest of the operation.
+            importFileName = importFileName.replace(lang.backSlashRegExp, "/");
+
+            try {
+                //if a relative path, then tack on the filePath.
+                //If it is not a relative path, then the readFile below will fail,
+                //and we will just skip that import.
+                var fullImportFileName = importFileName.charAt(0) === "/" ? importFileName : filePath + importFileName,
+                    importContents = file.readFile(fullImportFileName), i,
+                    importEndIndex, importPath, fixedUrlMatch, colonIndex, parts, flat;
+
+                //Skip the file if it has already been included.
+                if (included[fullImportFileName]) {
+                    return '';
+                }
+                included[fullImportFileName] = true;
+
+                //Make sure to flatten any nested imports.
+                flat = flattenCss(fullImportFileName, importContents, cssImportIgnore, cssPrefix, included);
+                importContents = flat.fileContents;
+
+                if (flat.importList.length) {
+                    importList.push.apply(importList, flat.importList);
+                }
+                if (flat.skippedList.length) {
+                    skippedList.push.apply(skippedList, flat.skippedList);
+                }
+
+                //Make the full import path
+                importEndIndex = importFileName.lastIndexOf("/");
+
+                //Make a file path based on the last slash.
+                //If no slash, so must be just a file name. Use empty string then.
+                importPath = (importEndIndex !== -1) ? importFileName.substring(0, importEndIndex + 1) : "";
+
+                //fix url() on relative import (#5)
+                importPath = importPath.replace(/^\.\//, '');
+
+                //Modify URL paths to match the path represented by this file.
+                importContents = importContents.replace(cssUrlRegExp, function (fullMatch, urlMatch) {
+                    fixedUrlMatch = cleanCssUrlQuotes(urlMatch);
+                    fixedUrlMatch = fixedUrlMatch.replace(lang.backSlashRegExp, "/");
+
+                    //Only do the work for relative URLs. Skip things that start with / or have
+                    //a protocol.
+                    colonIndex = fixedUrlMatch.indexOf(":");
+                    if (fixedUrlMatch.charAt(0) !== "/" && (colonIndex === -1 || colonIndex > fixedUrlMatch.indexOf("/"))) {
+                        //It is a relative URL, tack on the cssPrefix and path prefix
+                        urlMatch = cssPrefix + importPath + fixedUrlMatch;
+
+                    } else {
+                        logger.trace(importFileName + "\n  URL not a relative URL, skipping: " + urlMatch);
+                    }
+
+                    //Collapse .. and .
+                    parts = urlMatch.split("/");
+                    for (i = parts.length - 1; i > 0; i--) {
+                        if (parts[i] === ".") {
+                            parts.splice(i, 1);
+                        } else if (parts[i] === "..") {
+                            if (i !== 0 && parts[i - 1] !== "..") {
+                                parts.splice(i - 1, 2);
+                                i -= 1;
+                            }
+                        }
+                    }
+
+                    return "url(" + parts.join("/") + ")";
+                });
+
+                importList.push(fullImportFileName);
+                return importContents;
+            } catch (e) {
+                logger.warn(fileName + "\n  Cannot inline css import, skipping: " + importFileName);
+                return fullMatch;
+            }
+        });
+
+        return {
+            importList : importList,
+            skippedList: skippedList,
+            fileContents : fileContents
+        };
+    }
+
+    optimize = {
+        /**
+         * Optimizes a file that contains JavaScript content. Optionally collects
+         * plugin resources mentioned in a file, and then passes the content
+         * through an minifier if one is specified via config.optimize.
+         *
+         * @param {String} fileName the name of the file to optimize
+         * @param {String} fileContents the contents to optimize. If this is
+         * a null value, then fileName will be used to read the fileContents.
+         * @param {String} outFileName the name of the file to use for the
+         * saved optimized content.
+         * @param {Object} config the build config object.
+         * @param {Array} [pluginCollector] storage for any plugin resources
+         * found.
+         */
+        jsFile: function (fileName, fileContents, outFileName, config, pluginCollector) {
+            if (!fileContents) {
+                fileContents = file.readFile(fileName);
+            }
+
+            fileContents = optimize.js(fileName, fileContents, outFileName, config, pluginCollector);
+
+            file.saveUtf8File(outFileName, fileContents);
+        },
+
+        /**
+         * Optimizes a file that contains JavaScript content. Optionally collects
+         * plugin resources mentioned in a file, and then passes the content
+         * through an minifier if one is specified via config.optimize.
+         *
+         * @param {String} fileName the name of the file that matches the
+         * fileContents.
+         * @param {String} fileContents the string of JS to optimize.
+         * @param {Object} [config] the build config object.
+         * @param {Array} [pluginCollector] storage for any plugin resources
+         * found.
+         */
+        js: function (fileName, fileContents, outFileName, config, pluginCollector) {
+            var optFunc, optConfig,
+                parts = (String(config.optimize)).split('.'),
+                optimizerName = parts[0],
+                keepLines = parts[1] === 'keepLines',
+                licenseContents = '';
+
+            config = config || {};
+
+            //Apply pragmas/namespace renaming
+            fileContents = pragma.process(fileName, fileContents, config, 'OnSave', pluginCollector);
+
+            //Optimize the JS files if asked.
+            if (optimizerName && optimizerName !== 'none') {
+                optFunc = envOptimize[optimizerName] || optimize.optimizers[optimizerName];
+                if (!optFunc) {
+                    throw new Error('optimizer with name of "' +
+                                    optimizerName +
+                                    '" not found for this environment');
+                }
+
+                optConfig = config[optimizerName] || {};
+                if (config.generateSourceMaps) {
+                    optConfig.generateSourceMaps = !!config.generateSourceMaps;
+                }
+
+                try {
+                    if (config.preserveLicenseComments) {
+                        //Pull out any license comments for prepending after optimization.
+                        try {
+                            licenseContents = parse.getLicenseComments(fileName, fileContents);
+                        } catch (e) {
+                            throw new Error('Cannot parse file: ' + fileName + ' for comments. Skipping it. Error is:\n' + e.toString());
+                        }
+                    }
+if (fileName.indexOf('sourcemap') !== -1)
+    debugger;
+
+                    fileContents = licenseContents + optFunc(fileName,
+                                                             fileContents,
+                                                             outFileName,
+                                                             keepLines,
+                                                             optConfig);
+                } catch (e) {
+                    if (config.throwWhen && config.throwWhen.optimize) {
+                        throw e;
+                    } else {
+                        logger.error(e);
+                    }
+                }
+            }
+
+            return fileContents;
+        },
+
+        /**
+         * Optimizes one CSS file, inlining @import calls, stripping comments, and
+         * optionally removes line returns.
+         * @param {String} fileName the path to the CSS file to optimize
+         * @param {String} outFileName the path to save the optimized file.
+         * @param {Object} config the config object with the optimizeCss and
+         * cssImportIgnore options.
+         */
+        cssFile: function (fileName, outFileName, config) {
+
+            //Read in the file. Make sure we have a JS string.
+            var originalFileContents = file.readFile(fileName),
+                flat = flattenCss(fileName, originalFileContents, config.cssImportIgnore, config.cssPrefix, {}),
+                //Do not use the flattened CSS if there was one that was skipped.
+                fileContents = flat.skippedList.length ? originalFileContents : flat.fileContents,
+                startIndex, endIndex, buildText, comment;
+
+            if (flat.skippedList.length) {
+                logger.warn('Cannot inline @imports for ' + fileName +
+                            ',\nthe following files had media queries in them:\n' +
+                            flat.skippedList.join('\n'));
+            }
+
+            //Do comment removal.
+            try {
+                if (config.optimizeCss.indexOf(".keepComments") === -1) {
+                    startIndex = 0;
+                    //Get rid of comments.
+                    while ((startIndex = fileContents.indexOf("/*", startIndex)) !== -1) {
+                        endIndex = fileContents.indexOf("*/", startIndex + 2);
+                        if (endIndex === -1) {
+                            throw "Improper comment in CSS file: " + fileName;
+                        }
+                        comment = fileContents.substring(startIndex, endIndex);
+
+                        if (config.preserveLicenseComments &&
+                            (comment.indexOf('license') !== -1 ||
+                             comment.indexOf('opyright') !== -1 ||
+                             comment.indexOf('(c)') !== -1)) {
+                            //Keep the comment, just increment the startIndex
+                            startIndex = endIndex;
+                        } else {
+                            fileContents = fileContents.substring(0, startIndex) + fileContents.substring(endIndex + 2, fileContents.length);
+                            startIndex = 0;
+                        }
+                    }
+                }
+                //Get rid of newlines.
+                if (config.optimizeCss.indexOf(".keepLines") === -1) {
+                    fileContents = fileContents.replace(/[\r\n]/g, "");
+                    fileContents = fileContents.replace(/\s+/g, " ");
+                    fileContents = fileContents.replace(/\{\s/g, "{");
+                    fileContents = fileContents.replace(/\s\}/g, "}");
+                } else {
+                    //Remove multiple empty lines.
+                    fileContents = fileContents.replace(/(\r\n)+/g, "\r\n");
+                    fileContents = fileContents.replace(/(\n)+/g, "\n");
+                }
+            } catch (e) {
+                fileContents = originalFileContents;
+                logger.error("Could not optimized CSS file: " + fileName + ", error: " + e);
+            }
+
+            file.saveUtf8File(outFileName, fileContents);
+
+            //text output to stdout and/or written to build.txt file
+            buildText = "\n"+ outFileName.replace(config.dir, "") +"\n----------------\n";
+            flat.importList.push(fileName);
+            buildText += flat.importList.map(function(path){
+                return path.replace(config.dir, "");
+            }).join("\n");
+
+            return {
+                importList: flat.importList,
+                buildText: buildText +"\n"
+            };
+        },
+
+        /**
+         * Optimizes CSS files, inlining @import calls, stripping comments, and
+         * optionally removes line returns.
+         * @param {String} startDir the path to the top level directory
+         * @param {Object} config the config object with the optimizeCss and
+         * cssImportIgnore options.
+         */
+        css: function (startDir, config) {
+            var buildText = "",
+                importList = [],
+                shouldRemove = config.dir && config.removeCombined,
+                i, fileName, result, fileList;
+            if (config.optimizeCss.indexOf("standard") !== -1) {
+                fileList = file.getFilteredFileList(startDir, /\.css$/, true);
+                if (fileList) {
+                    for (i = 0; i < fileList.length; i++) {
+                        fileName = fileList[i];
+                        logger.trace("Optimizing (" + config.optimizeCss + ") CSS file: " + fileName);
+                        result = optimize.cssFile(fileName, fileName, config);
+                        buildText += result.buildText;
+                        if (shouldRemove) {
+                            result.importList.pop();
+                            importList = importList.concat(result.importList);
+                        }
+                    }
+                }
+
+                if (shouldRemove) {
+                    importList.forEach(function (path) {
+                        if (file.exists(path)) {
+                            file.deleteFile(path);
+                        }
+                    });
+                }
+            }
+            return buildText;
+        },
+
+        optimizers: {
+            uglify: function (fileName, fileContents, outFileName, keepLines, config) {
+                var parser = uglify.parser,
+                    processor = uglify.uglify,
+                    ast, errMessage, errMatch;
+
+                config = config || {};
+
+                logger.trace("Uglifying file: " + fileName);
+
+                try {
+                    ast = parser.parse(fileContents, config.strict_semicolons);
+                    if (config.no_mangle !== true) {
+                        ast = processor.ast_mangle(ast, config);
+                    }
+                    ast = processor.ast_squeeze(ast, config);
+
+                    fileContents = processor.gen_code(ast, config);
+
+                    if (config.max_line_length) {
+                        fileContents = processor.split_lines(fileContents, config.max_line_length);
+                    }
+
+                    //Add trailing semicolon to match uglifyjs command line version
+                    fileContents += ';';
+                } catch (e) {
+                    errMessage = e.toString();
+                    errMatch = /\nError(\r)?\n/.exec(errMessage);
+                    if (errMatch) {
+                        errMessage = errMessage.substring(0, errMatch.index);
+                    }
+                    throw new Error('Cannot uglify file: ' + fileName + '. Skipping it. Error is:\n' + errMessage);
+                }
+                return fileContents;
+            },
+            uglify2: function (fileName, fileContents, outFileName, keepLines, config) {
+                var result, existingMap, resultMap, finalMap, sourceIndex,
+                    uconfig = {},
+                    existingMapPath = outFileName + '.map',
+                    baseName = fileName && fileName.split('/').pop();
+
+                config = config || {};
+
+                lang.mixin(uconfig, config, true);
+
+                uconfig.fromString = true;
+
+                if (config.generateSourceMaps && outFileName) {
+                    uconfig.outSourceMap = baseName;
+
+                    if (file.exists(existingMapPath)) {
+                        uconfig.inSourceMap = existingMapPath;
+                        existingMap = JSON.parse(file.readFile(existingMapPath));
+                    }
+                }
+
+                logger.trace("Uglify2 file: " + fileName);
+
+                try {
+                    //var tempContents = fileContents.replace(/\/\/\@ sourceMappingURL=.*$/, '');
+                    result = uglify2.minify(fileContents, uconfig, baseName + '.src.js');
+                    if (uconfig.outSourceMap && result.map) {
+                        resultMap = result.map;
+                        if (existingMap) {
+                            resultMap = JSON.parse(resultMap);
+                            finalMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(resultMap));
+                            finalMap.applySourceMap(new SourceMapConsumer(existingMap));
+                            resultMap = finalMap.toString();
+                        } else {
+                            file.saveFile(outFileName + '.src.js', fileContents);
+                        }
+                        file.saveFile(outFileName + '.map', resultMap);
+                        fileContents = result.code + "\n//@ sourceMappingURL=" + baseName + ".map";
+                    } else {
+                        fileContents = result.code;
+                    }
+                } catch (e) {
+                    throw new Error('Cannot uglify2 file: ' + fileName + '. Skipping it. Error is:\n' + e.toString());
+                }
+                return fileContents;
+            }
+        }
+    };
+
+    return optimize;
+});
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+/*
+ * This file patches require.js to communicate with the build system.
+ */
+
+//Using sloppy since this uses eval for some code like plugins,
+//which may not be strict mode compliant. So if use strict is used
+//below they will have strict rules applied and may cause an error.
+/*jslint sloppy: true, nomen: true, plusplus: true, regexp: true */
+/*global require, define: true */
+
+//NOT asking for require as a dependency since the goal is to modify the
+//global require below
+define('requirePatch', [ 'env!env/file', 'pragma', 'parse', 'lang', 'logger', 'commonJs', 'prim'], function (
+    file,
+    pragma,
+    parse,
+    lang,
+    logger,
+    commonJs,
+    prim
+) {
+
+    var allowRun = true,
+        hasProp = lang.hasProp,
+        falseProp = lang.falseProp,
+        getOwn = lang.getOwn;
+
+    //This method should be called when the patches to require should take hold.
+    return function () {
+        if (!allowRun) {
+            return;
+        }
+        allowRun = false;
+
+        var layer,
+            pluginBuilderRegExp = /(["']?)pluginBuilder(["']?)\s*[=\:]\s*["']([^'"\s]+)["']/,
+            oldNewContext = require.s.newContext,
+            oldDef,
+
+            //create local undefined values for module and exports,
+            //so that when files are evaled in this function they do not
+            //see the node values used for r.js
+            exports,
+            module;
+
+        /**
+         * Reset "global" build caches that are kept around between
+         * build layer builds. Useful to do when there are multiple
+         * top level requirejs.optimize() calls.
+         */
+        require._cacheReset = function () {
+            //Stored raw text caches, used by browser use.
+            require._cachedRawText = {};
+            //Stored cached file contents for reuse in other layers.
+            require._cachedFileContents = {};
+            //Store which cached files contain a require definition.
+            require._cachedDefinesRequireUrls = {};
+        };
+        require._cacheReset();
+
+        /**
+         * Makes sure the URL is something that can be supported by the
+         * optimization tool.
+         * @param {String} url
+         * @returns {Boolean}
+         */
+        require._isSupportedBuildUrl = function (url) {
+            //Ignore URLs with protocols, hosts or question marks, means either network
+            //access is needed to fetch it or it is too dynamic. Note that
+            //on Windows, full paths are used for some urls, which include
+            //the drive, like c:/something, so need to test for something other
+            //than just a colon.
+            if (url.indexOf("://") === -1 && url.indexOf("?") === -1 &&
+                    url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {
+                return true;
+            } else {
+                if (!layer.ignoredUrls[url]) {
+                    if (url.indexOf('empty:') === -1) {
+                        logger.info('Cannot optimize network URL, skipping: ' + url);
+                    }
+                    layer.ignoredUrls[url] = true;
+                }
+                return false;
+            }
+        };
+
+        function normalizeUrlWithBase(context, moduleName, url) {
+            //Adjust the URL if it was not transformed to use baseUrl.
+            if (require.jsExtRegExp.test(moduleName)) {
+                url = (context.config.dir || context.config.dirBaseUrl) + url;
+            }
+            return url;
+        }
+
+        //Overrides the new context call to add existing tracking features.
+        require.s.newContext = function (name) {
+            var context = oldNewContext(name),
+                oldEnable = context.enable,
+                moduleProto = context.Module.prototype,
+                oldInit = moduleProto.init,
+                oldCallPlugin = moduleProto.callPlugin;
+
+            //Only do this for the context used for building.
+            if (name === '_') {
+                //For build contexts, do everything sync
+                context.nextTick = function (fn) {
+                    fn();
+                };
+
+                context.needFullExec = {};
+                context.fullExec = {};
+                context.plugins = {};
+                context.buildShimExports = {};
+
+                //Override the shim exports function generator to just
+                //spit out strings that can be used in the stringified
+                //build output.
+                context.makeShimExports = function (value) {
+                    function fn() {
+                        return '(function (global) {\n' +
+                            '    return function () {\n' +
+                            '        var ret, fn;\n' +
+                            (value.init ?
+                                    ('       fn = ' + value.init.toString() + ';\n' +
+                                    '        ret = fn.apply(global, arguments);\n') : '') +
+                            (value.exports ?
+                                    '        return ret || global.' + value.exports + ';\n' :
+                                    '        return ret;\n') +
+                            '    };\n' +
+                            '}(this))';
+                    }
+
+                    return fn;
+                };
+
+                context.enable = function (depMap, parent) {
+                    var id = depMap.id,
+                        parentId = parent && parent.map.id,
+                        needFullExec = context.needFullExec,
+                        fullExec = context.fullExec,
+                        mod = getOwn(context.registry, id);
+
+                    if (mod && !mod.defined) {
+                        if (parentId && getOwn(needFullExec, parentId)) {
+                            needFullExec[id] = true;
+                        }
+
+                    } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||
+                               (parentId && getOwn(needFullExec, parentId) &&
+                                falseProp(fullExec, id))) {
+                        context.require.undef(id);
+                    }
+
+                    return oldEnable.apply(context, arguments);
+                };
+
+                //Override load so that the file paths can be collected.
+                context.load = function (moduleName, url) {
+                    /*jslint evil: true */
+                    var contents, pluginBuilderMatch, builderName,
+                        shim, shimExports;
+
+                    //Do not mark the url as fetched if it is
+                    //not an empty: URL, used by the optimizer.
+                    //In that case we need to be sure to call
+                    //load() for each module that is mapped to
+                    //empty: so that dependencies are satisfied
+                    //correctly.
+                    if (url.indexOf('empty:') === 0) {
+                        delete context.urlFetched[url];
+                    }
+
+                    //Only handle urls that can be inlined, so that means avoiding some
+                    //URLs like ones that require network access or may be too dynamic,
+                    //like JSONP
+                    if (require._isSupportedBuildUrl(url)) {
+                        //Adjust the URL if it was not transformed to use baseUrl.
+                        url = normalizeUrlWithBase(context, moduleName, url);
+
+                        //Save the module name to path  and path to module name mappings.
+                        layer.buildPathMap[moduleName] = url;
+                        layer.buildFileToModule[url] = moduleName;
+
+                        if (hasProp(context.plugins, moduleName)) {
+                            //plugins need to have their source evaled as-is.
+                            context.needFullExec[moduleName] = true;
+                        }
+
+                        prim().start(function () {
+                            if (hasProp(require._cachedFileContents, url) &&
+                                    (falseProp(context.needFullExec, moduleName) ||
+                                    getOwn(context.fullExec, moduleName))) {
+                                contents = require._cachedFileContents[url];
+
+                                //If it defines require, mark it so it can be hoisted.
+                                //Done here and in the else below, before the
+                                //else block removes code from the contents.
+                                //Related to #263
+                                if (!layer.existingRequireUrl && require._cachedDefinesRequireUrls[url]) {
+                                    layer.existingRequireUrl = url;
+                                }
+                            } else {
+                                //Load the file contents, process for conditionals, then
+                                //evaluate it.
+                                return require._cacheReadAsync(url).then(function (text) {
+                                    contents = text;
+
+                                    if (context.config.cjsTranslate &&
+                                        (!context.config.shim || !lang.hasProp(context.config.shim, moduleName))) {
+                                        contents = commonJs.convert(url, contents);
+                                    }
+
+                                    //If there is a read filter, run it now.
+                                    if (context.config.onBuildRead) {
+                                        contents = context.config.onBuildRead(moduleName, url, contents);
+                                    }
+
+                                    contents = pragma.process(url, contents, context.config, 'OnExecute');
+
+                                    //Find out if the file contains a require() definition. Need to know
+                                    //this so we can inject plugins right after it, but before they are needed,
+                                    //and to make sure this file is first, so that define calls work.
+                                    try {
+                                        if (!layer.existingRequireUrl && parse.definesRequire(url, contents)) {
+                                            layer.existingRequireUrl = url;
+                                            require._cachedDefinesRequireUrls[url] = true;
+                                        }
+                                    } catch (e1) {
+                                        throw new Error('Parse error using esprima ' +
+                                                        'for file: ' + url + '\n' + e1);
+                                    }
+                                }).then(function () {
+                                    if (hasProp(context.plugins, moduleName)) {
+                                        //This is a loader plugin, check to see if it has a build extension,
+                                        //otherwise the plugin will act as the plugin builder too.
+                                        pluginBuilderMatch = pluginBuilderRegExp.exec(contents);
+                                        if (pluginBuilderMatch) {
+                                            //Load the plugin builder for the plugin contents.
+                                            builderName = context.makeModuleMap(pluginBuilderMatch[3],
+                                                                                context.makeModuleMap(moduleName),
+                                                                                null,
+                                                                                true).id;
+                                            return require._cacheReadAsync(context.nameToUrl(builderName));
+                                        }
+                                    }
+                                    return contents;
+                                }).then(function (text) {
+                                    contents = text;
+
+                                    //Parse out the require and define calls.
+                                    //Do this even for plugins in case they have their own
+                                    //dependencies that may be separate to how the pluginBuilder works.
+                                    try {
+                                        if (falseProp(context.needFullExec, moduleName)) {
+                                            contents = parse(moduleName, url, contents, {
+                                                insertNeedsDefine: true,
+                                                has: context.config.has,
+                                                findNestedDependencies: context.config.findNestedDependencies
+                                            });
+                                        }
+                                    } catch (e2) {
+                                        throw new Error('Parse error using esprima ' +
+                                                        'for file: ' + url + '\n' + e2);
+                                    }
+
+                                    require._cachedFileContents[url] = contents;
+                                });
+                            }
+                        }).then(function () {
+                            if (contents) {
+                                eval(contents);
+                            }
+
+                            try {
+                                //If have a string shim config, and this is
+                                //a fully executed module, try to see if
+                                //it created a variable in this eval scope
+                                if (getOwn(context.needFullExec, moduleName)) {
+                                    shim = getOwn(context.config.shim, moduleName);
+                                    if (shim && shim.exports) {
+                                        shimExports = eval(shim.exports);
+                                        if (typeof shimExports !== 'undefined') {
+                                            context.buildShimExports[moduleName] = shimExports;
+                                        }
+                                    }
+                                }
+
+                                //Need to close out completion of this module
+                                //so that listeners will get notified that it is available.
+                                context.completeLoad(moduleName);
+                            } catch (e) {
+                                //Track which module could not complete loading.
+                                if (!e.moduleTree) {
+                                    e.moduleTree = [];
+                                }
+                                e.moduleTree.push(moduleName);
+                                throw e;
+                            }
+                        }).then(null, function (eOuter) {
+
+                            if (!eOuter.fileName) {
+                                eOuter.fileName = url;
+                            }
+                            throw eOuter;
+                        }).end();
+                    } else {
+                        //With unsupported URLs still need to call completeLoad to
+                        //finish loading.
+                        context.completeLoad(moduleName);
+                    }
+                };
+
+                //Marks module has having a name, and optionally executes the
+                //callback, but only if it meets certain criteria.
+                context.execCb = function (name, cb, args, exports) {
+                    var buildShimExports = getOwn(layer.context.buildShimExports, name);
+
+                    if (buildShimExports) {
+                        return buildShimExports;
+                    } else if (cb.__requireJsBuild || getOwn(layer.context.needFullExec, name)) {
+                        return cb.apply(exports, args);
+                    }
+                    return undefined;
+                };
+
+                moduleProto.init = function (depMaps) {
+                    if (context.needFullExec[this.map.id]) {
+                        lang.each(depMaps, lang.bind(this, function (depMap) {
+                            if (typeof depMap === 'string') {
+                                depMap = context.makeModuleMap(depMap,
+                                               (this.map.isDefine ? this.map : this.map.parentMap));
+                            }
+
+                            if (!context.fullExec[depMap.id]) {
+                                context.require.undef(depMap.id);
+                            }
+                        }));
+                    }
+
+                    return oldInit.apply(this, arguments);
+                };
+
+                moduleProto.callPlugin = function () {
+                    var map = this.map,
+                        pluginMap = context.makeModuleMap(map.prefix),
+                        pluginId = pluginMap.id,
+                        pluginMod = getOwn(context.registry, pluginId);
+
+                    context.plugins[pluginId] = true;
+                    context.needFullExec[pluginId] = true;
+
+                    //If the module is not waiting to finish being defined,
+                    //undef it and start over, to get full execution.
+                    if (falseProp(context.fullExec, pluginId) && (!pluginMod || pluginMod.defined)) {
+                        context.require.undef(pluginMap.id);
+                    }
+
+                    return oldCallPlugin.apply(this, arguments);
+                };
+            }
+
+            return context;
+        };
+
+        //Clear up the existing context so that the newContext modifications
+        //above will be active.
+        delete require.s.contexts._;
+
+        /** Reset state for each build layer pass. */
+        require._buildReset = function () {
+            var oldContext = require.s.contexts._;
+
+            //Clear up the existing context.
+            delete require.s.contexts._;
+
+            //Set up new context, so the layer object can hold onto it.
+            require({});
+
+            layer = require._layer = {
+                buildPathMap: {},
+                buildFileToModule: {},
+                buildFilePaths: [],
+                pathAdded: {},
+                modulesWithNames: {},
+                needsDefine: {},
+                existingRequireUrl: "",
+                ignoredUrls: {},
+                context: require.s.contexts._
+            };
+
+            //Return the previous context in case it is needed, like for
+            //the basic config object.
+            return oldContext;
+        };
+
+        require._buildReset();
+
+        //Override define() to catch modules that just define an object, so that
+        //a dummy define call is not put in the build file for them. They do
+        //not end up getting defined via context.execCb, so we need to catch them
+        //at the define call.
+        oldDef = define;
+
+        //This function signature does not have to be exact, just match what we
+        //are looking for.
+        define = function (name) {
+            if (typeof name === "string" && falseProp(layer.needsDefine, name)) {
+                layer.modulesWithNames[name] = true;
+            }
+            return oldDef.apply(require, arguments);
+        };
+
+        define.amd = oldDef.amd;
+
+        //Add some utilities for plugins
+        require._readFile = file.readFile;
+        require._fileExists = function (path) {
+            return file.exists(path);
+        };
+
+        //Called when execManager runs for a dependency. Used to figure out
+        //what order of execution.
+        require.onResourceLoad = function (context, map) {
+            var id = map.id,
+                url;
+
+            //If build needed a full execution, indicate it
+            //has been done now. But only do it if the context is tracking
+            //that. Only valid for the context used in a build, not for
+            //other contexts being run, like for useLib, plain requirejs
+            //use in node/rhino.
+            if (context.needFullExec && getOwn(context.needFullExec, id)) {
+                context.fullExec[id] = true;
+            }
+
+            //A plugin.
+            if (map.prefix) {
+                if (falseProp(layer.pathAdded, id)) {
+                    layer.buildFilePaths.push(id);
+                    //For plugins the real path is not knowable, use the name
+                    //for both module to file and file to module mappings.
+                    layer.buildPathMap[id] = id;
+                    layer.buildFileToModule[id] = id;
+                    layer.modulesWithNames[id] = true;
+                    layer.pathAdded[id] = true;
+                }
+            } else if (map.url && require._isSupportedBuildUrl(map.url)) {
+                //If the url has not been added to the layer yet, and it
+                //is from an actual file that was loaded, add it now.
+                url = normalizeUrlWithBase(context, id, map.url);
+                if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {
+                    //Remember the list of dependencies for this layer.
+                    layer.buildFilePaths.push(url);
+                    layer.pathAdded[url] = true;
+                }
+            }
+        };
+
+        //Called by output of the parse() function, when a file does not
+        //explicitly call define, probably just require, but the parse()
+        //function normalizes on define() for dependency mapping and file
+        //ordering works correctly.
+        require.needsDefine = function (moduleName) {
+            layer.needsDefine[moduleName] = true;
+        };
+    };
+});
+/**
+ * @license RequireJS Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint */
+/*global define: false, console: false */
+
+define('commonJs', ['env!env/file', 'parse'], function (file, parse) {
+    'use strict';
+    var commonJs = {
+        //Set to false if you do not want this file to log. Useful in environments
+        //like node where you want the work to happen without noise.
+        useLog: true,
+
+        convertDir: function (commonJsPath, savePath) {
+            var fileList, i,
+                jsFileRegExp = /\.js$/,
+                fileName, convertedFileName, fileContents;
+
+            //Get list of files to convert.
+            fileList = file.getFilteredFileList(commonJsPath, /\w/, true);
+
+            //Normalize on front slashes and make sure the paths do not end in a slash.
+            commonJsPath = commonJsPath.replace(/\\/g, "/");
+            savePath = savePath.replace(/\\/g, "/");
+            if (commonJsPath.charAt(commonJsPath.length - 1) === "/") {
+                commonJsPath = commonJsPath.substring(0, commonJsPath.length - 1);
+            }
+            if (savePath.charAt(savePath.length - 1) === "/") {
+                savePath = savePath.substring(0, savePath.length - 1);
+            }
+
+            //Cycle through all the JS files and convert them.
+            if (!fileList || !fileList.length) {
+                if (commonJs.useLog) {
+                    if (commonJsPath === "convert") {
+                        //A request just to convert one file.
+                        console.log('\n\n' + commonJs.convert(savePath, file.readFile(savePath)));
+                    } else {
+                        console.log("No files to convert in directory: " + commonJsPath);
+                    }
+                }
+            } else {
+                for (i = 0; i < fileList.length; i++) {
+                    fileName = fileList[i];
+                    convertedFileName = fileName.replace(commonJsPath, savePath);
+
+                    //Handle JS files.
+                    if (jsFileRegExp.test(fileName)) {
+                        fileContents = file.readFile(fileName);
+                        fileContents = commonJs.convert(fileName, fileContents);
+                        file.saveUtf8File(convertedFileName, fileContents);
+                    } else {
+                        //Just copy the file over.
+                        file.copyFile(fileName, convertedFileName, true);
+                    }
+                }
+            }
+        },
+
+        /**
+         * Does the actual file conversion.
+         *
+         * @param {String} fileName the name of the file.
+         *
+         * @param {String} fileContents the contents of a file :)
+         *
+         * @returns {String} the converted contents
+         */
+        convert: function (fileName, fileContents) {
+            //Strip out comments.
+            try {
+                var preamble = '',
+                    commonJsProps = parse.usesCommonJs(fileName, fileContents);
+
+                //First see if the module is not already RequireJS-formatted.
+                if (parse.usesAmdOrRequireJs(fileName, fileContents) || !commonJsProps) {
+                    return fileContents;
+                }
+
+                if (commonJsProps.dirname || commonJsProps.filename) {
+                    preamble = 'var __filename = module.uri || "", ' +
+                               '__dirname = __filename.substring(0, __filename.lastIndexOf("/") + 1); ';
+                }
+
+                //Construct the wrapper boilerplate.
+                fileContents = 'define(function (require, exports, module) {' +
+                    preamble +
+                    fileContents +
+                    '\n});\n';
+
+            } catch (e) {
+                console.log("commonJs.convert: COULD NOT CONVERT: " + fileName + ", so skipping it. Error was: " + e);
+                return fileContents;
+            }
+
+            return fileContents;
+        }
+    };
+
+    return commonJs;
+});
+/**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*jslint plusplus: true, nomen: true, regexp: true  */
+/*global define, requirejs */
+
+
+define('build', function (require) {
+    'use strict';
+
+    var build, buildBaseConfig,
+        lang = require('lang'),
+        prim = require('prim'),
+        logger = require('logger'),
+        file = require('env!env/file'),
+        parse = require('parse'),
+        optimize = require('optimize'),
+        pragma = require('pragma'),
+        transform = require('transform'),
+        requirePatch = require('requirePatch'),
+        env = require('env'),
+        commonJs = require('commonJs'),
+        SourceMapGenerator = require('source-map/source-map-generator'),
+        hasProp = lang.hasProp,
+        getOwn = lang.getOwn,
+        falseProp = lang.falseProp,
+        endsWithSemiColonRegExp = /;\s*$/;
+
+    prim.nextTick = function (fn) {
+        fn();
+    };
+
+    //Now map require to the outermost requirejs, now that we have
+    //local dependencies for this module. The rest of the require use is
+    //manipulating the requirejs loader.
+    require = requirejs;
+
+    //Caching function for performance. Attached to
+    //require so it can be reused in requirePatch.js. _cachedRawText
+    //set up by requirePatch.js
+    require._cacheReadAsync = function (path, encoding) {
+        var d;
+
+        if (lang.hasProp(require._cachedRawText, path)) {
+            d = prim();
+            d.resolve(require._cachedRawText[path]);
+            return d.promise;
+        } else {
+            return file.readFileAsync(path, encoding).then(function (text) {
+                require._cachedRawText[path] = text;
+                return text;
+            });
+        }
+    };
+
+    buildBaseConfig = {
+        appDir: "",
+        pragmas: {},
+        paths: {},
+        optimize: "uglify",
+        optimizeCss: "standard.keepLines",
+        inlineText: true,
+        isBuild: true,
+        optimizeAllPluginResources: false,
+        findNestedDependencies: false,
+        preserveLicenseComments: true,
+        //By default, all files/directories are copied, unless
+        //they match this regexp, by default just excludes .folders
+        dirExclusionRegExp: file.dirExclusionRegExp,
+        _buildPathToModuleIndex: {}
+    };
+
+    /**
+     * Some JS may not be valid if concatenated with other JS, in particular
+     * the style of omitting semicolons and rely on ASI. Add a semicolon in
+     * those cases.
+     */
+    function addSemiColon(text) {
+        if (endsWithSemiColonRegExp.test(text)) {
+            return text;
+        } else {
+            return text + ";";
+        }
+    }
+
+    function endsWithSlash(dirName) {
+        if (dirName.charAt(dirName.length - 1) !== "/") {
+            dirName += "/";
+        }
+        return dirName;
+    }
+
+    //Method used by plugin writeFile calls, defined up here to avoid
+    //jslint warning about "making a function in a loop".
+    function makeWriteFile(namespace, layer) {
+        function writeFile(name, contents) {
+            logger.trace('Saving plugin-optimized file: ' + name);
+            file.saveUtf8File(name, contents);
+        }
+
+        writeFile.asModule = function (moduleName, fileName, contents) {
+            writeFile(fileName,
+                build.toTransport(namespace, moduleName, fileName, contents, layer));
+        };
+
+        return writeFile;
+    }
+
+    /**
+     * Main API entry point into the build. The args argument can either be
+     * an array of arguments (like the onese passed on a command-line),
+     * or it can be a JavaScript object that has the format of a build profile
+     * file.
+     *
+     * If it is an object, then in addition to the normal properties allowed in
+     * a build profile file, the object should contain one other property:
+     *
+     * The object could also contain a "buildFile" property, which is a string
+     * that is the file path to a build profile that contains the rest
+     * of the build profile directives.
+     *
+     * This function does not return a status, it should throw an error if
+     * there is a problem completing the build.
+     */
+    build = function (args) {
+        var buildFile, cmdConfig, errorMsg, errorStack, stackMatch, errorTree,
+            i, j, errorMod,
+            stackRegExp = /( {4}at[^\n]+)\n/,
+            standardIndent = '  ';
+
+        return prim().start(function () {
+            if (!args || lang.isArray(args)) {
+                if (!args || args.length < 1) {
+                    logger.error("build.js buildProfile.js\n" +
+                          "where buildProfile.js is the name of the build file (see example.build.js for hints on how to make a build file).");
+                    return undefined;
+                }
+
+                //Next args can include a build file path as well as other build args.
+                //build file path comes first. If it does not contain an = then it is
+                //a build file path. Otherwise, just all build args.
+                if (args[0].indexOf("=") === -1) {
+                    buildFile = args[0];
+                    args.splice(0, 1);
+                }
+
+                //Remaining args are options to the build
+                cmdConfig = build.convertArrayToObject(args);
+                cmdConfig.buildFile = buildFile;
+            } else {
+                cmdConfig = args;
+            }
+
+            return build._run(cmdConfig);
+        }).then(null, function (e) {
+            errorMsg = e.toString();
+            errorTree = e.moduleTree;
+            stackMatch = stackRegExp.exec(errorMsg);
+
+            if (stackMatch) {
+                errorMsg += errorMsg.substring(0, stackMatch.index + stackMatch[0].length + 1);
+            }
+
+            //If a module tree that shows what module triggered the error,
+            //print it out.
+            if (errorTree && errorTree.length > 0) {
+                errorMsg += '\nIn module tree:\n';
+
+                for (i = errorTree.length - 1; i > -1; i--) {
+                    errorMod = errorTree[i];
+                    if (errorMod) {
+                        for (j = errorTree.length - i; j > -1; j--) {
+                            errorMsg += standardIndent;
+                        }
+                        errorMsg += errorMod + '\n';
+                    }
+                }
+
+                logger.error(errorMsg);
+            }
+
+            errorStack = e.stack;
+
+            if (typeof args === 'string' && args.indexOf('stacktrace=true') !== -1) {
+                errorMsg += '\n' + errorStack;
+            } else {
+                if (!stackMatch && errorStack) {
+                    //Just trim out the first "at" in the stack.
+                    stackMatch = stackRegExp.exec(errorStack);
+                    if (stackMatch) {
+                        errorMsg += '\n' + stackMatch[0] || '';
+                    }
+                }
+            }
+
+            throw new Error(errorMsg);
+        });
+    };
+
+    build._run = function (cmdConfig) {
+        var buildPaths, fileName, fileNames,
+            paths, i,
+            baseConfig, config,
+            modules, srcPath, buildContext,
+            destPath, moduleMap, parentModuleMap, context,
+            resources, resource, plugin, fileContents,
+            pluginProcessed = {},
+            buildFileContents = "",
+            pluginCollector = {};
+
+        return prim().start(function () {
+            var prop;
+
+            //Can now run the patches to require.js to allow it to be used for
+            //build generation. Do it here instead of at the top of the module
+            //because we want normal require behavior to load the build tool
+            //then want to switch to build mode.
+            requirePatch();
+
+            config = build.createConfig(cmdConfig);
+            paths = config.paths;
+
+            //Remove the previous build dir, in case it contains source transforms,
+            //like the ones done with onBuildRead and onBuildWrite.
+            if (config.dir && !config.keepBuildDir && file.exists(config.dir)) {
+                file.deleteFile(config.dir);
+            }
+
+            if (!config.out && !config.cssIn) {
+                //This is not just a one-off file build but a full build profile, with
+                //lots of files to process.
+
+                //First copy all the baseUrl content
+                file.copyDir((config.appDir || config.baseUrl), config.dir, /\w/, true);
+
+                //Adjust baseUrl if config.appDir is in play, and set up build output paths.
+                buildPaths = {};
+                if (config.appDir) {
+                    //All the paths should be inside the appDir, so just adjust
+                    //the paths to use the dirBaseUrl
+                    for (prop in paths) {
+                        if (hasProp(paths, prop)) {
+                            buildPaths[prop] = paths[prop].replace(config.appDir, config.dir);
+                        }
+                    }
+                } else {
+                    //If no appDir, then make sure to copy the other paths to this directory.
+                    for (prop in paths) {
+                        if (hasProp(paths, prop)) {
+                            //Set up build path for each path prefix, but only do so
+                            //if the path falls out of the current baseUrl
+                            if (paths[prop].indexOf(config.baseUrl) === 0) {
+                                buildPaths[prop] = paths[prop].replace(config.baseUrl, config.dirBaseUrl);
+                            } else {
+                                buildPaths[prop] = paths[prop] === 'empty:' ? 'empty:' : prop.replace(/\./g, "/");
+
+                                //Make sure source path is fully formed with baseUrl,
+                                //if it is a relative URL.
+                                srcPath = paths[prop];
+                                if (srcPath.indexOf('/') !== 0 && srcPath.indexOf(':') === -1) {
+                                    srcPath = config.baseUrl + srcPath;
+                                }
+
+                                destPath = config.dirBaseUrl + buildPaths[prop];
+
+                                //Skip empty: paths
+                                if (srcPath !== 'empty:') {
+                                    //If the srcPath is a directory, copy the whole directory.
+                                    if (file.exists(srcPath) && file.isDirectory(srcPath)) {
+                                        //Copy files to build area. Copy all files (the /\w/ regexp)
+                                        file.copyDir(srcPath, destPath, /\w/, true);
+                                    } else {
+                                        //Try a .js extension
+                                        srcPath += '.js';
+                                        destPath += '.js';
+                                        file.copyFile(srcPath, destPath);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            //Figure out source file location for each module layer. Do this by seeding require
+            //with source area configuration. This is needed so that later the module layers
+            //can be manually copied over to the source area, since the build may be
+            //require multiple times and the above copyDir call only copies newer files.
+            require({
+                baseUrl: config.baseUrl,
+                paths: paths,
+                packagePaths: config.packagePaths,
+                packages: config.packages
+            });
+            buildContext = require.s.contexts._;
+            modules = config.modules;
+
+            if (modules) {
+                modules.forEach(function (module) {
+                    if (module.name) {
+                        module._sourcePath = buildContext.nameToUrl(module.name);
+                        //If the module does not exist, and this is not a "new" module layer,
+                        //as indicated by a true "create" property on the module, and
+                        //it is not a plugin-loaded resource, then throw an error.
+                        if (!file.exists(module._sourcePath) && !module.create &&
+                                module.name.indexOf('!') === -1) {
+                            throw new Error("ERROR: module path does not exist: " +
+                                            module._sourcePath + " for module named: " + module.name +
+                                            ". Path is relative to: " + file.absPath('.'));
+                        }
+                    }
+                });
+            }
+
+            if (config.out) {
+                //Just set up the _buildPath for the module layer.
+                require(config);
+                if (!config.cssIn) {
+                    config.modules[0]._buildPath = typeof config.out === 'function' ?
+                                                   'FUNCTION' : config.out;
+                }
+            } else if (!config.cssIn) {
+                //Now set up the config for require to use the build area, and calculate the
+                //build file locations. Pass along any config info too.
+                baseConfig = {
+                    baseUrl: config.dirBaseUrl,
+                    paths: buildPaths
+                };
+
+                lang.mixin(baseConfig, config);
+                require(baseConfig);
+
+                if (modules) {
+                    modules.forEach(function (module) {
+                        if (module.name) {
+                            module._buildPath = buildContext.nameToUrl(module.name, null);
+                            if (!module.create) {
+                                file.copyFile(module._sourcePath, module._buildPath);
+                            }
+                        }
+                    });
+                }
+            }
+
+            //Run CSS optimizations before doing JS module tracing, to allow
+            //things like text loader plugins loading CSS to get the optimized
+            //CSS.
+            if (config.optimizeCss && config.optimizeCss !== "none" && config.dir) {
+                buildFileContents += optimize.css(config.dir, config);
+            }
+        }).then(function () {
+            var actions = [];
+
+            if (modules) {
+                actions = modules.map(function (module, i) {
+                    return function () {
+                        //Save off buildPath to module index in a hash for quicker
+                        //lookup later.
+                        config._buildPathToModuleIndex[module._buildPath] = i;
+
+                        //Call require to calculate dependencies.
+                        return build.traceDependencies(module, config)
+                            .then(function (layer) {
+                                module.layer = layer;
+                            });
+                    };
+                });
+
+                return prim.serial(actions);
+            }
+        }).then(function () {
+            var actions;
+
+            if (modules) {
+                //Now build up shadow layers for anything that should be excluded.
+                //Do this after tracing dependencies for each module, in case one
+                //of those modules end up being one of the excluded values.
+                actions = modules.map(function (module) {
+                    return function () {
+                        if (module.exclude) {
+                            module.excludeLayers = [];
+                            return prim.serial(module.exclude.map(function (exclude, i) {
+                                return function () {
+                                    //See if it is already in the list of modules.
+                                    //If not trace dependencies for it.
+                                    var found = build.findBuildModule(exclude, modules);
+                                    if (found) {
+                                        module.excludeLayers[i] = found;
+                                    } else {
+                                        return build.traceDependencies({name: exclude}, config)
+                                            .then(function (layer) {
+                                                module.excludeLayers[i] = { layer: layer };
+                                            });
+                                    }
+                                };
+                            }));
+                        }
+                    };
+                });
+
+                return prim.serial(actions);
+            }
+        }).then(function () {
+            if (modules) {
+                return prim.serial(modules.map(function (module) {
+                    return function () {
+                        if (module.exclude) {
+                            //module.exclude is an array of module names. For each one,
+                            //get the nested dependencies for it via a matching entry
+                            //in the module.excludeLayers array.
+                            module.exclude.forEach(function (excludeModule, i) {
+                                var excludeLayer = module.excludeLayers[i].layer,
+                                    map = excludeLayer.buildFileToModule;
+                                excludeLayer.buildFilePaths.forEach(function(filePath){
+                                    build.removeModulePath(map[filePath], filePath, module.layer);
+                                });
+                            });
+                        }
+                        if (module.excludeShallow) {
+                            //module.excludeShallow is an array of module names.
+                            //shallow exclusions are just that module itself, and not
+                            //its nested dependencies.
+                            module.excludeShallow.forEach(function (excludeShallowModule) {
+                                var path = getOwn(module.layer.buildPathMap, excludeShallowModule);
+                                if (path) {
+                                    build.removeModulePath(excludeShallowModule, path, module.layer);
+                                }
+                            });
+                        }
+
+                        //Flatten them and collect the build output for each module.
+                        return build.flattenModule(module, module.layer, config).then(function (builtModule) {
+                            var finalText, baseName;
+                            //Save it to a temp file for now, in case there are other layers that
+                            //contain optimized content that should not be included in later
+                            //layer optimizations. See issue #56.
+                            if (module._buildPath === 'FUNCTION') {
+                                module._buildText = builtModule.text;
+                                module._buildSourceMap = builtModule.sourceMap;
+                            } else {
+                                finalText = builtModule.text;
+                                if (builtModule.sourceMap) {
+                                    baseName = module._buildPath.split('/');
+                                    baseName = baseName.pop();
+                                    finalText += '\n//@ sourceMappingURL=' + baseName + '.map';
+                                    file.saveUtf8File(module._buildPath + '.map', builtModule.sourceMap);
+                                }
+                                file.saveUtf8File(module._buildPath + '-temp', finalText);
+
+                            }
+                            buildFileContents += builtModule.buildText;
+                        });
+                    };
+                }));
+            }
+        }).then(function () {
+            var moduleName;
+            if (modules) {
+                //Now move the build layers to their final position.
+                modules.forEach(function (module) {
+                    var finalPath = module._buildPath;
+                    if (finalPath !== 'FUNCTION') {
+                        if (file.exists(finalPath)) {
+                            file.deleteFile(finalPath);
+                        }
+                        file.renameFile(finalPath + '-temp', finalPath);
+
+                        //And finally, if removeCombined is specified, remove
+                        //any of the files that were used in this layer.
+                        //Be sure not to remove other build layers.
+                        if (config.removeCombined) {
+                            module.layer.buildFilePaths.forEach(function (path) {
+                                if (file.exists(path) && !modules.some(function (mod) {
+                                        return mod._buildPath === path;
+                                    })) {
+                                    file.deleteFile(path);
+                                }
+                            });
+                        }
+                    }
+
+                    //Signal layer is done
+                    if (config.onModuleBundleComplete) {
+                        config.onModuleBundleComplete(module.onCompleteData);
+                    }
+                });
+            }
+
+            //If removeCombined in play, remove any empty directories that
+            //may now exist because of its use
+            if (config.removeCombined && !config.out && config.dir) {
+                file.deleteEmptyDirs(config.dir);
+            }
+
+            //Do other optimizations.
+            if (config.out && !config.cssIn) {
+                //Just need to worry about one JS file.
+                fileName = config.modules[0]._buildPath;
+                if (fileName === 'FUNCTION') {
+                    config.modules[0]._buildText = optimize.js(fileName,
+                                                               config.modules[0]._buildText,
+                                                               null,
+                                                               config);
+                } else {
+                    optimize.jsFile(fileName, null, fileName, config);
+                }
+            } else if (!config.cssIn) {
+                //Normal optimizations across modules.
+
+                //JS optimizations.
+                fileNames = file.getFilteredFileList(config.dir, /\.js$/, true);
+                fileNames.forEach(function (fileName) {
+                    var cfg, override, moduleIndex;
+
+                    //Generate the module name from the config.dir root.
+                    moduleName = fileName.replace(config.dir, '');
+                    //Get rid of the extension
+                    moduleName = moduleName.substring(0, moduleName.length - 3);
+
+                    //If there is an override for a specific layer build module,
+                    //and this file is that module, mix in the override for use
+                    //by optimize.jsFile.
+                    moduleIndex = getOwn(config._buildPathToModuleIndex, fileName);
+                    //Normalize, since getOwn could have returned undefined
+                    moduleIndex = moduleIndex === 0 || moduleIndex > 0 ? moduleIndex : -1;
+
+                    //Try to avoid extra work if the other files do not need to
+                    //be read. Build layers should be processed at the very
+                    //least for optimization.
+                    if (moduleIndex > -1 || !config.skipDirOptimize ||
+                            config.normalizeDirDefines === "all" ||
+                            config.cjsTranslate) {
+                        //Convert the file to transport format, but without a name
+                        //inserted (by passing null for moduleName) since the files are
+                        //standalone, one module per file.
+                        fileContents = file.readFile(fileName);
+
+
+                        //For builds, if wanting cjs translation, do it now, so that
+                        //the individual modules can be loaded cross domain via
+                        //plain script tags.
+                        if (config.cjsTranslate &&
+                            (!config.shim || !lang.hasProp(config.shim, moduleName))) {
+                            fileContents = commonJs.convert(fileName, fileContents);
+                        }
+
+                        if (moduleIndex === -1) {
+                            if (config.onBuildRead) {
+                                fileContents = config.onBuildRead(moduleName,
+                                                                  fileName,
+                                                                  fileContents);
+                            }
+
+                            //Only do transport normalization if this is not a build
+                            //layer (since it was already normalized) and if
+                            //normalizeDirDefines indicated all should be done.
+                            if (config.normalizeDirDefines === "all") {
+                                fileContents = build.toTransport(config.namespace,
+                                                             null,
+                                                             fileName,
+                                                             fileContents);
+                            }
+
+                            if (config.onBuildWrite) {
+                                fileContents = config.onBuildWrite(moduleName,
+                                                                   fileName,
+                                                                   fileContents);
+                            }
+                        }
+
+                        override = moduleIndex > -1 ?
+                                   config.modules[moduleIndex].override : null;
+                        if (override) {
+                            cfg = build.createOverrideConfig(config, override);
+                        } else {
+                            cfg = config;
+                        }
+
+                        if (moduleIndex > -1 || !config.skipDirOptimize) {
+                            optimize.jsFile(fileName, fileContents, fileName, cfg, pluginCollector);
+                        }
+                    }
+                });
+
+                //Normalize all the plugin resources.
+                context = require.s.contexts._;
+
+                for (moduleName in pluginCollector) {
+                    if (hasProp(pluginCollector, moduleName)) {
+                        parentModuleMap = context.makeModuleMap(moduleName);
+                        resources = pluginCollector[moduleName];
+                        for (i = 0; i < resources.length; i++) {
+                            resource = resources[i];
+                            moduleMap = context.makeModuleMap(resource, parentModuleMap);
+                            if (falseProp(context.plugins, moduleMap.prefix)) {
+                                //Set the value in context.plugins so it
+                                //will be evaluated as a full plugin.
+                                context.plugins[moduleMap.prefix] = true;
+
+                                //Do not bother if the plugin is not available.
+                                if (!file.exists(require.toUrl(moduleMap.prefix + '.js'))) {
+                                    continue;
+                                }
+
+                                //Rely on the require in the build environment
+                                //to be synchronous
+                                context.require([moduleMap.prefix]);
+
+                                //Now that the plugin is loaded, redo the moduleMap
+                                //since the plugin will need to normalize part of the path.
+                                moduleMap = context.makeModuleMap(resource, parentModuleMap);
+                            }
+
+                            //Only bother with plugin resources that can be handled
+                            //processed by the plugin, via support of the writeFile
+                            //method.
+                            if (falseProp(pluginProcessed, moduleMap.id)) {
+                                //Only do the work if the plugin was really loaded.
+                                //Using an internal access because the file may
+                                //not really be loaded.
+                                plugin = getOwn(context.defined, moduleMap.prefix);
+                                if (plugin && plugin.writeFile) {
+                                    plugin.writeFile(
+                                        moduleMap.prefix,
+                                        moduleMap.name,
+                                        require,
+                                        makeWriteFile(
+                                            config.namespace
+                                        ),
+                                        context.config
+                                    );
+                                }
+
+                                pluginProcessed[moduleMap.id] = true;
+                            }
+                        }
+
+                    }
+                }
+
+                //console.log('PLUGIN COLLECTOR: ' + JSON.stringify(pluginCollector, null, "  "));
+
+
+                //All module layers are done, write out the build.txt file.
+                file.saveUtf8File(config.dir + "build.txt", buildFileContents);
+            }
+
+            //If just have one CSS file to optimize, do that here.
+            if (config.cssIn) {
+                buildFileContents += optimize.cssFile(config.cssIn, config.out, config).buildText;
+            }
+
+            if (typeof config.out === 'function') {
+                config.out(config.modules[0]._buildText);
+            }
+
+            //Print out what was built into which layers.
+            if (buildFileContents) {
+                logger.info(buildFileContents);
+                return buildFileContents;
+            }
+
+            return '';
+        });
+    };
+
+    /**
+     * Converts command line args like "paths.foo=../some/path"
+     * result.paths = { foo: '../some/path' } where prop = paths,
+     * name = paths.foo and value = ../some/path, so it assumes the
+     * name=value splitting has already happened.
+     */
+    function stringDotToObj(result, name, value) {
+        var parts = name.split('.');
+
+        parts.forEach(function (prop, i) {
+            if (i === parts.length - 1) {
+                result[prop] = value;
+            } else {
+                if (falseProp(result, prop)) {
+                    result[prop] = {};
+                }
+                result = result[prop];
+            }
+
+        });
+    }
+
+    build.objProps = {
+        paths: true,
+        wrap: true,
+        pragmas: true,
+        pragmasOnSave: true,
+        has: true,
+        hasOnSave: true,
+        uglify: true,
+        uglify2: true,
+        closure: true,
+        map: true,
+        throwWhen: true
+    };
+
+    build.hasDotPropMatch = function (prop) {
+        var dotProp,
+            index = prop.indexOf('.');
+
+        if (index !== -1) {
+            dotProp = prop.substring(0, index);
+            return hasProp(build.objProps, dotProp);
+        }
+        return false;
+    };
+
+    /**
+     * Converts an array that has String members of "name=value"
+     * into an object, where the properties on the object are the names in the array.
+     * Also converts the strings "true" and "false" to booleans for the values.
+     * member name/value pairs, and converts some comma-separated lists into
+     * arrays.
+     * @param {Array} ary
+     */
+    build.convertArrayToObject = function (ary) {
+        var result = {}, i, separatorIndex, prop, value,
+            needArray = {
+                "include": true,
+                "exclude": true,
+                "excludeShallow": true,
+                "insertRequire": true
+            };
+
+        for (i = 0; i < ary.length; i++) {
+            separatorIndex = ary[i].indexOf("=");
+            if (separatorIndex === -1) {
+                throw "Malformed name/value pair: [" + ary[i] + "]. Format should be name=value";
+            }
+
+            value = ary[i].substring(separatorIndex + 1, ary[i].length);
+            if (value === "true") {
+                value = true;
+            } else if (value === "false") {
+                value = false;
+            }
+
+            prop = ary[i].substring(0, separatorIndex);
+
+            //Convert to array if necessary
+            if (getOwn(needArray, prop)) {
+                value = value.split(",");
+            }
+
+            if (build.hasDotPropMatch(prop)) {
+                stringDotToObj(result, prop, value);
+            } else {
+                result[prop] = value;
+            }
+        }
+        return result; //Object
+    };
+
+    build.makeAbsPath = function (path, absFilePath) {
+        if (!absFilePath) {
+            return path;
+        }
+
+        //Add abspath if necessary. If path starts with a slash or has a colon,
+        //then already is an abolute path.
+        if (path.indexOf('/') !== 0 && path.indexOf(':') === -1) {
+            path = absFilePath +
+                   (absFilePath.charAt(absFilePath.length - 1) === '/' ? '' : '/') +
+                   path;
+            path = file.normalize(path);
+        }
+        return path.replace(lang.backSlashRegExp, '/');
+    };
+
+    build.makeAbsObject = function (props, obj, absFilePath) {
+        var i, prop;
+        if (obj) {
+            for (i = 0; i < props.length; i++) {
+                prop = props[i];
+                if (hasProp(obj, prop) && typeof obj[prop] === 'string') {
+                    obj[prop] = build.makeAbsPath(obj[prop], absFilePath);
+                }
+            }
+        }
+    };
+
+    /**
+     * For any path in a possible config, make it absolute relative
+     * to the absFilePath passed in.
+     */
+    build.makeAbsConfig = function (config, absFilePath) {
+        var props, prop, i;
+
+        props = ["appDir", "dir", "baseUrl"];
+        for (i = 0; i < props.length; i++) {
+            prop = props[i];
+
+            if (getOwn(config, prop)) {
+                //Add abspath if necessary, make sure these paths end in
+                //slashes
+                if (prop === "baseUrl") {
+                    config.originalBaseUrl = config.baseUrl;
+                    if (config.appDir) {
+                        //If baseUrl with an appDir, the baseUrl is relative to
+                        //the appDir, *not* the absFilePath. appDir and dir are
+                        //made absolute before baseUrl, so this will work.
+                        config.baseUrl = build.makeAbsPath(config.originalBaseUrl, config.appDir);
+                    } else {
+                        //The dir output baseUrl is same as regular baseUrl, both
+                        //relative to the absFilePath.
+                        config.baseUrl = build.makeAbsPath(config[prop], absFilePath);
+                    }
+                } else {
+                    config[prop] = build.makeAbsPath(config[prop], absFilePath);
+                }
+
+                config[prop] = endsWithSlash(config[prop]);
+            }
+        }
+
+        build.makeAbsObject(["out", "cssIn"], config, absFilePath);
+        build.makeAbsObject(["startFile", "endFile"], config.wrap, absFilePath);
+    };
+
+    /**
+     * Creates a relative path to targetPath from refPath.
+     * Only deals with file paths, not folders. If folders,
+     * make sure paths end in a trailing '/'.
+     */
+    build.makeRelativeFilePath = function (refPath, targetPath) {
+        var i, dotLength, finalParts, length,
+            refParts = refPath.split('/'),
+            targetParts = targetPath.split('/'),
+            //Pull off file name
+            targetName = targetParts.pop(),
+            dotParts = [];
+
+        //Also pop off the ref file name to make the matches against
+        //targetParts equivalent.
+        refParts.pop();
+
+        length = refParts.length;
+
+        for (i = 0; i < length; i += 1) {
+            if (refParts[i] !== targetParts[i]) {
+                break;
+            }
+        }
+
+        //Now i is the index in which they diverge.
+        finalParts = targetParts.slice(i);
+
+        dotLength = length - i;
+        for (i = 0; i > -1 && i < dotLength; i += 1) {
+            dotParts.push('..');
+        }
+
+        return dotParts.join('/') + (dotParts.length ? '/' : '') +
+               finalParts.join('/') + (finalParts.length ? '/' : '') +
+               targetName;
+    };
+
+    build.nestedMix = {
+        paths: true,
+        has: true,
+        hasOnSave: true,
+        pragmas: true,
+        pragmasOnSave: true
+    };
+
+    /**
+     * Mixes additional source config into target config, and merges some
+     * nested config, like paths, correctly.
+     */
+    function mixConfig(target, source) {
+        var prop, value;
+
+        for (prop in source) {
+            if (hasProp(source, prop)) {
+                //If the value of the property is a plain object, then
+                //allow a one-level-deep mixing of it.
+                value = source[prop];
+                if (typeof value === 'object' && value &&
+                        !lang.isArray(value) && !lang.isFunction(value) &&
+                        !lang.isRegExp(value)) {
+                    target[prop] = lang.mixin({}, target[prop], value, true);
+                } else {
+                    target[prop] = value;
+                }
+            }
+        }
+
+        //Set up log level since it can affect if errors are thrown
+        //or caught and passed to errbacks while doing config setup.
+        if (lang.hasProp(target, 'logLevel')) {
+            logger.logLevel(target.logLevel);
+        }
+    }
+
+    /**
+     * Converts a wrap.startFile or endFile to be start/end as a string.
+     * the startFile/endFile values can be arrays.
+     */
+    function flattenWrapFile(wrap, keyName, absFilePath) {
+        var keyFileName = keyName + 'File';
+
+        if (typeof wrap[keyName] !== 'string' && wrap[keyFileName]) {
+            wrap[keyName] = '';
+            if (typeof wrap[keyFileName] === 'string') {
+                wrap[keyFileName] = [wrap[keyFileName]];
+            }
+            wrap[keyFileName].forEach(function (fileName) {
+                wrap[keyName] += (wrap[keyName] ? '\n' : '') +
+                    file.readFile(build.makeAbsPath(fileName, absFilePath));
+            });
+        } else if (wrap[keyName] === null ||  wrap[keyName] === undefined) {
+            //Allow missing one, just set to empty string.
+            wrap[keyName] = '';
+        } else if (typeof wrap[keyName] !== 'string') {
+            throw new Error('wrap.' + keyName + ' or wrap.' + keyFileName + ' malformed');
+        }
+    }
+
+    /**
+     * Creates a config object for an optimization build.
+     * It will also read the build profile if it is available, to create
+     * the configuration.
+     *
+     * @param {Object} cfg config options that take priority
+     * over defaults and ones in the build file. These options could
+     * be from a command line, for instance.
+     *
+     * @param {Object} the created config object.
+     */
+    build.createConfig = function (cfg) {
+        /*jslint evil: true */
+        var config = {}, buildFileContents, buildFileConfig, mainConfig,
+            mainConfigFile, mainConfigPath, buildFile, absFilePath;
+
+        //Make sure all paths are relative to current directory.
+        absFilePath = file.absPath('.');
+        build.makeAbsConfig(cfg, absFilePath);
+        build.makeAbsConfig(buildBaseConfig, absFilePath);
+
+        lang.mixin(config, buildBaseConfig);
+        lang.mixin(config, cfg, true);
+
+        //Set up log level early since it can affect if errors are thrown
+        //or caught and passed to errbacks, even while constructing config.
+        if (lang.hasProp(config, 'logLevel')) {
+            logger.logLevel(config.logLevel);
+        }
+
+        if (config.buildFile) {
+            //A build file exists, load it to get more config.
+            buildFile = file.absPath(config.buildFile);
+
+            //Find the build file, and make sure it exists, if this is a build
+            //that has a build profile, and not just command line args with an in=path
+            if (!file.exists(buildFile)) {
+                throw new Error("ERROR: build file does not exist: " + buildFile);
+            }
+
+            absFilePath = config.baseUrl = file.absPath(file.parent(buildFile));
+
+            //Load build file options.
+            buildFileContents = file.readFile(buildFile);
+            try {
+                buildFileConfig = eval("(" + buildFileContents + ")");
+                build.makeAbsConfig(buildFileConfig, absFilePath);
+
+                //Mix in the config now so that items in mainConfigFile can
+                //be resolved relative to them if necessary, like if appDir
+                //is set here, but the baseUrl is in mainConfigFile. Will
+                //re-mix in the same build config later after mainConfigFile
+                //is processed, since build config should take priority.
+                mixConfig(config, buildFileConfig);
+            } catch (e) {
+                throw new Error("Build file " + buildFile + " is malformed: " + e);
+            }
+        }
+
+        mainConfigFile = config.mainConfigFile || (buildFileConfig && buildFileConfig.mainConfigFile);
+        if (mainConfigFile) {
+            mainConfigFile = build.makeAbsPath(mainConfigFile, absFilePath);
+            if (!file.exists(mainConfigFile)) {
+                throw new Error(mainConfigFile + ' does not exist.');
+            }
+            try {
+                mainConfig = parse.findConfig(file.readFile(mainConfigFile)).config;
+            } catch (configError) {
+                throw new Error('The config in mainConfigFile ' +
+                        mainConfigFile +
+                        ' cannot be used because it cannot be evaluated' +
+                        ' correctly while running in the optimizer. Try only' +
+                        ' using a config that is also valid JSON, or do not use' +
+                        ' mainConfigFile and instead copy the config values needed' +
+                        ' into a build file or command line arguments given to the optimizer.');
+            }
+            if (mainConfig) {
+                mainConfigPath = mainConfigFile.substring(0, mainConfigFile.lastIndexOf('/'));
+
+                //Add in some existing config, like appDir, since they can be
+                //used inside the mainConfigFile -- paths and baseUrl are
+                //relative to them.
+                if (config.appDir && !mainConfig.appDir) {
+                    mainConfig.appDir = config.appDir;
+                }
+
+                //If no baseUrl, then use the directory holding the main config.
+                if (!mainConfig.baseUrl) {
+                    mainConfig.baseUrl = mainConfigPath;
+                }
+
+                build.makeAbsConfig(mainConfig, mainConfigPath);
+                mixConfig(config, mainConfig);
+            }
+        }
+
+        //Mix in build file config, but only after mainConfig has been mixed in.
+        if (buildFileConfig) {
+            mixConfig(config, buildFileConfig);
+        }
+
+        //Re-apply the override config values. Command line
+        //args should take precedence over build file values.
+        mixConfig(config, cfg);
+
+        //Fix paths to full paths so that they can be adjusted consistently
+        //lately to be in the output area.
+        lang.eachProp(config.paths, function (value, prop) {
+            if (lang.isArray(value)) {
+                throw new Error('paths fallback not supported in optimizer. ' +
+                                'Please provide a build config path override ' +
+                                'for ' + prop);
+            }
+            config.paths[prop] = build.makeAbsPath(value, config.baseUrl);
+        });
+
+        //Set final output dir
+        if (hasProp(config, "baseUrl")) {
+            if (config.appDir) {
+                config.dirBaseUrl = build.makeAbsPath(config.originalBaseUrl, config.dir);
+            } else {
+                config.dirBaseUrl = config.dir || config.baseUrl;
+            }
+            //Make sure dirBaseUrl ends in a slash, since it is
+            //concatenated with other strings.
+            config.dirBaseUrl = endsWithSlash(config.dirBaseUrl);
+        }
+
+        //Check for errors in config
+        if (config.main) {
+            throw new Error('"main" passed as an option, but the ' +
+                            'supported option is called "name".');
+        }
+        if (config.out && !config.name && !config.modules && !config.include &&
+                !config.cssIn) {
+            throw new Error('Missing either a "name", "include" or "modules" ' +
+                            'option');
+        }
+        if (config.cssIn) {
+            if (config.dir || config.appDir) {
+                throw new Error('cssIn is only for the output of single file ' +
+                    'CSS optimizations and is not compatible with "dir" or "appDir" configuration.');
+            }
+            if (!config.out) {
+                throw new Error('"out" option missing.');
+            }
+        }
+        if (!config.cssIn && !config.baseUrl) {
+            //Just use the current directory as the baseUrl
+            config.baseUrl = './';
+        }
+        if (!config.out && !config.dir) {
+            throw new Error('Missing either an "out" or "dir" config value. ' +
+                            'If using "appDir" for a full project optimization, ' +
+                            'use "dir". If you want to optimize to one file, ' +
+                            'use "out".');
+        }
+        if (config.appDir && config.out) {
+            throw new Error('"appDir" is not compatible with "out". Use "dir" ' +
+                            'instead. appDir is used to copy whole projects, ' +
+                            'where "out" with "baseUrl" is used to just ' +
+                            'optimize to one file.');
+        }
+        if (config.out && config.dir) {
+            throw new Error('The "out" and "dir" options are incompatible.' +
+                            ' Use "out" if you are targeting a single file for' +
+                            ' for optimization, and "dir" if you want the appDir' +
+                            ' or baseUrl directories optimized.');
+        }
+        if (config.dir && config.appDir && config.dir === config.appDir) {
+            throw new Error('"dir" and "appDir" set to the same directory.' +
+                            ' This could result in the deletion of appDir.' +
+                            ' Stopping.');
+        }
+
+        if (config.insertRequire && !lang.isArray(config.insertRequire)) {
+            throw new Error('insertRequire should be a list of module IDs' +
+                            ' to insert in to a require([]) call.');
+        }
+
+        if (config.generateSourceMaps) {
+            if (config.preserveLicenseComments && config.optimize !== 'none') {
+                throw new Error('Cannot use preserveLicenseComments and ' +
+                    'generateSourceMaps together. Either explcitly set ' +
+                    'preserveLicenseComments to false (default is true) or ' +
+                    'turn off generateSourceMaps. If you want source maps with ' +
+                    'license comments, see: ' +
+                    'http://requirejs.org/docs/errors.html#sourcemapcomments');
+            } else if (config.optimize !== 'none' &&
+                       config.optimize !== 'closure' &&
+                       config.optimize !== 'uglify2') {
+                //Allow optimize: none to pass, since it is useful when toggling
+                //minification on and off to debug something, and it implicitly
+                //works, since it does not need a source map.
+                throw new Error('optimize: "' + config.optimize +
+                    '" does not support generateSourceMaps.');
+            }
+        }
+
+        if ((config.name || config.include) && !config.modules) {
+            //Just need to build one file, but may be part of a whole appDir/
+            //baseUrl copy, but specified on the command line, so cannot do
+            //the modules array setup. So create a modules section in that
+            //case.
+            config.modules = [
+                {
+                    name: config.name,
+                    out: config.out,
+                    create: config.create,
+                    include: config.include,
+                    exclude: config.exclude,
+                    excludeShallow: config.excludeShallow,
+                    insertRequire: config.insertRequire,
+                    stubModules: config.stubModules
+                }
+            ];
+            delete config.stubModules;
+        } else if (config.modules && config.out) {
+            throw new Error('If the "modules" option is used, then there ' +
+                            'should be a "dir" option set and "out" should ' +
+                            'not be used since "out" is only for single file ' +
+                            'optimization output.');
+        } else if (config.modules && config.name) {
+            throw new Error('"name" and "modules" options are incompatible. ' +
+                            'Either use "name" if doing a single file ' +
+                            'optimization, or "modules" if you want to target ' +
+                            'more than one file for optimization.');
+        }
+
+        if (config.out && !config.cssIn) {
+            //Just one file to optimize.
+
+            //Does not have a build file, so set up some defaults.
+            //Optimizing CSS should not be allowed, unless explicitly
+            //asked for on command line. In that case the only task is
+            //to optimize a CSS file.
+            if (!cfg.optimizeCss) {
+                config.optimizeCss = "none";
+            }
+        }
+
+        //Normalize cssPrefix
+        if (config.cssPrefix) {
+            //Make sure cssPrefix ends in a slash
+            config.cssPrefix = endsWithSlash(config.cssPrefix);
+        } else {
+            config.cssPrefix = '';
+        }
+
+        //Cycle through modules and combine any local stubModules with
+        //global values.
+        if (config.modules && config.modules.length) {
+            config.modules.forEach(function (mod) {
+                if (config.stubModules) {
+                    mod.stubModules = config.stubModules.concat(mod.stubModules || []);
+                }
+
+                //Create a hash lookup for the stubModules config to make lookup
+                //cheaper later.
+                if (mod.stubModules) {
+                    mod.stubModules._byName = {};
+                    mod.stubModules.forEach(function (id) {
+                        mod.stubModules._byName[id] = true;
+                    });
+                }
+            });
+        }
+
+        //Get any wrap text.
+        try {
+            if (config.wrap) {
+                if (config.wrap === true) {
+                    //Use default values.
+                    config.wrap = {
+                        start: '(function () {',
+                        end: '}());'
+                    };
+                } else {
+                    flattenWrapFile(config.wrap, 'start', absFilePath);
+                    flattenWrapFile(config.wrap, 'end', absFilePath);
+                }
+            }
+        } catch (wrapError) {
+            throw new Error('Malformed wrap config: ' + wrapError.toString());
+        }
+
+        //Do final input verification
+        if (config.context) {
+            throw new Error('The build argument "context" is not supported' +
+                            ' in a build. It should only be used in web' +
+                            ' pages.');
+        }
+
+        //Set up normalizeDirDefines. If not explicitly set, if optimize "none",
+        //set to "skip" otherwise set to "all".
+        if (!hasProp(config, 'normalizeDirDefines')) {
+            if (config.optimize === 'none' || config.skipDirOptimize) {
+                config.normalizeDirDefines = 'skip';
+            } else {
+                config.normalizeDirDefines = 'all';
+            }
+        }
+
+        //Set file.fileExclusionRegExp if desired
+        if (hasProp(config, 'fileExclusionRegExp')) {
+            if (typeof config.fileExclusionRegExp === "string") {
+                file.exclusionRegExp = new RegExp(config.fileExclusionRegExp);
+            } else {
+                file.exclusionRegExp = config.fileExclusionRegExp;
+            }
+        } else if (hasProp(config, 'dirExclusionRegExp')) {
+            //Set file.dirExclusionRegExp if desired, this is the old
+            //name for fileExclusionRegExp before 1.0.2. Support for backwards
+            //compatibility
+            file.exclusionRegExp = config.dirExclusionRegExp;
+        }
+
+        //Remove things that may cause problems in the build.
+        delete config.jQuery;
+        delete config.enforceDefine;
+        delete config.urlArgs;
+
+        return config;
+    };
+
+    /**
+     * finds the module being built/optimized with the given moduleName,
+     * or returns null.
+     * @param {String} moduleName
+     * @param {Array} modules
+     * @returns {Object} the module object from the build profile, or null.
+     */
+    build.findBuildModule = function (moduleName, modules) {
+        var i, module;
+        for (i = 0; i < modules.length; i++) {
+            module = modules[i];
+            if (module.name === moduleName) {
+                return module;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Removes a module name and path from a layer, if it is supposed to be
+     * excluded from the layer.
+     * @param {String} moduleName the name of the module
+     * @param {String} path the file path for the module
+     * @param {Object} layer the layer to remove the module/path from
+     */
+    build.removeModulePath = function (module, path, layer) {
+        var index = layer.buildFilePaths.indexOf(path);
+        if (index !== -1) {
+            layer.buildFilePaths.splice(index, 1);
+        }
+    };
+
+    /**
+     * Uses the module build config object to trace the dependencies for the
+     * given module.
+     *
+     * @param {Object} module the module object from the build config info.
+     * @param {Object} the build config object.
+     *
+     * @returns {Object} layer information about what paths and modules should
+     * be in the flattened module.
+     */
+    build.traceDependencies = function (module, config) {
+        var include, override, layer, context, baseConfig, oldContext,
+            rawTextByIds,
+            syncChecks = {
+                rhino: true,
+                node: true,
+                xpconnect: true
+            },
+            deferred = prim();
+
+        //Reset some state set up in requirePatch.js, and clean up require's
+        //current context.
+        oldContext = require._buildReset();
+
+        //Grab the reset layer and context after the reset, but keep the
+        //old config to reuse in the new context.
+        baseConfig = oldContext.config;
+        layer = require._layer;
+        context = layer.context;
+
+        //Put back basic config, use a fresh object for it.
+        //WARNING: probably not robust for paths and packages/packagePaths,
+        //since those property's objects can be modified. But for basic
+        //config clone it works out.
+        require(lang.mixin({}, baseConfig, true));
+
+        logger.trace("\nTracing dependencies for: " + (module.name || module.out));
+        include = module.name && !module.create ? [module.name] : [];
+        if (module.include) {
+            include = include.concat(module.include);
+        }
+
+        //If there are overrides to basic config, set that up now.;
+        if (module.override) {
+            override = lang.mixin({}, baseConfig, true);
+            lang.mixin(override, module.override, true);
+            require(override);
+        }
+
+        //Now, populate the rawText cache with any values explicitly passed in
+        //via config.
+        rawTextByIds = require.s.contexts._.config.rawText;
+        if (rawTextByIds) {
+            lang.eachProp(rawTextByIds, function (contents, id) {
+                var url = require.toUrl(id) + '.js';
+                require._cachedRawText[url] = contents;
+            });
+        }
+
+        //Figure out module layer dependencies by calling require to do the work.
+        //Configure the callbacks to be called.
+        deferred.resolve.__requireJsBuild = true;
+        deferred.reject.__requireJsBuild = true;
+        require(include, deferred.resolve, deferred.reject);
+
+        //If a sync build environment, check for errors here, instead of
+        //in the then callback below, since some errors, like two IDs pointed
+        //to same URL but only one anon ID will leave the loader in an
+        //unresolved state since a setTimeout cannot be used to check for
+        //timeout.
+        if (syncChecks[env.get()]) {
+            try {
+                build.checkForErrors(context);
+            } catch (e) {
+                deferred.reject(e);
+            }
+        }
+
+        return deferred.promise.then(function () {
+            //Reset config
+            if (module.override) {
+                require(baseConfig);
+            }
+
+            build.checkForErrors(context);
+
+            return layer;
+        });
+    };
+
+    build.checkForErrors = function (context) {
+        //Check to see if it all loaded. If not, then throw, and give
+        //a message on what is left.
+        var id, prop, mod, errUrl, idParts, pluginId,
+            errMessage = '',
+            failedPluginMap = {},
+            failedPluginIds = [],
+            errIds = [],
+            errUrlMap = {},
+            errUrlConflicts = {},
+            hasErrUrl = false,
+            registry = context.registry;
+
+        for (id in registry) {
+            if (hasProp(registry, id) && id.indexOf('_@r') !== 0) {
+                mod = getOwn(registry, id);
+                if (id.indexOf('_unnormalized') === -1 && mod && mod.enabled) {
+                    errIds.push(id);
+                    errUrl = mod.map.url;
+
+                    if (errUrlMap[errUrl]) {
+                        hasErrUrl = true;
+                        //This error module has the same URL as another
+                        //error module, could be misconfiguration.
+                        if (!errUrlConflicts[errUrl]) {
+                            errUrlConflicts[errUrl] = [];
+                            //Store the original module that had the same URL.
+                            errUrlConflicts[errUrl].push(errUrlMap[errUrl]);
+                        }
+                        errUrlConflicts[errUrl].push(id);
+                    } else {
+                        errUrlMap[errUrl] = id;
+                    }
+                }
+
+                //Look for plugins that did not call load()
+                idParts = id.split('!');
+                pluginId = idParts[0];
+                if (idParts.length > 1 && falseProp(failedPluginMap, pluginId)) {
+                    failedPluginIds.push(pluginId);
+                    failedPluginMap[pluginId] = true;
+                }
+            }
+        }
+
+        if (errIds.length || failedPluginIds.length) {
+            if (failedPluginIds.length) {
+                errMessage += 'Loader plugin' +
+                    (failedPluginIds.length === 1 ? '' : 's') +
+                    ' did not call ' +
+                    'the load callback in the build: ' +
+                    failedPluginIds.join(', ') + '\n';
+            }
+            errMessage += 'Module loading did not complete for: ' + errIds.join(', ');
+
+            if (hasErrUrl) {
+                errMessage += '\nThe following modules share the same URL. This ' +
+                              'could be a misconfiguration if that URL only has ' +
+                              'one anonymous module in it:';
+                for (prop in errUrlConflicts) {
+                    if (hasProp(errUrlConflicts, prop)) {
+                        errMessage += '\n' + prop + ': ' +
+                                      errUrlConflicts[prop].join(', ');
+                    }
+                }
+            }
+            throw new Error(errMessage);
+        }
+
+    };
+
+    build.createOverrideConfig = function (config, override) {
+        var cfg = {};
+
+        lang.mixin(cfg, config, true);
+        lang.eachProp(override, function (value, prop) {
+            if (hasProp(build.objProps, prop)) {
+                //An object property, merge keys. Start a new object
+                //so that source object in config does not get modified.
+                cfg[prop] = {};
+                lang.mixin(cfg[prop], config[prop], true);
+                lang.mixin(cfg[prop], override[prop], true);
+            } else {
+                cfg[prop] = override[prop];
+            }
+        });
+        return cfg;
+    };
+
+    /**
+     * Uses the module build config object to create an flattened version
+     * of the module, with deep dependencies included.
+     *
+     * @param {Object} module the module object from the build config info.
+     *
+     * @param {Object} layer the layer object returned from build.traceDependencies.
+     *
+     * @param {Object} the build config object.
+     *
+     * @returns {Object} with two properties: "text", the text of the flattened
+     * module, and "buildText", a string of text representing which files were
+     * included in the flattened module text.
+     */
+    build.flattenModule = function (module, layer, config) {
+        var fileContents, sourceMapGenerator,
+            sourceMapBase,
+            buildFileContents = '';
+
+        return prim().start(function () {
+            var reqIndex, currContents,
+                moduleName, shim, packageConfig, nonPackageName,
+                parts, builder, writeApi,
+                namespace, namespaceWithDot, stubModulesByName,
+                context = layer.context,
+                onLayerEnds = [],
+                onLayerEndAdded = {};
+
+            //Use override settings, particularly for pragmas
+            //Do this before the var readings since it reads config values.
+            if (module.override) {
+                config = build.createOverrideConfig(config, module.override);
+            }
+
+            namespace = config.namespace || '';
+            namespaceWithDot = namespace ? namespace + '.' : '';
+            stubModulesByName = (module.stubModules && module.stubModules._byName) || {};
+
+            //Start build output for the module.
+            module.onCompleteData = {
+                name: module.name,
+                path: (config.dir ? module._buildPath.replace(config.dir, "") : module._buildPath),
+                included: []
+            };
+
+            buildFileContents += "\n" +
+                                  module.onCompleteData.path +
+                                 "\n----------------\n";
+
+            //If there was an existing file with require in it, hoist to the top.
+            if (layer.existingRequireUrl) {
+                reqIndex = layer.buildFilePaths.indexOf(layer.existingRequireUrl);
+                if (reqIndex !== -1) {
+                    layer.buildFilePaths.splice(reqIndex, 1);
+                    layer.buildFilePaths.unshift(layer.existingRequireUrl);
+                }
+            }
+
+            if (config.generateSourceMaps) {
+                sourceMapBase = config.dir || config.baseUrl;
+                sourceMapGenerator = new SourceMapGenerator.SourceMapGenerator({
+                    file: module._buildPath.replace(sourceMapBase, '')
+                });
+            }
+
+            //Write the built module to disk, and build up the build output.
+            fileContents = "";
+            return prim.serial(layer.buildFilePaths.map(function (path) {
+                return function () {
+                    var lineCount,
+                        singleContents = '';
+
+                    moduleName = layer.buildFileToModule[path];
+                    //If the moduleName is for a package main, then update it to the
+                    //real main value.
+                    packageConfig = layer.context.config.pkgs &&
+                                    getOwn(layer.context.config.pkgs, moduleName);
+                    if (packageConfig) {
+                        nonPackageName = moduleName;
+                        moduleName += '/' + packageConfig.main;
+                    }
+
+                    return prim().start(function () {
+                        //Figure out if the module is a result of a build plugin, and if so,
+                        //then delegate to that plugin.
+                        parts = context.makeModuleMap(moduleName);
+                        builder = parts.prefix && getOwn(context.defined, parts.prefix);
+                        if (builder) {
+                            if (builder.onLayerEnd && falseProp(onLayerEndAdded, parts.prefix)) {
+                                onLayerEnds.push(builder);
+                                onLayerEndAdded[parts.prefix] = true;
+                            }
+
+                            if (builder.write) {
+                                writeApi = function (input) {
+                                    singleContents += "\n" + addSemiColon(input);
+                                    if (config.onBuildWrite) {
+                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);
+                                    }
+                                };
+                                writeApi.asModule = function (moduleName, input) {
+                                    singleContents += "\n" +
+                                        addSemiColon(build.toTransport(namespace, moduleName, path, input, layer, {
+                                            useSourceUrl: layer.context.config.useSourceUrl
+                                        }));
+                                    if (config.onBuildWrite) {
+                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);
+                                    }
+                                };
+                                builder.write(parts.prefix, parts.name, writeApi);
+                            }
+                            return;
+                        } else {
+                            return prim().start(function () {
+                                if (hasProp(stubModulesByName, moduleName)) {
+                                    //Just want to insert a simple module definition instead
+                                    //of the source module. Useful for plugins that inline
+                                    //all their resources.
+                                    if (hasProp(layer.context.plugins, moduleName)) {
+                                        //Slightly different content for plugins, to indicate
+                                        //that dynamic loading will not work.
+                                        return 'define({load: function(id){throw new Error("Dynamic load not allowed: " + id);}});';
+                                    } else {
+                                        return 'define({});';
+                                    }
+                                } else {
+                                    return require._cacheReadAsync(path);
+                                }
+                            }).then(function (text) {
+                                var hasPackageName;
+
+                                currContents = text;
+
+                                if (config.cjsTranslate &&
+                                    (!config.shim || !lang.hasProp(config.shim, moduleName))) {
+                                    currContents = commonJs.convert(path, currContents);
+                                }
+
+                                if (config.onBuildRead) {
+                                    currContents = config.onBuildRead(moduleName, path, currContents);
+                                }
+
+                                if (packageConfig) {
+                                    hasPackageName = (nonPackageName === parse.getNamedDefine(currContents));
+                                }
+
+                                if (namespace) {
+                                    currContents = pragma.namespace(currContents, namespace);
+                                }
+
+                                currContents = build.toTransport(namespace, moduleName, path, currContents, layer, {
+                                    useSourceUrl: config.useSourceUrl
+                                });
+
+                                if (packageConfig && !hasPackageName) {
+                                    currContents = addSemiColon(currContents) + '\n';
+                                    currContents += namespaceWithDot + "define('" +
+                                                    packageConfig.name + "', ['" + moduleName +
+                                                    "'], function (main) { return main; });\n";
+                                }
+
+                                if (config.onBuildWrite) {
+                                    currContents = config.onBuildWrite(moduleName, path, currContents);
+                                }
+
+                                //Semicolon is for files that are not well formed when
+                                //concatenated with other content.
+                                singleContents += "\n" + addSemiColon(currContents);
+                            });
+                        }
+                    }).then(function () {
+                        var sourceMapPath, sourceMapLineNumber,
+                            shortPath = path.replace(config.dir, "");
+
+                        module.onCompleteData.included.push(shortPath);
+                        buildFileContents += shortPath + "\n";
+
+                        //Some files may not have declared a require module, and if so,
+                        //put in a placeholder call so the require does not try to load them
+                        //after the module is processed.
+                        //If we have a name, but no defined module, then add in the placeholder.
+                        if (moduleName && falseProp(layer.modulesWithNames, moduleName) && !config.skipModuleInsertion) {
+                            shim = config.shim && (getOwn(config.shim, moduleName) || (packageConfig && getOwn(config.shim, nonPackageName)));
+                            if (shim) {
+                                singleContents += '\n' + namespaceWithDot + 'define("' + moduleName + '", ' +
+                                                 (shim.deps && shim.deps.length ?
+                                                        build.makeJsArrayString(shim.deps) + ', ' : '') +
+                                                 (shim.exportsFn ? shim.exportsFn() : 'function(){}') +
+                                                 ');\n';
+                            } else {
+                                singleContents += '\n' + namespaceWithDot + 'define("' + moduleName + '", function(){});\n';
+                            }
+                        }
+
+                        //Add to the source map
+                        if (sourceMapGenerator) {
+                            sourceMapPath = build.makeRelativeFilePath(module._buildPath, path);
+                            sourceMapLineNumber = fileContents.split('\n').length - 1;
+                            lineCount = singleContents.split('\n').length;
+                            for (var i = 1; i <= lineCount; i += 1) {
+                                sourceMapGenerator.addMapping({
+                                    generated: {
+                                        line: sourceMapLineNumber + i,
+                                        column: 0
+                                    },
+                                    original: {
+                                        line: i,
+                                        column: 0
+                                    },
+                                    source: sourceMapPath
+                                });
+                            }
+
+                            //Store the content of the original in the source
+                            //map since other transforms later like minification
+                            //can mess up translating back to the original
+                            //source
+                            sourceMapGenerator.setSourceContent(sourceMapPath, singleContents);
+                        }
+
+                        //Add the file to the final contents
+                        fileContents += singleContents;
+                    });
+                };
+            })).then(function () {
+                if (onLayerEnds.length) {
+                    onLayerEnds.forEach(function (builder) {
+                        var path;
+                        if (typeof module.out === 'string') {
+                            path = module.out;
+                        } else if (typeof module._buildPath === 'string') {
+                            path = module._buildPath;
+                        }
+                        builder.onLayerEnd(function (input) {
+                            fileContents += "\n" + addSemiColon(input);
+                        }, {
+                            name: module.name,
+                            path: path
+                        });
+                    });
+                }
+
+                if (module.create) {
+                    //The ID is for a created layer. Write out
+                    //a module definition for it in case the
+                    //built file is used with enforceDefine
+                    //(#432)
+                    fileContents += '\n' + namespaceWithDot + 'define("' + module.name + '", function(){});\n';
+                }
+
+                //Add a require at the end to kick start module execution, if that
+                //was desired. Usually this is only specified when using small shim
+                //loaders like almond.
+                if (module.insertRequire) {
+                    fileContents += '\n' + namespaceWithDot + 'require(["' + module.insertRequire.join('", "') + '"]);\n';
+                }
+            });
+        }).then(function () {
+            return {
+                text: config.wrap ?
+                        config.wrap.start + fileContents + config.wrap.end :
+                        fileContents,
+                buildText: buildFileContents,
+                sourceMap: sourceMapGenerator ?
+                              JSON.stringify(sourceMapGenerator.toJSON(), null, '  ') :
+                              undefined
+            };
+        });
+    };
+
+    //Converts an JS array of strings to a string representation.
+    //Not using JSON.stringify() for Rhino's sake.
+    build.makeJsArrayString = function (ary) {
+        return '["' + ary.map(function (item) {
+            //Escape any double quotes, backslashes
+            return lang.jsEscape(item);
+        }).join('","') + '"]';
+    };
+
+    build.toTransport = function (namespace, moduleName, path, contents, layer, options) {
+        var baseUrl = layer && layer.context.config.baseUrl;
+
+        function onFound(info) {
+            //Only mark this module as having a name if not a named module,
+            //or if a named module and the name matches expectations.
+            if (layer && (info.needsId || info.foundId === moduleName)) {
+                layer.modulesWithNames[moduleName] = true;
+            }
+        }
+
+        //Convert path to be a local one to the baseUrl, useful for
+        //useSourceUrl.
+        if (baseUrl) {
+            path = path.replace(baseUrl, '');
+        }
+
+        return transform.toTransport(namespace, moduleName, path, contents, onFound, options);
+    };
+
+    return build;
+});
+
+    }
+
+
+    /**
+     * Sets the default baseUrl for requirejs to be directory of top level
+     * script.
+     */
+    function setBaseUrl(fileName) {
+        //Use the file name's directory as the baseUrl if available.
+        dir = fileName.replace(/\\/g, '/');
+        if (dir.indexOf('/') !== -1) {
+            dir = dir.split('/');
+            dir.pop();
+            dir = dir.join('/');
+            exec("require({baseUrl: '" + dir + "'});");
+        }
+    }
+
+    function createRjsApi() {
+        //Create a method that will run the optimzer given an object
+        //config.
+        requirejs.optimize = function (config, callback, errback) {
+            if (!loadedOptimizedLib) {
+                loadLib();
+                loadedOptimizedLib = true;
+            }
+
+            //Create the function that will be called once build modules
+            //have been loaded.
+            var runBuild = function (build, logger, quit) {
+                //Make sure config has a log level, and if not,
+                //make it "silent" by default.
+                config.logLevel = config.hasOwnProperty('logLevel') ?
+                                  config.logLevel : logger.SILENT;
+
+                //Reset build internals first in case this is part
+                //of a long-running server process that could have
+                //exceptioned out in a bad state. It is only defined
+                //after the first call though.
+                if (requirejs._buildReset) {
+                    requirejs._buildReset();
+                    requirejs._cacheReset();
+                }
+
+                function done(result) {
+                    //And clean up, in case something else triggers
+                    //a build in another pathway.
+                    if (requirejs._buildReset) {
+                        requirejs._buildReset();
+                        requirejs._cacheReset();
+                    }
+
+                    // Ensure errors get propagated to the errback
+                    if (result instanceof Error) {
+                      throw result;
+                    }
+
+                    return result;
+                }
+
+                errback = errback || function (err) {
+                    // Using console here since logger may have
+                    // turned off error logging. Since quit is
+                    // called want to be sure a message is printed.
+                    console.log(err);
+                    quit(1);
+                };
+
+                build(config).then(done, done).then(callback, errback);
+            };
+
+            requirejs({
+                context: 'build'
+            }, ['build', 'logger', 'env!env/quit'], runBuild);
+        };
+
+        requirejs.tools = {
+            useLib: function (contextName, callback) {
+                if (!callback) {
+                    callback = contextName;
+                    contextName = 'uselib';
+                }
+
+                if (!useLibLoaded[contextName]) {
+                    loadLib();
+                    useLibLoaded[contextName] = true;
+                }
+
+                var req = requirejs({
+                    context: contextName
+                });
+
+                req(['build'], function () {
+                    callback(req);
+                });
+            }
+        };
+
+        requirejs.define = define;
+    }
+
+    //If in Node, and included via a require('requirejs'), just export and
+    //THROW IT ON THE GROUND!
+    if (env === 'node' && reqMain !== module) {
+        setBaseUrl(path.resolve(reqMain ? reqMain.filename : '.'));
+
+        createRjsApi();
+
+        module.exports = requirejs;
+        return;
+    } else if (env === 'browser') {
+        //Only option is to use the API.
+        setBaseUrl(location.href);
+        createRjsApi();
+        return;
+    } else if ((env === 'rhino' || env === 'xpconnect') &&
+            //User sets up requirejsAsLib variable to indicate it is loaded
+            //via load() to be used as a library.
+            typeof requirejsAsLib !== 'undefined' && requirejsAsLib) {
+        //This script is loaded via rhino's load() method, expose the
+        //API and get out.
+        setBaseUrl(fileName);
+        createRjsApi();
+        return;
+    }
+
+    if (commandOption === 'o') {
+        //Do the optimizer work.
+        loadLib();
+
+        /**
+ * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+
+/*
+ * Create a build.js file that has the build options you want and pass that
+ * build file to this file to do the build. See example.build.js for more information.
+ */
+
+/*jslint strict: false, nomen: false */
+/*global require: false */
+
+require({
+    baseUrl: require.s.contexts._.config.baseUrl,
+    //Use a separate context than the default context so that the
+    //build can use the default context.
+    context: 'build',
+    catchError: {
+        define: true
+    }
+},       ['env!env/args', 'env!env/quit', 'logger', 'build'],
+function (args, quit, logger, build) {
+    build(args).then(function () {}, function (err) {
+        logger.error(err);
+        quit(1);
+    });
+});
+
+
+    } else if (commandOption === 'v') {
+        console.log('r.js: ' + version +
+                    ', RequireJS: ' + this.requirejsVars.require.version +
+                    ', UglifyJS2: 2.3.2, UglifyJS: 1.3.4');
+    } else if (commandOption === 'convert') {
+        loadLib();
+
+        this.requirejsVars.require(['env!env/args', 'commonJs', 'env!env/print'],
+            function (args, commonJs, print) {
+
+                var srcDir, outDir;
+                srcDir = args[0];
+                outDir = args[1];
+
+                if (!srcDir || !outDir) {
+                    print('Usage: path/to/commonjs/modules output/dir');
+                    return;
+                }
+
+                commonJs.convertDir(args[0], args[1]);
+            });
+    } else {
+        //Just run an app
+
+        //Load the bundled libraries for use in the app.
+        if (commandOption === 'lib') {
+            loadLib();
+        }
+
+        setBaseUrl(fileName);
+
+        if (exists(fileName)) {
+            exec(readFile(fileName), fileName);
+        } else {
+            showHelp();
+        }
+    }
+
+}((typeof console !== 'undefined' ? console : undefined),
+    (typeof Packages !== 'undefined' || (typeof window === 'undefined' &&
+        typeof Components !== 'undefined' && Components.interfaces) ?
+        Array.prototype.slice.call(arguments, 0) : []),
+    (typeof readFile !== 'undefined' ? readFile : undefined)));
\ No newline at end of file
diff --git a/public/js_src/domReady.js b/public/js_src/domReady.js
new file mode 100644
index 0000000..6a79772
--- /dev/null
+++ b/public/js_src/domReady.js
@@ -0,0 +1,125 @@
+/**
+ * @license RequireJS domReady 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/requirejs/domReady for details
+ */
+/*jslint */
+/*global require: false, define: false, requirejs: false,
+  window: false, clearInterval: false, document: false,
+  self: false, setInterval: false */
+
+
+define(function () {
+    'use strict';
+
+    var isBrowser = typeof window !== "undefined" && window.document,
+        isPageLoaded = !isBrowser,
+        doc = isBrowser ? document : null,
+        readyCalls = [],
+        isTop, testDiv, scrollIntervalId;
+
+    function runCallbacks(callbacks) {
+        var i;
+        for (i = 0; i < callbacks.length; i++) {
+            callbacks[i](doc);
+        }
+    }
+
+    function callReady() {
+        var callbacks = readyCalls;
+
+        if (isPageLoaded) {
+            //Call the DOM ready callbacks
+            if (callbacks.length) {
+                readyCalls = [];
+                runCallbacks(callbacks);
+            }
+        }
+    }
+
+    /**
+     * Sets the page as loaded.
+     */
+    function pageLoaded() {
+        if (!isPageLoaded) {
+            isPageLoaded = true;
+            if (scrollIntervalId) {
+                clearInterval(scrollIntervalId);
+            }
+
+            callReady();
+        }
+    }
+
+    if (isBrowser) {
+        if (document.addEventListener) {
+            //Standards. Hooray! Assumption here that if standards based,
+            //it knows about DOMContentLoaded.
+            document.addEventListener("DOMContentLoaded", pageLoaded, false);
+            window.addEventListener("load", pageLoaded, false);
+        } else if (window.attachEvent) {
+            window.attachEvent("onload", pageLoaded);
+
+            testDiv = document.createElement('div');
+            try {
+                isTop = window.frameElement === null;
+            } catch(e) {}
+
+            //DOMContentLoaded approximation that uses a doScroll, as found by
+            //Diego Perini: http://javascript.nwbox.com/IEContentLoaded/,
+            //but modified by other contributors, including jdalton
+            if (testDiv.doScroll && isTop && window.external) {
+                scrollIntervalId = setInterval(function () {
+                    try {
+                        testDiv.doScroll();
+                        pageLoaded();
+                    } catch (e) {}
+                }, 30);
+            }
+        }
+
+        //Check if document already complete, and if so, just trigger page load
+        //listeners. Latest webkit browsers also use "interactive", and
+        //will fire the onDOMContentLoaded before "interactive" but not after
+        //entering "interactive" or "complete". More details:
+        //http://dev.w3.org/html5/spec/the-end.html#the-end
+        //http://stackoverflow.com/questions/3665561/document-readystate-of-interactive-vs-ondomcontentloaded
+        if (document.readyState === "complete" ||
+            document.readyState === "interactive") {
+            pageLoaded();
+        }
+    }
+
+    /** START OF PUBLIC API **/
+
+    /**
+     * Registers a callback for DOM ready. If DOM is already ready, the
+     * callback is called immediately.
+     * @param {Function} callback
+     */
+    function domReady(callback) {
+        if (isPageLoaded) {
+            callback(doc);
+        } else {
+            readyCalls.push(callback);
+        }
+        return domReady;
+    }
+
+    domReady.version = '2.0.0';
+
+    /**
+     * Loader Plugin API method
+     */
+    domReady.load = function (name, req, onLoad, config) {
+        if (config.isBuild) {
+            onLoad(null);
+        } else {
+            domReady(onLoad);
+        }
+    };
+
+    /** END OF PUBLIC API **/
+
+    return domReady;
+});
diff --git a/public/js_src/external_libs/Placeholders.js b/public/js_src/external_libs/Placeholders.js
new file mode 100644
index 0000000..58293f8
--- /dev/null
+++ b/public/js_src/external_libs/Placeholders.js
@@ -0,0 +1,397 @@
+define( [],
+	function() {
+
+		"use strict";
+/*
+ * The MIT License
+ *
+ * Copyright (c) 2012 James Allardice
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+		// Cross-browser DOM event binding
+		function addEventListener(elem, event, fn) {
+			if (elem.addEventListener) {
+				return elem.addEventListener(event, fn, false);
+			}
+			if (elem.attachEvent) {
+				return elem.attachEvent("on" + event, fn);
+			}
+		}
+
+		// Check whether an item is in an array (we don't use Array.prototype.indexOf so we don't clobber any existing polyfills - this is a really simple alternative)
+		function inArray(arr, item) {
+			var i, len;
+			for (i = 0, len = arr.length; i < len; i++) {
+				if (arr[i] === item) {
+					return true;
+				}
+			}
+			return false;
+		}
+
+		// Move the caret to the index position specified. Assumes that the element has focus
+		function moveCaret(elem, index) {
+			var range;
+			if (elem.createTextRange) {
+				range = elem.createTextRange();
+				range.move("character", index);
+				range.select();
+			} else if (elem.selectionStart) {
+				elem.focus();
+				elem.setSelectionRange(index, index);
+			}
+		}
+
+		// Attempt to change the type property of an input element
+		function changeType(elem, type) {
+			try {
+				elem.type = type;
+				return true;
+			} catch (e) {
+						// You can't change input type in IE8 and below
+						return false;
+					}
+				}
+
+		// Expose public methods
+		var Placeholders = {
+			Utils: {
+				addEventListener: addEventListener,
+				inArray: inArray,
+				moveCaret: moveCaret,
+				changeType: changeType
+			}
+		};
+
+		var validTypes = [
+		"text",
+		"search",
+		"url",
+		"tel",
+		"email",
+		"password",
+		"number",
+		"textarea"
+		],
+
+				// The list of keycodes that are not allowed when the polyfill is configured to hide-on-input
+				badKeys = [
+
+						// The following keys all cause the caret to jump to the end of the input value
+						27, // Escape
+						33, // Page up
+						34, // Page down
+						35, // End
+						36, // Home
+
+						// Arrow keys allow you to move the caret manually, which should be prevented when the placeholder is visible
+						37, // Left
+						38, // Up
+						39, // Right
+						40, // Down
+
+						// The following keys allow you to modify the placeholder text by removing characters, which should be prevented when the placeholder is visible
+						8, // Backspace
+						46 // Delete
+						],
+
+				// Styling variables
+				placeholderStyleColor = "#ccc",
+				placeholderClassName = "placeholdersjs",
+				classNameRegExp = new RegExp("\\b" + placeholderClassName + "\\b"),
+
+				// These will hold references to all elements that can be affected. NodeList objects are live, so we only need to get those references once
+				inputs, textareas,
+
+				// The various data-* attributes used by the polyfill
+				ATTR_CURRENT_VAL = "data-placeholder-value",
+				ATTR_ACTIVE = "data-placeholder-active",
+				ATTR_INPUT_TYPE = "data-placeholder-type",
+				ATTR_FORM_HANDLED = "data-placeholder-submit",
+				ATTR_EVENTS_BOUND = "data-placeholder-bound",
+				ATTR_OPTION_FOCUS = "data-placeholder-focus",
+				ATTR_OPTION_LIVE = "data-placeholder-live",
+
+				// Various other variables used throughout the rest of the script
+				test = document.createElement("input"),
+				head = document.getElementsByTagName("head")[0],
+				root = document.documentElement,
+				Utils = Placeholders.Utils,
+				hideOnInput, liveUpdates, keydownVal, styleElem, styleRules, placeholder, timer, form, elem, len, i;
+
+		// Hide the placeholder value on a single element. Returns true if the placeholder was hidden and false if it was not (because it wasn't visible in the first place)
+		function hidePlaceholder(elem) {
+			var type;
+			if (elem.value === elem.getAttribute(ATTR_CURRENT_VAL) && elem.getAttribute(ATTR_ACTIVE) === "true") {
+				elem.setAttribute(ATTR_ACTIVE, "false");
+				elem.value = "";
+				elem.className = elem.className.replace(classNameRegExp, "");
+
+						// If the polyfill has changed the type of the element we need to change it back
+						type = elem.getAttribute(ATTR_INPUT_TYPE);
+						if (type) {
+							elem.type = type;
+						}
+						return true;
+					}
+					return false;
+				}
+
+		// Show the placeholder value on a single element. Returns true if the placeholder was shown and false if it was not (because it was already visible)
+		function showPlaceholder(elem) {
+			var type;
+			if (elem.value === "") {
+				elem.setAttribute(ATTR_ACTIVE, "true");
+				elem.value = elem.getAttribute(ATTR_CURRENT_VAL);
+				elem.className += " " + placeholderClassName;
+
+						// If the type of element needs to change, change it (e.g. password inputs)
+						type = elem.getAttribute(ATTR_INPUT_TYPE);
+						if (type) {
+							elem.type = "text";
+						} else if (elem.type === "password") {
+							if (Utils.changeType(elem, "text")) {
+								elem.setAttribute(ATTR_INPUT_TYPE, "password");
+							}
+						}
+						return true;
+					}
+					return false;
+				}
+
+				function handleElem(node, callback) {
+
+					var inputs, textareas, elem, len, i;
+
+				// Check if the passed in node is an input/textarea (in which case it can't have any affected descendants)
+				if (node && node.getAttribute(ATTR_CURRENT_VAL)) {
+					callback(node);
+				} else {
+
+						// If an element was passed in, get all affected descendants. Otherwise, get all affected elements in document
+						inputs = node ? node.getElementsByTagName("input") : inputs;
+						textareas = node ? node.getElementsByTagName("textarea") : textareas;
+
+						// Run the callback for each element
+						for (i = 0, len = inputs.length + textareas.length; i < len; i++) {
+							elem = i < inputs.length ? inputs[i] : textareas[i - inputs.length];
+							callback(elem);
+						}
+					}
+				}
+
+		// Return all affected elements to their normal state (remove placeholder value if present)
+		function disablePlaceholders(node) {
+			handleElem(node, hidePlaceholder);
+		}
+
+		// Show the placeholder value on all appropriate elements
+		function enablePlaceholders(node) {
+			handleElem(node, showPlaceholder);
+		}
+
+		// Returns a function that is used as a focus event handler
+		function makeFocusHandler(elem) {
+			return function () {
+
+						// Only hide the placeholder value if the (default) hide-on-focus behaviour is enabled
+						if (hideOnInput && elem.value === elem.getAttribute(ATTR_CURRENT_VAL) && elem.getAttribute(ATTR_ACTIVE) === "true") {
+
+								// Move the caret to the start of the input (this mimics the behaviour of all browsers that do not hide the placeholder on focus)
+								Utils.moveCaret(elem, 0);
+
+							} else {
+
+								// Remove the placeholder
+								hidePlaceholder(elem);
+							}
+						};
+					}
+
+		// Returns a function that is used as a blur event handler
+		function makeBlurHandler(elem) {
+			return function () {
+				showPlaceholder(elem);
+			};
+		}
+
+		// Functions that are used as a event handlers when the hide-on-input behaviour has been activated - very basic implementation of the "input" event
+		function makeKeydownHandler(elem) {
+			return function (e) {
+				keydownVal = elem.value;
+
+				//Prevent the use of the arrow keys (try to keep the cursor before the placeholder)
+				if (elem.getAttribute(ATTR_ACTIVE) === "true") {
+					return !(keydownVal === elem.getAttribute(ATTR_CURRENT_VAL) && Utils.inArray(badKeys, e.keyCode));
+				}
+			};
+		}
+		function makeKeyupHandler(elem) {
+			return function () {
+				var type;
+
+				if (elem.getAttribute(ATTR_ACTIVE) === "true" && elem.value !== keydownVal) {
+
+						// Remove the placeholder
+						elem.className = elem.className.replace(classNameRegExp, "");
+						elem.value = elem.value.replace(elem.getAttribute(ATTR_CURRENT_VAL), "");
+						elem.setAttribute(ATTR_ACTIVE, false);
+
+						// If the type of element needs to change, change it (e.g. password inputs)
+						type = elem.getAttribute(ATTR_INPUT_TYPE);
+						if (type) {
+							elem.type = type;
+						}
+					}
+
+				// If the element is now empty we need to show the placeholder
+				if (elem.value === "") {
+					elem.blur();
+					Utils.moveCaret(elem, 0);
+				}
+			};
+		}
+		function makeClickHandler(elem) {
+			return function () {
+				if (elem === document.activeElement && elem.value === elem.getAttribute(ATTR_CURRENT_VAL) && elem.getAttribute(ATTR_ACTIVE) === "true") {
+					Utils.moveCaret(elem, 0);
+				}
+			};
+		}
+
+		// Returns a function that is used as a submit event handler on form elements that have children affected by this polyfill
+		function makeSubmitHandler(form) {
+			return function () {
+				// Turn off placeholders on all appropriate descendant elements
+				disablePlaceholders(form);
+			};
+		}
+
+		// Bind event handlers to an element that we need to affect with the polyfill
+		function newElement(elem) {
+
+				// If the element is part of a form, make sure the placeholder string is not submitted as a value
+				if (elem.form) {
+					form = elem.form;
+
+					// Set a flag on the form so we know it's been handled (forms can contain multiple inputs)
+					if (!form.getAttribute(ATTR_FORM_HANDLED)) {
+						Utils.addEventListener(form, "submit", makeSubmitHandler(form));
+						form.setAttribute(ATTR_FORM_HANDLED, "true");
+					}
+				}
+
+				// Bind event handlers to the element so we can hide/show the placeholder as appropriate
+				Utils.addEventListener(elem, "focus", makeFocusHandler(elem));
+				Utils.addEventListener(elem, "blur", makeBlurHandler(elem));
+
+				// If the placeholder should hide on input rather than on focus we need additional event handlers
+				if (hideOnInput) {
+					Utils.addEventListener(elem, "keydown", makeKeydownHandler(elem));
+					Utils.addEventListener(elem, "keyup", makeKeyupHandler(elem));
+					Utils.addEventListener(elem, "click", makeClickHandler(elem));
+				}
+
+				// Remember that we've bound event handlers to this element
+				elem.setAttribute(ATTR_EVENTS_BOUND, "true");
+				elem.setAttribute(ATTR_CURRENT_VAL, placeholder);
+
+				// If the element doesn't have a value, set it to the placeholder string
+				showPlaceholder(elem);
+			}
+
+			if (test.placeholder === void 0) {
+
+				// Get references to all the input and textarea elements currently in the DOM (live NodeList objects to we only need to do this once)
+				inputs = document.getElementsByTagName("input");
+				textareas = document.getElementsByTagName("textarea");
+
+				// Get any settings declared as data-* attributes on the root element (currently the only options are whether to hide the placeholder on focus or input and whether to auto-update)
+				hideOnInput = root.getAttribute(ATTR_OPTION_FOCUS) === "false";
+				liveUpdates = root.getAttribute(ATTR_OPTION_LIVE) !== "false";
+
+				// Create style element for placeholder styles (instead of directly setting style properties on elements - allows for better flexibility alongside user-defined styles)
+				styleElem = document.createElement("style");
+				styleElem.type = "text/css";
+
+				// Create style rules as text node
+				styleRules = document.createTextNode("." + placeholderClassName + " { color:" + placeholderStyleColor + "; }");
+
+				// Append style rules to newly created stylesheet
+				if (styleElem.styleSheet) {
+					styleElem.styleSheet.cssText = styleRules.nodeValue;
+				} else {
+					styleElem.appendChild(styleRules);
+				}
+
+				// Prepend new style element to the head (before any existing stylesheets, so user-defined rules take precedence)
+				head.insertBefore(styleElem, head.firstChild);
+
+				// Set up the placeholders
+				for (i = 0, len = inputs.length + textareas.length; i < len; i++) {
+					elem = i < inputs.length ? inputs[i] : textareas[i - inputs.length];
+
+					// Only apply the polyfill if this element is of a type that supports placeholders, and has a placeholder attribute with a non-empty value
+					placeholder = elem.getAttribute("placeholder");
+					if (placeholder && Utils.inArray(validTypes, elem.type)) {
+						newElement(elem);
+					}
+				}
+
+				// If enabled, the polyfill will repeatedly check for changed/added elements and apply to those as well
+				timer = setInterval(function () {
+				for (i = 0, len = inputs.length + textareas.length; i < len; i++) {
+					elem = i < inputs.length ? inputs[i] : textareas[i - inputs.length];
+
+					// Only apply the polyfill if this element is of a type that supports placeholders, and has a placeholder attribute with a non-empty value
+					placeholder = elem.getAttribute("placeholder");
+					if (placeholder && Utils.inArray(validTypes, elem.type)) {
+
+						// If the element hasn't had event handlers bound to it then add them
+						if (!elem.getAttribute(ATTR_EVENTS_BOUND)) {
+							newElement(elem);
+						}
+
+						// If the placeholder value has changed or not been initialised yet we need to update the display
+						if (placeholder !== elem.getAttribute(ATTR_CURRENT_VAL) || (elem.type === "password" && !elem.getAttribute(ATTR_INPUT_TYPE))) {
+
+							// Attempt to change the type of password inputs (fails in IE < 9)
+							if (elem.type === "password" && !elem.getAttribute(ATTR_INPUT_TYPE) && Utils.changeType(elem, "text")) {
+								elem.setAttribute(ATTR_INPUT_TYPE, "password");
+							}
+
+							// If the placeholder value has changed and the placeholder is currently on display we need to change it
+							if (elem.value === elem.getAttribute(ATTR_CURRENT_VAL)) {
+								elem.value = placeholder;
+							}
+
+							// Keep a reference to the current placeholder value in case it changes via another script
+							elem.setAttribute(ATTR_CURRENT_VAL, placeholder);
+						}
+					}
+				}
+
+				// If live updates are not enabled cancel the timer
+				if (!liveUpdates) {
+					clearInterval(timer);
+				}
+			}, 100);
+		}
+
+		// Expose public methods
+		Placeholders.disable = disablePlaceholders;
+		Placeholders.enable = enablePlaceholders;
+
+		return Placeholders;
+} );
diff --git a/public/js_src/external_libs/ai1ec_datepicker.js b/public/js_src/external_libs/ai1ec_datepicker.js
new file mode 100644
index 0000000..ffcf8db
--- /dev/null
+++ b/public/js_src/external_libs/ai1ec_datepicker.js
@@ -0,0 +1,885 @@
+define( 
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+			
+			var DatePicker = function () {
+				var	ids = {},
+					views = {
+						years: 'datepickerViewYears',
+						moths: 'datepickerViewMonths',
+						days: 'datepickerViewDays'
+					},
+					tpl = {
+						wrapper: '<div class="datepicker"><div class="datepickerBorderT" /><div class="datepickerBorderB" /><div class="datepickerBorderL" /><div class="datepickerBorderR" /><div class="datepickerBorderTL" /><div class="datepickerBorderTR" /><div class="datepickerBorderBL" /><div class="datepickerBorderBR" /><div class="datepickerContainer"><table cellspacing="0" cellpadding="0"><tbody><tr></tr></tbody></table></div></div>',
+						head: [
+							'<td>',
+							'<table cellspacing="0" cellpadding="0">',
+								'<thead>',
+									'<tr>',
+										'<th class="datepickerGoPrev"><a href="#"><span><%=prev%></span></a></th>',
+										'<th colspan="6" class="datepickerMonth"><a href="#"><span></span></a></th>',
+										'<th class="datepickerGoNext"><a href="#"><span><%=next%></span></a></th>',
+									'</tr>',
+									'<tr class="datepickerDoW">',
+										'<th><span><%=week%></span></th>',
+										'<th><span><%=day1%></span></th>',
+										'<th><span><%=day2%></span></th>',
+										'<th><span><%=day3%></span></th>',
+										'<th><span><%=day4%></span></th>',
+										'<th><span><%=day5%></span></th>',
+										'<th><span><%=day6%></span></th>',
+										'<th><span><%=day7%></span></th>',
+									'</tr>',
+								'</thead>',
+							'</table></td>'
+						],
+						space : '<td class="datepickerSpace"><div></div></td>',
+						days: [
+							'<tbody class="datepickerDays">',
+								'<tr>',
+									'<th class="datepickerWeek"><a href="#"><span><%=weeks[0].week%></span></a></th>',
+									'<td class="<%=weeks[0].days[0].classname%>"><a href="#"><span><%=weeks[0].days[0].text%></span></a></td>',
+									'<td class="<%=weeks[0].days[1].classname%>"><a href="#"><span><%=weeks[0].days[1].text%></span></a></td>',
+									'<td class="<%=weeks[0].days[2].classname%>"><a href="#"><span><%=weeks[0].days[2].text%></span></a></td>',
+									'<td class="<%=weeks[0].days[3].classname%>"><a href="#"><span><%=weeks[0].days[3].text%></span></a></td>',
+									'<td class="<%=weeks[0].days[4].classname%>"><a href="#"><span><%=weeks[0].days[4].text%></span></a></td>',
+									'<td class="<%=weeks[0].days[5].classname%>"><a href="#"><span><%=weeks[0].days[5].text%></span></a></td>',
+									'<td class="<%=weeks[0].days[6].classname%>"><a href="#"><span><%=weeks[0].days[6].text%></span></a></td>',
+								'</tr>',
+								'<tr>',
+									'<th class="datepickerWeek"><a href="#"><span><%=weeks[1].week%></span></a></th>',
+									'<td class="<%=weeks[1].days[0].classname%>"><a href="#"><span><%=weeks[1].days[0].text%></span></a></td>',
+									'<td class="<%=weeks[1].days[1].classname%>"><a href="#"><span><%=weeks[1].days[1].text%></span></a></td>',
+									'<td class="<%=weeks[1].days[2].classname%>"><a href="#"><span><%=weeks[1].days[2].text%></span></a></td>',
+									'<td class="<%=weeks[1].days[3].classname%>"><a href="#"><span><%=weeks[1].days[3].text%></span></a></td>',
+									'<td class="<%=weeks[1].days[4].classname%>"><a href="#"><span><%=weeks[1].days[4].text%></span></a></td>',
+									'<td class="<%=weeks[1].days[5].classname%>"><a href="#"><span><%=weeks[1].days[5].text%></span></a></td>',
+									'<td class="<%=weeks[1].days[6].classname%>"><a href="#"><span><%=weeks[1].days[6].text%></span></a></td>',
+								'</tr>',
+								'<tr>',
+									'<th class="datepickerWeek"><a href="#"><span><%=weeks[2].week%></span></a></th>',
+									'<td class="<%=weeks[2].days[0].classname%>"><a href="#"><span><%=weeks[2].days[0].text%></span></a></td>',
+									'<td class="<%=weeks[2].days[1].classname%>"><a href="#"><span><%=weeks[2].days[1].text%></span></a></td>',
+									'<td class="<%=weeks[2].days[2].classname%>"><a href="#"><span><%=weeks[2].days[2].text%></span></a></td>',
+									'<td class="<%=weeks[2].days[3].classname%>"><a href="#"><span><%=weeks[2].days[3].text%></span></a></td>',
+									'<td class="<%=weeks[2].days[4].classname%>"><a href="#"><span><%=weeks[2].days[4].text%></span></a></td>',
+									'<td class="<%=weeks[2].days[5].classname%>"><a href="#"><span><%=weeks[2].days[5].text%></span></a></td>',
+									'<td class="<%=weeks[2].days[6].classname%>"><a href="#"><span><%=weeks[2].days[6].text%></span></a></td>',
+								'</tr>',
+								'<tr>',
+									'<th class="datepickerWeek"><a href="#"><span><%=weeks[3].week%></span></a></th>',
+									'<td class="<%=weeks[3].days[0].classname%>"><a href="#"><span><%=weeks[3].days[0].text%></span></a></td>',
+									'<td class="<%=weeks[3].days[1].classname%>"><a href="#"><span><%=weeks[3].days[1].text%></span></a></td>',
+									'<td class="<%=weeks[3].days[2].classname%>"><a href="#"><span><%=weeks[3].days[2].text%></span></a></td>',
+									'<td class="<%=weeks[3].days[3].classname%>"><a href="#"><span><%=weeks[3].days[3].text%></span></a></td>',
+									'<td class="<%=weeks[3].days[4].classname%>"><a href="#"><span><%=weeks[3].days[4].text%></span></a></td>',
+									'<td class="<%=weeks[3].days[5].classname%>"><a href="#"><span><%=weeks[3].days[5].text%></span></a></td>',
+									'<td class="<%=weeks[3].days[6].classname%>"><a href="#"><span><%=weeks[3].days[6].text%></span></a></td>',
+								'</tr>',
+								'<tr>',
+									'<th class="datepickerWeek"><a href="#"><span><%=weeks[4].week%></span></a></th>',
+									'<td class="<%=weeks[4].days[0].classname%>"><a href="#"><span><%=weeks[4].days[0].text%></span></a></td>',
+									'<td class="<%=weeks[4].days[1].classname%>"><a href="#"><span><%=weeks[4].days[1].text%></span></a></td>',
+									'<td class="<%=weeks[4].days[2].classname%>"><a href="#"><span><%=weeks[4].days[2].text%></span></a></td>',
+									'<td class="<%=weeks[4].days[3].classname%>"><a href="#"><span><%=weeks[4].days[3].text%></span></a></td>',
+									'<td class="<%=weeks[4].days[4].classname%>"><a href="#"><span><%=weeks[4].days[4].text%></span></a></td>',
+									'<td class="<%=weeks[4].days[5].classname%>"><a href="#"><span><%=weeks[4].days[5].text%></span></a></td>',
+									'<td class="<%=weeks[4].days[6].classname%>"><a href="#"><span><%=weeks[4].days[6].text%></span></a></td>',
+								'</tr>',
+								'<tr>',
+									'<th class="datepickerWeek"><a href="#"><span><%=weeks[5].week%></span></a></th>',
+									'<td class="<%=weeks[5].days[0].classname%>"><a href="#"><span><%=weeks[5].days[0].text%></span></a></td>',
+									'<td class="<%=weeks[5].days[1].classname%>"><a href="#"><span><%=weeks[5].days[1].text%></span></a></td>',
+									'<td class="<%=weeks[5].days[2].classname%>"><a href="#"><span><%=weeks[5].days[2].text%></span></a></td>',
+									'<td class="<%=weeks[5].days[3].classname%>"><a href="#"><span><%=weeks[5].days[3].text%></span></a></td>',
+									'<td class="<%=weeks[5].days[4].classname%>"><a href="#"><span><%=weeks[5].days[4].text%></span></a></td>',
+									'<td class="<%=weeks[5].days[5].classname%>"><a href="#"><span><%=weeks[5].days[5].text%></span></a></td>',
+									'<td class="<%=weeks[5].days[6].classname%>"><a href="#"><span><%=weeks[5].days[6].text%></span></a></td>',
+								'</tr>',
+							'</tbody>'
+						],
+						months: [
+							'<tbody class="<%=className%>">',
+								'<tr>',
+									'<td colspan="2"><a href="#"><span><%=data[0]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[1]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[2]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[3]%></span></a></td>',
+								'</tr>',
+								'<tr>',
+									'<td colspan="2"><a href="#"><span><%=data[4]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[5]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[6]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[7]%></span></a></td>',
+								'</tr>',
+								'<tr>',
+									'<td colspan="2"><a href="#"><span><%=data[8]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[9]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[10]%></span></a></td>',
+									'<td colspan="2"><a href="#"><span><%=data[11]%></span></a></td>',
+								'</tr>',
+							'</tbody>'
+						]
+					},
+					defaults = {
+						flat: false,
+						starts: 1,
+						prev: '&#9664;',
+						next: '&#9654;',
+						lastSel: false,
+						mode: 'single',
+						view: 'days',
+						calendars: 1,
+						format: 'Y-m-d',
+						position: 'bottom',
+						eventName: 'click',
+						onRender: function(){return {};},
+						onChange: function(){return true;},
+						onShow: function(){return true;},
+						onBeforeShow: function(){return true;},
+						onHide: function(){return true;},
+						locale: {
+							days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
+							daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
+							daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
+							months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
+							monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
+							weekMin: 'wk'
+						}
+					},
+					fill = function(el) {
+						var options = $(el).data('datepicker');
+						var cal = $(el);
+						var currentCal = Math.floor(options.calendars/2), date, data, dow, month, cnt = 0, week, days, indic, indic2, html, tblCal;
+						cal.find('td>table tbody').remove();
+						for (var i = 0; i < options.calendars; i++) {
+							date = new Date(options.current);
+							date.addMonths(-currentCal + i);
+							tblCal = cal.find('table').eq(i+1);
+							switch (tblCal[0].className) {
+								case 'datepickerViewDays':
+									dow = formatDate(date, 'B, Y');
+									break;
+								case 'datepickerViewMonths':
+									dow = date.getFullYear();
+									break;
+								case 'datepickerViewYears':
+									dow = (date.getFullYear()-6) + ' - ' + (date.getFullYear()+5);
+									break;
+							} 
+							tblCal.find('thead tr:first th:eq(1) span').text(dow);
+							dow = date.getFullYear()-6;
+							data = {
+								data: [],
+								className: 'datepickerYears'
+							}
+							for ( var j = 0; j < 12; j++) {
+								data.data.push(dow + j);
+							}
+							html = tmpl(tpl.months.join(''), data);
+							date.setDate(1);
+							data = {weeks:[], test: 10};
+							month = date.getMonth();
+							var dow = (date.getDay() - options.starts) % 7;
+							date.addDays(-(dow + (dow < 0 ? 7 : 0)));
+							week = -1;
+							cnt = 0;
+							while (cnt < 42) {
+								indic = parseInt(cnt/7,10);
+								indic2 = cnt%7;
+								if (!data.weeks[indic]) {
+									week = date.getWeekNumber();
+									data.weeks[indic] = {
+										week: week,
+										days: []
+									};
+								}
+								data.weeks[indic].days[indic2] = {
+									text: date.getDate(),
+									classname: []
+								};
+								if (month != date.getMonth()) {
+									data.weeks[indic].days[indic2].classname.push('datepickerNotInMonth');
+								}
+								if (date.getDay() == 0) {
+									data.weeks[indic].days[indic2].classname.push('datepickerSunday');
+								}
+								if (date.getDay() == 6) {
+									data.weeks[indic].days[indic2].classname.push('datepickerSaturday');
+								}
+								var fromUser = options.onRender(date);
+								var val = date.valueOf();
+								if (fromUser.selected || options.date == val || $.inArray(val, options.date) > -1 || (options.mode == 'range' && val >= options.date[0] && val <= options.date[1])) {
+									data.weeks[indic].days[indic2].classname.push('datepickerSelected');
+								}
+								if (fromUser.disabled) {
+									data.weeks[indic].days[indic2].classname.push('datepickerDisabled');
+								}
+								if (fromUser.className) {
+									data.weeks[indic].days[indic2].classname.push(fromUser.className);
+								}
+								data.weeks[indic].days[indic2].classname = data.weeks[indic].days[indic2].classname.join(' ');
+								cnt++;
+								date.addDays(1);
+							}
+							html = tmpl(tpl.days.join(''), data) + html;
+							data = {
+								data: options.locale.monthsShort,
+								className: 'datepickerMonths'
+							};
+							html = tmpl(tpl.months.join(''), data) + html;
+							tblCal.append(html);
+						}
+					},
+					parseDate = function (date, format) {
+						if (date.constructor == Date) {
+							return new Date(date);
+						}
+						var parts = date.split(/\W+/);
+						var against = format.split(/\W+/), d, m, y, h, min, now = new Date();
+						for (var i = 0; i < parts.length; i++) {
+							switch (against[i]) {
+								case 'd':
+								case 'e':
+									d = parseInt(parts[i],10);
+									break;
+								case 'm':
+									m = parseInt(parts[i], 10)-1;
+									break;
+								case 'Y':
+								case 'y':
+									y = parseInt(parts[i], 10);
+									y += y > 100 ? 0 : (y < 29 ? 2000 : 1900);
+									break;
+								case 'H':
+								case 'I':
+								case 'k':
+								case 'l':
+									h = parseInt(parts[i], 10);
+									break;
+								case 'P':
+								case 'p':
+									if (/pm/i.test(parts[i]) && h < 12) {
+										h += 12;
+									} else if (/am/i.test(parts[i]) && h >= 12) {
+										h -= 12;
+									}
+									break;
+								case 'M':
+									min = parseInt(parts[i], 10);
+									break;
+							}
+						}
+						return new Date(
+							y === undefined ? now.getFullYear() : y,
+							m === undefined ? now.getMonth() : m,
+							d === undefined ? now.getDate() : d,
+							h === undefined ? now.getHours() : h,
+							min === undefined ? now.getMinutes() : min,
+							0
+						);
+					},
+					formatDate = function(date, format) {
+						var m = date.getMonth();
+						var d = date.getDate();
+						var y = date.getFullYear();
+						var wn = date.getWeekNumber();
+						var w = date.getDay();
+						var s = {};
+						var hr = date.getHours();
+						var pm = (hr >= 12);
+						var ir = (pm) ? (hr - 12) : hr;
+						var dy = date.getDayOfYear();
+						if (ir == 0) {
+							ir = 12;
+						}
+						var min = date.getMinutes();
+						var sec = date.getSeconds();
+						var parts = format.split(''), part;
+						for ( var i = 0; i < parts.length; i++ ) {
+							part = parts[i];
+							switch (parts[i]) {
+								case 'a':
+									part = date.getDayName();
+									break;
+								case 'A':
+									part = date.getDayName(true);
+									break;
+								case 'b':
+									part = date.getMonthName();
+									break;
+								case 'B':
+									part = date.getMonthName(true);
+									break;
+								case 'C':
+									part = 1 + Math.floor(y / 100);
+									break;
+								case 'd':
+									part = (d < 10) ? ("0" + d) : d;
+									break;
+								case 'e':
+									part = d;
+									break;
+								case 'H':
+									part = (hr < 10) ? ("0" + hr) : hr;
+									break;
+								case 'I':
+									part = (ir < 10) ? ("0" + ir) : ir;
+									break;
+								case 'j':
+									part = (dy < 100) ? ((dy < 10) ? ("00" + dy) : ("0" + dy)) : dy;
+									break;
+								case 'k':
+									part = hr;
+									break;
+								case 'l':
+									part = ir;
+									break;
+								case 'm':
+									part = (m < 9) ? ("0" + (1+m)) : (1+m);
+									break;
+								case 'M':
+									part = (min < 10) ? ("0" + min) : min;
+									break;
+								case 'p':
+								case 'P':
+									part = pm ? "PM" : "AM";
+									break;
+								case 's':
+									part = Math.floor(date.getTime() / 1000);
+									break;
+								case 'S':
+									part = (sec < 10) ? ("0" + sec) : sec;
+									break;
+								case 'u':
+									part = w + 1;
+									break;
+								case 'w':
+									part = w;
+									break;
+								case 'y':
+									part = ('' + y).substr(2, 2);
+									break;
+								case 'Y':
+									part = y;
+									break;
+							}
+							parts[i] = part;
+						}
+						return parts.join('');
+					},
+					extendDate = function(options) {
+						if (Date.prototype.tempDate) {
+							return;
+						}
+						Date.prototype.tempDate = null;
+						Date.prototype.months = options.months;
+						Date.prototype.monthsShort = options.monthsShort;
+						Date.prototype.days = options.days;
+						Date.prototype.daysShort = options.daysShort;
+						Date.prototype.getMonthName = function(fullName) {
+							return this[fullName ? 'months' : 'monthsShort'][this.getMonth()];
+						};
+						Date.prototype.getDayName = function(fullName) {
+							return this[fullName ? 'days' : 'daysShort'][this.getDay()];
+						};
+						Date.prototype.addDays = function (n) {
+							this.setDate(this.getDate() + n);
+							this.tempDate = this.getDate();
+						};
+						Date.prototype.addMonths = function (n) {
+							if (this.tempDate == null) {
+								this.tempDate = this.getDate();
+							}
+							this.setDate(1);
+							this.setMonth(this.getMonth() + n);
+							this.setDate(Math.min(this.tempDate, this.getMaxDays()));
+						};
+						Date.prototype.addYears = function (n) {
+							if (this.tempDate == null) {
+								this.tempDate = this.getDate();
+							}
+							this.setDate(1);
+							this.setFullYear(this.getFullYear() + n);
+							this.setDate(Math.min(this.tempDate, this.getMaxDays()));
+						};
+						Date.prototype.getMaxDays = function() {
+							var tmpDate = new Date(Date.parse(this)),
+								d = 28, m;
+							m = tmpDate.getMonth();
+							d = 28;
+							while (tmpDate.getMonth() == m) {
+								d ++;
+								tmpDate.setDate(d);
+							}
+							return d - 1;
+						};
+						Date.prototype.getFirstDay = function() {
+							var tmpDate = new Date(Date.parse(this));
+							tmpDate.setDate(1);
+							return tmpDate.getDay();
+						};
+						Date.prototype.getWeekNumber = function() {
+							var tempDate = new Date(this);
+							tempDate.setDate(tempDate.getDate() - (tempDate.getDay() + 6) % 7 + 3);
+							var dms = tempDate.valueOf();
+							tempDate.setMonth(0);
+							tempDate.setDate(4);
+							return Math.round((dms - tempDate.valueOf()) / (604800000)) + 1;
+						};
+						Date.prototype.getDayOfYear = function() {
+							var now = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0);
+							var then = new Date(this.getFullYear(), 0, 0, 0, 0, 0);
+							var time = now - then;
+							return Math.floor(time / 24*60*60*1000);
+						};
+					},
+					layout = function (el) {
+						var options = $(el).data('datepicker');
+						var cal = $('#' + options.id);
+						if (!options.extraHeight) {
+							var divs = $(el).find('div');
+							options.extraHeight = divs.get(0).offsetHeight + divs.get(1).offsetHeight;
+							options.extraWidth = divs.get(2).offsetWidth + divs.get(3).offsetWidth;
+						}
+						var tbl = cal.find('table:first').get(0);
+						var width = tbl.offsetWidth;
+						var height = tbl.offsetHeight;
+						cal.css({
+							width: width + options.extraWidth + 'px',
+							height: height + options.extraHeight + 'px'
+						}).find('div.datepickerContainer').css({
+							width: width + 'px',
+							height: height + 'px'
+						});
+					},
+					click = function(ev) {
+						if ($(ev.target).is('span')) {
+							ev.target = ev.target.parentNode;
+						}
+						var el = $(ev.target);
+						if (el.is('a')) {
+							ev.target.blur();
+							if (el.hasClass('datepickerDisabled')) {
+								return false;
+							}
+							var options = $(this).data('datepicker');
+							var parentEl = el.parent();
+							var tblEl = parentEl.parent().parent().parent();
+							var tblIndex = $('table', this).index(tblEl.get(0)) - 1;
+							var tmp = new Date(options.current);
+							var changed = false;
+							var fillIt = false;
+							if (parentEl.is('th')) {
+								if (parentEl.hasClass('datepickerWeek') && options.mode == 'range' && !parentEl.next().hasClass('datepickerDisabled')) {
+									var val = parseInt(parentEl.next().text(), 10);
+									tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
+									if (parentEl.next().hasClass('datepickerNotInMonth')) {
+										tmp.addMonths(val > 15 ? -1 : 1);
+									}
+									tmp.setDate(val);
+									options.date[0] = (tmp.setHours(0,0,0,0)).valueOf();
+									tmp.setHours(23,59,59,0);
+									tmp.addDays(6);
+									options.date[1] = tmp.valueOf();
+									fillIt = true;
+									changed = true;
+									options.lastSel = false;
+								} else if (parentEl.hasClass('datepickerMonth')) {
+									tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
+									switch (tblEl.get(0).className) {
+										case 'datepickerViewDays':
+											tblEl.get(0).className = 'datepickerViewMonths';
+											el.find('span').text(tmp.getFullYear());
+											break;
+										case 'datepickerViewMonths':
+											tblEl.get(0).className = 'datepickerViewYears';
+											el.find('span').text((tmp.getFullYear()-6) + ' - ' + (tmp.getFullYear()+5));
+											break;
+										case 'datepickerViewYears':
+											tblEl.get(0).className = 'datepickerViewDays';
+											el.find('span').text(formatDate(tmp, 'B, Y'));
+											break;
+									}
+								} else if (parentEl.parent().parent().is('thead')) {
+									switch (tblEl.get(0).className) {
+										case 'datepickerViewDays':
+											options.current.addMonths(parentEl.hasClass('datepickerGoPrev') ? -1 : 1);
+											break;
+										case 'datepickerViewMonths':
+											options.current.addYears(parentEl.hasClass('datepickerGoPrev') ? -1 : 1);
+											break;
+										case 'datepickerViewYears':
+											options.current.addYears(parentEl.hasClass('datepickerGoPrev') ? -12 : 12);
+											break;
+									}
+									fillIt = true;
+								}
+							} else if (parentEl.is('td') && !parentEl.hasClass('datepickerDisabled')) {
+								switch (tblEl.get(0).className) {
+									case 'datepickerViewMonths':
+										options.current.setMonth(tblEl.find('tbody.datepickerMonths td').index(parentEl));
+										options.current.setFullYear(parseInt(tblEl.find('thead th.datepickerMonth span').text(), 10));
+										options.current.addMonths(Math.floor(options.calendars/2) - tblIndex);
+										tblEl.get(0).className = 'datepickerViewDays';
+										break;
+									case 'datepickerViewYears':
+										options.current.setFullYear(parseInt(el.text(), 10));
+										tblEl.get(0).className = 'datepickerViewMonths';
+										break;
+									default:
+										var val = parseInt(el.text(), 10);
+										tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
+										if (parentEl.hasClass('datepickerNotInMonth')) {
+											tmp.addMonths(val > 15 ? -1 : 1);
+										}
+										tmp.setDate(val);
+										switch (options.mode) {
+											case 'multiple':
+												val = (tmp.setHours(0,0,0,0)).valueOf();
+												if ($.inArray(val, options.date) > -1) {
+													$.each(options.date, function(nr, dat){
+														if (dat == val) {
+															options.date.splice(nr,1);
+															return false;
+														}
+													});
+												} else {
+													options.date.push(val);
+												}
+												break;
+											case 'range':
+												if (!options.lastSel) {
+													options.date[0] = (tmp.setHours(0,0,0,0)).valueOf();
+												}
+												val = (tmp.setHours(23,59,59,0)).valueOf();
+												if (val < options.date[0]) {
+													options.date[1] = options.date[0] + 86399000;
+													options.date[0] = val - 86399000;
+												} else {
+													options.date[1] = val;
+												}
+												options.lastSel = !options.lastSel;
+												break;
+											default:
+												options.date = tmp.valueOf();
+												break;
+										}
+										break;
+								}
+								fillIt = true;
+								changed = true;
+							}
+							if (fillIt) {
+								fill(this);
+							}
+							if (changed) {
+								options.onChange.apply(this, prepareDate(options));
+							}
+						}
+						return false;
+					},
+					prepareDate = function (options) {
+						var tmp;
+						if (options.mode == 'single') {
+							tmp = new Date(options.date);
+							return [formatDate(tmp, options.format), tmp, options.el];
+						} else {
+							tmp = [[],[], options.el];
+							$.each(options.date, function(nr, val){
+								var date = new Date(val);
+								tmp[0].push(formatDate(date, options.format));
+								tmp[1].push(date);
+							});
+							return tmp;
+						}
+					},
+					getViewport = function () {
+						var m = document.compatMode == 'CSS1Compat';
+						return {
+							l : window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
+							t : window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
+							w : window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
+							h : window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
+						};
+					},
+					isChildOf = function(parentEl, el, container) {
+						if (parentEl == el) {
+							return true;
+						}
+						if (parentEl.contains) {
+							return parentEl.contains(el);
+						}
+						if ( parentEl.compareDocumentPosition ) {
+							return !!(parentEl.compareDocumentPosition(el) & 16);
+						}
+						var prEl = el.parentNode;
+						while(prEl && prEl != container) {
+							if (prEl == parentEl)
+								return true;
+							prEl = prEl.parentNode;
+						}
+						return false;
+					},
+					show = function (ev) {
+						var cal = $('#' + $(this).data('datepickerId'));
+						if (!cal.is(':visible')) {
+							var calEl = cal.get(0);
+							fill(calEl);
+							var options = cal.data('datepicker');
+							options.onBeforeShow.apply(this, [cal.get(0)]);
+							var pos = $(this).offset();
+							var viewPort = getViewport();
+							var top = pos.top;
+							var left = pos.left;
+							var oldDisplay = $.curCSS(calEl, 'display');
+							cal.css({
+								visibility: 'hidden',
+								display: 'block'
+							});
+							layout(calEl);
+							switch (options.position){
+								case 'top':
+									top -= calEl.offsetHeight;
+									break;
+								case 'left':
+									left -= calEl.offsetWidth;
+									break;
+								case 'right':
+									left += this.offsetWidth;
+									break;
+								case 'bottom':
+									top += this.offsetHeight;
+									break;
+							}
+							if (top + calEl.offsetHeight > viewPort.t + viewPort.h) {
+								top = pos.top  - calEl.offsetHeight;
+							}
+							if (top < viewPort.t) {
+								top = pos.top + this.offsetHeight + calEl.offsetHeight;
+							}
+							if (left + calEl.offsetWidth > viewPort.l + viewPort.w) {
+								left = pos.left - calEl.offsetWidth;
+							}
+							if (left < viewPort.l) {
+								left = pos.left + this.offsetWidth
+							}
+							cal.css({
+								visibility: 'visible',
+								display: 'block',
+								top: top + 'px',
+								left: left + 'px'
+							});
+							if (options.onShow.apply(this, [cal.get(0)]) != false) {
+								cal.show();
+							}
+							$(document).bind('mousedown', {cal: cal, trigger: this}, hide);
+						}
+						return false;
+					},
+					hide = function (ev) {
+						if (ev.target != ev.data.trigger && !isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {
+							if (ev.data.cal.data('datepicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
+								ev.data.cal.hide();
+							}
+							$(document).unbind('mousedown', hide);
+						}
+					};
+				return {
+					init: function(options){
+						options = $.extend({}, defaults, options||{});
+						extendDate(options.locale);
+						options.calendars = Math.max(1, parseInt(options.calendars,10)||1);
+						options.mode = /single|multiple|range/.test(options.mode) ? options.mode : 'single';
+						return this.each(function(){
+							if (!$(this).data('datepicker')) {
+								options.el = this;
+								if (options.date.constructor == String) {
+									options.date = parseDate(options.date, options.format);
+									options.date.setHours(0,0,0,0);
+								}
+								if (options.mode != 'single') {
+									if (options.date.constructor != Array) {
+										options.date = [options.date.valueOf()];
+										if (options.mode == 'range') {
+											options.date.push(((new Date(options.date[0])).setHours(23,59,59,0)).valueOf());
+										}
+									} else {
+										for (var i = 0; i < options.date.length; i++) {
+											options.date[i] = (parseDate(options.date[i], options.format).setHours(0,0,0,0)).valueOf();
+										}
+										if (options.mode == 'range') {
+											options.date[1] = ((new Date(options.date[1])).setHours(23,59,59,0)).valueOf();
+										}
+									}
+								} else {
+									options.date = options.date.valueOf();
+								}
+								if (!options.current) {
+									options.current = new Date();
+								} else {
+									options.current = parseDate(options.current, options.format);
+								} 
+								options.current.setDate(1);
+								options.current.setHours(0,0,0,0);
+								var id = 'datepicker_' + parseInt(Math.random() * 1000), cnt;
+								options.id = id;
+								$(this).data('datepickerId', options.id);
+								var cal = $(tpl.wrapper).attr('id', id).bind('click', click).data('datepicker', options);
+								if (options.className) {
+									cal.addClass(options.className);
+								}
+								var html = '';
+								for (var i = 0; i < options.calendars; i++) {
+									cnt = options.starts;
+									if (i > 0) {
+										html += tpl.space;
+									}
+									html += tmpl(tpl.head.join(''), {
+											week: options.locale.weekMin,
+											prev: options.prev,
+											next: options.next,
+											day1: options.locale.daysMin[(cnt++)%7],
+											day2: options.locale.daysMin[(cnt++)%7],
+											day3: options.locale.daysMin[(cnt++)%7],
+											day4: options.locale.daysMin[(cnt++)%7],
+											day5: options.locale.daysMin[(cnt++)%7],
+											day6: options.locale.daysMin[(cnt++)%7],
+											day7: options.locale.daysMin[(cnt++)%7]
+										});
+								}
+								cal
+									.find('tr:first').append(html)
+										.find('table').addClass(views[options.view]);
+								fill(cal.get(0));
+								if (options.flat) {
+									cal.appendTo(this).show().css('position', 'relative');
+									layout(cal.get(0));
+								} else {
+									cal.appendTo(document.body);
+									$(this).bind(options.eventName, show);
+								}
+							}
+						});
+					},
+					showPicker: function() {
+						return this.each( function () {
+							if ($(this).data('datepickerId')) {
+								show.apply(this);
+							}
+						});
+					},
+					hidePicker: function() {
+						return this.each( function () {
+							if ($(this).data('datepickerId')) {
+								$('#' + $(this).data('datepickerId')).hide();
+							}
+						});
+					},
+					setDate: function(date, shiftTo){
+						return this.each(function(){
+							if ($(this).data('datepickerId')) {
+								var cal = $('#' + $(this).data('datepickerId'));
+								var options = cal.data('datepicker');
+								options.date = date;
+								if (options.date.constructor == String) {
+									options.date = parseDate(options.date, options.format);
+									options.date.setHours(0,0,0,0);
+								}
+								if (options.mode != 'single') {
+									if (options.date.constructor != Array) {
+										options.date = [options.date.valueOf()];
+										if (options.mode == 'range') {
+											options.date.push(((new Date(options.date[0])).setHours(23,59,59,0)).valueOf());
+										}
+									} else {
+										for (var i = 0; i < options.date.length; i++) {
+											options.date[i] = (parseDate(options.date[i], options.format).setHours(0,0,0,0)).valueOf();
+										}
+										if (options.mode == 'range') {
+											options.date[1] = ((new Date(options.date[1])).setHours(23,59,59,0)).valueOf();
+										}
+									}
+								} else {
+									options.date = options.date.valueOf();
+								}
+								if (shiftTo) {
+									options.current = new Date (options.mode != 'single' ? options.date[0] : options.date);
+								}
+								fill(cal.get(0));
+							}
+						});
+					},
+					getDate: function(formated) {
+						if (this.size() > 0) {
+							return prepareDate($('#' + $(this).data('datepickerId')).data('datepicker'))[formated ? 0 : 1];
+						}
+					},
+					clear: function(){
+						return this.each(function(){
+							if ($(this).data('datepickerId')) {
+								var cal = $('#' + $(this).data('datepickerId'));
+								var options = cal.data('datepicker');
+								if (options.mode != 'single') {
+									options.date = [];
+									fill(cal.get(0));
+								}
+							}
+						});
+					},
+					fixLayout: function(){
+						return this.each(function(){
+							if ($(this).data('datepickerId')) {
+								var cal = $('#' + $(this).data('datepickerId'));
+								var options = cal.data('datepicker');
+								if (options.flat) {
+									layout(cal.get(0));
+								}
+							}
+						});
+					}
+				};
+			}();
+			$.fn.extend({
+				DatePicker: DatePicker.init,
+				DatePickerHide: DatePicker.hidePicker,
+				DatePickerShow: DatePicker.showPicker,
+				DatePickerSetDate: DatePicker.setDate,
+				DatePickerGetDate: DatePicker.getDate,
+				DatePickerClear: DatePicker.clear,
+				DatePickerLayout: DatePicker.fixLayout
+			});
+			  var cache = {};
+
+			   var tmpl = function(str, data){
+			     // Figure out if we're getting a template, or if we need to
+			     // load the template - and be sure to cache the result.
+			     var fn = !/\W/.test(str) ?
+			       cache[str] = cache[str] ||
+			         tmpl(document.getElementById(str).innerHTML) :
+			      
+			       // Generate a reusable function that will serve as a template
+			       // generator (and which will be cached).
+			       new Function("obj",
+			         "var p=[],print=function(){p.push.apply(p,arguments);};" +
+			        
+			         // Introduce the data as local variables using with(){}
+			         "with(obj){p.push('" +
+			        
+			         // Convert the template into pure JavaScript
+			         str
+			           .replace(/[\r\t\n]/g, " ")
+			           .split("<%").join("\t")
+			           .replace(/((^|%>)[^\t]*)'/g, "$1\r")
+			           .replace(/\t=(.*?)%>/g, "',$1,'")
+			           .split("\t").join("');")
+			           .split("%>").join("p.push('")
+			           .split("\r").join("\\'")
+			       + "');}return p.join('');");
+			    
+			     // Provide some basic currying to the user
+			     return data ? fn( data ) : fn;
+			   };
+		} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/bootstrap_alert.js b/public/js_src/external_libs/bootstrap_alert.js
new file mode 100644
index 0000000..fbe0a03
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_alert.js
@@ -0,0 +1,70 @@
+define( ["jquery_timely"],
+		function( $ ) {
+
+	  "use strict"; // jshint ;_;
+
+
+	 /* ALERT CLASS DEFINITION
+	  * ====================== */
+
+	  var dismiss = '[data-dismiss="alert"]'
+	    , Alert = function (el) {
+	        $(el).on('click', dismiss, this.close)
+	      }
+
+	  Alert.prototype.close = function (e) {
+	    var $this = $(this)
+	      , selector = $this.attr('data-target')
+	      , $parent
+
+	    if (!selector) {
+	      selector = $this.attr('href')
+	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
+	    }
+
+	    $parent = $(selector)
+
+	    e && e.preventDefault()
+
+	    $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())
+
+	    $parent.trigger(e = $.Event('close'))
+
+	    if (e.isDefaultPrevented()) return
+
+	    $parent.removeClass('in')
+
+	    function removeElement() {
+	      $parent
+	        .trigger('closed')
+	        .remove()
+	    }
+
+	    $.support.transition && $parent.hasClass('fade') ?
+	      $parent.on($.support.transition.end, removeElement) :
+	      removeElement()
+	  }
+
+
+	 /* ALERT PLUGIN DEFINITION
+	  * ======================= */
+
+	  $.fn.alert = function (option) {
+	    return this.each(function () {
+	      var $this = $(this)
+	        , data = $this.data('alert')
+	      if (!data) $this.data('alert', (data = new Alert(this)))
+	      if (typeof option == 'string') data[option].call($this)
+	    })
+	  }
+
+	  $.fn.alert.Constructor = Alert
+
+
+	 /* ALERT DATA-API
+	  * ============== */
+
+	  $(function () {
+	    $('body').on('click.alert.data-api', dismiss, Alert.prototype.close)
+	  })
+} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/bootstrap_collapse.js b/public/js_src/external_libs/bootstrap_collapse.js
new file mode 100644
index 0000000..2216be5
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_collapse.js
@@ -0,0 +1,157 @@
+define( ["jquery_timely"],
+	function( $ ) {
+
+/* =============================================================
+ * bootstrap-collapse.js v2.0.4
+ * http://twitter.github.com/bootstrap/javascript.html#collapse
+ * =============================================================
+ * Copyright 2012 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ============================================================ */
+
+  "use strict"; // jshint ;_;
+
+
+ /* COLLAPSE PUBLIC CLASS DEFINITION
+  * ================================ */
+
+  var Collapse = function (element, options) {
+    this.$element = $(element)
+    this.options = $.extend({}, $.fn.collapse.defaults, options)
+
+    if (this.options.parent) {
+      this.$parent = $(this.options.parent)
+    }
+
+    this.options.toggle && this.toggle()
+  }
+
+  Collapse.prototype = {
+
+    constructor: Collapse
+
+  , dimension: function () {
+      var hasWidth = this.$element.hasClass('width')
+      return hasWidth ? 'width' : 'height'
+    }
+
+  , show: function () {
+      var dimension
+        , scroll
+        , actives
+        , hasData
+
+      if (this.transitioning) return
+
+      dimension = this.dimension()
+      scroll = $.camelCase(['scroll', dimension].join('-'))
+      actives = this.$parent && this.$parent.find('> .accordion-group > .in')
+
+      if (actives && actives.length) {
+        hasData = actives.data('collapse')
+        if (hasData && hasData.transitioning) return
+        actives.collapse('hide')
+        hasData || actives.data('collapse', null)
+      }
+
+      this.$element[dimension](0)
+      this.transition('addClass', $.Event('show'), 'shown')
+      this.$element[dimension](this.$element[0][scroll])
+    }
+
+  , hide: function () {
+      var dimension
+      if (this.transitioning) return
+      dimension = this.dimension()
+      this.reset(this.$element[dimension]())
+      this.transition('removeClass', $.Event('hide'), 'hidden')
+      this.$element[dimension](0)
+    }
+
+  , reset: function (size) {
+      var dimension = this.dimension()
+
+      this.$element
+        .removeClass('collapse')
+        [dimension](size || 'auto')
+        [0].offsetWidth
+
+      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')
+
+      return this
+    }
+
+  , transition: function (method, startEvent, completeEvent) {
+      var that = this
+        , complete = function () {
+            if (startEvent.type == 'show') that.reset()
+            that.transitioning = 0
+            that.$element.trigger(completeEvent)
+          }
+
+      this.$element.trigger(startEvent)
+
+      if (startEvent.isDefaultPrevented()) return
+
+      this.transitioning = 1
+
+      this.$element[method]('in')
+
+      $.support.transition && this.$element.hasClass('collapse') ?
+        this.$element.one($.support.transition.end, complete) :
+        complete()
+    }
+
+  , toggle: function () {
+      this[this.$element.hasClass('in') ? 'hide' : 'show']()
+    }
+
+  }
+
+
+ /* COLLAPSIBLE PLUGIN DEFINITION
+  * ============================== */
+
+  $.fn.collapse = function (option) {
+    return this.each(function () {
+      var $this = $(this)
+        , data = $this.data('collapse')
+        , options = typeof option == 'object' && option
+      if (!data) $this.data('collapse', (data = new Collapse(this, options)))
+      if (typeof option == 'string') data[option]()
+    })
+  }
+
+  $.fn.collapse.defaults = {
+    toggle: true
+  }
+
+  $.fn.collapse.Constructor = Collapse
+
+
+ /* COLLAPSIBLE DATA-API
+  * ==================== */
+
+  $(function () {
+    $('body').on('click.collapse.data-api', '[data-toggle=ai1ec_collapse]', function ( e ) {
+      var $this = $(this), href
+        , target = $this.attr('data-target')
+          || e.preventDefault()
+          || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
+        , option = $(target).data('collapse') ? 'toggle' : $this.data()
+      $(target).collapse(option)
+    })
+  })
+
+} );
diff --git a/public/js_src/external_libs/bootstrap_colorpicker.js b/public/js_src/external_libs/bootstrap_colorpicker.js
new file mode 100644
index 0000000..b841212
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_colorpicker.js
@@ -0,0 +1,504 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+			
+	// Color object
+	
+	var Color = function(val) {
+		this.value = {
+			h: 1,
+			s: 1,
+			b: 1,
+			a: 1
+		};
+		this.setColor(val);
+	};
+	
+	Color.prototype = {
+		constructor: Color,
+		
+		//parse a string to HSB
+		setColor: function(val){
+			val = val.toLowerCase();
+			var that = this;
+			$.each( CPGlobal.stringParsers, function( i, parser ) {
+				var match = parser.re.exec( val ),
+					values = match && parser.parse( match ),
+					space = parser.space||'rgba';
+				if ( values ) {
+					if (space == 'hsla') {
+						that.value = CPGlobal.RGBtoHSB.apply(null, CPGlobal.HSLtoRGB.apply(null, values));
+					} else {
+						that.value = CPGlobal.RGBtoHSB.apply(null, values);
+					}
+					return false;
+				}
+			});
+		},
+		
+		setHue: function(h) {
+			this.value.h = 1- h;
+		},
+		
+		setSaturation: function(s) {
+			this.value.s = s;
+		},
+		
+		setLightness: function(b) {
+			this.value.b = 1- b;
+		},
+		
+		setAlpha: function(a) {
+			this.value.a = parseInt((1 - a)*100, 10)/100;
+		},
+		
+		// HSBtoRGB from RaphaelJS
+		// https://github.com/DmitryBaranovskiy/raphael/
+		toRGB: function(h, s, b, a) {
+			if (!h) {
+				h = this.value.h;
+				s = this.value.s;
+				b = this.value.b;
+			}
+			h *= 360;
+			var R, G, B, X, C;
+			h = (h % 360) / 60;
+			C = b * s;
+			X = C * (1 - Math.abs(h % 2 - 1));
+			R = G = B = b - C;
+
+			h = ~~h;
+			R += [C, X, 0, 0, X, C][h];
+			G += [X, C, C, X, 0, 0][h];
+			B += [0, 0, X, C, C, X][h];
+			return {
+				r: Math.round(R*255),
+				g: Math.round(G*255),
+				b: Math.round(B*255),
+				a: a||this.value.a
+			};
+		},
+		
+		toHex: function(h, s, b, a){
+			var rgb = this.toRGB(h, s, b, a);
+			return '#'+((1 << 24) | (parseInt(rgb.r) << 16) | (parseInt(rgb.g) << 8) | parseInt(rgb.b)).toString(16).substr(1);
+		},
+		
+		toHSL: function(h, s, b, a){
+			if (!h) {
+				h = this.value.h;
+				s = this.value.s;
+				b = this.value.b;
+			}
+			var H = h,
+				L = (2 - s) * b,
+				S = s * b;
+			if (L > 0 && L <= 1) {
+				S /= L;
+			} else {
+				S /= 2 - L;
+			}
+			L /= 2;
+			if (S > 1) {
+				S = 1;
+			}
+			return {
+				h: H,
+				s: S,
+				l: L,
+				a: a||this.value.a
+			};
+		}
+	};
+	
+	// Picker object
+	
+	var Colorpicker = function(element, options){
+		this.element = $(element);
+		var format = options.format||this.element.data('color-format')||'hex';
+		this.format = CPGlobal.translateFormats[format];
+		this.isInput = this.element.is('input');
+		this.component = this.element.is('.color') ? this.element.find('.add-on') : false;
+		
+		this.picker = $(CPGlobal.template)
+							.appendTo('body')
+							.on('mousedown', $.proxy(this.mousedown, this));
+		
+		if (this.isInput) {
+			this.element.on({
+				'focus': $.proxy(this.show, this),
+				'keyup': $.proxy(this.update, this)
+			});
+		} else if (this.component){
+			this.component.on({
+				'click': $.proxy(this.show, this)
+			});
+		} else {
+			this.element.on({
+				'click': $.proxy(this.show, this)
+			});
+		}
+		if (format == 'rgba' || format == 'hsla') {
+			this.picker.addClass('alpha');
+			this.alpha = this.picker.find('.colorpicker-alpha')[0].style;
+		}
+		
+		if (this.component){
+			this.picker.find('.colorpicker-color').hide();
+			this.preview = this.element.find('i')[0].style;
+		} else {
+			this.preview = this.picker.find('div:last')[0].style;
+		}
+		
+		this.base = this.picker.find('div:first')[0].style;
+		this.update();
+	};
+	
+	Colorpicker.prototype = {
+		constructor: Colorpicker,
+		
+		show: function(e) {
+			this.picker.show();
+			this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
+			this.place();
+			$(window).on('resize', $.proxy(this.place, this));
+			if (!this.isInput) {
+				if (e) {
+					e.stopPropagation();
+					e.preventDefault();
+				}
+			}
+			$(document).on({
+				'mousedown': $.proxy(this.hide, this)
+			});
+			this.element.trigger({
+				type: 'show',
+				color: this.color
+			});
+		},
+		
+		update: function(){
+			this.color = new Color(this.isInput ? this.element.prop('value') : this.element.data('color'));
+			this.picker.find('i')
+				.eq(0).css({left: this.color.value.s*100, top: 100 - this.color.value.b*100}).end()
+				.eq(1).css('top', 100 * (1 - this.color.value.h)).end()
+				.eq(2).css('top', 100 * (1 - this.color.value.a));
+			this.previewColor();
+		},
+		
+		hide: function(){
+			this.picker.hide();
+			$(window).off('resize', this.place);
+			if (!this.isInput) {
+				$(document).off({
+					'mousedown': this.hide
+				});
+				if (this.component){
+					this.element.find('input').prop('value', this.format.call(this));
+				}
+				this.element.data('color', this.format.call(this));
+			} else {
+				this.element.prop('value', this.format.call(this));
+			}
+			this.element.trigger({
+				type: 'hide',
+				color: this.color
+			});
+		},
+		
+		place: function(){
+			var offset = this.component ? this.component.offset() : this.element.offset();
+			this.picker.css({
+				top: offset.top + this.height,
+				left: offset.left
+			});
+		},
+		
+		//preview color change
+		previewColor: function(){
+			this.preview.backgroundColor = this.format.call(this);
+			//set the color for brightness/saturation slider
+			this.base.backgroundColor = this.color.toHex(this.color.value.h, 1, 1, 1);
+			//set te color for alpha slider
+			if (this.alpha) {
+				this.alpha.backgroundColor = this.color.toHex();
+			}
+		},
+		
+		pointer: null,
+		
+		slider: null,
+		
+		mousedown: function(e){
+			e.stopPropagation();
+			e.preventDefault();
+			
+			var target = $(e.target);
+			
+			//detect the slider and set the limits and callbacks
+			var zone = target.closest('div');
+			if (!zone.is('.colorpicker')) {
+				if (zone.is('.colorpicker-saturation')) {
+					this.slider = $.extend({}, CPGlobal.sliders['saturation']);
+				} 
+				else if (zone.is('.colorpicker-hue')) {
+					this.slider = $.extend({}, CPGlobal.sliders['hue']);
+				}
+				else if (zone.is('.colorpicker-alpha')) {
+					this.slider = $.extend({}, CPGlobal.sliders['alpha']);
+				}
+				var offset = zone.offset();
+				//reference to knob's style
+				this.slider.knob = zone.find('i')[0].style;
+				this.slider.left = e.pageX - offset.left;
+				this.slider.top = e.pageY - offset.top;
+				this.pointer = {
+					left: e.pageX,
+					top: e.pageY
+				};
+				//trigger mousemove to move the knob to the current position
+				$(document).on({
+					mousemove: $.proxy(this.mousemove, this),
+					mouseup: $.proxy(this.mouseup, this)
+				}).trigger('mousemove');
+			}
+			return false;
+		},
+		
+		mousemove: function(e){
+			e.stopPropagation();
+			e.preventDefault();
+			var left = Math.max(
+				0,
+				Math.min(
+					this.slider.maxLeft,
+					this.slider.left + ((e.pageX||this.pointer.left) - this.pointer.left)
+				)
+			);
+			var top = Math.max(
+				0,
+				Math.min(
+					this.slider.maxTop,
+					this.slider.top + ((e.pageY||this.pointer.top) - this.pointer.top)
+				)
+			);
+			this.slider.knob.left = left + 'px';
+			this.slider.knob.top = top + 'px';
+			if (this.slider.callLeft) {
+				this.color[this.slider.callLeft].call(this.color, left/100);
+			}
+			if (this.slider.callTop) {
+				this.color[this.slider.callTop].call(this.color, top/100);
+			}
+			this.previewColor();
+			this.element.trigger({
+				type: 'changeColor',
+				color: this.color
+			});
+			return false;
+		},
+		
+		mouseup: function(e){
+			e.stopPropagation();
+			e.preventDefault();
+			$(document).off({
+				mousemove: this.mousemove,
+				mouseup: this.mouseup
+			});
+			return false;
+		}
+	}
+
+	$.fn.colorpicker = function ( option ) {
+		return this.each(function () {
+			var $this = $(this),
+				data = $this.data('colorpicker'),
+				options = typeof option == 'object' && option;
+			if (!data) {
+				$this.data('colorpicker', (data = new Colorpicker(this, $.extend({}, $.fn.colorpicker.defaults,options))));
+			}
+			if (typeof option == 'string') data[option]();
+		});
+	};
+
+	$.fn.colorpicker.defaults = {
+	};
+	
+	$.fn.colorpicker.Constructor = Colorpicker;
+	
+	var CPGlobal = {
+	
+		// translate a format from Color object to a string
+		translateFormats: {
+			'rgb': function(){
+				var rgb = this.color.toRGB();
+				return 'rgb('+rgb.r+','+rgb.g+','+rgb.b+')';
+			},
+			
+			'rgba': function(){
+				var rgb = this.color.toRGB();
+				return 'rgba('+rgb.r+','+rgb.g+','+rgb.b+','+rgb.a+')';
+			},
+			
+			'hsl': function(){
+				var hsl = this.color.toHSL();
+				return 'hsl('+Math.round(hsl.h*360)+','+Math.round(hsl.s*100)+'%,'+Math.round(hsl.l*100)+'%)';
+			},
+			
+			'hsla': function(){
+				var hsl = this.color.toHSL();
+				return 'hsla('+Math.round(hsl.h*360)+','+Math.round(hsl.s*100)+'%,'+Math.round(hsl.l*100)+'%,'+hsl.a+')';
+			},
+			
+			'hex': function(){
+				return  this.color.toHex();
+			}
+		},
+		
+		sliders: {
+			saturation: {
+				maxLeft: 100,
+				maxTop: 100,
+				callLeft: 'setSaturation',
+				callTop: 'setLightness'
+			},
+			
+			hue: {
+				maxLeft: 0,
+				maxTop: 100,
+				callLeft: false,
+				callTop: 'setHue'
+			},
+			
+			alpha: {
+				maxLeft: 0,
+				maxTop: 100,
+				callLeft: false,
+				callTop: 'setAlpha'
+			}
+		},
+		
+		// HSBtoRGB from RaphaelJS
+		// https://github.com/DmitryBaranovskiy/raphael/
+		RGBtoHSB: function (r, g, b, a){
+			r /= 255;
+			g /= 255;
+			b /= 255;
+
+			var H, S, V, C;
+			V = Math.max(r, g, b);
+			C = V - Math.min(r, g, b);
+			H = (C == 0 ? null :
+				 V == r ? (g - b) / C :
+				 V == g ? (b - r) / C + 2 :
+						  (r - g) / C + 4
+				);
+			H = ((H + 360) % 6) * 60 / 360;
+			S = C == 0 ? 0 : C / V;
+			return {h: H||1, s: S, b: V, a: a||1};
+		},
+		
+		HueToRGB: function (p, q, h) {
+			if (h < 0)
+				h += 1;
+			else if (h > 1)
+				h -= 1;
+
+			if ((h * 6) < 1)
+				return p + (q - p) * h * 6;
+			else if ((h * 2) < 1)
+				return q;
+			else if ((h * 3) < 2)
+				return p + (q - p) * ((2 / 3) - h) * 6;
+			else
+				return p;
+		},
+	
+		HSLtoRGB: function (h, s, l, a)
+		{
+
+			if (s < 0)
+				s = 0;
+
+			if (l <= 0.5)
+				var q = l * (1 + s);
+			else
+				var q = l + s - (l * s);
+
+			var p = 2 * l - q;
+
+			var tr = h + (1 / 3);
+			var tg = h;
+			var tb = h - (1 / 3);
+
+			var r = Math.round(CPGlobal.HueToRGB(p, q, tr) * 255);
+			var g = Math.round(CPGlobal.HueToRGB(p, q, tg) * 255);
+			var b = Math.round(CPGlobal.HueToRGB(p, q, tb) * 255);
+			return [r, g, b, a||1];
+		},
+		
+		// a set of RE's that can match strings and generate color tuples.
+		// from John Resig color plugin
+		// https://github.com/jquery/jquery-color/
+		stringParsers: [
+			{
+				re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
+				parse: function( execResult ) {
+					return [
+						execResult[ 1 ],
+						execResult[ 2 ],
+						execResult[ 3 ],
+						execResult[ 4 ]
+					];
+				}
+			}, {
+				re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
+				parse: function( execResult ) {
+					return [
+						2.55 * execResult[1],
+						2.55 * execResult[2],
+						2.55 * execResult[3],
+						execResult[ 4 ]
+					];
+				}
+			}, {
+				re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
+				parse: function( execResult ) {
+					return [
+						parseInt( execResult[ 1 ], 16 ),
+						parseInt( execResult[ 2 ], 16 ),
+						parseInt( execResult[ 3 ], 16 )
+					];
+				}
+			}, {
+				re: /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/,
+				parse: function( execResult ) {
+					return [
+						parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
+						parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
+						parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
+					];
+				}
+			}, {
+				re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
+				space: 'hsla',
+				parse: function( execResult ) {
+					return [
+						execResult[1]/360,
+						execResult[2] / 100,
+						execResult[3] / 100,
+						execResult[4]
+					];
+				}
+			}
+		],
+		template: '<div class="colorpicker dropdown-menu">'+
+							'<div class="colorpicker-saturation"><i><b></b></i></div>'+
+							'<div class="colorpicker-hue"><i></i></div>'+
+							'<div class="colorpicker-alpha"><i></i></div>'+
+							'<div class="colorpicker-color"><div /></div>'+
+						'</div>'
+	};
+});
diff --git a/public/js_src/external_libs/bootstrap_datepicker.js b/public/js_src/external_libs/bootstrap_datepicker.js
new file mode 100644
index 0000000..716ab9a
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_datepicker.js
@@ -0,0 +1,877 @@
+/* =========================================================
+ * bootstrap-datepicker.js
+ * http://www.eyecon.ro/bootstrap-datepicker
+ * =========================================================
+ * Copyright 2012 Stefan Petre
+ * Improvements by Andrew Rowls
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ========================================================= */
+
+define(
+	[
+		"jquery_timely",
+		"ai1ec_config",
+		"external_libs/locales/bootstrap-datepicker.bg",
+		"external_libs/locales/bootstrap-datepicker.br",
+		"external_libs/locales/bootstrap-datepicker.cs",
+		"external_libs/locales/bootstrap-datepicker.da",
+		"external_libs/locales/bootstrap-datepicker.de",
+		"external_libs/locales/bootstrap-datepicker.es",
+		"external_libs/locales/bootstrap-datepicker.fi",
+		"external_libs/locales/bootstrap-datepicker.fr",
+		"external_libs/locales/bootstrap-datepicker.id",
+		"external_libs/locales/bootstrap-datepicker.is",
+		"external_libs/locales/bootstrap-datepicker.it",
+		"external_libs/locales/bootstrap-datepicker.ja",
+		"external_libs/locales/bootstrap-datepicker.kr",
+		"external_libs/locales/bootstrap-datepicker.lt",
+		"external_libs/locales/bootstrap-datepicker.lv",
+		"external_libs/locales/bootstrap-datepicker.ms",
+		"external_libs/locales/bootstrap-datepicker.nb",
+		"external_libs/locales/bootstrap-datepicker.nl",
+		"external_libs/locales/bootstrap-datepicker.pl",
+		"external_libs/locales/bootstrap-datepicker.pt-BR",
+		"external_libs/locales/bootstrap-datepicker.pt",
+		"external_libs/locales/bootstrap-datepicker.ru",
+		"external_libs/locales/bootstrap-datepicker.sl",
+		"external_libs/locales/bootstrap-datepicker.sv",
+		"external_libs/locales/bootstrap-datepicker.th",
+		"external_libs/locales/bootstrap-datepicker.tr",
+		"external_libs/locales/bootstrap-datepicker.zh-CN",
+		"external_libs/locales/bootstrap-datepicker.zh-TW"
+	],
+	function(
+		$,
+		ai1ec_config
+	) {
+
+	function UTCDate(){
+		return new Date(Date.UTC.apply(Date, arguments));
+	}
+	function UTCToday(){
+		var today = new Date();
+		return UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());
+	}
+
+	// Picker object
+
+	var Datepicker = function(element, options) {
+		var that = this;
+
+		this.element = $(element);
+		this.language = options.language||this.element.data('date-language')||ai1ec_config.language||"en";
+		this.language = this.language in dates ? this.language : "en";
+		this.format = DPGlobal.parseFormat(options.format||this.element.data('date-format')||'mm/dd/yyyy');
+		this.picker = $(DPGlobal.template)
+							.appendTo('body')
+							.on({
+								click: $.proxy(this.click, this)
+							});
+		this.isInput = this.element.is('input');
+		this.component = this.element.is('.date') ? this.element.find('.add-on') : false;
+		this.hasInput = this.component && this.element.find('input').length;
+		if(this.component && this.component.length === 0)
+			this.component = false;
+
+		if (this.isInput) {
+			this.element.on({
+				focus: $.proxy(this.show, this),
+				keyup: $.proxy(this.update, this),
+				keydown: $.proxy(this.keydown, this)
+			});
+		} else {
+			if (this.component && this.hasInput){
+				// For components that are not readonly, allow keyboard nav
+				this.element.find('input').on({
+					focus: $.proxy(this.show, this),
+					keyup: $.proxy(this.update, this),
+					keydown: $.proxy(this.keydown, this)
+				});
+
+				this.component.on('click', $.proxy(this.show, this));
+			} else {
+				this.element.on('click', $.proxy(this.show, this));
+			}
+		}
+
+		$(document).on('mousedown', function (e) {
+			// Clicked outside the datepicker, hide it
+			if ($(e.target).closest('.datepicker').length == 0) {
+				that.hide();
+			}
+		});
+
+		this.autoclose = false;
+		if ('autoclose' in options) {
+			this.autoclose = options.autoclose;
+		} else if ('dateAutoclose' in this.element.data()) {
+			this.autoclose = this.element.data('date-autoclose');
+		}
+
+		this.keyboardNavigation = true;
+		if ('keyboardNavigation' in options) {
+			this.keyboardNavigation = options.keyboardNavigation;
+		} else if ('dateKeyboardNavigation' in this.element.data()) {
+			this.keyboardNavigation = this.element.data('date-keyboard-navigation');
+		}
+
+		switch(options.startView || this.element.data('date-start-view')){
+			case 2:
+			case 'decade':
+				this.viewMode = this.startViewMode = 2;
+				break;
+			case 1:
+			case 'year':
+				this.viewMode = this.startViewMode = 1;
+				break;
+			case 0:
+			case 'month':
+			default:
+				this.viewMode = this.startViewMode = 0;
+				break;
+		}
+
+		this.todayBtn = (options.todayBtn||this.element.data('date-today-btn')||false);
+		this.todayHighlight = (options.todayHighlight||this.element.data('date-today-highlight')||false);
+
+		this.weekStart = ((options.weekStart||this.element.data('date-weekstart')||dates[this.language].weekStart||0) % 7);
+		this.weekEnd = ((this.weekStart + 6) % 7);
+		this.startDate = -Infinity;
+		this.endDate = Infinity;
+		this.setStartDate(options.startDate||this.element.data('date-startdate'));
+		this.setEndDate(options.endDate||this.element.data('date-enddate'));
+		this.fillDow();
+		this.fillMonths();
+		this.update();
+		this.showMode();
+	};
+
+	Datepicker.prototype = {
+		constructor: Datepicker,
+
+		show: function(e) {
+			this.picker.show();
+			this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
+			this.update();
+			this.place();
+			$(window).on('resize', $.proxy(this.place, this));
+			if (e ) {
+				e.stopPropagation();
+				e.preventDefault();
+			}
+			this.element.trigger({
+				type: 'show',
+				date: this.date
+			});
+		},
+
+		hide: function(e){
+			this.picker.hide();
+			$(window).off('resize', this.place);
+			this.viewMode = this.startViewMode;
+			this.showMode();
+			if (!this.isInput) {
+				$(document).off('mousedown', this.hide);
+			}
+			if (e && e.currentTarget.value)
+				this.setValue();
+			this.element.trigger({
+				type: 'hide',
+				date: this.date
+			});
+		},
+
+		getDate: function() {
+			var d = this.getUTCDate();
+			return new Date(d.getTime() + (d.getTimezoneOffset()*60000))
+		},
+
+		getUTCDate: function() {
+			return this.date;
+		},
+
+		setDate: function(d) {
+			this.setUTCDate(new Date(d.getTime() - (d.getTimezoneOffset()*60000)));
+		},
+
+		setUTCDate: function(d) {
+			this.date = d;
+			this.setValue();
+		},
+
+		setValue: function() {
+			var formatted = DPGlobal.formatDate(this.date, this.format, this.language);
+			if (!this.isInput) {
+				if (this.component){
+					this.element.find('input').prop('value', formatted);
+				}
+				this.element.data('date', formatted);
+			} else {
+				this.element.prop('value', formatted);
+			}
+		},
+
+		setStartDate: function(startDate){
+			this.startDate = startDate||-Infinity;
+			if (this.startDate !== -Infinity) {
+				this.startDate = DPGlobal.parseDate(this.startDate, this.format, this.language);
+			}
+			this.update();
+			this.updateNavArrows();
+		},
+
+		setEndDate: function(endDate){
+			this.endDate = endDate||Infinity;
+			if (this.endDate !== Infinity) {
+				this.endDate = DPGlobal.parseDate(this.endDate, this.format, this.language);
+			}
+			this.update();
+			this.updateNavArrows();
+		},
+
+		place: function(){
+			var zIndex = parseInt(this.element.parents().filter(function() {
+							return $(this).css('z-index') != 'auto';
+						}).first().css('z-index'))+10;
+			var offset = this.component ? this.component.offset() : this.element.offset();
+			this.picker.css({
+				top: offset.top + this.height,
+				left: offset.left,
+				zIndex: zIndex
+			});
+		},
+
+		update: function(){
+			this.date = DPGlobal.parseDate(
+				this.isInput ? this.element.prop('value') : this.element.data('date') || this.element.find('input').prop('value'),
+				this.format, this.language
+			);
+			if (this.date < this.startDate) {
+				this.viewDate = new Date(this.startDate);
+			} else if (this.date > this.endDate) {
+				this.viewDate = new Date(this.endDate);
+			} else {
+				this.viewDate = new Date(this.date);
+			}
+			this.fill();
+		},
+
+		fillDow: function(){
+			var dowCnt = this.weekStart;
+			var html = '<tr>';
+			while (dowCnt < this.weekStart + 7) {
+				html += '<th class="dow">'+dates[this.language].daysMin[(dowCnt++)%7]+'</th>';
+			}
+			html += '</tr>';
+			this.picker.find('.datepicker-days thead').append(html);
+		},
+
+		fillMonths: function(){
+			var html = '';
+			var i = 0
+			while (i < 12) {
+				html += '<span class="month">'+dates[this.language].monthsShort[i++]+'</span>';
+			}
+			this.picker.find('.datepicker-months td').html(html);
+		},
+
+		fill: function() {
+			var d = new Date(this.viewDate),
+				year = d.getUTCFullYear(),
+				month = d.getUTCMonth(),
+				startYear = this.startDate !== -Infinity ? this.startDate.getUTCFullYear() : -Infinity,
+				startMonth = this.startDate !== -Infinity ? this.startDate.getUTCMonth() : -Infinity,
+				endYear = this.endDate !== Infinity ? this.endDate.getUTCFullYear() : Infinity,
+				endMonth = this.endDate !== Infinity ? this.endDate.getUTCMonth() : Infinity,
+				currentDate = this.date.valueOf(),
+				today = new Date();
+			this.picker.find('.datepicker-days thead th:eq(1)')
+						.text(dates[this.language].months[month]+' '+year);
+			this.picker.find('tfoot th.today')
+						.text(dates[this.language].today)
+						.toggle(this.todayBtn);
+			this.updateNavArrows();
+			this.fillMonths();
+			var prevMonth = UTCDate(year, month-1, 28,0,0,0,0),
+				day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
+			prevMonth.setUTCDate(day);
+			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.weekStart + 7)%7);
+			var nextMonth = new Date(prevMonth);
+			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
+			nextMonth = nextMonth.valueOf();
+			var html = [];
+			var clsName;
+			while(prevMonth.valueOf() < nextMonth) {
+				if (prevMonth.getUTCDay() == this.weekStart) {
+					html.push('<tr>');
+				}
+				clsName = '';
+				if (prevMonth.getUTCFullYear() < year || (prevMonth.getUTCFullYear() == year && prevMonth.getUTCMonth() < month)) {
+					clsName += ' old';
+				} else if (prevMonth.getUTCFullYear() > year || (prevMonth.getUTCFullYear() == year && prevMonth.getUTCMonth() > month)) {
+					clsName += ' new';
+				}
+				// Compare internal UTC date with local today, not UTC today
+				if (this.todayHighlight &&
+					prevMonth.getUTCFullYear() == today.getFullYear() &&
+					prevMonth.getUTCMonth() == today.getMonth() &&
+					prevMonth.getUTCDate() == today.getDate()) {
+					clsName += ' today';
+				}
+				if (prevMonth.valueOf() == currentDate) {
+					clsName += ' active';
+				}
+				if (prevMonth.valueOf() < this.startDate || prevMonth.valueOf() > this.endDate) {
+					clsName += ' disabled';
+				}
+				html.push('<td class="day'+clsName+'">'+prevMonth.getUTCDate() + '</td>');
+				if (prevMonth.getUTCDay() == this.weekEnd) {
+					html.push('</tr>');
+				}
+				prevMonth.setUTCDate(prevMonth.getUTCDate()+1);
+			}
+			this.picker.find('.datepicker-days tbody').empty().append(html.join(''));
+			var currentYear = this.date.getUTCFullYear();
+
+			var months = this.picker.find('.datepicker-months')
+						.find('th:eq(1)')
+							.text(year)
+							.end()
+						.find('span').removeClass('active');
+			if (currentYear == year) {
+				months.eq(this.date.getUTCMonth()).addClass('active');
+			}
+			if (year < startYear || year > endYear) {
+				months.addClass('disabled');
+			}
+			if (year == startYear) {
+				months.slice(0, startMonth).addClass('disabled');
+			}
+			if (year == endYear) {
+				months.slice(endMonth+1).addClass('disabled');
+			}
+
+			html = '';
+			year = parseInt(year/10, 10) * 10;
+			var yearCont = this.picker.find('.datepicker-years')
+								.find('th:eq(1)')
+									.text(year + '-' + (year + 9))
+									.end()
+								.find('td');
+			year -= 1;
+			for (var i = -1; i < 11; i++) {
+				html += '<span class="year'+(i == -1 || i == 10 ? ' old' : '')+(currentYear == year ? ' active' : '')+(year < startYear || year > endYear ? ' disabled' : '')+'">'+year+'</span>';
+				year += 1;
+			}
+			yearCont.html(html);
+		},
+
+		updateNavArrows: function() {
+			var d = new Date(this.viewDate),
+				year = d.getUTCFullYear(),
+				month = d.getUTCMonth();
+			switch (this.viewMode) {
+				case 0:
+					if (this.startDate !== -Infinity && year <= this.startDate.getUTCFullYear() && month <= this.startDate.getUTCMonth()) {
+						this.picker.find('.prev').css({visibility: 'hidden'});
+					} else {
+						this.picker.find('.prev').css({visibility: 'visible'});
+					}
+					if (this.endDate !== Infinity && year >= this.endDate.getUTCFullYear() && month >= this.endDate.getUTCMonth()) {
+						this.picker.find('.next').css({visibility: 'hidden'});
+					} else {
+						this.picker.find('.next').css({visibility: 'visible'});
+					}
+					break;
+				case 1:
+				case 2:
+					if (this.startDate !== -Infinity && year <= this.startDate.getUTCFullYear()) {
+						this.picker.find('.prev').css({visibility: 'hidden'});
+					} else {
+						this.picker.find('.prev').css({visibility: 'visible'});
+					}
+					if (this.endDate !== Infinity && year >= this.endDate.getUTCFullYear()) {
+						this.picker.find('.next').css({visibility: 'hidden'});
+					} else {
+						this.picker.find('.next').css({visibility: 'visible'});
+					}
+					break;
+			}
+		},
+
+		click: function(e) {
+			e.stopPropagation();
+			e.preventDefault();
+			var target = $(e.target).closest('span, td, th');
+			if (target.length == 1) {
+				switch(target[0].nodeName.toLowerCase()) {
+					case 'th':
+						switch(target[0].className) {
+							case 'switch':
+								this.showMode(1);
+								break;
+							case 'prev':
+							case 'next':
+								var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);
+								switch(this.viewMode){
+									case 0:
+										this.viewDate = this.moveMonth(this.viewDate, dir);
+										break;
+									case 1:
+									case 2:
+										this.viewDate = this.moveYear(this.viewDate, dir);
+										break;
+								}
+								this.fill();
+								break;
+							case 'today':
+								var date = new Date();
+								date.setUTCHours(0);
+								date.setUTCMinutes(0);
+								date.setUTCSeconds(0);
+								date.setUTCMilliseconds(0);
+
+								this.showMode(-2);
+								var which = this.todayBtn == 'linked' ? null : 'view';
+								this._setDate(date, which);
+								break;
+						}
+						break;
+					case 'span':
+						if (!target.is('.disabled')) {
+							this.viewDate.setUTCDate(1);
+							if (target.is('.month')) {
+								var month = target.parent().find('span').index(target);
+								this.viewDate.setUTCMonth(month);
+								this.element.trigger({
+									type: 'changeMonth',
+									date: this.viewDate
+								});
+							} else {
+								var year = parseInt(target.text(), 10)||0;
+								this.viewDate.setUTCFullYear(year);
+								this.element.trigger({
+									type: 'changeYear',
+									date: this.viewDate
+								});
+							}
+							this.showMode(-1);
+							this.fill();
+						}
+						break;
+					case 'td':
+						if (target.is('.day') && !target.is('.disabled')){
+							var day = parseInt(target.text(), 10)||1;
+							var year = this.viewDate.getUTCFullYear(),
+								month = this.viewDate.getUTCMonth();
+							if (target.is('.old')) {
+								if (month == 0) {
+									month = 11;
+									year -= 1;
+								} else {
+									month -= 1;
+								}
+							} else if (target.is('.new')) {
+								if (month == 11) {
+									month = 0;
+									year += 1;
+								} else {
+									month += 1;
+								}
+							}
+							this._setDate(UTCDate(year, month, day,0,0,0,0));
+						}
+						break;
+				}
+			}
+		},
+
+		_setDate: function(date, which){
+			if (!which || which == 'date')
+				this.date = date;
+			if (!which || which  == 'view')
+				this.viewDate = date;
+			this.fill();
+			this.setValue();
+			this.element.trigger({
+				type: 'changeDate',
+				date: this.date
+			});
+			var element;
+			if (this.isInput) {
+				element = this.element;
+			} else if (this.component){
+				element = this.element.find('input');
+			}
+			if (element) {
+				element.change();
+				if (this.autoclose) {
+									this.hide();
+				}
+			}
+		},
+
+		moveMonth: function(date, dir){
+			if (!dir) return date;
+			var new_date = new Date(date.valueOf()),
+				day = new_date.getUTCDate(),
+				month = new_date.getUTCMonth(),
+				mag = Math.abs(dir),
+				new_month, test;
+			dir = dir > 0 ? 1 : -1;
+			if (mag == 1){
+				test = dir == -1
+					// If going back one month, make sure month is not current month
+					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
+					? function(){ return new_date.getUTCMonth() == month; }
+					// If going forward one month, make sure month is as expected
+					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
+					: function(){ return new_date.getUTCMonth() != new_month; };
+				new_month = month + dir;
+				new_date.setUTCMonth(new_month);
+				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
+				if (new_month < 0 || new_month > 11)
+					new_month = (new_month + 12) % 12;
+			} else {
+				// For magnitudes >1, move one month at a time...
+				for (var i=0; i<mag; i++)
+					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
+					new_date = this.moveMonth(new_date, dir);
+				// ...then reset the day, keeping it in the new month
+				new_month = new_date.getUTCMonth();
+				new_date.setUTCDate(day);
+				test = function(){ return new_month != new_date.getUTCMonth(); };
+			}
+			// Common date-resetting loop -- if date is beyond end of month, make it
+			// end of month
+			while (test()){
+				new_date.setUTCDate(--day);
+				new_date.setUTCMonth(new_month);
+			}
+			return new_date;
+		},
+
+		moveYear: function(date, dir){
+			return this.moveMonth(date, dir*12);
+		},
+
+		dateWithinRange: function(date){
+			return date >= this.startDate && date <= this.endDate;
+		},
+
+		keydown: function(e){
+			if (this.picker.is(':not(:visible)')){
+				if (e.keyCode == 27) // allow escape to hide and re-show picker
+					this.show();
+				return;
+			}
+			var dateChanged = false,
+				dir, day, month,
+				newDate, newViewDate;
+			switch(e.keyCode){
+				case 27: // escape
+					this.hide();
+					e.preventDefault();
+					break;
+				case 37: // left
+				case 39: // right
+					if (!this.keyboardNavigation) break;
+					dir = e.keyCode == 37 ? -1 : 1;
+					if (e.ctrlKey){
+						newDate = this.moveYear(this.date, dir);
+						newViewDate = this.moveYear(this.viewDate, dir);
+					} else if (e.shiftKey){
+						newDate = this.moveMonth(this.date, dir);
+						newViewDate = this.moveMonth(this.viewDate, dir);
+					} else {
+						newDate = new Date(this.date);
+						newDate.setUTCDate(this.date.getUTCDate() + dir);
+						newViewDate = new Date(this.viewDate);
+						newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);
+					}
+					if (this.dateWithinRange(newDate)){
+						this.date = newDate;
+						this.viewDate = newViewDate;
+						this.setValue();
+						this.update();
+						e.preventDefault();
+						dateChanged = true;
+					}
+					break;
+				case 38: // up
+				case 40: // down
+					if (!this.keyboardNavigation) break;
+					dir = e.keyCode == 38 ? -1 : 1;
+					if (e.ctrlKey){
+						newDate = this.moveYear(this.date, dir);
+						newViewDate = this.moveYear(this.viewDate, dir);
+					} else if (e.shiftKey){
+						newDate = this.moveMonth(this.date, dir);
+						newViewDate = this.moveMonth(this.viewDate, dir);
+					} else {
+						newDate = new Date(this.date);
+						newDate.setUTCDate(this.date.getUTCDate() + dir * 7);
+						newViewDate = new Date(this.viewDate);
+						newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);
+					}
+					if (this.dateWithinRange(newDate)){
+						this.date = newDate;
+						this.viewDate = newViewDate;
+						this.setValue();
+						this.update();
+						e.preventDefault();
+						dateChanged = true;
+					}
+					break;
+				case 13: // enter
+					this.hide();
+					e.preventDefault();
+					break;
+				case 9: // tab
+					this.hide();
+					break;
+			}
+			if (dateChanged){
+				this.element.trigger({
+					type: 'changeDate',
+					date: this.date
+				});
+				var element;
+				if (this.isInput) {
+					element = this.element;
+				} else if (this.component){
+					element = this.element.find('input');
+				}
+				if (element) {
+					element.change();
+				}
+			}
+		},
+
+		showMode: function(dir) {
+			if (dir) {
+				this.viewMode = Math.max(0, Math.min(2, this.viewMode + dir));
+			}
+			this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();
+			this.updateNavArrows();
+		}
+	};
+
+	$.fn.datepicker = function ( option ) {
+		var args = Array.apply(null, arguments);
+		args.shift();
+		return this.each(function () {
+			var $this = $(this),
+				data = $this.data('datepicker'),
+				options = typeof option == 'object' && option;
+			if (!data) {
+				$this.data('datepicker', (data = new Datepicker(this, $.extend({}, $.fn.datepicker.defaults,options))));
+			}
+			if (typeof option == 'string' && typeof data[option] == 'function') {
+				data[option].apply(data, args);
+			}
+		});
+	};
+
+	$.fn.datepicker.defaults = {
+	};
+	$.fn.datepicker.Constructor = Datepicker;
+	var dates = $.fn.datepicker.dates = {
+		en: {
+			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
+			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
+			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
+			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
+			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
+			today: "Today"
+		}
+	}
+
+	var DPGlobal = {
+		modes: [
+			{
+				clsName: 'days',
+				navFnc: 'Month',
+				navStep: 1
+			},
+			{
+				clsName: 'months',
+				navFnc: 'FullYear',
+				navStep: 1
+			},
+			{
+				clsName: 'years',
+				navFnc: 'FullYear',
+				navStep: 10
+		}],
+		isLeapYear: function (year) {
+			return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0))
+		},
+		getDaysInMonth: function (year, month) {
+			return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
+		},
+		validParts: /dd?|mm?|MM?|yy(?:yy)?/g,
+		nonpunctuation: /[^ -\/:-@\[-`{-~\t\n\r]+/g,
+		parseFormat: function(format){
+			// IE treats \0 as a string end in inputs (truncating the value),
+			// so it's a bad format delimiter, anyway
+			var separators = format.replace(this.validParts, '\0').split('\0'),
+				parts = format.match(this.validParts);
+			if (!separators || !separators.length || !parts || parts.length == 0){
+				throw new Error("Invalid date format.");
+			}
+			return {separators: separators, parts: parts};
+		},
+		parseDate: function(date, format, language) {
+			if (date instanceof Date) return date;
+			if (/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(date)) {
+				var part_re = /([-+]\d+)([dmwy])/,
+					parts = date.match(/([-+]\d+)([dmwy])/g),
+					part, dir;
+				date = new Date();
+				for (var i=0; i<parts.length; i++) {
+					part = part_re.exec(parts[i]);
+					dir = parseInt(part[1]);
+					switch(part[2]){
+						case 'd':
+							date.setUTCDate(date.getUTCDate() + dir);
+							break;
+						case 'm':
+							date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
+							break;
+						case 'w':
+							date.setUTCDate(date.getUTCDate() + dir * 7);
+							break;
+						case 'y':
+							date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
+							break;
+					}
+				}
+				return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
+			}
+			var parts = date && date.match(this.nonpunctuation) || [],
+				date = new Date(),
+				parsed = {},
+				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
+				setters_map = {
+					yyyy: function(d,v){ return d.setUTCFullYear(v); },
+					yy: function(d,v){ return d.setUTCFullYear(2000+v); },
+					m: function(d,v){
+						v -= 1;
+						while (v<0) v += 12;
+						v %= 12;
+						d.setUTCMonth(v);
+						while (d.getUTCMonth() != v)
+							d.setUTCDate(d.getUTCDate()-1);
+						return d;
+					},
+					d: function(d,v){ return d.setUTCDate(v); }
+				},
+				val, filtered, part;
+			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
+			setters_map['dd'] = setters_map['d'];
+			date = UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
+			if (parts.length == format.parts.length) {
+				for (var i=0, cnt = format.parts.length; i < cnt; i++) {
+					val = parseInt(parts[i], 10);
+					part = format.parts[i];
+					if (isNaN(val)) {
+						switch(part) {
+							case 'MM':
+								filtered = $(dates[language].months).filter(function(){
+									var m = this.slice(0, parts[i].length),
+										p = parts[i].slice(0, m.length);
+									return m == p;
+								});
+								val = $.inArray(filtered[0], dates[language].months) + 1;
+								break;
+							case 'M':
+								filtered = $(dates[language].monthsShort).filter(function(){
+									var m = this.slice(0, parts[i].length),
+										p = parts[i].slice(0, m.length);
+									return m == p;
+								});
+								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
+								break;
+						}
+					}
+					parsed[part] = val;
+				}
+				for (var i=0, s; i<setters_order.length; i++){
+					s = setters_order[i];
+					if (s in parsed)
+						setters_map[s](date, parsed[s])
+				}
+			}
+			return date;
+		},
+		formatDate: function(date, format, language){
+			var val = {
+				d: date.getUTCDate(),
+				m: date.getUTCMonth() + 1,
+				M: dates[language].monthsShort[date.getUTCMonth()],
+				MM: dates[language].months[date.getUTCMonth()],
+				yy: date.getUTCFullYear().toString().substring(2),
+				yyyy: date.getUTCFullYear()
+			};
+			val.dd = (val.d < 10 ? '0' : '') + val.d;
+			val.mm = (val.m < 10 ? '0' : '') + val.m;
+			var date = [],
+				seps = $.extend([], format.separators);
+			for (var i=0, cnt = format.parts.length; i < cnt; i++) {
+				if (seps.length)
+					date.push(seps.shift())
+				date.push(val[format.parts[i]]);
+			}
+			return date.join('');
+		},
+		headTemplate: '<thead>'+
+							'<tr>'+
+								'<th class="prev"><i class="icon-arrow-left"/></th>'+
+								'<th colspan="5" class="switch"></th>'+
+								'<th class="next"><i class="icon-arrow-right"/></th>'+
+							'</tr>'+
+						'</thead>',
+		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
+		footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr></tfoot>'
+	};
+	DPGlobal.template = '<div class="datepicker dropdown-menu">'+
+							'<div class="datepicker-days">'+
+								'<table class=" table-condensed">'+
+									DPGlobal.headTemplate+
+									'<tbody></tbody>'+
+									DPGlobal.footTemplate+
+								'</table>'+
+							'</div>'+
+							'<div class="datepicker-months">'+
+								'<table class="table-condensed">'+
+									DPGlobal.headTemplate+
+									DPGlobal.contTemplate+
+									DPGlobal.footTemplate+
+								'</table>'+
+							'</div>'+
+							'<div class="datepicker-years">'+
+								'<table class="table-condensed">'+
+									DPGlobal.headTemplate+
+									DPGlobal.contTemplate+
+									DPGlobal.footTemplate+
+								'</table>'+
+							'</div>'+
+						'</div>';
+
+	// Load language files.
+	for ( var i = 2, len = arguments.length; i < len; i++ ) {
+		arguments[i].localize();
+	}
+} );
diff --git a/public/js_src/external_libs/bootstrap_dropdown.js b/public/js_src/external_libs/bootstrap_dropdown.js
new file mode 100644
index 0000000..b735fdf
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_dropdown.js
@@ -0,0 +1,105 @@
+define(
+		[
+		 "jquery_timely",
+		 "domReady"
+		 ],
+		 function( $, domReady ) {
+			/* ============================================================
+			 * bootstrap-dropdown.js v2.0.3
+			 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
+			 * ============================================================
+			 * Copyright 2012 Twitter, Inc.
+			 *
+			 * Licensed under the Apache License, Version 2.0 (the "License");
+			 * you may not use this file except in compliance with the License.
+			 * You may obtain a copy of the License at
+			 *
+			 * http://www.apache.org/licenses/LICENSE-2.0
+			 *
+			 * Unless required by applicable law or agreed to in writing, software
+			 * distributed under the License is distributed on an "AS IS" BASIS,
+			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+			 * See the License for the specific language governing permissions and
+			 * limitations under the License.
+			 * ============================================================ */
+if ( ! $.fn.dropdown ) {
+
+	  "use strict"; // jshint ;_;
+
+
+	  /* DROPDOWN CLASS DEFINITION
+	   * ========================= */
+
+	   var toggle = '[data-toggle="dropdown"]'
+	     , Dropdown = function (element) {
+	         var $el = $(element).on('click.dropdown.data-api', this.toggle)
+	         $('html').on('click.dropdown.data-api', function () {
+	           $el.parent().removeClass('open')
+	         })
+	       }
+
+	   Dropdown.prototype = {
+
+	     constructor: Dropdown
+
+	   , toggle: function (e) {
+	       var $this = $(this)
+	         , $parent
+	         , selector
+	         , isActive
+
+	       if ($this.is('.disabled, :disabled')) return
+
+	       selector = $this.attr('data-target')
+
+	       if (!selector) {
+	         selector = $this.attr('href')
+	         selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
+	       }
+
+	       $parent = $(selector)
+	       $parent.length || ($parent = $this.parent())
+
+	       isActive = $parent.hasClass('open')
+
+	       clearMenus()
+
+	       if (!isActive) $parent.toggleClass('open')
+
+	       return false
+	     }
+
+	   }
+
+	   function clearMenus() {
+	     $(toggle).parent().removeClass('open')
+	   }
+
+
+	   /* DROPDOWN PLUGIN DEFINITION
+	    * ========================== */
+
+	   $.fn.dropdown = function (option) {
+	     return this.each(function () {
+	       var $this = $(this)
+	         , data = $this.data('dropdown')
+	       if (!data) $this.data('dropdown', (data = new Dropdown(this)))
+	       if (typeof option == 'string') data[option].call($this)
+	     })
+	   }
+
+	   $.fn.dropdown.Constructor = Dropdown
+
+
+	   /* APPLY TO STANDARD DROPDOWN ELEMENTS
+	    * =================================== */
+
+	   domReady(function () {
+	     $(document).on('click.dropdown.data-api', clearMenus)
+	     $(document)
+	       .on('click.dropdown', '.dropdown form', function (e) { e.stopPropagation() })
+	       .on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle)
+	   })
+
+	}
+} );
diff --git a/public/js_src/external_libs/bootstrap_fileupload.js b/public/js_src/external_libs/bootstrap_fileupload.js
new file mode 100644
index 0000000..8480252
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_fileupload.js
@@ -0,0 +1,144 @@
+define( ["jquery_timely"],
+	function( $ ) {
+
+/* ===========================================================
+ * bootstrap-fileupload.js j2
+ * http://jasny.github.com/bootstrap/javascript.html#fileupload
+ * ===========================================================
+ * Copyright 2012 Jasny BV, Netherlands.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License")
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ========================================================== */
+
+  "use strict"; // jshint ;_
+
+ /* INPUTMASK PUBLIC CLASS DEFINITION
+  * ================================= */
+
+  var Fileupload = function (element, options) {
+    this.$element = $(element)
+    this.type = this.$element.data('uploadtype') || (this.$element.find('.thumbnail').length > 0 ? "image" : "file")
+
+    this.$input = this.$element.find(':file')
+    if (this.$input.length === 0) return
+
+    this.name = this.$input.attr('name') || options.name
+
+    this.$hidden = this.$element.find(':hidden[name="'+this.name+'"]')
+    if (this.$hidden.length === 0) {
+      this.$hidden = $('<input type="hidden" />')
+      this.$element.prepend(this.$hidden)
+    }
+
+    this.$preview = this.$element.find('.fileupload-preview')
+    var height = this.$preview.css('height')
+    if (this.$preview.css('display') != 'inline' && height != '0px' && height != 'none') this.$preview.css('line-height', height)
+
+    this.$remove = this.$element.find('[data-dismiss="fileupload"]')
+
+    this.$element.find('[data-trigger="fileupload"]').on('click.fileupload', $.proxy(this.trigger, this))
+
+    this.listen()
+  }
+
+  Fileupload.prototype = {
+
+    listen: function() {
+      this.$input.on('change.fileupload', $.proxy(this.change, this))
+      if (this.$remove) this.$remove.on('click.fileupload', $.proxy(this.clear, this))
+    },
+
+    change: function(e, invoked) {
+      var file = e.target.files !== undefined ? e.target.files[0] : (e.target.value ? { name: e.target.value.replace(/^.+\\/, '') } : null)
+      if (invoked === 'clear') return
+
+      if (!file) {
+        this.clear()
+        return
+      }
+
+      this.$hidden.val('')
+      this.$hidden.attr('name', '')
+      this.$input.attr('name', this.name)
+
+      if (this.type === "image" && this.$preview.length > 0 && (typeof file.type !== "undefined" ? file.type.match('image.*') : file.name.match('\\.(gif|png|jpe?g)$')) && typeof FileReader !== "undefined") {
+        var reader = new FileReader()
+        var preview = this.$preview
+        var element = this.$element
+
+        reader.onload = function(e) {
+          preview.html('<img src="' + e.target.result + '" ' + (preview.css('max-height') != 'none' ? 'style="max-height: ' + preview.css('max-height') + ';"' : '') + ' />')
+          element.addClass('fileupload-exists').removeClass('fileupload-new')
+        }
+
+        reader.readAsDataURL(file)
+      } else {
+        this.$preview.text(file.name)
+        this.$element.addClass('fileupload-exists').removeClass('fileupload-new')
+      }
+    },
+
+    clear: function(e) {
+      this.$hidden.val('')
+      this.$hidden.attr('name', this.name)
+      this.$input.attr('name', '')
+      this.$input.val('') // Doesn't work in IE, which causes issues when selecting the same file twice
+
+      this.$preview.html('')
+      this.$element.addClass('fileupload-new').removeClass('fileupload-exists')
+
+      if (e) {
+        this.$input.trigger('change', [ 'clear' ])
+        e.preventDefault()
+      }
+    },
+
+    trigger: function(e) {
+      this.$input.trigger('click')
+      e.preventDefault()
+    }
+  }
+
+
+ /* INPUTMASK PLUGIN DEFINITION
+  * =========================== */
+
+  $.fn.fileupload = function (options) {
+    return this.each(function () {
+      var $this = $(this)
+      , data = $this.data('fileupload')
+      if (!data) $this.data('fileupload', (data = new Fileupload(this, options)))
+    })
+  }
+
+  $.fn.fileupload.Constructor = Fileupload
+
+
+ /* INPUTMASK DATA-API
+  * ================== */
+
+  $(function () {
+    $('body').on('click.fileupload.data-api', '[data-provides="fileupload"]', function (e) {
+      var $this = $(this)
+      if ($this.data('fileupload')) return
+      $this.fileupload($this.data())
+
+      var $target = $(e.target).parents('[data-dismiss=fileupload],[data-trigger=fileupload]').first()
+      if ($target.length > 0) {
+          $target.trigger('click.fileupload')
+          e.preventDefault()
+      }
+    })
+  })
+
+} );
diff --git a/public/js_src/external_libs/bootstrap_modal.js b/public/js_src/external_libs/bootstrap_modal.js
new file mode 100644
index 0000000..2155a8a
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_modal.js
@@ -0,0 +1,257 @@
+// Bootstrap Modals, manually namespaced
+// Important: Whenever updating this file from Bootstrap, replace all
+// occurrences as follows:
+// 	data-dismiss="modal" => data-dismiss="ai1ec_modal"
+// 	data-toggle="modal" => data-toggle="ai1ec_modal"
+// 	modal-backdrop => ai1ec-modal-backdrop
+// 	modal-body => ai1ec-modal-body
+
+define( ["jquery_timely"],
+		function( $ ) {
+
+	/* =========================================================
+	 * bootstrap-modal.js v2.2.2
+	 * http://twitter.github.com/bootstrap/javascript.html#modals
+	 * =========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * ========================================================= */
+
+
+
+
+	  "use strict"; // jshint ;_;
+
+
+	 /* MODAL CLASS DEFINITION
+	  * ====================== */
+
+	  var Modal = function (element, options) {
+	    this.options = options
+	    this.$element = $(element)
+	      .delegate('[data-dismiss="ai1ec_modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
+	    this.options.remote && this.$element.find('.ai1ec-modal-body').load(this.options.remote)
+	  }
+
+	  Modal.prototype = {
+
+	      constructor: Modal
+
+	    , toggle: function () {
+	        return this[!this.isShown ? 'show' : 'hide']()
+	      }
+
+	    , show: function () {
+	        var that = this
+	          , e = $.Event('show')
+
+	        this.$element.trigger(e)
+
+	        if (this.isShown || e.isDefaultPrevented()) return
+
+	        this.isShown = true
+
+	        this.escape()
+
+	        this.backdrop(function () {
+	          var transition = $.support.transition && that.$element.hasClass('fade')
+
+	          if (!that.$element.parent().length) {
+	            that.$element.appendTo(document.body) //don't move modals dom position
+	          }
+
+	          that.$element
+	            .show()
+
+	          if (transition) {
+	            that.$element[0].offsetWidth // force reflow
+	          }
+
+	          that.$element
+	            .addClass('in')
+	            .attr('aria-hidden', false)
+
+	          that.enforceFocus()
+
+	          transition ?
+	            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
+	            that.$element.focus().trigger('shown')
+
+	        })
+	      }
+
+	    , hide: function (e) {
+	        e && e.preventDefault()
+
+	        var that = this
+
+	        e = $.Event('hide')
+
+	        this.$element.trigger(e)
+
+	        if (!this.isShown || e.isDefaultPrevented()) return
+
+	        this.isShown = false
+
+	        this.escape()
+
+	        $(document).off('focusin.modal')
+
+	        this.$element
+	          .removeClass('in')
+	          .attr('aria-hidden', true)
+
+	        $.support.transition && this.$element.hasClass('fade') ?
+	          this.hideWithTransition() :
+	          this.hideModal()
+	      }
+
+	    , enforceFocus: function () {
+	        var that = this
+	        $(document).on('focusin.modal', function (e) {
+	          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
+	            that.$element.focus()
+	          }
+	        })
+	      }
+
+	    , escape: function () {
+	        var that = this
+	        if (this.isShown && this.options.keyboard) {
+	          this.$element.on('keyup.dismiss.modal', function ( e ) {
+	            e.which == 27 && that.hide()
+	          })
+	        } else if (!this.isShown) {
+	          this.$element.off('keyup.dismiss.modal')
+	        }
+	      }
+
+	    , hideWithTransition: function () {
+	        var that = this
+	          , timeout = setTimeout(function () {
+	              that.$element.off($.support.transition.end)
+	              that.hideModal()
+	            }, 500)
+
+	        this.$element.one($.support.transition.end, function () {
+	          clearTimeout(timeout)
+	          that.hideModal()
+	        })
+	      }
+
+	    , hideModal: function (that) {
+	        this.$element
+	          .hide()
+	          .trigger('hidden')
+
+	        this.backdrop()
+	      }
+
+	    , removeBackdrop: function () {
+	        this.$backdrop.remove()
+	        this.$backdrop = null
+	      }
+
+	    , backdrop: function (callback) {
+	        var that = this
+	          , animate = this.$element.hasClass('fade') ? 'fade' : ''
+
+	        if (this.isShown && this.options.backdrop) {
+	          var doAnimate = $.support.transition && animate
+
+	          this.$backdrop = $('<div class="ai1ec-modal-backdrop ' + animate + '" />')
+	            .appendTo(document.body)
+
+	          this.$backdrop.click(
+	            this.options.backdrop == 'static' ?
+	              $.proxy(this.$element[0].focus, this.$element[0])
+	            : $.proxy(this.hide, this)
+	          )
+
+	          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
+
+	          this.$backdrop.addClass('in')
+
+	          doAnimate ?
+	            this.$backdrop.one($.support.transition.end, callback) :
+	            callback()
+
+	        } else if (!this.isShown && this.$backdrop) {
+	          this.$backdrop.removeClass('in')
+
+	          $.support.transition && this.$element.hasClass('fade')?
+	            this.$backdrop.one($.support.transition.end, $.proxy(this.removeBackdrop, this)) :
+	            this.removeBackdrop()
+
+	        } else if (callback) {
+	          callback()
+	        }
+	      }
+	  }
+
+
+	 /* MODAL PLUGIN DEFINITION
+	  * ======================= */
+
+	  var old = $.fn.modal
+
+	  $.fn.modal = function (option) {
+	    return this.each(function () {
+	      var $this = $(this)
+	        , data = $this.data('modal')
+	        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
+	      if (!data) $this.data('modal', (data = new Modal(this, options)))
+	      if (typeof option == 'string') data[option]()
+	      else if (options.show) data.show()
+	    })
+	  }
+
+	  $.fn.modal.defaults = {
+	      backdrop: true
+	    , keyboard: true
+	    , show: true
+	  }
+
+	  $.fn.modal.Constructor = Modal
+
+
+	 /* MODAL NO CONFLICT
+	  * ================= */
+
+	  $.fn.modal.noConflict = function () {
+	    $.fn.modal = old
+	    return this
+	  }
+
+
+	 /* MODAL DATA-API
+	  * ============== */
+
+	  $(document).on('click.modal.data-api', '[data-toggle="ai1ec_modal"]', function (e) {
+	    var $this = $(this)
+	      , href = $this.attr('href')
+	      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
+	      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())
+
+	    e.preventDefault()
+
+	    $target
+	      .modal(option)
+	      .one('hide', function () {
+	        $this.focus()
+	      })
+	  })
+
+
+} );
diff --git a/public/js_src/external_libs/bootstrap_popover.js b/public/js_src/external_libs/bootstrap_popover.js
new file mode 100644
index 0000000..828d16e
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_popover.js
@@ -0,0 +1,254 @@
+define(
+		[
+		 "jquery_timely",
+		 "external_libs/bootstrap_tooltip"
+		 ],
+		 function( $, domReady ) {
+	/* ===========================================================
+	 * bootstrap-popover.js v2.0.4
+	 * http://twitter.github.com/bootstrap/javascript.html#popovers
+	 * ===========================================================
+	 * Copyright 2012 Twitter, Inc.
+	 *
+	 * Licensed under the Apache License, Version 2.0 (the "License");
+	 * you may not use this file except in compliance with the License.
+	 * You may obtain a copy of the License at
+	 *
+	 * http://www.apache.org/licenses/LICENSE-2.0
+	 *
+	 * Unless required by applicable law or agreed to in writing, software
+	 * distributed under the License is distributed on an "AS IS" BASIS,
+	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	 * See the License for the specific language governing permissions and
+	 * limitations under the License.
+	 * =========================================================== */
+
+if ( ! $.fn.popover ) {
+
+		"use strict"; // jshint ;_;
+
+ /* POPOVER PUBLIC CLASS DEFINITION
+	* =============================== */
+
+	var Popover = function ( element, options ) {
+		this.init('popover', element, options)
+	}
+
+
+	/* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
+		 ========================================== */
+
+	Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {
+
+		constructor: Popover
+
+	, setContent: function () {
+			var $tip = this.tip()
+				, title = this.getTitle()
+				, content = this.getContent()
+
+			$tip.find('.popover-title')[this.isHTML(title) ? 'html' : 'text'](title)
+			$tip.find('.popover-content > *')[this.isHTML(content) ? 'html' : 'text'](content)
+
+			$tip.removeClass('fade top bottom left right in')
+		}
+
+	, hasContent: function () {
+			return this.getTitle() || this.getContent()
+		}
+
+	, getContent: function () {
+			var content
+				, $e = this.$element
+				, o = this.options
+
+			content = $e.attr('data-content')
+				|| (typeof o.content == 'function' ? o.content.call($e[0]) :  o.content)
+
+			return content
+		}
+
+	, tip: function () {
+			if (!this.$tip) {
+				this.$tip = $(this.options.template)
+			}
+			return this.$tip
+		}
+
+	})
+
+
+ /* POPOVER PLUGIN DEFINITION
+	* ======================= */
+
+	$.fn.popover = function (option) {
+		return this.each(function () {
+			var $this = $(this)
+				, data = $this.data('popover')
+				, options = typeof option == 'object' && option
+			if (!data) $this.data('popover', (data = new Popover(this, options)))
+			if (typeof option == 'string') data[option]()
+		})
+	}
+
+	$.fn.popover.Constructor = Popover
+
+	$.fn.popover.defaults = $.extend({} , $.fn.tooltip.defaults, {
+		placement: 'right'
+	, content: ''
+	, template: '<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'
+	})
+
+}
+
+if ( ! $.fn.constrained_popover ) {
+
+	/* CONSTRAINED_POPOVER PUBLIC CLASS DEFINITION
+	 * =========================================== */
+
+	var ConstrainedPopover = function ( element, options ) {
+		this.init('constrained_popover', element, options )
+	};
+
+	/* NOTE: CONSTRAINED_POPOVER EXTENDS BOOTSTRAP-POPOVER.js
+	 ========================================== */
+
+	ConstrainedPopover.prototype = $.extend( {}, $.fn.popover.Constructor.prototype, {
+
+		constructor: ConstrainedPopover
+
+	, show: function () {
+		var $tip
+			, inside
+			, pos
+			, newPos
+			, actualWidth
+			, actualHeight
+			, placement
+			, tp
+			, finalPos = {}
+
+		if (this.hasContent() && this.enabled) {
+			$tip = this.tip()
+			this.setContent()
+
+			if (this.options.animation) {
+				$tip.addClass('fade')
+			}
+
+			placement = typeof this.options.placement == 'function' ?
+				this.options.placement.call(this, $tip[0], this.$element[0]) :
+				this.options.placement
+
+			inside = /in/.test(placement)
+
+			$tip
+				.remove()
+				.css({ top: 0, left: 0, display: 'block' })
+				.appendTo(inside ? this.$element : document.body)
+
+			pos = this.getPosition( inside )
+
+			actualWidth = $tip[0].offsetWidth
+			actualHeight = $tip[0].offsetHeight
+
+			switch (inside ? placement.split(' ')[1] : placement) {
+				case 'left':
+					newPos = this.defineBounds( pos )
+					if ( typeof newPos.top === "undefined" ) {
+						finalPos["top"] = pos.top + pos.height / 2 - actualHeight / 2
+					} else {
+						finalPos["top"] = newPos.top - actualHeight / 2
+					}
+					if ( typeof newPos.left === "undefined" ) {
+						finalPos["left"] = pos.left - actualWidth
+					} else {
+						finalPos["left"] = newPos.left - actualWidth
+					}
+					tp = { top: finalPos.top , left: finalPos.left }
+					break
+				case 'right':
+					newPos = this.defineBounds( pos )
+					if ( typeof newPos.top === "undefined" ) {
+						finalPos["top"] = pos.top + pos.height / 2 - actualHeight / 2
+					} else {
+						finalPos["top"] = newPos.top - actualHeight / 2
+					}
+					if ( typeof newPos.left === "undefined" ) {
+						finalPos["left"] = pos.left + pos.width
+					} else {
+						finalPos["left"] = newPos.left + pos.width
+					}
+					tp = { top: finalPos.top , left: finalPos.left }
+					break
+			}
+
+			$tip
+				.css(tp)
+				.addClass(placement)
+				.addClass('in')
+		}
+	}
+
+	, defineBounds: function ( pos ) {
+		var container
+		, containerOffset
+			, boundTop
+			, boundLeft
+			, boundBottom
+			, boundRight
+			, newPos = {}
+			, $container = $( this.options.container )
+
+		if ( $container.length ) {
+			containerOffset = $container.offset()
+
+			boundTop = containerOffset.top
+			boundLeft = containerOffset.left
+			boundBottom = boundTop + $container.height()
+			boundRight = boundLeft + $container.width()
+
+			// Constrain y-axis overflow
+			if ( pos.top + ( pos.height / 2 ) < boundTop ) {
+				newPos["top"] = boundTop
+			}
+			if ( pos.top + ( pos.height / 2 ) > boundBottom ) {
+				newPos["top"] = boundBottom
+			}
+
+			// Constrain x-axis overflow
+			if ( pos.left - ( pos.width / 2 ) < boundLeft ) {
+				newPos["left"] = boundLeft
+			}
+			if ( pos.left - ( pos.width / 2 ) > boundRight ) {
+				newPos["left"] = boundRight
+			}
+			return newPos
+		}
+		return false
+	}
+
+	})
+
+	 /* CONSTRAINED_POPOVER PLUGIN DEFINITION
+		* ===================================== */
+
+	$.fn.constrained_popover = function ( option ) {
+		return this.each( function () {
+			var $this = $(this)
+						, data = $this.data('constrained_popover')
+						, options = typeof option == 'object' && option
+					if (!data) $this.data('constrained_popover', (data = new ConstrainedPopover(this, options)))
+					if (typeof option == 'string') data[option]()
+		})
+	}
+
+	$.fn.constrained_popover.Constructor = ConstrainedPopover
+
+	$.fn.constrained_popover.defaults = $.extend({} , $.fn.popover.defaults, {
+		container: ''
+		, content: this.options
+	})
+} // END: CONSTRAINED_POPOVER
+
+} );
diff --git a/public/js_src/external_libs/bootstrap_tab.js b/public/js_src/external_libs/bootstrap_tab.js
new file mode 100644
index 0000000..d2daee8
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_tab.js
@@ -0,0 +1,114 @@
+define( ["jquery_timely"],
+		function( $ ) {
+	  "use strict"; // jshint ;_;
+
+
+	 /* TAB CLASS DEFINITION
+	  * ==================== */
+
+	  var Tab = function ( element ) {
+	    this.element = $(element)
+	  }
+
+	  Tab.prototype = {
+
+	    constructor: Tab
+
+	  , show: function () {
+	      var $this = this.element
+	        , $ul = $this.closest('ul:not(.dropdown-menu)')
+	        , selector = $this.attr('data-target')
+	        , previous
+	        , $target
+	        , e
+
+	      if (!selector) {
+	        selector = $this.attr('href')
+	        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
+	      }
+
+	      if ( $this.parent('li').hasClass('active') ) return
+
+	      previous = $ul.find('.active a').last()[0]
+
+	      e = $.Event('show', {
+	        relatedTarget: previous
+	      })
+
+	      $this.trigger(e)
+
+	      if (e.isDefaultPrevented()) return
+
+	      $target = $(selector)
+
+	      this.activate($this.parent('li'), $ul)
+	      this.activate($target, $target.parent(), function () {
+	        $this.trigger({
+	          type: 'shown'
+	        , relatedTarget: previous
+	        })
+	      })
+	    }
+
+	  , activate: function ( element, container, callback) {
+	      var $active = container.find('> .active')
+	        , transition = callback
+	            && $.support.transition
+	            && $active.hasClass('fade')
+
+	      function next() {
+	        $active
+	          .removeClass('active')
+	          .find('> .dropdown-menu > .active')
+	          .removeClass('active')
+
+	        element.addClass('active')
+
+	        if (transition) {
+	          element[0].offsetWidth // reflow for transition
+	          element.addClass('in')
+	        } else {
+	          element.removeClass('fade')
+	        }
+
+	        if ( element.parent('.dropdown-menu') ) {
+	          element.closest('li.dropdown').addClass('active')
+	        }
+
+	        callback && callback()
+	      }
+
+	      transition ?
+	        $active.one($.support.transition.end, next) :
+	        next()
+
+	      $active.removeClass('in')
+	    }
+	  }
+
+
+	 /* TAB PLUGIN DEFINITION
+	  * ===================== */
+
+	  $.fn.tab = function ( option ) {
+	    return this.each(function () {
+	      var $this = $(this)
+	        , data = $this.data('tab')
+	      if (!data) $this.data('tab', (data = new Tab(this)))
+	      if (typeof option == 'string') data[option]()
+	    })
+	  }
+
+	  $.fn.tab.Constructor = Tab
+
+
+	 /* TAB DATA-API
+	  * ============ */
+
+	  $(function () {
+	    $('body').on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
+	      e.preventDefault()
+	      $(this).tab('show')
+	    })
+	  })
+} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/bootstrap_timepicker.js b/public/js_src/external_libs/bootstrap_timepicker.js
new file mode 100644
index 0000000..c28a8be
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_timepicker.js
@@ -0,0 +1,889 @@
+/*!
+ * Timepicker Component for Twitter Bootstrap
+ *
+ * Copyright 2013 Joris de Wit
+ *
+ * Contributors https://github.com/jdewit/bootstrap-timepicker/graphs/contributors
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+define( ["jquery_timely"],
+	function( $ ) {
+
+    "use strict"; // jshint ;_;
+    ;(function($, window, document, undefined) {
+
+    	  'use strict'; // jshint ;_;
+
+    	  // TIMEPICKER PUBLIC CLASS DEFINITION
+    	  var Timepicker = function(element, options) {
+    	    this.widget = '';
+    	    this.$element = $(element);
+    	    this.defaultTime = options.defaultTime;
+    	    this.disableFocus = options.disableFocus;
+    	    this.isOpen = options.isOpen;
+    	    this.minuteStep = options.minuteStep;
+    	    this.modalBackdrop = options.modalBackdrop;
+    	    this.secondStep = options.secondStep;
+    	    this.showInputs = options.showInputs;
+    	    this.showMeridian = options.showMeridian;
+    	    this.showSeconds = options.showSeconds;
+    	    this.template = options.template;
+    	    this.appendWidgetTo = options.appendWidgetTo;
+
+    	    this._init();
+    	  };
+
+    	  Timepicker.prototype = {
+
+    	    constructor: Timepicker,
+
+    	    _init: function() {
+    	      var self = this;
+
+    	      if (this.$element.parent().hasClass('input-append') || this.$element.parent().hasClass('input-prepend')) {
+    	          this.$element.parent('.input-append, .input-prepend').find('.add-on').on({
+    	            'click.timepicker': $.proxy(this.showWidget, this)
+    	          });
+    	          this.$element.on({
+    	            'focus.timepicker': $.proxy(this.highlightUnit, this),
+    	            'click.timepicker': $.proxy(this.highlightUnit, this),
+    	            'keydown.timepicker': $.proxy(this.elementKeydown, this),
+    	            'blur.timepicker': $.proxy(this.blurElement, this)
+    	          });
+    	      } else {
+    	        if (this.template) {
+    	          this.$element.on({
+    	            'focus.timepicker': $.proxy(this.showWidget, this),
+    	            'click.timepicker': $.proxy(this.showWidget, this),
+    	            'blur.timepicker': $.proxy(this.blurElement, this)
+    	          });
+    	        } else {
+    	          this.$element.on({
+    	            'focus.timepicker': $.proxy(this.highlightUnit, this),
+    	            'click.timepicker': $.proxy(this.highlightUnit, this),
+    	            'keydown.timepicker': $.proxy(this.elementKeydown, this),
+    	            'blur.timepicker': $.proxy(this.blurElement, this)
+    	          });
+    	        }
+    	      }
+
+    	      if (this.template !== false) {
+    	        this.$widget = $(this.getTemplate()).prependTo(this.$element.parents(this.appendWidgetTo)).on('click', $.proxy(this.widgetClick, this));
+    	      } else {
+    	        this.$widget = false;
+    	      }
+
+    	      if (this.showInputs && this.$widget !== false) {
+    	          this.$widget.find('input').each(function() {
+    	            $(this).on({
+    	              'click.timepicker': function() { $(this).select(); },
+    	              'keydown.timepicker': $.proxy(self.widgetKeydown, self)
+    	            });
+    	          });
+    	      }
+
+    	      this.setDefaultTime(this.defaultTime);
+    	    },
+
+    	    blurElement: function() {
+    	      this.highlightedUnit = undefined;
+    	      this.updateFromElementVal();
+    	    },
+
+    	    decrementHour: function() {
+    	      if (this.showMeridian) {
+    	        if (this.hour === 1) {
+    	          this.hour = 12;
+    	        } else if (this.hour === 12) {
+    	          this.hour--;
+
+    	          return this.toggleMeridian();
+    	        } else if (this.hour === 0) {
+    	          this.hour = 11;
+
+    	          return this.toggleMeridian();
+    	        } else {
+    	          this.hour--;
+    	        }
+    	      } else {
+    	        if (this.hour === 0) {
+    	          this.hour = 23;
+    	        } else {
+    	          this.hour--;
+    	        }
+    	      }
+    	      this.update();
+    	    },
+
+    	    decrementMinute: function(step) {
+    	      var newVal;
+
+    	      if (step) {
+    	        newVal = this.minute - step;
+    	      } else {
+    	        newVal = this.minute - this.minuteStep +
+    	          ((this.minuteStep - this.minute) % this.minuteStep);
+    	      }
+
+    	      if (newVal < 0) {
+    	        this.decrementHour();
+    	        this.minute = newVal + 60;
+    	      } else {
+    	        this.minute = newVal;
+    	      }
+    	      this.update();
+    	    },
+
+    	    decrementSecond: function() {
+    	      var newVal = this.second - this.secondStep;
+
+    	      if (newVal < 0) {
+    	        this.decrementMinute(true);
+    	        this.second = newVal + 60;
+    	      } else {
+    	        this.second = newVal;
+    	      }
+    	      this.update();
+    	    },
+
+    	    elementKeydown: function(e) {
+    	      switch (e.keyCode) {
+    	        case 9: //tab
+    	          this.updateFromElementVal();
+
+    	          switch (this.highlightedUnit) {
+    	            case 'hour':
+    	              e.preventDefault();
+    	              this.highlightNextUnit();
+    	            break;
+    	            case 'minute':
+    	              if (this.showMeridian || this.showSeconds) {
+    	                e.preventDefault();
+    	                this.highlightNextUnit();
+    	              }
+    	            break;
+    	            case 'second':
+    	              if (this.showMeridian) {
+    	                e.preventDefault();
+    	                this.highlightNextUnit();
+    	              }
+    	            break;
+    	          }
+    	        break;
+    	        case 27: // escape
+    	          this.updateFromElementVal();
+    	        break;
+    	        case 37: // left arrow
+    	          e.preventDefault();
+    	          this.highlightPrevUnit();
+    	          this.updateFromElementVal();
+    	        break;
+    	        case 38: // up arrow
+    	          e.preventDefault();
+    	          switch (this.highlightedUnit) {
+    	            case 'hour':
+    	              this.incrementHour();
+    	              this.highlightHour();
+    	            break;
+    	            case 'minute':
+    	              this.incrementMinute();
+    	              this.highlightMinute();
+    	            break;
+    	            case 'second':
+    	              this.incrementSecond();
+    	              this.highlightSecond();
+    	            break;
+    	            case 'meridian':
+    	              this.toggleMeridian();
+    	              this.highlightMeridian();
+    	            break;
+    	          }
+    	        break;
+    	        case 39: // right arrow
+    	          e.preventDefault();
+    	          this.updateFromElementVal();
+    	          this.highlightNextUnit();
+    	        break;
+    	        case 40: // down arrow
+    	          e.preventDefault();
+    	          switch (this.highlightedUnit) {
+    	            case 'hour':
+    	              this.decrementHour();
+    	              this.highlightHour();
+    	            break;
+    	            case 'minute':
+    	              this.decrementMinute();
+    	              this.highlightMinute();
+    	            break;
+    	            case 'second':
+    	              this.decrementSecond();
+    	              this.highlightSecond();
+    	            break;
+    	            case 'meridian':
+    	              this.toggleMeridian();
+    	              this.highlightMeridian();
+    	            break;
+    	          }
+    	        break;
+    	      }
+    	    },
+
+    	    formatTime: function(hour, minute, second, meridian) {
+    	      hour = hour < 10 ? '0' + hour : hour;
+    	      minute = minute < 10 ? '0' + minute : minute;
+    	      second = second < 10 ? '0' + second : second;
+
+    	      return hour + ':' + minute + (this.showSeconds ? ':' + second : '') + (this.showMeridian ? ' ' + meridian : '');
+    	    },
+
+    	    getCursorPosition: function() {
+    	      var input = this.$element.get(0);
+
+    	      if ('selectionStart' in input) {// Standard-compliant browsers
+
+    	        return input.selectionStart;
+    	      } else if (document.selection) {// IE fix
+    	        input.focus();
+    	        var sel = document.selection.createRange(),
+    	          selLen = document.selection.createRange().text.length;
+
+    	        sel.moveStart('character', - input.value.length);
+
+    	        return sel.text.length - selLen;
+    	      }
+    	    },
+
+    	    getTemplate: function() {
+    	      var template,
+    	        hourTemplate,
+    	        minuteTemplate,
+    	        secondTemplate,
+    	        meridianTemplate,
+    	        templateContent;
+
+    	      if (this.showInputs) {
+    	        hourTemplate = '<input type="text" name="hour" class="bootstrap-timepicker-hour" maxlength="2"/>';
+    	        minuteTemplate = '<input type="text" name="minute" class="bootstrap-timepicker-minute" maxlength="2"/>';
+    	        secondTemplate = '<input type="text" name="second" class="bootstrap-timepicker-second" maxlength="2"/>';
+    	        meridianTemplate = '<input type="text" name="meridian" class="bootstrap-timepicker-meridian" maxlength="2"/>';
+    	      } else {
+    	        hourTemplate = '<span class="bootstrap-timepicker-hour"></span>';
+    	        minuteTemplate = '<span class="bootstrap-timepicker-minute"></span>';
+    	        secondTemplate = '<span class="bootstrap-timepicker-second"></span>';
+    	        meridianTemplate = '<span class="bootstrap-timepicker-meridian"></span>';
+    	      }
+
+    	      templateContent = '<table>'+
+    	         '<tr>'+
+    	           '<td><a href="#" data-action="incrementHour"><i class="icon-chevron-up"></i></a></td>'+
+    	           '<td class="separator">&nbsp;</td>'+
+    	           '<td><a href="#" data-action="incrementMinute"><i class="icon-chevron-up"></i></a></td>'+
+    	           (this.showSeconds ?
+    	             '<td class="separator">&nbsp;</td>'+
+    	             '<td><a href="#" data-action="incrementSecond"><i class="icon-chevron-up"></i></a></td>'
+    	           : '') +
+    	           (this.showMeridian ?
+    	             '<td class="separator">&nbsp;</td>'+
+    	             '<td class="meridian-column"><a href="#" data-action="toggleMeridian"><i class="icon-chevron-up"></i></a></td>'
+    	           : '') +
+    	         '</tr>'+
+    	         '<tr>'+
+    	           '<td>'+ hourTemplate +'</td> '+
+    	           '<td class="separator">:</td>'+
+    	           '<td>'+ minuteTemplate +'</td> '+
+    	           (this.showSeconds ?
+    	            '<td class="separator">:</td>'+
+    	            '<td>'+ secondTemplate +'</td>'
+    	           : '') +
+    	           (this.showMeridian ?
+    	            '<td class="separator">&nbsp;</td>'+
+    	            '<td>'+ meridianTemplate +'</td>'
+    	           : '') +
+    	         '</tr>'+
+    	         '<tr>'+
+    	           '<td><a href="#" data-action="decrementHour"><i class="icon-chevron-down"></i></a></td>'+
+    	           '<td class="separator"></td>'+
+    	           '<td><a href="#" data-action="decrementMinute"><i class="icon-chevron-down"></i></a></td>'+
+    	           (this.showSeconds ?
+    	            '<td class="separator">&nbsp;</td>'+
+    	            '<td><a href="#" data-action="decrementSecond"><i class="icon-chevron-down"></i></a></td>'
+    	           : '') +
+    	           (this.showMeridian ?
+    	            '<td class="separator">&nbsp;</td>'+
+    	            '<td><a href="#" data-action="toggleMeridian"><i class="icon-chevron-down"></i></a></td>'
+    	           : '') +
+    	         '</tr>'+
+    	       '</table>';
+
+    	      switch(this.template) {
+    	        case 'modal':
+    	          template = '<div class="bootstrap-timepicker-widget modal hide fade in" data-backdrop="'+ (this.modalBackdrop ? 'true' : 'false') +'">'+
+    	            '<div class="modal-header">'+
+    	              '<a href="#" class="close" data-dismiss="modal"></a>'+
+    	              '<h3>Pick a Time</h3>'+
+    	            '</div>'+
+    	            '<div class="modal-content">'+
+    	              templateContent +
+    	            '</div>'+
+    	            '<div class="modal-footer">'+
+    	              '<a href="#" class="btn btn-primary" data-dismiss="modal">OK</a>'+
+    	            '</div>'+
+    	          '</div>';
+    	        break;
+    	        case 'dropdown':
+    	          template = '<div class="bootstrap-timepicker-widget dropdown-menu">'+ templateContent +'</div>';
+    	        break;
+    	      }
+
+    	      return template;
+    	    },
+
+    	    getTime: function() {
+    	      return this.formatTime(this.hour, this.minute, this.second, this.meridian);
+    	    },
+
+    	    hideWidget: function() {
+    	      if (this.isOpen === false) {
+    	        return;
+    	      }
+
+    				if (this.showInputs) {
+    					this.updateFromWidgetInputs();
+    				}
+
+    	      this.$element.trigger({
+    	        'type': 'hide.timepicker',
+    	        'time': {
+    	            'value': this.getTime(),
+    	            'hours': this.hour,
+    	            'minutes': this.minute,
+    	            'seconds': this.second,
+    	            'meridian': this.meridian
+    	         }
+    	      });
+
+    	      if (this.template === 'modal') {
+    	        this.$widget.modal('hide');
+    	      } else {
+    	        this.$widget.removeClass('open');
+    	      }
+
+    	      $(document).off('mousedown.timepicker');
+
+    	      this.isOpen = false;
+    	    },
+
+    	    highlightUnit: function() {
+    	      this.position = this.getCursorPosition();
+    	      if (this.position >= 0 && this.position <= 2) {
+    	        this.highlightHour();
+    	      } else if (this.position >= 3 && this.position <= 5) {
+    	        this.highlightMinute();
+    	      } else if (this.position >= 6 && this.position <= 8) {
+    	        if (this.showSeconds) {
+    	          this.highlightSecond();
+    	        } else {
+    	          this.highlightMeridian();
+    	        }
+    	      } else if (this.position >= 9 && this.position <= 11) {
+    	        this.highlightMeridian();
+    	      }
+    	    },
+
+    	    highlightNextUnit: function() {
+    	      switch (this.highlightedUnit) {
+    	        case 'hour':
+    	          this.highlightMinute();
+    	        break;
+    	        case 'minute':
+    	          if (this.showSeconds) {
+    	            this.highlightSecond();
+    	          } else if (this.showMeridian){
+    	            this.highlightMeridian();
+    	          } else {
+    	            this.highlightHour();
+    	          }
+    	        break;
+    	        case 'second':
+    	          if (this.showMeridian) {
+    	            this.highlightMeridian();
+    	          } else {
+    	            this.highlightHour();
+    	          }
+    	        break;
+    	        case 'meridian':
+    	          this.highlightHour();
+    	        break;
+    	      }
+    	    },
+
+    	    highlightPrevUnit: function() {
+    	      switch (this.highlightedUnit) {
+    	        case 'hour':
+    	          this.highlightMeridian();
+    	        break;
+    	        case 'minute':
+    	          this.highlightHour();
+    	        break;
+    	        case 'second':
+    	          this.highlightMinute();
+    	        break;
+    	        case 'meridian':
+    	          if (this.showSeconds) {
+    	            this.highlightSecond();
+    	          } else {
+    	            this.highlightMinute();
+    	          }
+    	        break;
+    	      }
+    	    },
+
+    	    highlightHour: function() {
+    	      var $element = this.$element.get(0);
+
+    	      this.highlightedUnit = 'hour';
+
+    				if ($element.setSelectionRange) {
+    					setTimeout(function() {
+    						$element.setSelectionRange(0,2);
+    					}, 0);
+    				}
+    	    },
+
+    	    highlightMinute: function() {
+    	      var $element = this.$element.get(0);
+
+    	      this.highlightedUnit = 'minute';
+
+    				if ($element.setSelectionRange) {
+    					setTimeout(function() {
+    						$element.setSelectionRange(3,5);
+    					}, 0);
+    				}
+    	    },
+
+    	    highlightSecond: function() {
+    	      var $element = this.$element.get(0);
+
+    	      this.highlightedUnit = 'second';
+
+    				if ($element.setSelectionRange) {
+    					setTimeout(function() {
+    						$element.setSelectionRange(6,8);
+    					}, 0);
+    				}
+    	    },
+
+    	    highlightMeridian: function() {
+    	      var $element = this.$element.get(0);
+
+    	      this.highlightedUnit = 'meridian';
+
+    				if ($element.setSelectionRange) {
+    					if (this.showSeconds) {
+    						setTimeout(function() {
+    							$element.setSelectionRange(9,11);
+    						}, 0);
+    					} else {
+    						setTimeout(function() {
+    							$element.setSelectionRange(6,8);
+    						}, 0);
+    					}
+    				}
+    	    },
+
+    	    incrementHour: function() {
+    	      if (this.showMeridian) {
+    	        if (this.hour === 11) {
+    	          this.hour++;
+    	          return this.toggleMeridian();
+    	        } else if (this.hour === 12) {
+    	          this.hour = 0;
+    	        }
+    	      }
+    	      if (this.hour === 23) {
+    	        return this.hour = 0;
+    	      }
+    	      this.hour++;
+    	      this.update();
+    	    },
+
+    	    incrementMinute: function(step) {
+    	      var newVal;
+
+    	      if (step) {
+    	        newVal = this.minute + step;
+    	      } else {
+    	        newVal = this.minute + this.minuteStep - (this.minute % this.minuteStep);
+    	      }
+
+    	      if (newVal > 59) {
+    	        this.incrementHour();
+    	        this.minute = newVal - 60;
+    	      } else {
+    	        this.minute = newVal;
+    	      }
+    	      this.update();
+    	    },
+
+    	    incrementSecond: function() {
+    	      var newVal = this.second + this.secondStep - (this.second % this.secondStep);
+
+    	      if (newVal > 59) {
+    	        this.incrementMinute(true);
+    	        this.second = newVal - 60;
+    	      } else {
+    	        this.second = newVal;
+    	      }
+    	      this.update();
+    	    },
+
+    	    remove: function() {
+    	      $('document').off('.timepicker');
+    	      if (this.$widget) {
+    	        this.$widget.remove();
+    	      }
+    	      delete this.$element.data().timepicker;
+    	    },
+
+    	    setDefaultTime: function(defaultTime){
+    	      if (!this.$element.val()) {
+    	        if (defaultTime === 'current') {
+    	          var dTime = new Date(),
+    	            hours = dTime.getHours(),
+    	            minutes = Math.floor(dTime.getMinutes() / this.minuteStep) * this.minuteStep,
+    	            seconds = Math.floor(dTime.getSeconds() / this.secondStep) * this.secondStep,
+    	            meridian = 'AM';
+
+    	          if (this.showMeridian) {
+    	            if (hours === 0) {
+    	              hours = 12;
+    	            } else if (hours >= 12) {
+    	              if (hours > 12) {
+    	                hours = hours - 12;
+    	              }
+    	              meridian = 'PM';
+    	            } else {
+    	              meridian = 'AM';
+    	            }
+    	          }
+
+    	          this.hour = hours;
+    	          this.minute = minutes;
+    	          this.second = seconds;
+    	          this.meridian = meridian;
+
+    	          this.update();
+
+    	        } else if (defaultTime === false) {
+    	          this.hour = 0;
+    	          this.minute = 0;
+    	          this.second = 0;
+    	          this.meridian = 'AM';
+    	        } else {
+    	          this.setTime(defaultTime);
+    	        }
+    	      } else {
+    	        this.updateFromElementVal();
+    	      }
+    	    },
+
+    	    setTime: function(time) {
+    	      var arr,
+    	        timeArray;
+
+    	      if (this.showMeridian) {
+    	        arr = time.split(' ');
+    	        timeArray = arr[0].split(':');
+    	        this.meridian = arr[1];
+    	      } else {
+    	        timeArray = time.split(':');
+    	      }
+
+    	      this.hour = parseInt(timeArray[0], 10);
+    	      this.minute = parseInt(timeArray[1], 10);
+    	      this.second = parseInt(timeArray[2], 10);
+
+    	      if (isNaN(this.hour)) {
+    	        this.hour = 0;
+    	      }
+    	      if (isNaN(this.minute)) {
+    	        this.minute = 0;
+    	      }
+
+    	      if (this.showMeridian) {
+    	        if (this.hour > 12) {
+    	          this.hour = 12;
+    	        } else if (this.hour < 1) {
+    	          this.hour = 12;
+    	        }
+
+    	        if (this.meridian === 'am' || this.meridian === 'a') {
+    	          this.meridian = 'AM';
+    	        } else if (this.meridian === 'pm' || this.meridian === 'p') {
+    	          this.meridian = 'PM';
+    	        }
+
+    	        if (this.meridian !== 'AM' && this.meridian !== 'PM') {
+    	          this.meridian = 'AM';
+    	        }
+    	      } else {
+    	         if (this.hour >= 24) {
+    	          this.hour = 23;
+    	        } else if (this.hour < 0) {
+    	          this.hour = 0;
+    	        }
+    	      }
+
+    	      if (this.minute < 0) {
+    	        this.minute = 0;
+    	      } else if (this.minute >= 60) {
+    	        this.minute = 59;
+    	      }
+
+    	      if (this.showSeconds) {
+    	        if (isNaN(this.second)) {
+    	          this.second = 0;
+    	        } else if (this.second < 0) {
+    	          this.second = 0;
+    	        } else if (this.second >= 60) {
+    	          this.second = 59;
+    	        }
+    	      }
+
+    	      this.update();
+    	    },
+
+    	    showWidget: function() {
+    	      if (this.isOpen) {
+    	        return;
+    	      }
+
+    	      var self = this;
+    	      $(document).on('mousedown.timepicker', function (e) {
+    	        // Clicked outside the timepicker, hide it
+    	        if ($(e.target).closest('.bootstrap-timepicker-widget').length === 0) {
+    	          self.hideWidget();
+    	        }
+    	      });
+
+    	      this.$element.trigger({
+    	        'type': 'show.timepicker',
+    	        'time': {
+    	            'value': this.getTime(),
+    	            'hours': this.hour,
+    	            'minutes': this.minute,
+    	            'seconds': this.second,
+    	            'meridian': this.meridian
+    	         }
+    	      });
+
+    	      if (this.disableFocus) {
+    	        this.$element.blur();
+    	      }
+
+    	      this.updateFromElementVal();
+
+    	      if (this.template === 'modal') {
+    	        this.$widget.modal('show').on('hidden', $.proxy(this.hideWidget, this));
+    	      } else {
+    	        if (this.isOpen === false) {
+    	          this.$widget.addClass('open');
+    	        }
+    	      }
+
+    	      this.isOpen = true;
+    	    },
+
+    	    toggleMeridian: function() {
+    	      this.meridian = this.meridian === 'AM' ? 'PM' : 'AM';
+    	      this.update();
+    	    },
+
+    	    update: function() {
+    	      this.$element.trigger({
+    	        'type': 'changeTime.timepicker',
+    	        'time': {
+    	            'value': this.getTime(),
+    	            'hours': this.hour,
+    	            'minutes': this.minute,
+    	            'seconds': this.second,
+    	            'meridian': this.meridian
+    	         }
+    	      });
+
+    	      this.updateElement();
+    	      this.updateWidget();
+    	    },
+
+    	    updateElement: function() {
+    	      this.$element.val(this.getTime()).change();
+    	    },
+
+    	    updateFromElementVal: function() {
+    				var val = this.$element.val();
+
+    				if (val) {
+    					this.setTime(val);
+    				}
+    	    },
+
+    	    updateWidget: function() {
+    	      if (this.$widget === false) {
+    	        return;
+    	      }
+
+    	      var hour = this.hour < 10 ? '0' + this.hour : this.hour,
+    	          minute = this.minute < 10 ? '0' + this.minute : this.minute,
+    	          second = this.second < 10 ? '0' + this.second : this.second;
+
+    	      if (this.showInputs) {
+    	        this.$widget.find('input.bootstrap-timepicker-hour').val(hour);
+    	        this.$widget.find('input.bootstrap-timepicker-minute').val(minute);
+
+    	        if (this.showSeconds) {
+    	          this.$widget.find('input.bootstrap-timepicker-second').val(second);
+    	        }
+    	        if (this.showMeridian) {
+    	          this.$widget.find('input.bootstrap-timepicker-meridian').val(this.meridian);
+    	        }
+    	      } else {
+    	        this.$widget.find('span.bootstrap-timepicker-hour').text(hour);
+    	        this.$widget.find('span.bootstrap-timepicker-minute').text(minute);
+
+    	        if (this.showSeconds) {
+    	          this.$widget.find('span.bootstrap-timepicker-second').text(second);
+    	        }
+    	        if (this.showMeridian) {
+    	          this.$widget.find('span.bootstrap-timepicker-meridian').text(this.meridian);
+    	        }
+    	      }
+    	    },
+
+    	    updateFromWidgetInputs: function() {
+    	      if (this.$widget === false) {
+    	        return;
+    	      }
+    	      var time = $('input.bootstrap-timepicker-hour', this.$widget).val() + ':' +
+    	        $('input.bootstrap-timepicker-minute', this.$widget).val() +
+    	        (this.showSeconds ? ':' + $('input.bootstrap-timepicker-second', this.$widget).val() : '') +
+    	        (this.showMeridian ? ' ' + $('input.bootstrap-timepicker-meridian', this.$widget).val() : '');
+
+    	      this.setTime(time);
+    	    },
+
+    	    widgetClick: function(e) {
+    	      e.stopPropagation();
+    	      e.preventDefault();
+
+    	      var action = $(e.target).closest('a').data('action');
+    	      if (action) {
+    	        this[action]();
+    	      }
+    	    },
+
+    	    widgetKeydown: function(e) {
+    	      var $input = $(e.target).closest('input'),
+    	          name = $input.attr('name');
+
+    	      switch (e.keyCode) {
+    	        case 9: //tab
+    	          if (this.showMeridian) {
+    	            if (name === 'meridian') {
+    	              return this.hideWidget();
+    	            }
+    	          } else {
+    	            if (this.showSeconds) {
+    	              if (name === 'second') {
+    	                return this.hideWidget();
+    	              }
+    	            } else {
+    	              if (name === 'minute') {
+    	                return this.hideWidget();
+    	              }
+    	            }
+    	          }
+
+    	          this.updateFromWidgetInputs();
+    	        break;
+    	        case 27: // escape
+    	          this.hideWidget();
+    	        break;
+    	        case 38: // up arrow
+    	          e.preventDefault();
+    	          switch (name) {
+    	            case 'hour':
+    	              this.incrementHour();
+    	            break;
+    	            case 'minute':
+    	              this.incrementMinute();
+    	            break;
+    	            case 'second':
+    	              this.incrementSecond();
+    	            break;
+    	            case 'meridian':
+    	              this.toggleMeridian();
+    	            break;
+    	          }
+    	        break;
+    	        case 40: // down arrow
+    	          e.preventDefault();
+    	          switch (name) {
+    	            case 'hour':
+    	              this.decrementHour();
+    	            break;
+    	            case 'minute':
+    	              this.decrementMinute();
+    	            break;
+    	            case 'second':
+    	              this.decrementSecond();
+    	            break;
+    	            case 'meridian':
+    	              this.toggleMeridian();
+    	            break;
+    	          }
+    	        break;
+    	      }
+    	    }
+    	  };
+
+
+    	  //TIMEPICKER PLUGIN DEFINITION
+    	  $.fn.timepicker = function(option) {
+    	    var args = Array.apply(null, arguments);
+    	    args.shift();
+    	    return this.each(function() {
+    	      var $this = $(this),
+    	        data = $this.data('timepicker'),
+    	        options = typeof option === 'object' && option;
+
+    	      if (!data) {
+    	        $this.data('timepicker', (data = new Timepicker(this, $.extend({}, $.fn.timepicker.defaults, options, $(this).data()))));
+    	      }
+
+    	      if (typeof option === 'string') {
+    	        data[option].apply(data, args);
+    	      }
+    	    });
+    	  };
+
+    	  $.fn.timepicker.defaults = {
+    	    defaultTime: 'current',
+    	    disableFocus: false,
+    	    isOpen: false,
+    	    minuteStep: 15,
+    	    modalBackdrop: false,
+    	    secondStep: 15,
+    	    showSeconds: false,
+    	    showInputs: true,
+    	    showMeridian: true,
+    	    template: 'dropdown',
+    	    appendWidgetTo: '.bootstrap-timepicker'
+    	  };
+
+    	  $.fn.timepicker.Constructor = Timepicker;
+
+    	})($, window, document);
+} );
diff --git a/public/js_src/external_libs/bootstrap_tooltip.js b/public/js_src/external_libs/bootstrap_tooltip.js
new file mode 100644
index 0000000..f1da34b
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_tooltip.js
@@ -0,0 +1,280 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+  /* ===========================================================
+   * bootstrap-tooltip.js v2.0.4
+   * http://twitter.github.com/bootstrap/javascript.html#tooltips
+   * Inspired by the original jQuery.tipsy by Jason Frame
+   * ===========================================================
+   * Copyright 2012 Twitter, Inc.
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   * http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   * ========================================================== */
+
+if ( ! $.fn.tooltip ) {
+
+    "use strict"; // jshint ;_;
+
+ /* TOOLTIP PUBLIC CLASS DEFINITION
+  * =============================== */
+
+  var Tooltip = function (element, options) {
+    this.init('tooltip', element, options)
+  }
+
+  Tooltip.prototype = {
+
+    constructor: Tooltip
+
+  , init: function (type, element, options) {
+      var eventIn
+        , eventOut
+
+      this.type = type
+      this.$element = $(element)
+      this.options = this.getOptions(options)
+      this.enabled = true
+
+      if (this.options.trigger != 'manual') {
+        eventIn  = this.options.trigger == 'hover' ? 'mouseenter' : 'focus'
+        eventOut = this.options.trigger == 'hover' ? 'mouseleave' : 'blur'
+        this.$element.on(eventIn, this.options.selector, $.proxy(this.enter, this))
+        this.$element.on(eventOut, this.options.selector, $.proxy(this.leave, this))
+      }
+
+      this.options.selector ?
+        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
+        this.fixTitle()
+    }
+
+  , getOptions: function (options) {
+      options = $.extend({}, $.fn[this.type].defaults, options, this.$element.data())
+
+      if (options.delay && typeof options.delay == 'number') {
+        options.delay = {
+          show: options.delay
+        , hide: options.delay
+        }
+      }
+
+      return options
+    }
+
+  , enter: function (e) {
+      var self = $(e.currentTarget)[this.type](this._options).data(this.type)
+
+      if (!self.options.delay || !self.options.delay.show) return self.show()
+
+      clearTimeout(this.timeout)
+      self.hoverState = 'in'
+      this.timeout = setTimeout(function() {
+        if (self.hoverState == 'in') self.show()
+      }, self.options.delay.show)
+    }
+
+  , leave: function (e) {
+      var self = $(e.currentTarget)[this.type](this._options).data(this.type)
+
+      if (this.timeout) clearTimeout(this.timeout)
+      if (!self.options.delay || !self.options.delay.hide) return self.hide()
+
+      self.hoverState = 'out'
+      this.timeout = setTimeout(function() {
+        if (self.hoverState == 'out') self.hide()
+      }, self.options.delay.hide)
+    }
+
+  , show: function () {
+      var $tip
+        , inside
+        , pos
+        , actualWidth
+        , actualHeight
+        , placement
+        , tp
+
+      if (this.hasContent() && this.enabled) {
+        $tip = this.tip()
+        this.setContent()
+
+        if (this.options.animation) {
+          $tip.addClass('fade')
+        }
+
+        placement = typeof this.options.placement == 'function' ?
+          this.options.placement.call(this, $tip[0], this.$element[0]) :
+          this.options.placement
+
+        inside = /in/.test(placement)
+
+        $tip
+          .remove()
+          .css({ top: 0, left: 0, display: 'block' })
+          .appendTo(inside ? this.$element : document.body)
+
+        pos = this.getPosition(inside)
+
+        actualWidth = $tip[0].offsetWidth
+        actualHeight = $tip[0].offsetHeight
+
+        switch (inside ? placement.split(' ')[1] : placement) {
+          case 'bottom':
+            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
+            break
+          case 'top':
+            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
+            break
+          case 'left':
+            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
+            break
+          case 'right':
+            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
+            break
+        }
+
+        $tip
+          .css(tp)
+          .addClass(placement)
+          .addClass('in')
+      }
+    }
+
+  , isHTML: function(text) {
+      // html string detection logic adapted from jQuery
+      return typeof text != 'string'
+        || ( text.charAt(0) === "<"
+          && text.charAt( text.length - 1 ) === ">"
+          && text.length >= 3
+        ) || /^(?:[^<]*<[\w\W]+>[^>]*$)/.exec(text)
+    }
+
+  , setContent: function () {
+      var $tip = this.tip()
+        , title = this.getTitle()
+
+      $tip.find('.tooltip-inner')[this.isHTML(title) ? 'html' : 'text'](title)
+      $tip.removeClass('fade in top bottom left right')
+    }
+
+  , hide: function () {
+      var that = this
+        , $tip = this.tip()
+
+      $tip.removeClass('in')
+
+      function removeWithAnimation() {
+        var timeout = setTimeout(function () {
+          $tip.off($.support.transition.end).remove()
+        }, 500)
+
+        $tip.one($.support.transition.end, function () {
+          clearTimeout(timeout)
+          $tip.remove()
+        })
+      }
+
+      $.support.transition && this.$tip.hasClass('fade') ?
+        removeWithAnimation() :
+        $tip.remove()
+    }
+
+  , fixTitle: function () {
+      var $e = this.$element
+      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
+        $e.attr('data-original-title', $e.attr('title') || '').removeAttr('title')
+      }
+    }
+
+  , hasContent: function () {
+      return this.getTitle()
+    }
+
+  , getPosition: function (inside) {
+      return $.extend({}, (inside ? {top: 0, left: 0} : this.$element.offset()), {
+        width: this.$element[0].offsetWidth
+      , height: this.$element[0].offsetHeight
+      })
+    }
+
+  , getTitle: function () {
+      var title
+        , $e = this.$element
+        , o = this.options
+
+      title = $e.attr('data-original-title')
+        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
+
+      return title
+    }
+
+  , tip: function () {
+      return this.$tip = this.$tip || $(this.options.template)
+    }
+
+  , validate: function () {
+      if (!this.$element[0].parentNode) {
+        this.hide()
+        this.$element = null
+        this.options = null
+      }
+    }
+
+  , enable: function () {
+      this.enabled = true
+    }
+
+  , disable: function () {
+      this.enabled = false
+    }
+
+  , toggleEnabled: function () {
+      this.enabled = !this.enabled
+    }
+
+  , toggle: function () {
+      this[this.tip().hasClass('in') ? 'hide' : 'show']()
+    }
+
+  }
+
+
+ /* TOOLTIP PLUGIN DEFINITION
+  * ========================= */
+
+  $.fn.tooltip = function ( option ) {
+    return this.each(function () {
+      var $this = $(this)
+        , data = $this.data('tooltip')
+        , options = typeof option == 'object' && option
+      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
+      if (typeof option == 'string') data[option]()
+    })
+  }
+
+  $.fn.tooltip.Constructor = Tooltip
+
+  $.fn.tooltip.defaults = {
+    animation: true
+  , placement: 'top'
+  , selector: false
+  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
+  , trigger: 'hover'
+  , title: ''
+  , delay: 0
+  }
+
+}
+
+} );
diff --git a/public/js_src/external_libs/bootstrap_transition.js b/public/js_src/external_libs/bootstrap_transition.js
new file mode 100644
index 0000000..97a1e74
--- /dev/null
+++ b/public/js_src/external_libs/bootstrap_transition.js
@@ -0,0 +1,40 @@
+define( ["jquery_timely"],
+		function( $ ) {
+
+	  "use strict"; // jshint ;_;
+
+	  /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
+	   * ======================================================= */
+
+	  $(function () {
+
+	    $.support.transition = (function () {
+
+	      var transitionEnd = (function () {
+
+	        var el = document.createElement('bootstrap')
+	          , transEndEventNames = {
+	               'WebkitTransition' : 'webkitTransitionEnd'
+	            ,  'MozTransition'    : 'transitionend'
+	            ,  'OTransition'      : 'oTransitionEnd otransitionend'
+	            ,  'transition'       : 'transitionend'
+	            }
+	          , name
+
+	        for (name in transEndEventNames){
+	          if (el.style[name] !== undefined) {
+	            return transEndEventNames[name]
+	          }
+	        }
+
+	      }())
+
+	      return transitionEnd && {
+	        end: transitionEnd
+	      }
+
+	    })()
+
+	  })
+
+} );
diff --git a/public/js_src/external_libs/colorpicker.js b/public/js_src/external_libs/colorpicker.js
new file mode 100644
index 0000000..821b3af
--- /dev/null
+++ b/public/js_src/external_libs/colorpicker.js
@@ -0,0 +1,475 @@
+define( 
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+	var ColorPicker = function () {
+		var
+			ids = {},
+			inAction,
+			charMin = 65,
+			visible,
+			tpl = '<div class="colorpicker"><div class="colorpicker_color"><div><div></div></div></div><div class="colorpicker_hue"><div></div></div><div class="colorpicker_new_color"></div><div class="colorpicker_current_color"></div><div class="colorpicker_hex"><input type="text" maxlength="6" size="6" /></div><div class="colorpicker_rgb_r colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_g colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_h colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_s colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_submit"></div></div>',
+			defaults = {
+				eventName: 'click',
+				onShow: function () {},
+				onBeforeShow: function(){},
+				onHide: function () {},
+				onChange: function () {},
+				onSubmit: function () {},
+				color: 'ff0000',
+				livePreview: true,
+				flat: false
+			},
+			fillRGBFields = function  (hsb, cal) {
+				var rgb = HSBToRGB(hsb);
+				$(cal).data('colorpicker').fields
+					.eq(1).val(rgb.r).end()
+					.eq(2).val(rgb.g).end()
+					.eq(3).val(rgb.b).end();
+			},
+			fillHSBFields = function  (hsb, cal) {
+				$(cal).data('colorpicker').fields
+					.eq(4).val(hsb.h).end()
+					.eq(5).val(hsb.s).end()
+					.eq(6).val(hsb.b).end();
+			},
+			fillHexFields = function (hsb, cal) {
+				$(cal).data('colorpicker').fields
+					.eq(0).val(HSBToHex(hsb)).end();
+			},
+			setSelector = function (hsb, cal) {
+				$(cal).data('colorpicker').selector.css('backgroundColor', '#' + HSBToHex({h: hsb.h, s: 100, b: 100}));
+				$(cal).data('colorpicker').selectorIndic.css({
+					left: parseInt(150 * hsb.s/100, 10),
+					top: parseInt(150 * (100-hsb.b)/100, 10)
+				});
+			},
+			setHue = function (hsb, cal) {
+				$(cal).data('colorpicker').hue.css('top', parseInt(150 - 150 * hsb.h/360, 10));
+			},
+			setCurrentColor = function (hsb, cal) {
+				$(cal).data('colorpicker').currentColor.css('backgroundColor', '#' + HSBToHex(hsb));
+			},
+			setNewColor = function (hsb, cal) {
+				$(cal).data('colorpicker').newColor.css('backgroundColor', '#' + HSBToHex(hsb));
+			},
+			keyDown = function (ev) {
+				var pressedKey = ev.charCode || ev.keyCode || -1;
+				if ((pressedKey > charMin && pressedKey <= 90) || pressedKey == 32) {
+					return false;
+				}
+				var cal = $(this).parent().parent();
+				if (cal.data('colorpicker').livePreview === true) {
+					change.apply(this);
+				}
+			},
+			change = function (ev) {
+				var cal = $(this).parent().parent(), col;
+				if (this.parentNode.className.indexOf('_hex') > 0) {
+					cal.data('colorpicker').color = col = HexToHSB(fixHex(this.value));
+				} else if (this.parentNode.className.indexOf('_hsb') > 0) {
+					cal.data('colorpicker').color = col = fixHSB({
+						h: parseInt(cal.data('colorpicker').fields.eq(4).val(), 10),
+						s: parseInt(cal.data('colorpicker').fields.eq(5).val(), 10),
+						b: parseInt(cal.data('colorpicker').fields.eq(6).val(), 10)
+					});
+				} else {
+					cal.data('colorpicker').color = col = RGBToHSB(fixRGB({
+						r: parseInt(cal.data('colorpicker').fields.eq(1).val(), 10),
+						g: parseInt(cal.data('colorpicker').fields.eq(2).val(), 10),
+						b: parseInt(cal.data('colorpicker').fields.eq(3).val(), 10)
+					}));
+				}
+				if (ev) {
+					fillRGBFields(col, cal.get(0));
+					fillHexFields(col, cal.get(0));
+					fillHSBFields(col, cal.get(0));
+				}
+				setSelector(col, cal.get(0));
+				setHue(col, cal.get(0));
+				setNewColor(col, cal.get(0));
+				cal.data('colorpicker').onChange.apply(cal, [col, HSBToHex(col), HSBToRGB(col)]);
+			},
+			blur = function (ev) {
+				var cal = $(this).parent().parent();
+				cal.data('colorpicker').fields.parent().removeClass('colorpicker_focus');
+			},
+			focus = function () {
+				charMin = this.parentNode.className.indexOf('_hex') > 0 ? 70 : 65;
+				$(this).parent().parent().data('colorpicker').fields.parent().removeClass('colorpicker_focus');
+				$(this).parent().addClass('colorpicker_focus');
+			},
+			downIncrement = function (ev) {
+				var field = $(this).parent().find('input').focus();
+				var current = {
+					el: $(this).parent().addClass('colorpicker_slider'),
+					max: this.parentNode.className.indexOf('_hsb_h') > 0 ? 360 : (this.parentNode.className.indexOf('_hsb') > 0 ? 100 : 255),
+					y: ev.pageY,
+					field: field,
+					val: parseInt(field.val(), 10),
+					preview: $(this).parent().parent().data('colorpicker').livePreview
+				};
+				$(document).bind('mouseup', current, upIncrement);
+				$(document).bind('mousemove', current, moveIncrement);
+			},
+			moveIncrement = function (ev) {
+				ev.data.field.val(Math.max(0, Math.min(ev.data.max, parseInt(ev.data.val + ev.pageY - ev.data.y, 10))));
+				if (ev.data.preview) {
+					change.apply(ev.data.field.get(0), [true]);
+				}
+				return false;
+			},
+			upIncrement = function (ev) {
+				change.apply(ev.data.field.get(0), [true]);
+				ev.data.el.removeClass('colorpicker_slider').find('input').focus();
+				$(document).unbind('mouseup', upIncrement);
+				$(document).unbind('mousemove', moveIncrement);
+				return false;
+			},
+			downHue = function (ev) {
+				var current = {
+					cal: $(this).parent(),
+					y: $(this).offset().top
+				};
+				current.preview = current.cal.data('colorpicker').livePreview;
+				$(document).bind('mouseup', current, upHue);
+				$(document).bind('mousemove', current, moveHue);
+			},
+			moveHue = function (ev) {
+				change.apply(
+					ev.data.cal.data('colorpicker')
+						.fields
+						.eq(4)
+						.val(parseInt(360*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.y))))/150, 10))
+						.get(0),
+					[ev.data.preview]
+				);
+				return false;
+			},
+			upHue = function (ev) {
+				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
+				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
+				$(document).unbind('mouseup', upHue);
+				$(document).unbind('mousemove', moveHue);
+				return false;
+			},
+			downSelector = function (ev) {
+				var current = {
+					cal: $(this).parent(),
+					pos: $(this).offset()
+				};
+				current.preview = current.cal.data('colorpicker').livePreview;
+				$(document).bind('mouseup', current, upSelector);
+				$(document).bind('mousemove', current, moveSelector);
+			},
+			moveSelector = function (ev) {
+				change.apply(
+					ev.data.cal.data('colorpicker')
+						.fields
+						.eq(6)
+						.val(parseInt(100*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.pos.top))))/150, 10))
+						.end()
+						.eq(5)
+						.val(parseInt(100*(Math.max(0,Math.min(150,(ev.pageX - ev.data.pos.left))))/150, 10))
+						.get(0),
+					[ev.data.preview]
+				);
+				return false;
+			},
+			upSelector = function (ev) {
+				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
+				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
+				$(document).unbind('mouseup', upSelector);
+				$(document).unbind('mousemove', moveSelector);
+				return false;
+			},
+			enterSubmit = function (ev) {
+				$(this).addClass('colorpicker_focus');
+			},
+			leaveSubmit = function (ev) {
+				$(this).removeClass('colorpicker_focus');
+			},
+			clickSubmit = function (ev) {
+				var cal = $(this).parent();
+				var col = cal.data('colorpicker').color;
+				cal.data('colorpicker').origColor = col;
+				setCurrentColor(col, cal.get(0));
+				cal.data('colorpicker').onSubmit(col, HSBToHex(col), HSBToRGB(col), cal.data('colorpicker').el);
+			},
+			show = function (ev) {
+				var cal = $('#' + $(this).data('colorpickerId'));
+				cal.data('colorpicker').onBeforeShow.apply(this, [cal.get(0)]);
+				var pos = $(this).offset();
+				var viewPort = getViewport();
+				var fs_offset = $( '#tag-color' ).offset();
+				var top = (fs_offset.top) + $( '#tag-color' ).height() ;
+				var left = (fs_offset.left + 1);
+				cal.css({left: left + 'px', top: top + 'px'});
+				if (cal.data('colorpicker').onShow.apply(this, [cal.get(0)]) != false) {
+					cal.show();
+				}
+				$(document).bind('mousedown', {cal: cal}, hide);
+				return false;
+			},
+			hide = function (ev) {
+				if (!isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {
+					if (ev.data.cal.data('colorpicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
+						ev.data.cal.hide();
+					}
+					$(document).unbind('mousedown', hide);
+				}
+			},
+			isChildOf = function(parentEl, el, container) {
+				if (parentEl == el) {
+					return true;
+				}
+				if (parentEl.contains) {
+					return parentEl.contains(el);
+				}
+				if ( parentEl.compareDocumentPosition ) {
+					return !!(parentEl.compareDocumentPosition(el) & 16);
+				}
+				var prEl = el.parentNode;
+				while(prEl && prEl != container) {
+					if (prEl == parentEl)
+						return true;
+					prEl = prEl.parentNode;
+				}
+				return false;
+			},
+			getViewport = function () {
+				var m = document.compatMode == 'CSS1Compat';
+				return {
+					l : window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
+					t : window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
+					w : window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
+					h : window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
+				};
+			},
+			fixHSB = function (hsb) {
+				return {
+					h: Math.min(360, Math.max(0, hsb.h)),
+					s: Math.min(100, Math.max(0, hsb.s)),
+					b: Math.min(100, Math.max(0, hsb.b))
+				};
+			},
+			fixRGB = function (rgb) {
+				return {
+					r: Math.min(255, Math.max(0, rgb.r)),
+					g: Math.min(255, Math.max(0, rgb.g)),
+					b: Math.min(255, Math.max(0, rgb.b))
+				};
+			},
+			fixHex = function (hex) {
+				var len = 6 - hex.length;
+				if (len > 0) {
+					var o = [];
+					for (var i=0; i<len; i++) {
+						o.push('0');
+					}
+					o.push(hex);
+					hex = o.join('');
+				}
+				return hex;
+			},
+			HexToRGB = function (hex) {
+				var hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
+				return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
+			},
+			HexToHSB = function (hex) {
+				return RGBToHSB(HexToRGB(hex));
+			},
+			RGBToHSB = function (rgb) {
+				var hsb = {
+					h: 0,
+					s: 0,
+					b: 0
+				};
+				var min = Math.min(rgb.r, rgb.g, rgb.b);
+				var max = Math.max(rgb.r, rgb.g, rgb.b);
+				var delta = max - min;
+				hsb.b = max;
+				if (max != 0) {
+	
+				}
+				hsb.s = max != 0 ? 255 * delta / max : 0;
+				if (hsb.s != 0) {
+					if (rgb.r == max) {
+						hsb.h = (rgb.g - rgb.b) / delta;
+					} else if (rgb.g == max) {
+						hsb.h = 2 + (rgb.b - rgb.r) / delta;
+					} else {
+						hsb.h = 4 + (rgb.r - rgb.g) / delta;
+					}
+				} else {
+					hsb.h = -1;
+				}
+				hsb.h *= 60;
+				if (hsb.h < 0) {
+					hsb.h += 360;
+				}
+				hsb.s *= 100/255;
+				hsb.b *= 100/255;
+				return hsb;
+			},
+			HSBToRGB = function (hsb) {
+				var rgb = {};
+				var h = Math.round(hsb.h);
+				var s = Math.round(hsb.s*255/100);
+				var v = Math.round(hsb.b*255/100);
+				if(s == 0) {
+					rgb.r = rgb.g = rgb.b = v;
+				} else {
+					var t1 = v;
+					var t2 = (255-s)*v/255;
+					var t3 = (t1-t2)*(h%60)/60;
+					if(h==360) h = 0;
+					if(h<60) {rgb.r=t1;	rgb.b=t2; rgb.g=t2+t3}
+					else if(h<120) {rgb.g=t1; rgb.b=t2;	rgb.r=t1-t3}
+					else if(h<180) {rgb.g=t1; rgb.r=t2;	rgb.b=t2+t3}
+					else if(h<240) {rgb.b=t1; rgb.r=t2;	rgb.g=t1-t3}
+					else if(h<300) {rgb.b=t1; rgb.g=t2;	rgb.r=t2+t3}
+					else if(h<360) {rgb.r=t1; rgb.g=t2;	rgb.b=t1-t3}
+					else {rgb.r=0; rgb.g=0;	rgb.b=0}
+				}
+				return {r:Math.round(rgb.r), g:Math.round(rgb.g), b:Math.round(rgb.b)};
+			},
+			RGBToHex = function (rgb) {
+				var hex = [
+					rgb.r.toString(16),
+					rgb.g.toString(16),
+					rgb.b.toString(16)
+				];
+				$.each(hex, function (nr, val) {
+					if (val.length == 1) {
+						hex[nr] = '0' + val;
+					}
+				});
+				return hex.join('');
+			},
+			HSBToHex = function (hsb) {
+				return RGBToHex(HSBToRGB(hsb));
+			},
+			restoreOriginal = function () {
+				var cal = $(this).parent();
+				var col = cal.data('colorpicker').origColor;
+				cal.data('colorpicker').color = col;
+				fillRGBFields(col, cal.get(0));
+				fillHexFields(col, cal.get(0));
+				fillHSBFields(col, cal.get(0));
+				setSelector(col, cal.get(0));
+				setHue(col, cal.get(0));
+				setNewColor(col, cal.get(0));
+			};
+		return {
+			init: function (opt) {
+				opt = $.extend({}, defaults, opt||{});
+				if (typeof opt.color == 'string') {
+					opt.color = HexToHSB(opt.color);
+				} else if (opt.color.r != undefined && opt.color.g != undefined && opt.color.b != undefined) {
+					opt.color = RGBToHSB(opt.color);
+				} else if (opt.color.h != undefined && opt.color.s != undefined && opt.color.b != undefined) {
+					opt.color = fixHSB(opt.color);
+				} else {
+					return this;
+				}
+				return this.each(function () {
+					if (!$(this).data('colorpickerId')) {
+						var options = $.extend({}, opt);
+						options.origColor = opt.color;
+						var id = 'collorpicker_' + parseInt(Math.random() * 1000);
+						$(this).data('colorpickerId', id);
+						var cal = $(tpl).attr('id', id);
+						if (options.flat) {
+							cal.appendTo(this).show();
+						} else {
+							cal.appendTo(document.body);
+						}
+						options.fields = cal
+											.find('input')
+												.bind('keyup', keyDown)
+												.bind('change', change)
+												.bind('blur', blur)
+												.bind('focus', focus);
+						cal
+							.find('span').bind('mousedown', downIncrement).end()
+							.find('>div.colorpicker_current_color').bind('click', restoreOriginal);
+						options.selector = cal.find('div.colorpicker_color').bind('mousedown', downSelector);
+						options.selectorIndic = options.selector.find('div div');
+						options.el = this;
+						options.hue = cal.find('div.colorpicker_hue div');
+						cal.find('div.colorpicker_hue').bind('mousedown', downHue);
+						options.newColor = cal.find('div.colorpicker_new_color');
+						options.currentColor = cal.find('div.colorpicker_current_color');
+						cal.data('colorpicker', options);
+						cal.find('div.colorpicker_submit')
+							.bind('mouseenter', enterSubmit)
+							.bind('mouseleave', leaveSubmit)
+							.bind('click', clickSubmit);
+						fillRGBFields(options.color, cal.get(0));
+						fillHSBFields(options.color, cal.get(0));
+						fillHexFields(options.color, cal.get(0));
+						setHue(options.color, cal.get(0));
+						setSelector(options.color, cal.get(0));
+						setCurrentColor(options.color, cal.get(0));
+						setNewColor(options.color, cal.get(0));
+						if (options.flat) {
+							cal.css({
+								position: 'relative',
+								display: 'block'
+							});
+						} else {
+							$(this).bind(options.eventName, show);
+						}
+					}
+				});
+			},
+			showPicker: function() {
+				return this.each( function () {
+					if ($(this).data('colorpickerId')) {
+						show.apply(this);
+					}
+				});
+			},
+			hidePicker: function() {
+				return this.each( function () {
+					if ($(this).data('colorpickerId')) {
+						$('#' + $(this).data('colorpickerId')).hide();
+					}
+				});
+			},
+			setColor: function(col) {
+				if (typeof col == 'string') {
+					col = HexToHSB(col);
+				} else if (col.r != undefined && col.g != undefined && col.b != undefined) {
+					col = RGBToHSB(col);
+				} else if (col.h != undefined && col.s != undefined && col.b != undefined) {
+					col = fixHSB(col);
+				} else {
+					return this;
+				}
+				return this.each(function(){
+					if ($(this).data('colorpickerId')) {
+						var cal = $('#' + $(this).data('colorpickerId'));
+						cal.data('colorpicker').color = col;
+						cal.data('colorpicker').origColor = col;
+						fillRGBFields(col, cal.get(0));
+						fillHSBFields(col, cal.get(0));
+						fillHexFields(col, cal.get(0));
+						setHue(col, cal.get(0));
+						setSelector(col, cal.get(0));
+						setCurrentColor(col, cal.get(0));
+						setNewColor(col, cal.get(0));
+					}
+				});
+			}
+		};
+	}();
+	$.fn.extend({
+		ColorPicker: ColorPicker.init,
+		ColorPickerHide: ColorPicker.hidePicker,
+		ColorPickerShow: ColorPicker.showPicker,
+		ColorPickerSetColor: ColorPicker.setColor
+	});
+} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/geo_autocomplete.js b/public/js_src/external_libs/geo_autocomplete.js
new file mode 100644
index 0000000..b98d81d
--- /dev/null
+++ b/public/js_src/external_libs/geo_autocomplete.js
@@ -0,0 +1,93 @@
+define(
+		[
+		 "jquery_timely",
+		 "external_libs/jquery.autocomplete_geomod"
+		 ],
+		 function( $ ) {
+
+$.fn.extend({
+	geo_autocomplete: function( _geocoder, _options ) {
+		options = $.extend({}, $.Autocompleter.defaults, {
+			geocoder: _geocoder,
+			mapwidth: 100,
+			mapheight: 100,
+			maptype: 'terrain',
+			mapkey: 'ABQIAAAAbnvDoAoYOSW2iqoXiGTpYBT2yXp_ZAY8_ufC3CFXhHIE1NvwkxQNumU68AwGqjbSNF9YO8NokKst8w', // localhost
+			mapsensor: false,
+			parse: function(_results, _status, _query) {
+				var _parsed = [];
+				if (_results && _status && _status == 'OK') {
+					$.each(_results, function(_key, _result) {
+						if (_result.geometry && _result.geometry.viewport) {
+							// place is first matching segment, or first segment
+							var _place_parts = _result.formatted_address.split(',');
+							var _place = _place_parts[0];
+							$.each(_place_parts, function(_key, _part) {
+								if (_part.toLowerCase().indexOf(_query.toLowerCase()) != -1) {
+									_place = $.trim(_part);
+									return false; // break
+								}
+							});
+							_parsed.push({
+								data: _result,
+								value: _place,
+								result: _place
+							});
+						}
+					});
+				}
+				return _parsed;
+			},
+			formatItem: function(_data, _i, _n, _value) {
+				var _src = 'https://maps.google.com/maps/api/staticmap?visible=' +
+					_data.geometry.viewport.getSouthWest().toUrlValue() + '|' +
+					_data.geometry.viewport.getNorthEast().toUrlValue() +
+					'&size=' + options.mapwidth + 'x' + options.mapheight +
+					'&maptype=' + options.maptype +
+					'&key=' + options.mapkey +
+					'&sensor=' + (options.mapsensor ? 'true' : 'false');
+				var _place = _data.formatted_address.replace(/,/gi, ',<br/>');
+				return '<img src="' + _src + '" width="' + options.mapwidth +
+					'" height="' + options.mapheight + '" /> ' + _place +
+					'<br clear="both"/>';
+			}
+		}, _options);
+
+		// if highlight is set to false, replace it with a do-nothing function
+		options.highlight = options.highlight || function(value) { return value; };
+
+		// if the formatMatch option is not specified, then use formatItem for backwards compatibility
+		options.formatMatch = options.formatMatch || options.formatItem;
+
+		// Add class to hide results until restyled below.
+		options.resultsClass = 'ai1ec-geo-ac-results-not-ready';
+
+		return this.each( function() {
+			// Schedule polling function the first time the form element is focused.
+			// The polling function will check once a second if the results have been
+			// shown, and if so, apply markup-based styling to it. Then the function
+			// is cancelled.
+			$( this ).one( 'focus', function() {
+				var interval_id = setInterval(
+					function() {
+						var $results = $( '.ai1ec-geo-ac-results-not-ready' );
+						if ( $results.length ) {
+							$results
+								.removeClass( 'ai1ec-geo-ac-results-not-ready' )
+								.addClass( 'ai1ec-geo-ac-results' )
+								.wrap( '<div class="timely"/>' )
+								.children( 'ul' )
+									.addClass( 'dropdown-menu' );
+							clearInterval( interval_id );
+						}
+					},
+					500
+				);
+			} );
+
+			new $.Autocompleter( this, options );
+		} );
+	}
+});
+
+} );
diff --git a/public/js_src/external_libs/jquery.autocomplete_geomod.js b/public/js_src/external_libs/jquery.autocomplete_geomod.js
new file mode 100644
index 0000000..a7e41c6
--- /dev/null
+++ b/public/js_src/external_libs/jquery.autocomplete_geomod.js
@@ -0,0 +1,817 @@
+define( 
+		[
+		 "jquery_timely"
+		 ],
+function( $ ) {
+	
+	$.fn.extend({
+		autocomplete: function(urlOrData, options) {
+			var isUrl = typeof urlOrData == "string";
+			options = $.extend({}, $.Autocompleter.defaults, {
+				url: isUrl ? urlOrData : null,
+				data: isUrl ? null : urlOrData,
+				delay: isUrl ? $.Autocompleter.defaults.delay : 10,
+				max: options && !options.scroll ? 10 : 150
+			}, options);
+			
+			// if highlight is set to false, replace it with a do-nothing function
+			options.highlight = options.highlight || function(value) { return value; };
+			
+			// if the formatMatch option is not specified, then use formatItem for backwards compatibility
+			options.formatMatch = options.formatMatch || options.formatItem;
+			
+			return this.each(function() {
+				new $.Autocompleter(this, options);
+			});
+		},
+		result: function(handler) {
+			return this.bind("result", handler);
+		},
+		search: function(handler) {
+			return this.trigger("search", [handler]);
+		},
+		flushCache: function() {
+			return this.trigger("flushCache");
+		},
+		setOptions: function(options){
+			return this.trigger("setOptions", [options]);
+		},
+		unautocomplete: function() {
+			return this.trigger("unautocomplete");
+		}
+	});
+
+	$.Autocompleter = function(input, options) {
+
+		var KEY = {
+			UP: 38,
+			DOWN: 40,
+			DEL: 46,
+			TAB: 9,
+			RETURN: 13,
+			ESC: 27,
+			COMMA: 188,
+			PAGEUP: 33,
+			PAGEDOWN: 34,
+			BACKSPACE: 8
+		};
+
+		// Create $ object for input element
+		var $input = $(input).attr("autocomplete", "off").addClass(options.inputClass);
+
+		var timeout;
+		var previousValue = "";
+		var cache = $.Autocompleter.Cache(options);
+		var hasFocus = 0;
+		var lastKeyPressCode;
+		var isOpera = navigator.userAgent.match(/opera/i)
+		var config = {
+			mouseDownOnSelect: false
+		};
+		var select = $.Autocompleter.Select(options, input, selectCurrent, config);
+		
+		var blockSubmit;
+		
+		// prevent form submit in opera when selecting with return key
+		isOpera && $(input.form).bind("submit.autocomplete", function() {
+			if (blockSubmit) {
+				blockSubmit = false;
+				return false;
+			}
+		});
+		
+		// only opera doesn't trigger keydown multiple times while pressed, others don't work with keypress at all
+		$input.bind((isOpera ? "keypress" : "keydown") + ".autocomplete", function(event) {
+			// a keypress means the input has focus
+			// avoids issue where input had focus before the autocomplete was applied
+			hasFocus = 1;
+			// track last key pressed
+			lastKeyPressCode = event.keyCode;
+			switch(event.keyCode) {
+			
+				case KEY.UP:
+					event.preventDefault();
+					if ( select.visible() ) {
+						select.prev();
+					} else {
+						onChange(0, true);
+					}
+					break;
+					
+				case KEY.DOWN:
+					event.preventDefault();
+					if ( select.visible() ) {
+						select.next();
+					} else {
+						onChange(0, true);
+					}
+					break;
+					
+				case KEY.PAGEUP:
+					event.preventDefault();
+					if ( select.visible() ) {
+						select.pageUp();
+					} else {
+						onChange(0, true);
+					}
+					break;
+					
+				case KEY.PAGEDOWN:
+					event.preventDefault();
+					if ( select.visible() ) {
+						select.pageDown();
+					} else {
+						onChange(0, true);
+					}
+					break;
+				
+				// matches also semicolon
+				case options.multiple && $.trim(options.multipleSeparator) == "," && KEY.COMMA:
+				case KEY.TAB:
+				case KEY.RETURN:
+					if( selectCurrent() ) {
+						// stop default to prevent a form submit, Opera needs special handling
+						event.preventDefault();
+						blockSubmit = true;
+						return false;
+					}
+					break;
+					
+				case KEY.ESC:
+					select.hide();
+					break;
+					
+				default:
+					clearTimeout(timeout);
+					timeout = setTimeout(onChange, options.delay);
+					break;
+			}
+		}).focus(function(){
+			// track whether the field has focus, we shouldn't process any
+			// results if the field no longer has focus
+			hasFocus++;
+		}).blur(function() {
+			hasFocus = 0;
+			if (!config.mouseDownOnSelect) {
+				hideResults();
+			}
+		}).click(function() {
+			// show select when clicking in a focused field
+			if ( hasFocus++ > 1 && !select.visible() ) {
+				onChange(0, true);
+			}
+		}).bind("search", function() {
+			// TODO why not just specifying both arguments?
+			var fn = (arguments.length > 1) ? arguments[1] : null;
+			function findValueCallback(q, data) {
+				var result;
+				if( data && data.length ) {
+					for (var i=0; i < data.length; i++) {
+						if( data[i].result.toLowerCase() == q.toLowerCase() ) {
+							result = data[i];
+							break;
+						}
+					}
+				}
+				if( typeof fn == "function" ) fn(result);
+				else $input.trigger("result", result && [result.data, result.value]);
+			}
+			$.each(trimWords($input.val()), function(i, value) {
+				request(value, findValueCallback, findValueCallback);
+			});
+		}).bind("flushCache", function() {
+			cache.flush();
+		}).bind("setOptions", function() {
+			$.extend(options, arguments[1]);
+			// if we've updated the data, repopulate
+			if ( "data" in arguments[1] )
+				cache.populate();
+		}).bind("unautocomplete", function() {
+			select.unbind();
+			$input.unbind();
+			$(input.form).unbind(".autocomplete");
+		});
+		
+		
+		function selectCurrent() {
+			var selected = select.selected();
+			if( !selected )
+				return false;
+			
+			var v = selected.result;
+			previousValue = v;
+			
+			if ( options.multiple ) {
+				var words = trimWords($input.val());
+				if ( words.length > 1 ) {
+					var seperator = options.multipleSeparator.length;
+					var cursorAt = $(input).selection().start;
+					var wordAt, progress = 0;
+					$.each(words, function(i, word) {
+						progress += word.length;
+						if (cursorAt <= progress) {
+							wordAt = i;
+							return false;
+						}
+						progress += seperator;
+					});
+					words[wordAt] = v;
+					// TODO this should set the cursor to the right position, but it gets overriden somewhere
+					//$.Autocompleter.Selection(input, progress + seperator, progress + seperator);
+					v = words.join( options.multipleSeparator );
+				}
+				v += options.multipleSeparator;
+			}
+			
+			$input.val(v);
+			hideResultsNow();
+			$input.trigger("result", [selected.data, selected.value]);
+			return true;
+		}
+		
+		function onChange(crap, skipPrevCheck) {
+			if( lastKeyPressCode == KEY.DEL ) {
+				select.hide();
+				return;
+			}
+			
+			var currentValue = $input.val();
+			
+			if ( !skipPrevCheck && currentValue == previousValue )
+				return;
+			
+			previousValue = currentValue;
+			
+			currentValue = lastWord(currentValue);
+			if ( currentValue.length >= options.minChars) {
+				$input.addClass(options.loadingClass);
+				if (!options.matchCase)
+					currentValue = currentValue.toLowerCase();
+				request(currentValue, receiveData, hideResultsNow);
+			} else {
+				stopLoading();
+				select.hide();
+			}
+		};
+		
+		function trimWords(value) {
+			if (!value)
+				return [""];
+			if (!options.multiple)
+				return [$.trim(value)];
+			return $.map(value.split(options.multipleSeparator), function(word) {
+				return $.trim(value).length ? $.trim(word) : null;
+			});
+		}
+		
+		function lastWord(value) {
+			if ( !options.multiple )
+				return value;
+			var words = trimWords(value);
+			if (words.length == 1) 
+				return words[0];
+			var cursorAt = $(input).selection().start;
+			if (cursorAt == value.length) {
+				words = trimWords(value)
+			} else {
+				words = trimWords(value.replace(value.substring(cursorAt), ""));
+			}
+			return words[words.length - 1];
+		}
+		
+		// fills in the input box w/the first match (assumed to be the best match)
+		// q: the term entered
+		// sValue: the first matching result
+		function autoFill(q, sValue){
+			// autofill in the complete box w/the first match as long as the user hasn't entered in more data
+			// if the last user key pressed was backspace, don't autofill
+			if( options.autoFill && (lastWord($input.val()).toLowerCase() == q.toLowerCase()) && lastKeyPressCode != KEY.BACKSPACE ) {
+				// fill in the value (keep the case the user has typed)
+				$input.val($input.val() + sValue.substring(lastWord(previousValue).length));
+				// select the portion of the value not typed by the user (so the next character will erase)
+				$(input).selection(previousValue.length, previousValue.length + sValue.length);
+			}
+		};
+
+		function hideResults() {
+			clearTimeout(timeout);
+			timeout = setTimeout(hideResultsNow, 200);
+		};
+
+		function hideResultsNow() {
+			var wasVisible = select.visible();
+			select.hide();
+			clearTimeout(timeout);
+			stopLoading();
+			if (options.mustMatch) {
+				// call search and run callback
+				$input.search(
+					function (result){
+						// if no value found, clear the input box
+						if( !result ) {
+							if (options.multiple) {
+								var words = trimWords($input.val()).slice(0, -1);
+								$input.val( words.join(options.multipleSeparator) + (words.length ? options.multipleSeparator : "") );
+							}
+							else {
+								$input.val( "" );
+								$input.trigger("result", null);
+							}
+						}
+					}
+				);
+			}
+		};
+
+		function receiveData(q, data) {
+			if ( data && data.length && hasFocus ) {
+				stopLoading();
+				select.display(data, q);
+				autoFill(q, data[0].value);
+				select.show();
+			} else {
+				hideResultsNow();
+			}
+		};
+
+		function request(term, success, failure) {
+			if (!options.matchCase)
+				term = term.toLowerCase();
+			var data = cache.load(term);
+			// recieve the cached data
+			if (data && data.length) {
+				success(term, data);
+
+			// start geo_Autocomplete mod
+			// request handler for google geocoder
+			} else if (options.geocoder) {
+				var _query = lastWord(term);
+				var _opts = { 'address': _query };
+				if( options.region )
+					_opts.region = options.region;
+				
+				options.geocoder.geocode( _opts, function(_results, _status) {
+					var parsed = options.parse(_results, _status, _query);
+					cache.add(term, parsed);
+					success(term, parsed);
+				});
+			// end geo_Autocomplete mod
+					
+			// if an AJAX url has been supplied, try loading the data now
+			} else if( (typeof options.url == "string") && (options.url.length > 0) ){
+				
+				var extraParams = {
+					timestamp: +new Date()
+				};
+				$.each(options.extraParams, function(key, param) {
+					extraParams[key] = typeof param == "function" ? param() : param;
+				});
+							
+				$.ajax({
+					// try to leverage ajaxQueue plugin to abort previous requests
+					mode: "abort",
+					// limit abortion to this input
+					port: "autocomplete" + input.name,
+					dataType: options.dataType,
+					url: options.url,
+					data: $.extend({
+						q: lastWord(term),
+						limit: options.max
+					}, extraParams),
+					success: function(data) {
+						var parsed = options.parse && options.parse(data) || parse(data);
+						cache.add(term, parsed);
+						success(term, parsed);
+					}
+				});
+				
+			} else {
+				// if we have a failure, we need to empty the list -- this prevents the the [TAB] key from selecting the last successful match
+				select.emptyList();
+				failure(term);
+			}
+		};
+		
+		function parse(data) {
+			var parsed = [];
+			var rows = data.split("\n");
+			for (var i=0; i < rows.length; i++) {
+				var row = $.trim(rows[i]);
+				if (row) {
+					row = row.split("|");
+					parsed[parsed.length] = {
+						data: row,
+						value: row[0],
+						result: options.formatResult && options.formatResult(row, row[0]) || row[0]
+					};
+				}
+			}
+			return parsed;
+		};
+
+		function stopLoading() {
+			$input.removeClass(options.loadingClass);
+		};
+
+	};
+
+	$.Autocompleter.defaults = {
+		inputClass: "ac_input",
+		resultsClass: "ac_results",
+		loadingClass: "ac_loading",
+		minChars: 1,
+		delay: 400,
+		matchCase: false,
+		matchSubset: true,
+		matchContains: false,
+		cacheLength: 10,
+		max: 100,
+		mustMatch: false,
+		extraParams: {},
+		selectFirst: true,
+		formatItem: function(row) { return row[0]; },
+		formatMatch: null,
+		autoFill: false,
+		width: 0,
+		multiple: false,
+		multipleSeparator: ", ",
+		highlight: function(value, term) {
+			return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<strong>$1</strong>");
+		},
+	    scroll: true,
+	    scrollHeight: 180
+	};
+
+	$.Autocompleter.Cache = function(options) {
+
+		var data = {};
+		var length = 0;
+		
+		function matchSubset(s, sub) {
+			if (!options.matchCase) 
+				s = s.toLowerCase();
+			var i = s.indexOf(sub);
+			if (options.matchContains == "word"){
+				i = s.toLowerCase().search("\\b" + sub.toLowerCase());
+			}
+			if (i == -1) return false;
+			return i == 0 || options.matchContains;
+		};
+		
+		function add(q, value) {
+			if (length > options.cacheLength){
+				flush();
+			}
+			if (!data[q]){ 
+				length++;
+			}
+			data[q] = value;
+		}
+		
+		function populate(){
+			if( !options.data ) return false;
+			// track the matches
+			var stMatchSets = {},
+				nullData = 0;
+
+			// no url was specified, we need to adjust the cache length to make sure it fits the local data store
+			if( !options.url ) options.cacheLength = 1;
+			
+			// track all options for minChars = 0
+			stMatchSets[""] = [];
+			
+			// loop through the array and create a lookup structure
+			for ( var i = 0, ol = options.data.length; i < ol; i++ ) {
+				var rawValue = options.data[i];
+				// if rawValue is a string, make an array otherwise just reference the array
+				rawValue = (typeof rawValue == "string") ? [rawValue] : rawValue;
+				
+				var value = options.formatMatch(rawValue, i+1, options.data.length);
+				if ( value === false )
+					continue;
+					
+				var firstChar = value.charAt(0).toLowerCase();
+				// if no lookup array for this character exists, look it up now
+				if( !stMatchSets[firstChar] ) 
+					stMatchSets[firstChar] = [];
+
+				// if the match is a string
+				var row = {
+					value: value,
+					data: rawValue,
+					result: options.formatResult && options.formatResult(rawValue) || value
+				};
+				
+				// push the current match into the set list
+				stMatchSets[firstChar].push(row);
+
+				// keep track of minChars zero items
+				if ( nullData++ < options.max ) {
+					stMatchSets[""].push(row);
+				}
+			};
+
+			// add the data items to the cache
+			$.each(stMatchSets, function(i, value) {
+				// increase the cache size
+				options.cacheLength++;
+				// add to the cache
+				add(i, value);
+			});
+		}
+		
+		// populate any existing data
+		setTimeout(populate, 25);
+		
+		function flush(){
+			data = {};
+			length = 0;
+		}
+		
+		return {
+			flush: flush,
+			add: add,
+			populate: populate,
+			load: function(q) {
+				if (!options.cacheLength || !length)
+					return null;
+				/* 
+				 * if dealing w/local data and matchContains than we must make sure
+				 * to loop through all the data collections looking for matches
+				 */
+				if( !options.url && options.matchContains ){
+					// track all matches
+					var csub = [];
+					// loop through all the data grids for matches
+					for( var k in data ){
+						// don't search through the stMatchSets[""] (minChars: 0) cache
+						// this prevents duplicates
+						if( k.length > 0 ){
+							var c = data[k];
+							$.each(c, function(i, x) {
+								// if we've got a match, add it to the array
+								if (matchSubset(x.value, q)) {
+									csub.push(x);
+								}
+							});
+						}
+					}				
+					return csub;
+				} else 
+				// if the exact item exists, use it
+				if (data[q]){
+					return data[q];
+				} else
+				if (options.matchSubset) {
+					for (var i = q.length - 1; i >= options.minChars; i--) {
+						var c = data[q.substr(0, i)];
+						if (c) {
+							var csub = [];
+							$.each(c, function(i, x) {
+								if (matchSubset(x.value, q)) {
+									csub[csub.length] = x;
+								}
+							});
+							return csub;
+						}
+					}
+				}
+				return null;
+			}
+		};
+	};
+
+	$.Autocompleter.Select = function (options, input, select, config) {
+		var CLASSES = {
+			ACTIVE: "ac_over"
+		};
+		
+		var listItems,
+			active = -1,
+			data,
+			term = "",
+			needsInit = true,
+			element,
+			list;
+		
+		// Create results
+		function init() {
+			if (!needsInit)
+				return;
+			element = $("<div/>")
+			.hide()
+			.addClass(options.resultsClass)
+			.css("position", "absolute")
+			.appendTo(document.body);
+		
+			list = $("<ul/>").appendTo(element).mouseover( function(event) {
+				if(target(event).nodeName && target(event).nodeName.toUpperCase() == 'LI') {
+		            active = $("li", list).removeClass(CLASSES.ACTIVE).index(target(event));
+				    $(target(event)).addClass(CLASSES.ACTIVE);            
+		        }
+			}).click(function(event) {
+				$(target(event)).addClass(CLASSES.ACTIVE);
+				select();
+				// TODO provide option to avoid setting focus again after selection? useful for cleanup-on-focus
+				input.focus();
+				return false;
+			}).mousedown(function() {
+				config.mouseDownOnSelect = true;
+			}).mouseup(function() {
+				config.mouseDownOnSelect = false;
+			});
+			
+			if( options.width > 0 )
+				element.css("width", options.width);
+				
+			needsInit = false;
+		} 
+		
+		function target(event) {
+			var element = event.target;
+			while(element && element.tagName != "LI")
+				element = element.parentNode;
+			// more fun with IE, sometimes event.target is empty, just ignore it then
+			if(!element)
+				return [];
+			return element;
+		}
+
+		function moveSelect(step) {
+			listItems.slice(active, active + 1).removeClass(CLASSES.ACTIVE);
+			movePosition(step);
+	        var activeItem = listItems.slice(active, active + 1).addClass(CLASSES.ACTIVE);
+	        if(options.scroll) {
+	            var offset = 0;
+	            listItems.slice(0, active).each(function() {
+					offset += this.offsetHeight;
+				});
+	            if((offset + activeItem[0].offsetHeight - list.scrollTop()) > list[0].clientHeight) {
+	                list.scrollTop(offset + activeItem[0].offsetHeight - list.innerHeight());
+	            } else if(offset < list.scrollTop()) {
+	                list.scrollTop(offset);
+	            }
+	        }
+		};
+		
+		function movePosition(step) {
+			active += step;
+			if (active < 0) {
+				active = listItems.size() - 1;
+			} else if (active >= listItems.size()) {
+				active = 0;
+			}
+		}
+		
+		function limitNumberOfItems(available) {
+			return options.max && options.max < available
+				? options.max
+				: available;
+		}
+		
+		function fillList() {
+			list.empty();
+			var max = limitNumberOfItems(data.length);
+			for (var i=0; i < max; i++) {
+				if (!data[i])
+					continue;
+				var formatted = options.formatItem(data[i].data, i+1, max, data[i].value, term);
+				if ( formatted === false )
+					continue;
+				var li = $("<li/>").html( options.highlight(formatted, term) ).addClass(i%2 == 0 ? "ac_even" : "ac_odd").appendTo(list)[0];
+				$.data(li, "ac_data", data[i]);
+			}
+			listItems = list.find("li");
+			if ( options.selectFirst ) {
+				listItems.slice(0, 1).addClass(CLASSES.ACTIVE);
+				active = 0;
+			}
+			// apply bgiframe if available
+			if ( $.fn.bgiframe )
+				list.bgiframe();
+		}
+		
+		return {
+			display: function(d, q) {
+				init();
+				data = d;
+				term = q;
+				fillList();
+			},
+			next: function() {
+				moveSelect(1);
+			},
+			prev: function() {
+				moveSelect(-1);
+			},
+			pageUp: function() {
+				if (active != 0 && active - 8 < 0) {
+					moveSelect( -active );
+				} else {
+					moveSelect(-8);
+				}
+			},
+			pageDown: function() {
+				if (active != listItems.size() - 1 && active + 8 > listItems.size()) {
+					moveSelect( listItems.size() - 1 - active );
+				} else {
+					moveSelect(8);
+				}
+			},
+			hide: function() {
+				element && element.hide();
+				listItems && listItems.removeClass(CLASSES.ACTIVE);
+				active = -1;
+			},
+			visible : function() {
+				return element && element.is(":visible");
+			},
+			current: function() {
+				return this.visible() && (listItems.filter("." + CLASSES.ACTIVE)[0] || options.selectFirst && listItems[0]);
+			},
+			show: function() {
+				var offset = $(input).offset();
+				element.css({
+					width: typeof options.width == "string" || options.width > 0 ? options.width : $(input).width(),
+					top: offset.top + input.offsetHeight,
+					left: offset.left
+				}).show();
+	            if(options.scroll) {
+	                list.scrollTop(0);
+	                list.css({
+						maxHeight: options.scrollHeight,
+						overflow: 'auto'
+					});
+					
+	                if(navigator.userAgent.match(/msie/i) && typeof document.body.style.maxHeight === "undefined") {
+						var listHeight = 0;
+						listItems.each(function() {
+							listHeight += this.offsetHeight;
+						});
+						var scrollbarsVisible = listHeight > options.scrollHeight;
+	                    list.css('height', scrollbarsVisible ? options.scrollHeight : listHeight );
+						if (!scrollbarsVisible) {
+							// IE doesn't recalculate width when scrollbar disappears
+							listItems.width( list.width() - parseInt(listItems.css("padding-left")) - parseInt(listItems.css("padding-right")) );
+						}
+	                }
+	                
+	            }
+			},
+			selected: function() {
+				var selected = listItems && listItems.filter("." + CLASSES.ACTIVE).removeClass(CLASSES.ACTIVE);
+				return selected && selected.length && $.data(selected[0], "ac_data");
+			},
+			emptyList: function (){
+				list && list.empty();
+			},
+			unbind: function() {
+				element && element.remove();
+			}
+		};
+	};
+
+	$.fn.selection = function(start, end) {
+		if (start !== undefined) {
+			return this.each(function() {
+				if( this.createTextRange ){
+					var selRange = this.createTextRange();
+					if (end === undefined || start == end) {
+						selRange.move("character", start);
+						selRange.select();
+					} else {
+						selRange.collapse(true);
+						selRange.moveStart("character", start);
+						selRange.moveEnd("character", end);
+						selRange.select();
+					}
+				} else if( this.setSelectionRange ){
+					this.setSelectionRange(start, end);
+				} else if( this.selectionStart ){
+					this.selectionStart = start;
+					this.selectionEnd = end;
+				}
+			});
+		}
+		var field = this[0];
+		if ( field.createTextRange ) {
+			var range = document.selection.createRange(),
+				orig = field.value,
+				teststring = "<->",
+				textLength = range.text.length;
+			range.text = teststring;
+			var caretAt = field.value.indexOf(teststring);
+			field.value = orig;
+			this.selection(caretAt, caretAt + textLength);
+			return {
+				start: caretAt,
+				end: caretAt + textLength
+			}
+		} else if( field.selectionStart !== undefined ){
+			return {
+				start: field.selectionStart,
+				end: field.selectionEnd
+			}
+		}
+	};
+} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/jquery.blockui.js b/public/js_src/external_libs/jquery.blockui.js
new file mode 100644
index 0000000..f0a15e7
--- /dev/null
+++ b/public/js_src/external_libs/jquery.blockui.js
@@ -0,0 +1,592 @@
+define( 
+		[
+		 "jquery_timely"
+		 ],
+		 function( jQuery ) {
+			
+			/*!
+			 * jQuery blockUI plugin
+			 * Version 2.59.0-2013.04.05
+			 * @requires jQuery v1.7 or later
+			 *
+			 * Examples at: http://malsup.com/jquery/block/
+			 * Copyright (c) 2007-2013 M. Alsup
+			 * Dual licensed under the MIT and GPL licenses:
+			 * http://www.opensource.org/licenses/mit-license.php
+			 * http://www.gnu.org/licenses/gpl.html
+			 *
+			 * Thanks to Amir-Hossein Sobhi for some excellent contributions!
+			 */
+
+			;(function() {
+			/*jshint eqeqeq:false curly:false latedef:false */
+			"use strict";
+
+				function setup($) {
+					$.fn._fadeIn = $.fn.fadeIn;
+
+					var noOp = $.noop || function() {};
+
+					// this bit is to ensure we don't call setExpression when we shouldn't (with extra muscle to handle
+					// retarded userAgent strings on Vista)
+					var msie = /MSIE/.test(navigator.userAgent);
+					var ie6  = /MSIE 6.0/.test(navigator.userAgent) && ! /MSIE 8.0/.test(navigator.userAgent);
+					var mode = document.documentMode || 0;
+					var setExpr = $.isFunction( document.createElement('div').style.setExpression );
+
+					// global $ methods for blocking/unblocking the entire page
+					$.blockUI   = function(opts) { install(window, opts); };
+					$.unblockUI = function(opts) { remove(window, opts); };
+
+					// convenience method for quick growl-like notifications  (http://www.google.com/search?q=growl)
+					$.growlUI = function(title, message, timeout, onClose) {
+						var $m = $('<div class="growlUI"></div>');
+						if (title) $m.append('<h1>'+title+'</h1>');
+						if (message) $m.append('<h2>'+message+'</h2>');
+						if (timeout === undefined) timeout = 3000;
+						$.blockUI({
+							message: $m, fadeIn: 700, fadeOut: 1000, centerY: false,
+							timeout: timeout, showOverlay: false,
+							onUnblock: onClose,
+							css: $.blockUI.defaults.growlCSS
+						});
+					};
+
+					// plugin method for blocking element content
+					$.fn.block = function(opts) {
+						if ( this[0] === window ) {
+							$.blockUI( opts );
+							return this;
+						}
+						var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
+						this.each(function() {
+							var $el = $(this);
+							if (fullOpts.ignoreIfBlocked && $el.data('blockUI.isBlocked'))
+								return;
+							$el.unblock({ fadeOut: 0 });
+						});
+
+						return this.each(function() {
+							if ($.css(this,'position') == 'static') {
+								this.style.position = 'relative';
+								$(this).data('blockUI.static', true);
+							}
+							this.style.zoom = 1; // force 'hasLayout' in ie
+							install(this, opts);
+						});
+					};
+
+					// plugin method for unblocking element content
+					$.fn.unblock = function(opts) {
+						if ( this[0] === window ) {
+							$.unblockUI( opts );
+							return this;
+						}
+						return this.each(function() {
+							remove(this, opts);
+						});
+					};
+
+					$.blockUI.version = 2.59; // 2nd generation blocking at no extra cost!
+
+					// override these in your code to change the default behavior and style
+					$.blockUI.defaults = {
+						// message displayed when blocking (use null for no message)
+						message:  '<h1>Please wait...</h1>',
+
+						title: null,		// title string; only used when theme == true
+						draggable: true,	// only used when theme == true (requires jquery-ui.js to be loaded)
+
+						theme: false, // set to true to use with jQuery UI themes
+
+						// styles for the message when blocking; if you wish to disable
+						// these and use an external stylesheet then do this in your code:
+						// $.blockUI.defaults.css = {};
+						css: {
+							padding:	0,
+							margin:		0,
+							width:		'30%',
+							top:		'40%',
+							left:		'35%',
+							textAlign:	'center',
+							color:		'#000',
+							border:		'3px solid #aaa',
+							backgroundColor:'#fff',
+							cursor:		'wait'
+						},
+
+						// minimal style set used when themes are used
+						themedCSS: {
+							width:	'30%',
+							top:	'40%',
+							left:	'35%'
+						},
+
+						// styles for the overlay
+						overlayCSS:  {
+							backgroundColor:	'#000',
+							opacity:			0.6,
+							cursor:				'wait'
+						},
+
+						// style to replace wait cursor before unblocking to correct issue
+						// of lingering wait cursor
+						cursorReset: 'default',
+
+						// styles applied when using $.growlUI
+						growlCSS: {
+							width:		'350px',
+							top:		'10px',
+							left:		'',
+							right:		'10px',
+							border:		'none',
+							padding:	'5px',
+							opacity:	0.6,
+							cursor:		'default',
+							color:		'#fff',
+							backgroundColor: '#000',
+							'-webkit-border-radius':'10px',
+							'-moz-border-radius':	'10px',
+							'border-radius':		'10px'
+						},
+
+						// IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w
+						// (hat tip to Jorge H. N. de Vasconcelos)
+						/*jshint scripturl:true */
+						iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank',
+
+						// force usage of iframe in non-IE browsers (handy for blocking applets)
+						forceIframe: false,
+
+						// z-index for the blocking overlay
+						baseZ: 1000,
+
+						// set these to true to have the message automatically centered
+						centerX: true, // <-- only effects element blocking (page block controlled via css above)
+						centerY: true,
+
+						// allow body element to be stetched in ie6; this makes blocking look better
+						// on "short" pages.  disable if you wish to prevent changes to the body height
+						allowBodyStretch: true,
+
+						// enable if you want key and mouse events to be disabled for content that is blocked
+						bindEvents: true,
+
+						// be default blockUI will supress tab navigation from leaving blocking content
+						// (if bindEvents is true)
+						constrainTabKey: true,
+
+						// fadeIn time in millis; set to 0 to disable fadeIn on block
+						fadeIn:  200,
+
+						// fadeOut time in millis; set to 0 to disable fadeOut on unblock
+						fadeOut:  400,
+
+						// time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
+						timeout: 0,
+
+						// disable if you don't want to show the overlay
+						showOverlay: true,
+
+						// if true, focus will be placed in the first available input field when
+						// page blocking
+						focusInput: true,
+
+						// suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
+						// no longer needed in 2012
+						// applyPlatformOpacityRules: true,
+
+						// callback method invoked when fadeIn has completed and blocking message is visible
+						onBlock: null,
+
+						// callback method invoked when unblocking has completed; the callback is
+						// passed the element that has been unblocked (which is the window object for page
+						// blocks) and the options that were passed to the unblock call:
+						//	onUnblock(element, options)
+						onUnblock: null,
+
+						// callback method invoked when the overlay area is clicked.
+						// setting this will turn the cursor to a pointer, otherwise cursor defined in overlayCss will be used.
+						onOverlayClick: null,
+
+						// don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493
+						quirksmodeOffsetHack: 4,
+
+						// class name of the message block
+						blockMsgClass: 'blockMsg',
+
+						// if it is already blocked, then ignore it (don't unblock and reblock)
+						ignoreIfBlocked: false
+					};
+
+					// private data and functions follow...
+
+					var pageBlock = null;
+					var pageBlockEls = [];
+
+					function install(el, opts) {
+						var css, themedCSS;
+						var full = (el == window);
+						var msg = (opts && opts.message !== undefined ? opts.message : undefined);
+						opts = $.extend({}, $.blockUI.defaults, opts || {});
+
+						if (opts.ignoreIfBlocked && $(el).data('blockUI.isBlocked'))
+							return;
+
+						opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
+						css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
+						if (opts.onOverlayClick)
+							opts.overlayCSS.cursor = 'pointer';
+
+						themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
+						msg = msg === undefined ? opts.message : msg;
+
+						// remove the current block (if there is one)
+						if (full && pageBlock)
+							remove(window, {fadeOut:0});
+
+						// if an existing element is being used as the blocking content then we capture
+						// its current place in the DOM (and current display style) so we can restore
+						// it when we unblock
+						if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) {
+							var node = msg.jquery ? msg[0] : msg;
+							var data = {};
+							$(el).data('blockUI.history', data);
+							data.el = node;
+							data.parent = node.parentNode;
+							data.display = node.style.display;
+							data.position = node.style.position;
+							if (data.parent)
+								data.parent.removeChild(node);
+						}
+
+						$(el).data('blockUI.onUnblock', opts.onUnblock);
+						var z = opts.baseZ;
+
+						// blockUI uses 3 layers for blocking, for simplicity they are all used on every platform;
+						// layer1 is the iframe layer which is used to supress bleed through of underlying content
+						// layer2 is the overlay layer which has opacity and a wait cursor (by default)
+						// layer3 is the message content that is displayed while blocking
+						var lyr1, lyr2, lyr3, s;
+						if (msie || opts.forceIframe)
+							lyr1 = $('<iframe class="blockUI" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="'+opts.iframeSrc+'"></iframe>');
+						else
+							lyr1 = $('<div class="blockUI" style="display:none"></div>');
+
+						if (opts.theme)
+							lyr2 = $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:'+ (z++) +';display:none"></div>');
+						else
+							lyr2 = $('<div class="blockUI blockOverlay" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
+
+						if (opts.theme && full) {
+							s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:fixed">';
+							if ( opts.title ) {
+								s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>';
+							}
+							s += '<div class="ui-widget-content ui-dialog-content"></div>';
+							s += '</div>';
+						}
+						else if (opts.theme) {
+							s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:absolute">';
+							if ( opts.title ) {
+								s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>';
+							}  
+							s += '<div class="ui-widget-content ui-dialog-content"></div>';
+							s += '</div>';
+						}
+						else if (full) {
+							s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:'+(z+10)+';display:none;position:fixed"></div>';
+						}
+						else {
+							s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:'+(z+10)+';display:none;position:absolute"></div>';
+						}
+						lyr3 = $(s);
+
+						// if we have a message, style it
+						if (msg) {
+							if (opts.theme) {
+								lyr3.css(themedCSS);
+								lyr3.addClass('ui-widget-content');
+							}
+							else
+								lyr3.css(css);
+						}
+
+						// style the overlay
+						if (!opts.theme /*&& (!opts.applyPlatformOpacityRules)*/)
+							lyr2.css(opts.overlayCSS);
+						lyr2.css('position', full ? 'fixed' : 'absolute');
+
+						// make iframe layer transparent in IE
+						if (msie || opts.forceIframe)
+							lyr1.css('opacity',0.0);
+
+						//$([lyr1[0],lyr2[0],lyr3[0]]).appendTo(full ? 'body' : el);
+						var layers = [lyr1,lyr2,lyr3], $par = full ? $('body') : $(el);
+						$.each(layers, function() {
+							this.appendTo($par);
+						});
+
+						if (opts.theme && opts.draggable && $.fn.draggable) {
+							lyr3.draggable({
+								handle: '.ui-dialog-titlebar',
+								cancel: 'li'
+							});
+						}
+
+						// ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling)
+						var expr = setExpr && (!$.support.boxModel || $('object,embed', full ? null : el).length > 0);
+						if (ie6 || expr) {
+							// give body 100% height
+							if (full && opts.allowBodyStretch && $.support.boxModel)
+								$('html,body').css('height','100%');
+
+							// fix ie6 issue when blocked element has a border width
+							if ((ie6 || !$.support.boxModel) && !full) {
+								var t = sz(el,'borderTopWidth'), l = sz(el,'borderLeftWidth');
+								var fixT = t ? '(0 - '+t+')' : 0;
+								var fixL = l ? '(0 - '+l+')' : 0;
+							}
+
+							// simulate fixed position
+							$.each(layers, function(i,o) {
+								var s = o[0].style;
+								s.position = 'absolute';
+								if (i < 2) {
+									if (full)
+										s.setExpression('height','Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:'+opts.quirksmodeOffsetHack+') + "px"');
+									else
+										s.setExpression('height','this.parentNode.offsetHeight + "px"');
+									if (full)
+										s.setExpression('width','jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"');
+									else
+										s.setExpression('width','this.parentNode.offsetWidth + "px"');
+									if (fixL) s.setExpression('left', fixL);
+									if (fixT) s.setExpression('top', fixT);
+								}
+								else if (opts.centerY) {
+									if (full) s.setExpression('top','(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
+									s.marginTop = 0;
+								}
+								else if (!opts.centerY && full) {
+									var top = (opts.css && opts.css.top) ? parseInt(opts.css.top, 10) : 0;
+									var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + '+top+') + "px"';
+									s.setExpression('top',expression);
+								}
+							});
+						}
+
+						// show the message
+						if (msg) {
+							if (opts.theme)
+								lyr3.find('.ui-widget-content').append(msg);
+							else
+								lyr3.append(msg);
+							if (msg.jquery || msg.nodeType)
+								$(msg).show();
+						}
+
+						if ((msie || opts.forceIframe) && opts.showOverlay)
+							lyr1.show(); // opacity is zero
+						if (opts.fadeIn) {
+							var cb = opts.onBlock ? opts.onBlock : noOp;
+							var cb1 = (opts.showOverlay && !msg) ? cb : noOp;
+							var cb2 = msg ? cb : noOp;
+							if (opts.showOverlay)
+								lyr2._fadeIn(opts.fadeIn, cb1);
+							if (msg)
+								lyr3._fadeIn(opts.fadeIn, cb2);
+						}
+						else {
+							if (opts.showOverlay)
+								lyr2.show();
+							if (msg)
+								lyr3.show();
+							if (opts.onBlock)
+								opts.onBlock();
+						}
+
+						// bind key and mouse events
+						bind(1, el, opts);
+
+						if (full) {
+							pageBlock = lyr3[0];
+							pageBlockEls = $(':input:enabled:visible',pageBlock);
+							if (opts.focusInput)
+								setTimeout(focus, 20);
+						}
+						else
+							center(lyr3[0], opts.centerX, opts.centerY);
+
+						if (opts.timeout) {
+							// auto-unblock
+							var to = setTimeout(function() {
+								if (full)
+									$.unblockUI(opts);
+								else
+									$(el).unblock(opts);
+							}, opts.timeout);
+							$(el).data('blockUI.timeout', to);
+						}
+					}
+
+					// remove the block
+					function remove(el, opts) {
+						var count;
+						var full = (el == window);
+						var $el = $(el);
+						var data = $el.data('blockUI.history');
+						var to = $el.data('blockUI.timeout');
+						if (to) {
+							clearTimeout(to);
+							$el.removeData('blockUI.timeout');
+						}
+						opts = $.extend({}, $.blockUI.defaults, opts || {});
+						bind(0, el, opts); // unbind events
+
+						if (opts.onUnblock === null) {
+							opts.onUnblock = $el.data('blockUI.onUnblock');
+							$el.removeData('blockUI.onUnblock');
+						}
+
+						var els;
+						if (full) // crazy selector to handle odd field errors in ie6/7
+							els = $('body').children().filter('.blockUI').add('body > .blockUI');
+						else
+							els = $el.find('>.blockUI');
+
+						// fix cursor issue
+						if ( opts.cursorReset ) {
+							if ( els.length > 1 )
+								els[1].style.cursor = opts.cursorReset;
+							if ( els.length > 2 )
+								els[2].style.cursor = opts.cursorReset;
+						}
+
+						if (full)
+							pageBlock = pageBlockEls = null;
+
+						if (opts.fadeOut) {
+							count = els.length;
+							els.fadeOut(opts.fadeOut, function() { 
+								if ( --count === 0)
+									reset(els,data,opts,el);
+							});
+						}
+						else
+							reset(els, data, opts, el);
+					}
+
+					// move blocking element back into the DOM where it started
+					function reset(els,data,opts,el) {
+						var $el = $(el);
+						els.each(function(i,o) {
+							// remove via DOM calls so we don't lose event handlers
+							if (this.parentNode)
+								this.parentNode.removeChild(this);
+						});
+
+						if (data && data.el) {
+							data.el.style.display = data.display;
+							data.el.style.position = data.position;
+							if (data.parent)
+								data.parent.appendChild(data.el);
+							$el.removeData('blockUI.history');
+						}
+
+						if ($el.data('blockUI.static')) {
+							$el.css('position', 'static'); // #22
+						}
+
+						if (typeof opts.onUnblock == 'function')
+							opts.onUnblock(el,opts);
+
+						// fix issue in Safari 6 where block artifacts remain until reflow
+						var body = $(document.body), w = body.width(), cssW = body[0].style.width;
+						body.width(w-1).width(w);
+						body[0].style.width = cssW;
+					}
+
+					// bind/unbind the handler
+					function bind(b, el, opts) {
+						var full = el == window, $el = $(el);
+
+						// don't bother unbinding if there is nothing to unbind
+						if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked')))
+							return;
+
+						$el.data('blockUI.isBlocked', b);
+
+						// don't bind events when overlay is not in use or if bindEvents is false
+						if (!full || !opts.bindEvents || (b && !opts.showOverlay))
+							return;
+
+						// bind anchors and inputs for mouse and key events
+						var events = 'mousedown mouseup keydown keypress keyup touchstart touchend touchmove';
+						if (b)
+							$(document).bind(events, opts, handler);
+						else
+							$(document).unbind(events, handler);
+
+					// former impl...
+					//		var $e = $('a,:input');
+					//		b ? $e.bind(events, opts, handler) : $e.unbind(events, handler);
+					}
+
+					// event handler to suppress keyboard/mouse events when blocking
+					function handler(e) {
+						// allow tab navigation (conditionally)
+						if (e.keyCode && e.keyCode == 9) {
+							if (pageBlock && e.data.constrainTabKey) {
+								var els = pageBlockEls;
+								var fwd = !e.shiftKey && e.target === els[els.length-1];
+								var back = e.shiftKey && e.target === els[0];
+								if (fwd || back) {
+									setTimeout(function(){focus(back);},10);
+									return false;
+								}
+							}
+						}
+						var opts = e.data;
+						var target = $(e.target);
+						if (target.hasClass('blockOverlay') && opts.onOverlayClick)
+							opts.onOverlayClick();
+
+						// allow events within the message content
+						if (target.parents('div.' + opts.blockMsgClass).length > 0)
+							return true;
+
+						// allow events for content that is not being blocked
+						return target.parents().children().filter('div.blockUI').length === 0;
+					}
+
+					function focus(back) {
+						if (!pageBlockEls)
+							return;
+						var e = pageBlockEls[back===true ? pageBlockEls.length-1 : 0];
+						if (e)
+							e.focus();
+					}
+
+					function center(el, x, y) {
+						var p = el.parentNode, s = el.style;
+						var l = ((p.offsetWidth - el.offsetWidth)/2) - sz(p,'borderLeftWidth');
+						var t = ((p.offsetHeight - el.offsetHeight)/2) - sz(p,'borderTopWidth');
+						if (x) s.left = l > 0 ? (l+'px') : '0';
+						if (y) s.top  = t > 0 ? (t+'px') : '0';
+					}
+
+					function sz(el, p) {
+						return parseInt($.css(el,p),10)||0;
+					}
+
+				}
+
+
+				/*global define:true */
+				setup(jQuery);
+
+
+			})();
+
+		} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/jquery.calendrical_timespan.js b/public/js_src/external_libs/jquery.calendrical_timespan.js
new file mode 100644
index 0000000..7a23abd
--- /dev/null
+++ b/public/js_src/external_libs/jquery.calendrical_timespan.js
@@ -0,0 +1,993 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+// I merged two plugins into one because they had a lot of dependencies.
+var calendricalDateFormats = {
+		us  : { //US date format (eg. 12/1/2011)
+			pattern : /([\d]{1,2})\/([\d]{1,2})\/([\d]{4}|[\d]{2})/,
+			format  : 'm/d/y',
+			order   : 'middleEndian',
+			zeroPad : false },
+		iso : { //ISO 8601 (eg. 2011-12-01)
+			pattern : /([\d]{4}|[\d]{2})-([\d]{1,2})-([\d]{1,2})/,
+			format  : 'y-m-d',
+			order   : 'bigEndian',
+			zeroPad : true },
+		dot : { //Little endian with dots (eg. 1.12.2011)
+			pattern : /([\d]{1,2}).([\d]{1,2}).([\d]{4}|[\d]{2})/,
+			format  : 'd.m.y',
+			order   : 'littleEndian',
+			zeroPad : false },
+		def : { //Default (eg. 1/12/2011)
+			pattern : /([\d]{1,2})\/([\d]{1,2})\/([\d]{4}|[\d]{2})/,
+			format  : 'd/m/y',
+			order   : 'littleEndian',
+			zeroPad : false }
+	};
+
+	var formatDate = function(date, format, noutc)
+	{
+		var y, m, d;
+		if( typeof calendricalDateFormats[format] === 'undefined' ){
+			format = 'def';
+		}
+		if( typeof noutc === 'undefined' ) {
+			noutc = false;
+		}
+		if( true === noutc ) {
+			y = ( date.getFullYear() ).toString();
+			m = ( date.getMonth() + 1 ).toString();
+			d = ( date.getDate() ).toString();
+		} else {
+			y = ( date.getUTCFullYear() ).toString();
+			m = ( date.getUTCMonth() + 1 ).toString();
+			d = ( date.getUTCDate() ).toString();
+		}
+
+		if( calendricalDateFormats[format].zeroPad ) {
+			if( m.length == 1 ) m = '0' + m;
+			if( d.length == 1 ) d = '0' + d;
+		}
+		var dt = calendricalDateFormats[format].format;
+		dt = dt.replace('d', d);
+		dt = dt.replace('m', m);
+		dt = dt.replace('y', y);
+		return dt;
+	};
+
+	var formatTime = function(hour, minute, iso)
+	{
+		var printMinute = minute;
+		if( minute < 10 ) printMinute = '0' + minute;
+
+		if( iso ) {
+			var printHour = hour
+			if( printHour < 10 ) printHour = '0' + hour;
+			return printHour + ':' + printMinute;
+		} else {
+			var printHour = hour % 12;
+			if( printHour == 0 ) printHour = 12;
+			var half = ( hour < 12 ) ? 'am' : 'pm';
+			return printHour + ':' + printMinute + half;
+		}
+	};
+
+	var parseDate = function(date, format)
+	{
+		if( typeof calendricalDateFormats[format] === 'undefined' )
+			format = 'def';
+
+		var matches = date.match(calendricalDateFormats[format].pattern);
+		if( !matches || matches.length != 4 ) {
+			// Return an "invalid date" date instance like the original parseDate
+			return Date( 'invalid' );
+		}
+
+		switch( calendricalDateFormats[format].order ) {
+			case 'bigEndian' :
+				var d = matches[3];	var m = matches[2];	var y = matches[1];
+				break;
+			case 'littleEndian' :
+				var d = matches[1];	var m = matches[2];	var y = matches[3];
+				break;
+			case 'middleEndian' :
+				var d = matches[2];	var m = matches[1];	var y = matches[3];
+				break;
+			default : //Default to little endian
+				var d = matches[1];	var m = matches[2];	var y = matches[3];
+				break;
+		}
+
+		// Add century to a two digit year
+		if( y.length == 2 ) {
+			y = new Date().getUTCFullYear().toString().substr(0, 2) + y;
+		}
+
+		// This is how the original parseDate does it
+		return new Date( m + '/' + d + '/' + y + ' GMT' );
+	};
+
+	var parseTime = function(text)
+	{
+		var match = match = /(\d+)\s*[:\-\.,]\s*(\d+)\s*(am|pm)?/i.exec(text);
+		if( match && match.length >= 3 ) {
+			var hour = Number(match[1]);
+			var minute = Number(match[2]);
+			if( hour == 12 && match[3] ) hour -= 12;
+			if( match[3] && match[3].toLowerCase() == 'pm' ) hour += 12;
+			return {
+				hour:   hour,
+				minute: minute
+			};
+		} else {
+			return null;
+		}
+	};
+
+    function getToday()
+    {
+        var date = new Date();
+        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
+    }
+
+    function areDatesEqual(date1, date2)
+    {
+			if( typeof date1 === 'string' )
+				date1 = new Date( date1 );
+
+			if( typeof date2 === 'string' )
+				date2 = new Date(date2);
+
+			if( date1.getUTCDate() === date2.getUTCDate() ) {
+				if( date1.getUTCMonth() === date2.getUTCMonth() ) {
+					if( date1.getUTCFullYear() === date2.getUTCFullYear() ) {
+						return true;
+					}
+				}
+			}
+			return false;
+    }
+
+    function daysInMonth(year, month)
+    {
+        if (year instanceof Date) return daysInMonth(year.getUTCFullYear(), year.getUTCMonth());
+        if (month == 1) {
+            var leapYear = (year % 4 == 0) &&
+                (!(year % 100 == 0) || (year % 400 == 0));
+            return leapYear ? 29 : 28;
+        } else if (month == 3 || month == 5 || month == 8 || month == 10) {
+            return 30;
+        } else {
+            return 31;
+        }
+    }
+
+		function dayAfter(date)
+    {
+				// + 1 day
+        return new Date( date.getTime() + (1*24*60*60*1000) );
+    }
+
+    function dayBefore(date)
+    {
+				// - 1 day
+        return new Date( date.getTime() - (1*24*60*60*1000) );
+    }
+
+    function monthAfter(year, month)
+    {
+        return (month == 11) ?
+            new Date(year + 1, 0, 1) :
+            new Date(year, month + 1, 1);
+    }
+
+    /**
+     * Generates calendar header, with month name, << and >> controls, and
+     * initials for days of the week.
+     */
+    function renderCalendarHeader(element, year, month, options)
+    {
+				var monthNames = options.monthNames.split(',');
+        //Prepare thead element
+        var thead = $('<thead />');
+        var titleRow = $('<tr />').appendTo(thead);
+
+        //Generate << (back a month) link
+        $('<th />').addClass('monthCell').append(
+          $('<a href="javascript:;">&laquo;</a>')
+                  .addClass('prevMonth')
+                  .mousedown(function(e) {
+                      renderCalendarPage(element,
+                          month == 0 ? (year - 1) : year,
+                          month == 0 ? 11 : (month - 1), options
+                      );
+                      e.preventDefault();
+                  })
+        ).appendTo(titleRow);
+
+        //Generate month title
+        $('<th />').addClass('monthCell').attr('colSpan', 5).append(
+            $('<a href="javascript:;">' + monthNames[month] + ' ' +
+                year + '</a>').addClass('monthName')
+        ).appendTo(titleRow);
+
+        //Generate >> (forward a month) link
+        $('<th />').addClass('monthCell').append(
+            $('<a href="javascript:;">&raquo;</a>')
+                .addClass('nextMonth')
+                .mousedown(function() {
+                    renderCalendarPage(element,
+                        month == 11 ? (year + 1) : year,
+                        month == 11 ? 0 : (month + 1), options
+                    );
+                })
+        ).appendTo(titleRow);
+
+        // Generate weekday initials row. Adjust for week start day
+				var names = options.dayNames.split(',');
+				var startDay = parseInt(options.weekStartDay);
+				var adjustedNames = [];
+				for( var i = 0, len = names.length; i < len; i++ ) {
+					adjustedNames[i] = names[(i + startDay) % len];
+				}
+        var dayNames = $('<tr />').appendTo(thead);
+        $.each( adjustedNames, function( k, v ) {
+            $('<td />').addClass('dayName').append(v).appendTo(dayNames);
+        });
+
+        return thead;
+    }
+
+    function renderCalendarPage(element, year, month, options)
+    {
+        options = options || {};
+
+				var startDay = parseInt(options.weekStartDay);
+        var today = options.today ? options.today : getToday();
+        // Normalize
+				today.setHours(0);
+				today.setMinutes(0);
+
+        var date = new Date(year, month, 1);
+				var endDate = monthAfter(year, month);
+
+        //Adjust dates for current timezone. This is a workaround to get
+				//date comparison to work properly.
+				var tzOffset = Math.abs(today.getTimezoneOffset());
+				if (tzOffset != 0) {
+					today.setHours(today.getHours() + tzOffset / 60);
+					today.setMinutes(today.getMinutes() + tzOffset % 60);
+					date.setHours(date.getHours() + tzOffset / 60);
+					date.setMinutes(date.getMinutes() + tzOffset % 60);
+					endDate.setHours(endDate.getHours() + tzOffset / 60);
+					endDate.setMinutes(endDate.getMinutes() + tzOffset % 60);
+				}
+
+				//Wind end date forward to last day of week
+				var ff = endDate.getUTCDay() - startDay;
+				if (ff < 0) {
+					ff = Math.abs(ff) - 1;
+				} else {
+					ff = 6 - ff;
+				}
+        for (var i = 0; i < ff; i++) endDate = dayAfter(endDate);
+
+        var table = $('<table />');
+        renderCalendarHeader(element, year, month, options).appendTo(table);
+
+        var tbody = $('<tbody />').appendTo(table);
+        var row = $('<tr />');
+
+				//Rewind date to first day of week
+				var rewind = date.getUTCDay() - startDay;
+				if (rewind < 0) rewind = 7 + rewind;
+        for (var i = 0; i < rewind; i++) date = dayBefore(date);
+
+        while (date <= endDate) {
+            var td = $('<td />')
+                .addClass('day')
+                .append(
+                    $('<a href="javascript:;">' +
+                        date.getUTCDate() + '</a>'
+                    ).click((function() {
+                        var thisDate = date;
+
+                        return function() {
+                            if (options && options.selectDate) {
+                                options.selectDate(thisDate);
+                            }
+                        }
+                    }()))
+                )
+                .appendTo(row);
+
+            var isToday     = areDatesEqual(date, today);
+            var isSelected  = options.selected &&
+                                areDatesEqual(options.selected, date);
+
+            if (isToday)                    td.addClass('today');
+            if (isSelected)                 td.addClass('selected');
+            if (isToday && isSelected)      td.addClass('today_selected');
+            if (date.getUTCMonth() != month)   td.addClass('nonMonth');
+
+           	var dow = date.getUTCDay();
+						if (((dow + 1) % 7) == startDay) {
+                tbody.append(row);
+                row = $('<tr />');
+            }
+            date = dayAfter(date);
+        }
+        if (row.children().length) {
+            tbody.append(row);
+        } else {
+            row.remove();
+        }
+
+        element.empty().append(table);
+    }
+
+    function renderTimeSelect(element, options)
+    {
+        var selection = options.selection && parseTime(options.selection);
+        if (selection) {
+            selection.minute = Math.floor(selection.minute / 15.0) * 15;
+        }
+        var startTime = options.startTime &&
+            (options.startTime.hour * 60 + options.startTime.minute);
+
+        var scrollTo;   //Element to scroll the dropdown box to when shown
+        var ul = $('<ul />');
+        for (var hour = 0; hour < 24; hour++) {
+            for (var minute = 0; minute < 60; minute += 15) {
+                if (startTime && startTime > (hour * 60 + minute)) continue;
+
+                (function() {
+                    var timeText = formatTime(hour, minute, options.isoTime);
+                    var fullText = timeText;
+                    if (startTime != null) {
+                        var duration = (hour * 60 + minute) - startTime;
+                        if (duration < 60) {
+                            fullText += ' (' + duration + ' min)';
+                        } else if (duration == 60) {
+                            fullText += ' (1 hr)';
+                        } else {
+                            fullText += ' (' + Math.floor( duration / 60.0 ) + ' hr ' + ( duration % 60 ) + ' min)';
+                        }
+                    }
+                    var li = $('<li />').append(
+                        $('<a href="javascript:;">' + fullText + '</a>')
+                        .click(function() {
+                            if (options && options.selectTime) {
+                                options.selectTime(timeText);
+                            }
+                        }).mousemove(function() {
+                            $('li.selected', ul).removeClass('selected');
+                        })
+                    ).appendTo(ul);
+
+                    //Set to scroll to the default hour, unless already set
+                    if (!scrollTo && hour == options.defaultHour) {
+                        scrollTo = li;
+                    }
+
+                    if (selection &&
+                        selection.hour == hour &&
+                        selection.minute == minute)
+                    {
+                        //Highlight selected item
+                        li.addClass('selected');
+
+                        //Set to scroll to the selected hour
+                        //
+                        //This is set even if scrollTo is already set, since
+                        //scrolling to selected hour is more important than
+                        //scrolling to default hour
+                        scrollTo = li;
+                    }
+                })();
+            }
+        }
+        if (scrollTo) {
+            //Set timeout of zero so code runs immediately after any calling
+            //functions are finished (this is needed, since box hasn't been
+            //added to the DOM yet)
+            setTimeout(function() {
+                //Scroll the dropdown box so that scrollTo item is in
+                //the middle
+                element[0].scrollTop =
+                    scrollTo[0].offsetTop - scrollTo.height() * 2;
+            }, 0);
+        }
+        element.empty().append(ul);
+    }
+
+    $.fn.calendricalDate = function(options)
+    {
+        options = options || {};
+        options.padding = options.padding || 4;
+				options.monthNames = options.monthNames ||
+														 'January,February,March,April,May,June,July,August,September,October,November,December';
+				options.dayNames = options.dayNames || 'S,M,T,W,T,F,S';
+				options.weekStartDay = options.weekStartDay || 0;
+
+        return this.each(function() {
+            var element = $(this);
+            var div;
+            var within = false;
+
+            element.bind('focus', function() {
+                if (div) return;
+                var offset = element.position();
+                var padding = element.css('padding-left');
+                div = $('<div />')
+                    .addClass('calendricalDatePopup')
+                    .mouseenter(function() { within = true; })
+                    .mouseleave(function() { within = false; })
+                    .mousedown(function(e) {
+                        e.preventDefault();
+                    })
+                    .css({
+                        position: 'absolute',
+                        left: offset.left,
+                        top: offset.top + element.height() +
+                            options.padding * 2
+                    });
+                element.after(div);
+
+                var selected = parseDate(element.val(), options.dateFormat);
+                if (!selected.getUTCFullYear()) selected = options.today ? options.today : getToday();
+
+                renderCalendarPage(
+                    div,
+                    selected.getUTCFullYear(),
+                    selected.getUTCMonth(), {
+												today: options.today,
+                        selected: selected,
+												monthNames: options.monthNames,
+												dayNames: options.dayNames,
+												weekStartDay: options.weekStartDay,
+                        selectDate: function(date) {
+                            within = false;
+                            element.val(formatDate(date, options.dateFormat));
+                            div.remove();
+                            div = null;
+                            if (options.endDate) {
+                                var endDate = parseDate(
+                                    options.endDate.val(), options.dateFormat
+                                );
+                                if (endDate >= selected) {
+                                    options.endDate.val(formatDate(
+                                        new Date(
+                                            date.getTime() +
+                                            endDate.getTime() -
+                                            selected.getTime()
+                                        ),
+                                        options.dateFormat
+                                    ));
+                                }
+                            }
+                        }
+                    }
+                );
+            }).blur(function() {
+                if (within){
+                    if (div) element.focus();
+                    return;
+                }
+                if (!div) return;
+                div.remove();
+                div = null;
+            });
+        });
+    };
+
+    $.fn.calendricalDateRange = function(options)
+    {
+        if (this.length >= 2) {
+            $(this[0]).calendricalDate($.extend({
+                endDate:   $(this[1])
+            }, options));
+            $(this[1]).calendricalDate(options);
+        }
+        return this;
+    };
+
+		$.fn.calendricalDateRangeSingle = function(options)
+    {
+        if (this.length == 1) {
+            $(this).calendricalDate(options);
+        }
+        return this;
+    };
+
+    $.fn.calendricalTime = function(options)
+    {
+        options = options || {};
+        options.padding = options.padding || 4;
+
+        return this.each(function() {
+            var element = $(this);
+            var div;
+            var within = false;
+
+            element.bind('focus click', function() {
+                if (div) return;
+
+                var useStartTime = options.startTime;
+                if (useStartTime) {
+                    if (options.startDate && options.endDate &&
+                        !areDatesEqual(parseDate(options.startDate.val()),
+                            parseDate(options.endDate.val())))
+                        useStartTime = false;
+                }
+
+                var offset = element.position();
+                div = $('<div />')
+                    .addClass('calendricalTimePopup')
+                    .mouseenter(function() { within = true; })
+                    .mouseleave(function() { within = false; })
+                    .mousedown(function(e) {
+                        e.preventDefault();
+                    })
+                    .css({
+                        position: 'absolute',
+                        left: offset.left,
+                        top: offset.top + element.height() +
+                            options.padding * 2
+                    });
+                if (useStartTime) {
+                    div.addClass('calendricalEndTimePopup');
+                }
+
+                element.after(div);
+
+                var opts = {
+                    selection: element.val(),
+                    selectTime: function(time) {
+                        within = false;
+                        element.val(time);
+                        div.remove();
+                        div = null;
+                    },
+                    isoTime: options.isoTime || false,
+                    defaultHour: (options.defaultHour != null) ?
+                                    options.defaultHour : 8
+                };
+
+                if (useStartTime) {
+                    opts.startTime = parseTime(options.startTime.val());
+                }
+
+                renderTimeSelect(div, opts);
+            }).blur(function() {
+                if (within){
+                    if (div) element.focus();
+                    return;
+                }
+                if (!div) return;
+                div.remove();
+                div = null;
+            });
+        });
+    },
+
+    $.fn.calendricalTimeRange = function(options)
+    {
+        if (this.length >= 2) {
+            $(this[0]).calendricalTime(options);
+            $(this[1]).calendricalTime($.extend({
+                startTime: $(this[0])
+            }, options));
+        }
+        return this;
+    };
+
+    $.fn.calendricalDateTimeRange = function(options)
+    {
+        if (this.length >= 4) {
+            $(this[0]).calendricalDate($.extend({
+                endDate:   $(this[2])
+            }, options));
+            $(this[1]).calendricalTime(options);
+            $(this[2]).calendricalDate(options);
+            $(this[3]).calendricalTime($.extend({
+                startTime: $(this[1]),
+                startDate: $(this[0]),
+                endDate:   $(this[2])
+            }, options));
+        }
+        return this;
+    };
+    /**
+     * Private functions
+     */
+
+    // Helper function - reset contents of current field to stored original
+    // value and alert user.
+    function reset_invalid( field )
+    {
+    	field
+    		.addClass( 'error' )
+    		.fadeOut( 'normal', function() {
+    			field
+    				.val( field.data( 'timespan.stored' ) )
+    				.removeClass( 'error' )
+    				.fadeIn( 'fast' );
+    		});
+    }
+
+    // Stores the value of the HTML element in context to its "stored" jQuery data.
+    function store_value() {
+    	$(this).data( 'timespan.stored', this.value );
+    }
+
+    /**
+     * Value initialization
+     */
+    function reset( start_date_input, start_time_input, start_time,
+    		end_date_input, end_time_input, end_time, allday, twentyfour_hour,
+    		date_format, now )
+    {
+    	// Restore original values of fields when the page was loaded
+    	start_time.val( start_time.data( 'timespan.initial_value' ) );
+    	end_time.val( end_time.data( 'timespan.initial_value' ) );
+    	allday.get(0).checked = allday.data( 'timespan.initial_value' );
+
+    	// Fill out input fields with default date/time based on these original
+    	// values.
+
+    	var start = parseInt( start_time.val() );
+    	// If start_time field has a valid integer, use it, else use current time
+    	// rounded to nearest quarter-hour.
+    	if( ! isNaN( parseInt( start ) ) ) {
+    		start = new Date( parseInt( start ) * 1000 );
+    		start_time_input.val( formatTime( start.getUTCHours(), start.getUTCMinutes(), twentyfour_hour ) );
+    	} else {
+    		start = new Date( now );
+    		// Round minutes to nearest quarter-hour.
+    		start_time_input.val(
+    			formatTime( start.getUTCHours(), start.getUTCMinutes() - start.getUTCMinutes() % 15, twentyfour_hour ) );
+    	}
+    	start_date_input.val( formatDate( start, date_format ) );
+
+    	var end = parseInt( end_time.val() );
+    	// If end_time field has a valid integer, use it, else use start time plus
+    	// one hour.
+    	if( ! isNaN( parseInt( end ) ) ) {
+    		end = new Date( parseInt( end ) * 1000 );
+    		end_time_input.val( formatTime( end.getUTCHours(), end.getUTCMinutes(), twentyfour_hour ) );
+    	} else {
+    		end = new Date( start.getTime() + 3600000 );
+    		// Round minutes to nearest quarter-hour.
+    		end_time_input.val(
+    			formatTime( end.getUTCHours(), end.getUTCMinutes() - end.getUTCMinutes() % 15, twentyfour_hour ) );
+    	}
+    	// If all-day is checked, end date one day *before* last day of the span,
+    	// provided we were given an iCalendar-spec all-day timespan.
+    	if( allday.get(0).checked )
+    		end.setUTCDate( end.getUTCDate() - 1 );
+    	end_date_input.val( formatDate( end, date_format ) );
+
+    	// Trigger function (defined above) to internally store values of each
+    	// input field (used in calculations later).
+    	start_date_input.each( store_value );
+    	start_time_input.each( store_value );
+    	end_date_input.each( store_value );
+    	end_time_input.each( store_value );
+
+    	// Set up visibility of controls and Calendrical activation based on
+    	// original "checked" status of "All day" box.
+    	allday.trigger( 'change.timespan' );
+    	$( '#ai1ec_instant_event' ).trigger( 'change.timespan' );
+    }
+
+    /**
+     * Private constants
+     */
+
+    var default_options = {
+    	allday: '#allday',
+    	start_date_input: '#start-date-input',
+    	start_time_input: '#start-time-input',
+    	start_time: '#start-time',
+    	end_date_input: '#end-date-input',
+    	end_time_input: '#end-time-input',
+    	end_time: '#end-time',
+    	twentyfour_hour: false,
+    	date_format: 'def',
+    	now: new Date()
+    };
+
+    /**
+     * Public methods
+     */
+
+    var methods = {
+
+    	/**
+    	 * Initialize settings.
+    	 */
+    	init: function( options )
+    	{
+    		var o = $.extend( {}, default_options, options );
+
+    		// Shortcut jQuery objects
+    		var allday = $(o.allday);
+    		var start_date_input = $(o.start_date_input);
+    		var start_time_input = $(o.start_time_input);
+    		var start_time = $(o.start_time);
+    		var end_date_input = $(o.end_date_input);
+    		var end_time_input = $(o.end_time_input);
+    		var end_time = $(o.end_time);
+    		var instant = $('#ai1ec_instant_event');
+
+    		var end_date_time = end_date_input.add( end_time_input );
+    		var date_inputs = start_date_input.add( o.end_date_input );
+    		var time_inputs = start_time_input.add( o.end_time_input );
+    		var all_inputs = start_date_input.add( o.start_time_input )
+    			.add( o.end_date_input ).add( o.end_time_input );
+
+    		/**
+    		 * Event handlers
+    		 */
+    		// Save original (presumably valid) value of every input field upon focus.
+    		all_inputs.bind( 'focus.timespan', store_value );
+
+    		instant
+				.bind( 'change.timespan', function() {
+					if( this.checked ) {
+						end_date_time.closest('tr').fadeOut();
+						allday.attr( 'disabled', true );
+					} else {
+						allday.removeAttr( 'disabled' );
+						end_date_time.closest('tr').fadeIn();
+					}
+				} );
+
+    		// When "All day" is toggled, show/hide time.
+    		var today = new Date( o.now.getFullYear(), o.now.getMonth(), o.now.getDate() );
+    		var all_inputs_set = false;
+    		allday
+			.bind( 'change.timespan', function() {
+				if( this.checked ) {
+					time_inputs.fadeOut();
+					instant.attr( 'disabled', true );
+				} else {
+					instant.removeAttr( 'disabled' );
+					time_inputs.fadeIn();
+				}
+				if( ! all_inputs_set ) {
+					all_inputs_set = true;
+					all_inputs.calendricalDateTimeRange( {
+						today: today, dateFormat: o.date_format, isoTime: o.twentyfour_hour,
+						monthNames: o.month_names, dayNames: o.day_names, weekStartDay: o.week_start_day
+					} );
+				}
+			} )
+			.get().checked = false;
+
+    		// Validate and update saved value of DATE fields upon blur.
+    		date_inputs
+    			.bind( 'blur.timespan', function() {
+    				// Validate contents of this field.
+    				var date = parseDate( this.value, o.date_format );
+    				if( isNaN( date ) ) {
+    					// This field is invalid.
+    					reset_invalid( $(this) );
+    				} else {
+    					// Value is valid, so store it for later use (below).
+    					$(this).data( 'timespan.stored', this.value );
+    					// Re-format contents of field correctly (in case parsable but not
+    					// perfect).
+    					$(this).val( formatDate( date, o.date_format ) );
+    				}
+    			});
+
+    		// Validate and update saved value of TIME fields upon blur.
+    		time_inputs
+    			.bind( 'blur.timespan', function() {
+    				// Validate contents of this field.
+    				var time = parseTime( this.value );
+    				if( ! time ) {
+    					// This field is invalid.
+    					reset_invalid( $(this) );
+    				} else {
+    					// Value is valid, so store it for later use (below).
+    					$(this).data( 'timespan.stored', this.value );
+    					// Re-format contents of field correctly (in case parsable but not
+    					// perfect).
+    					$(this).val( formatTime( time.hour, time.minute, o.twentyfour_hour ) );
+    				}
+    			});
+
+    		// Gets the time difference between start and end dates
+    		function get_startend_time_difference() {
+    			var start_date_val = parseDate( start_date_input.val(), o.date_format ).getTime() / 1000;
+    			var start_time_val = parseTime( start_time_input.val() );
+    			start_date_val += start_time_val.hour * 3600 + start_time_val.minute * 60;
+    			var end_date_val = parseDate( end_date_input.val(), o.date_format ).getTime() / 1000;
+    			var end_time_val = parseTime( end_time_input.val() );
+    			end_date_val += end_time_val.hour * 3600 + end_time_val.minute * 60;
+
+    			return end_date_val - start_date_val;
+    		}
+
+    		function shift_jqts_enddate() {
+    			var start_date_val = parseDate( start_date_input.data( 'timespan.stored' ), o.date_format );
+    			var start_time_val = parseTime( start_time_input.data( 'timespan.stored' ) );
+    			var end_time_val = start_date_val.getTime() / 1000
+    				+ start_time_val.hour * 3600 + start_time_val.minute * 60
+    				+ start_date_input.data( 'time_diff' );
+    			end_time_val = new Date( end_time_val * 1000 );
+    			end_date_input.val( formatDate( end_time_val, o.date_format ) );
+    			end_time_input.val( formatTime( end_time_val.getUTCHours(), end_time_val.getUTCMinutes(), o.twentyfour_hour ) );
+
+    			return true;
+    		}
+
+    		// When start date/time are modified, update end date/time by shifting the
+    		// appropriate amount.
+    		start_date_input.add( o.start_time_input )
+    			.bind( 'focus.timespan', function() {
+    				// Calculate the time difference between start & end and save it.
+    				start_date_input.data( 'time_diff', get_startend_time_difference() );
+    			} )
+    			.bind( 'blur.timespan', function() {
+    				// If End date is earlier than StartDate, reset it to 15 mins after startDate
+    				if ( start_date_input.data( 'time_diff' ) < 0 ) {
+    					start_date_input.data( 'time_diff', 15 * 60 );
+    				}
+    				// Shift end date/time as appropriate.
+    				var shift_jqts = shift_jqts_enddate();
+    			} );
+
+    		// When end date/time is modified, check if it is earlier than start date/time and shift it if needed
+    		end_date_input.add( o.start_time_input )
+    			.bind( 'blur.timespan', function() {
+    				// If End date is earlier than StartDate, reset it to 15 mins after startDate
+    				if ( get_startend_time_difference() < 0 ) {
+    					start_date_input.data( 'time_diff', 15 * 60 );
+    					// Shift end date/time as appropriate.
+    					var shift_jqts = shift_jqts_enddate();
+    				}
+    			} );
+
+    		// Validation upon form submission
+    		start_date_input.closest( 'form' )
+    			.bind( 'submit.timespan', function() {
+    				// Update hidden field values with chosen date/time.
+    				//
+    				// 1. Start date/time
+
+    				// Convert Date object into UNIX timestamp for form submission
+    				var unix_start_time = parseDate( start_date_input.val(), o.date_format ).getTime() / 1000;
+    				// If parsed correctly, proceed to add the time.
+    				if( ! isNaN( unix_start_time ) ) {
+    					// Add time quantity to date, unless "All day" is checked.
+    					if( ! allday.get(0).checked ) {
+    						var time = parseTime( start_time_input.val() );
+    						// If parsed correctly, proceed add its value.
+    						if( time ) {
+    							unix_start_time += time.hour * 3600 + time.minute * 60;
+    						} else {
+    							// Else entire calculation is invalid.
+    							unix_start_time = '';
+    						}
+    					}
+    				} else {
+    					// Else entire calculation is invalid.
+    					unix_start_time = '';
+    				}
+    				// Set start date value to valid unix time, or empty string, depending
+    				// on above validation.
+    				start_time.val( unix_start_time );
+
+    				// 2. End date/time
+
+    				// Convert Date object into UNIX timestamp for form submission
+    				var unix_end_time = parseDate( end_date_input.val(), o.date_format ).getTime() / 1000;
+    				// If parsed correctly, proceed to add the time.
+    				if( ! isNaN( unix_end_time ) ) {
+    					// If "All day" is checked, store an end date that is one day
+    					// *after* the start date (following iCalendar spec).
+    					if( allday.get(0).checked ) {
+    						unix_end_time += 24 * 60 * 60;
+    					// Else add time quantity to date.
+    					} else {
+    						var time = parseTime( end_time_input.val() );
+    						// If parsed correctly, proceed add its value.
+    						if( time ) {
+    							unix_end_time += time.hour * 3600 + time.minute * 60;
+    						} else {
+    							// Else entire calculation is invalid.
+    							unix_end_time = '';
+    						}
+    					}
+    				} else {
+    					// Else entire calculation is invalid.
+    					unix_end_time = '';
+    				}
+    				// Set end date value to valid unix time, or empty string, depending
+    				// on above validation.
+    				end_time.val( unix_end_time );
+    			} );
+
+    		// Store original form values
+    		start_time.data( 'timespan.initial_value', start_time.val() );
+    		end_time.data( 'timespan.initial_value', end_time.val() );
+    		allday.data( 'timespan.initial_value', allday.get(0).checked );
+
+    		// Initialize input fields
+    		reset( start_date_input,
+    				start_time_input,
+    				start_time,
+    				end_date_input,
+    				end_time_input,
+    				end_time,
+    				allday,
+    				o.twentyfour_hour,
+    				o.date_format,
+    				o.now )
+
+    		return this;
+    	},
+
+    	/**
+    	 * Reset values to defaults.
+    	 */
+    	reset: function( options )
+    	{
+    		var o = $.extend( {}, default_options, options );
+
+    		reset( $(o.start_date_input),
+    				$(o.start_time_input),
+    				$(o.start_time),
+    				$(o.end_date_input),
+    				$(o.end_time_input),
+    				$(o.end_time),
+    				$(o.allday),
+    				o.twentyfour_hour,
+    				o.date_format,
+    				o.now );
+
+    		return this;
+    	},
+
+    	/**
+    	 * Destroy registered event handlers.
+    	 */
+    	destroy: function( options )
+     	{
+    		options = $.extend( {}, default_options, options );
+
+    		$.each( options, function( option_name, value ) {
+    			$(value).unbind( '.timespan' );
+    		} );
+    		$(options.start_date_input).closest('form').unbind( '.timespan' );
+
+    		return this;
+    	}
+    }
+
+    /**
+     * Main jQuery plugin definition
+     */
+
+    $.timespan = function( arg )
+    {
+    	// Method calling logic
+    	if( methods[arg] ) {
+    		return methods[arg].apply( this, Array.prototype.slice.call( arguments, 1 ));
+    	} else if( typeof arg === 'object' || ! arg ) {
+    		return methods.init.apply( this, arguments );
+    	} else {
+    		$.error( 'Method ' + arg + ' does not exist on jQuery.timespan' );
+    	}
+    };
+    return {
+    	formatDate : formatDate,
+    	parseDate  : parseDate
+    };
+} );
diff --git a/public/js_src/external_libs/jquery.debouncedresize.js b/public/js_src/external_libs/jquery.debouncedresize.js
new file mode 100644
index 0000000..8f7da62
--- /dev/null
+++ b/public/js_src/external_libs/jquery.debouncedresize.js
@@ -0,0 +1,50 @@
+define(
+	[
+		"jquery_timely"
+	],
+	function( $ ) {
+	/*
+	 * debouncedresize: special jQuery event that happens once after a window resize
+	 *
+	 * latest version and complete README available on Github:
+	 * https://github.com/louisremi/jquery-smartresize
+	 *
+	 * Copyright 2012 @louis_remi
+	 * Licensed under the MIT license.
+	 *
+	 * This saved you an hour of work?
+	 * Send me music http://www.amazon.co.uk/wishlist/HNTU0468LQON
+	 */
+	var $event = $.event,
+	    $special,
+	    resizeTimeout;
+
+	$special = $event.special.debouncedresize = {
+		setup: function() {
+			$( this ).on( "resize", $special.handler );
+		},
+		teardown: function() {
+			$( this ).off( "resize", $special.handler );
+		},
+		handler: function( event, execAsap ) {
+			// Save the context
+			var context = this,
+				args = arguments,
+				dispatch = function() {
+					// set correct event type
+					event.type = "debouncedresize";
+					$event.dispatch.apply( context, args );
+				};
+
+			if ( resizeTimeout ) {
+				clearTimeout( resizeTimeout );
+			}
+
+			execAsap ?
+				dispatch() :
+				resizeTimeout = setTimeout( dispatch, $special.threshold );
+		},
+		threshold: 150
+	};
+
+} );
diff --git a/public/js_src/external_libs/jquery.inputdate.js b/public/js_src/external_libs/jquery.inputdate.js
new file mode 100644
index 0000000..29121e6
--- /dev/null
+++ b/public/js_src/external_libs/jquery.inputdate.js
@@ -0,0 +1,205 @@
+define( 
+		[
+		 "jquery_timely",
+		 "external_libs/jquery.calendrical_timespan"
+		 ],
+		 function( $, calendrical_functions ) {
+
+	/**
+	 * Private functions
+	 */
+	
+	// Helper function - reset contents of current field to stored original
+	// value and alert user.
+	function reset_invalid( field )
+	{
+		field
+			.addClass( 'error' )
+			.fadeOut( 'normal', function() {
+				field
+					.val( field.data( 'timespan.stored' ) )
+					.removeClass( 'error' )
+					.fadeIn( 'fast' );
+			});
+	}
+	
+	// Stores the value of the HTML element in context to its "stored" jQuery data.
+	function store_value() {
+		$(this).data( 'timespan.stored', this.value );
+	}
+	
+	/**
+	 * Value initialization
+	 */
+	function reset( start_date_input, start_time, twentyfour_hour, date_format, now )
+	{
+		// Restore original values of fields when the page was loaded
+		start_time.val( start_time.data( 'timespan.initial_value' ) );
+	
+		// Fill out input field with default date/time based on this original
+		// value.
+	
+		var start = parseInt( start_time.val() );
+		// If start_time field has a valid integer, use it, else use current time
+		// rounded to nearest quarter-hour.
+		if( ! isNaN( parseInt( start ) ) ) {
+			start = new Date( parseInt( start ) * 1000 );
+		} else {
+			start = new Date( now );
+		}
+		start_date_input.val( calendrical_functions.formatDate( start, date_format ) );
+	
+		// Trigger function (defined above) to internally store values of each
+		// input field (used in calculations later).
+		start_date_input.each( store_value );
+	}
+	
+	/**
+	 * Private constants
+	 */
+	
+	var default_options = {
+		start_date_input: 'date-input',
+		start_time: 'time',
+		twentyfour_hour: false,
+		date_format: 'def',
+		now: new Date()
+	};
+	
+	/**
+	 * Public methods
+	 */
+	
+	var methods = {
+	
+		/**
+		 * Initialize settings.
+		 */
+		init: function( options )
+		{
+			var o = $.extend( {}, default_options, options );
+	
+			// Shortcut jQuery objects
+			var start_date_input = $(o.start_date_input);
+			var start_time = $(o.start_time);
+	
+			var date_inputs = start_date_input;
+			var all_inputs = start_date_input;
+	
+			/**
+			 * Event handlers
+			 */
+	
+			// Save original (presumably valid) value of every input field upon focus.
+			all_inputs.bind( 'focus.timespan', store_value );
+			date_inputs.calendricalDate( {
+				today: new Date( o.now.getFullYear(), o.now.getMonth(), o.now.getDate() ),
+				dateFormat: o.date_format, monthNames: o.month_names, dayNames: o.day_names,
+				weekStartDay: o.week_start_day
+			} );
+	
+			// Validate and update saved value of DATE fields upon blur.
+			date_inputs
+				.bind( 'blur.timespan', function() {
+					// Validate contents of this field.
+					var date = calendrical_functions.parseDate( this.value, o.date_format );
+					if( isNaN( date ) ) {
+						// This field is invalid.
+						reset_invalid( $(this) );
+					} else {
+						// Value is valid, so store it for later use (below).
+						$(this).data( 'timespan.stored', this.value );
+						// Re-format contents of field correctly (in case parsable but not
+						// perfect).
+						$(this).val( calendrical_functions.formatDate( date, o.date_format ) );
+					}
+				});
+	
+			// When start date/time are modified, update end date/time by shifting the
+			// appropriate amount.
+			start_date_input.bind( 'focus.timespan', function() {
+					// Calculate the time difference between start & end and save it.
+					var start_date_val = calendrical_functions.parseDate( start_date_input.val(), o.date_format ).getTime() / 1000;
+				} )
+				.bind( 'blur.timespan', function() {
+					var start_date_val = calendrical_functions.parseDate( start_date_input.data( 'timespan.stored' ), o.date_format );
+					// Shift end date/time as appropriate.
+				} );
+	
+			// Validation upon form submission
+			start_date_input.closest( 'form' )
+				.bind( 'submit.timespan', function() {
+					// Update hidden field value with chosen date/time.
+	
+					// Convert Date object into UNIX timestamp for form submission
+					var unix_start_time = calendrical_functions.parseDate( start_date_input.val(), o.date_format ).getTime() / 1000;
+					// If parsed incorrectly, entire calculation is invalid.
+					if( isNaN( unix_start_time ) ) {
+						unix_start_time = '';
+					}
+					// Set start date value to valid unix time, or empty string, depending
+					// on above validation.
+					start_time.val( unix_start_time );
+				} );
+	
+			// Store original form value
+			start_time.data( 'timespan.initial_value', start_time.val() );
+	
+			// Initialize input fields
+			reset( start_date_input,
+					start_time,
+					o.twentyfour_hour,
+					o.date_format,
+					o.now )
+	
+			return this;
+		},
+	
+		/**
+		 * Reset values to defaults.
+		 */
+		reset: function( options )
+		{
+			var o = $.extend( {}, default_options, options );
+	
+			reset( $(o.start_date_input),
+					$(o.start_time),
+					o.twentyfour_hour,
+					o.date_format,
+					o.now );
+	
+			return this;
+		},
+	
+		/**
+		 * Destroy registered event handlers.
+		 */
+		destroy: function( options )
+	 	{
+			options = $.extend( {}, default_options, options );
+	
+			$.each( options, function( option_name, value ) {
+				$(value).unbind( '.timespan' );
+			} );
+			$(options.start_date_input).closest('form').unbind( '.timespan' );
+	
+			return this;
+		}
+	}
+	
+	/**
+	 * Main jQuery plugin definition
+	 */
+	
+	$.inputdate = function( arg )
+	{
+		// Method calling logic
+		if( methods[arg] ) {
+			return methods[arg].apply( this, Array.prototype.slice.call( arguments, 1 ));
+		} else if( typeof arg === 'object' || ! arg ) {
+			return methods.init.apply( this, arguments );
+		} else {
+			$.error( 'Method ' + arg + ' does not exist on jQuery.timespan' );
+		}
+	};
+} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/jquery.masonry.js b/public/js_src/external_libs/jquery.masonry.js
new file mode 100644
index 0000000..10c8278
--- /dev/null
+++ b/public/js_src/external_libs/jquery.masonry.js
@@ -0,0 +1,507 @@
+define(
+		[
+		 "jquery_timely"
+		],
+		function( jQuery ) {
+	'use strict';
+/**
+ * jQuery Masonry v2.1.05
+ * A dynamic layout plugin for jQuery
+ * The flip-side of CSS Floats
+ * http://masonry.desandro.com
+ *
+ * Licensed under the MIT license.
+ * Copyright 2012 David DeSandro
+ */
+
+/*jshint browser: true, curly: true, eqeqeq: true, forin: false, immed: false, newcap: true, noempty: true, strict: true, undef: true */
+/*global jQuery: false */
+
+(function( window, $, undefined ){
+
+
+
+  /*
+   * smartresize: debounced resize event for jQuery
+   *
+   * latest version and complete README available on Github:
+   * https://github.com/louisremi/jquery.smartresize.js
+   *
+   * Copyright 2011 @louis_remi
+   * Licensed under the MIT license.
+   */
+
+  var $event = $.event,
+      resizeTimeout;
+
+  $event.special.smartresize = {
+    setup: function() {
+      $(this).bind( "resize", $event.special.smartresize.handler );
+    },
+    teardown: function() {
+      $(this).unbind( "resize", $event.special.smartresize.handler );
+    },
+    handler: function( event, execAsap ) {
+      // Save the context
+      var context = this,
+          args = arguments;
+
+      // set correct event type
+      event.type = "smartresize";
+
+      if ( resizeTimeout ) { clearTimeout( resizeTimeout ); }
+      resizeTimeout = setTimeout(function() {
+        $.event.handle.apply( context, args );
+      }, execAsap === "execAsap"? 0 : 100 );
+    }
+  };
+
+  $.fn.smartresize = function( fn ) {
+    return fn ? this.bind( "smartresize", fn ) : this.trigger( "smartresize", ["execAsap"] );
+  };
+
+
+
+// ========================= Masonry ===============================
+
+
+  // our "Widget" object constructor
+  $.Mason = function( options, element ){
+    this.element = $( element );
+
+    this._create( options );
+    this._init();
+  };
+
+  $.Mason.settings = {
+    isResizable: true,
+    isAnimated: false,
+    animationOptions: {
+      queue: false,
+      duration: 500
+    },
+    gutterWidth: 0,
+    isRTL: false,
+    isFitWidth: false,
+    containerStyle: {
+      position: 'relative'
+    }
+  };
+
+  $.Mason.prototype = {
+
+    _filterFindBricks: function( $elems ) {
+      var selector = this.options.itemSelector;
+      // if there is a selector
+      // filter/find appropriate item elements
+      return !selector ? $elems : $elems.filter( selector ).add( $elems.find( selector ) );
+    },
+
+    _getBricks: function( $elems ) {
+      var $bricks = this._filterFindBricks( $elems )
+        .css({ position: 'absolute' })
+        .addClass('masonry-brick');
+      return $bricks;
+    },
+
+    // sets up widget
+    _create : function( options ) {
+
+      this.options = $.extend( true, {}, $.Mason.settings, options );
+      this.styleQueue = [];
+
+      // get original styles in case we re-apply them in .destroy()
+      var elemStyle = this.element[0].style;
+      this.originalStyle = {
+        // get height
+        height: elemStyle.height || ''
+      };
+      // get other styles that will be overwritten
+      var containerStyle = this.options.containerStyle;
+      for ( var prop in containerStyle ) {
+        this.originalStyle[ prop ] = elemStyle[ prop ] || '';
+      }
+
+      this.element.css( containerStyle );
+
+      this.horizontalDirection = this.options.isRTL ? 'right' : 'left';
+
+      this.offset = {
+        x: parseInt( this.element.css( 'padding-' + this.horizontalDirection ), 10 ),
+        y: parseInt( this.element.css( 'padding-top' ), 10 )
+      };
+
+      this.isFluid = this.options.columnWidth && typeof this.options.columnWidth === 'function';
+
+      // add masonry class first time around
+      var instance = this;
+      setTimeout( function() {
+        instance.element.addClass('masonry');
+      }, 0 );
+
+      // bind resize method
+      if ( this.options.isResizable ) {
+        $(window).bind( 'smartresize.masonry', function() {
+          instance.resize();
+        });
+      }
+
+
+      // need to get bricks
+      this.reloadItems();
+
+    },
+
+    // _init fires when instance is first created
+    // and when instance is triggered again -> $el.masonry();
+    _init : function( callback ) {
+      this._getColumns();
+      this._reLayout( callback );
+    },
+
+    option: function( key, value ){
+      // set options AFTER initialization:
+      // signature: $('#foo').bar({ cool:false });
+      if ( $.isPlainObject( key ) ){
+        this.options = $.extend(true, this.options, key);
+      }
+    },
+
+    // ====================== General Layout ======================
+
+    // used on collection of atoms (should be filtered, and sorted before )
+    // accepts atoms-to-be-laid-out to start with
+    layout : function( $bricks, callback ) {
+
+      // place each brick
+      for (var i=0, len = $bricks.length; i < len; i++) {
+        this._placeBrick( $bricks[i] );
+      }
+
+      // set the size of the container
+      var containerSize = {};
+      containerSize.height = Math.max.apply( Math, this.colYs );
+      if ( this.options.isFitWidth ) {
+        var unusedCols = 0;
+        i = this.cols;
+        // count unused columns
+        while ( --i ) {
+          if ( this.colYs[i] !== 0 ) {
+            break;
+          }
+          unusedCols++;
+        }
+        // fit container to columns that have been used;
+        containerSize.width = (this.cols - unusedCols) * this.columnWidth - this.options.gutterWidth;
+      }
+      this.styleQueue.push({ $el: this.element, style: containerSize });
+
+      // are we animating the layout arrangement?
+      // use plugin-ish syntax for css or animate
+      var styleFn = !this.isLaidOut ? 'css' : (
+            this.options.isAnimated ? 'animate' : 'css'
+          ),
+          animOpts = this.options.animationOptions;
+
+      // process styleQueue
+      var obj;
+      for (i=0, len = this.styleQueue.length; i < len; i++) {
+        obj = this.styleQueue[i];
+        obj.$el[ styleFn ]( obj.style, animOpts );
+      }
+
+      // clear out queue for next time
+      this.styleQueue = [];
+
+      // provide $elems as context for the callback
+      if ( callback ) {
+        callback.call( $bricks );
+      }
+
+      this.isLaidOut = true;
+    },
+
+    // calculates number of columns
+    // i.e. this.columnWidth = 200
+    _getColumns : function() {
+      var container = this.options.isFitWidth ? this.element.parent() : this.element,
+          containerWidth = container.width();
+
+                         // use fluid columnWidth function if there
+      this.columnWidth = this.isFluid ? this.options.columnWidth( containerWidth ) :
+                    // if not, how about the explicitly set option?
+                    this.options.columnWidth ||
+                    // or use the size of the first item
+                    this.$bricks.outerWidth(true) ||
+                    // if there's no items, use size of container
+                    containerWidth;
+
+      this.columnWidth += this.options.gutterWidth;
+
+      this.cols = Math.floor( ( containerWidth + this.options.gutterWidth ) / this.columnWidth );
+      this.cols = Math.max( this.cols, 1 );
+
+    },
+
+    // layout logic
+    _placeBrick: function( brick ) {
+      var $brick = $(brick),
+          colSpan, groupCount, groupY, groupColY, j;
+
+      //how many columns does this brick span
+      colSpan = Math.ceil( $brick.outerWidth(true) / this.columnWidth );
+      colSpan = Math.min( colSpan, this.cols );
+
+      if ( colSpan === 1 ) {
+        // if brick spans only one column, just like singleMode
+        groupY = this.colYs;
+      } else {
+        // brick spans more than one column
+        // how many different places could this brick fit horizontally
+        groupCount = this.cols + 1 - colSpan;
+        groupY = [];
+
+        // for each group potential horizontal position
+        for ( j=0; j < groupCount; j++ ) {
+          // make an array of colY values for that one group
+          groupColY = this.colYs.slice( j, j+colSpan );
+          // and get the max value of the array
+          groupY[j] = Math.max.apply( Math, groupColY );
+        }
+
+      }
+
+      // get the minimum Y value from the columns
+      var minimumY = Math.min.apply( Math, groupY ),
+          shortCol = 0;
+
+      // Find index of short column, the first from the left
+      for (var i=0, len = groupY.length; i < len; i++) {
+        if ( groupY[i] === minimumY ) {
+          shortCol = i;
+          break;
+        }
+      }
+
+      // position the brick
+      var position = {
+        top: minimumY + this.offset.y
+      };
+      // position.left or position.right
+      position[ this.horizontalDirection ] = this.columnWidth * shortCol + this.offset.x;
+      this.styleQueue.push({ $el: $brick, style: position });
+
+      // apply setHeight to necessary columns
+      var setHeight = minimumY + $brick.outerHeight(true),
+          setSpan = this.cols + 1 - len;
+      for ( i=0; i < setSpan; i++ ) {
+        this.colYs[ shortCol + i ] = setHeight;
+      }
+
+    },
+
+
+    resize: function() {
+      var prevColCount = this.cols;
+      // get updated colCount
+      this._getColumns();
+      if ( this.isFluid || this.cols !== prevColCount ) {
+        // if column count has changed, trigger new layout
+        this._reLayout();
+      }
+    },
+
+
+    _reLayout : function( callback ) {
+      // reset columns
+      var i = this.cols;
+      this.colYs = [];
+      while (i--) {
+        this.colYs.push( 0 );
+      }
+      // apply layout logic to all bricks
+      this.layout( this.$bricks, callback );
+    },
+
+    // ====================== Convenience methods ======================
+
+    // goes through all children again and gets bricks in proper order
+    reloadItems : function() {
+      this.$bricks = this._getBricks( this.element.children() );
+    },
+
+
+    reload : function( callback ) {
+      this.reloadItems();
+      this._init( callback );
+    },
+
+
+    // convienence method for working with Infinite Scroll
+    appended : function( $content, isAnimatedFromBottom, callback ) {
+      if ( isAnimatedFromBottom ) {
+        // set new stuff to the bottom
+        this._filterFindBricks( $content ).css({ top: this.element.height() });
+        var instance = this;
+        setTimeout( function(){
+          instance._appended( $content, callback );
+        }, 1 );
+      } else {
+        this._appended( $content, callback );
+      }
+    },
+
+    _appended : function( $content, callback ) {
+      var $newBricks = this._getBricks( $content );
+      // add new bricks to brick pool
+      this.$bricks = this.$bricks.add( $newBricks );
+      this.layout( $newBricks, callback );
+    },
+
+    // removes elements from Masonry widget
+    remove : function( $content ) {
+      this.$bricks = this.$bricks.not( $content );
+      $content.remove();
+    },
+
+    // destroys widget, returns elements and container back (close) to original style
+    destroy : function() {
+
+      this.$bricks
+        .removeClass('masonry-brick')
+        .each(function(){
+          this.style.position = '';
+          this.style.top = '';
+          this.style.left = '';
+        });
+
+      // re-apply saved container styles
+      var elemStyle = this.element[0].style;
+      for ( var prop in this.originalStyle ) {
+        elemStyle[ prop ] = this.originalStyle[ prop ];
+      }
+
+      this.element
+        .unbind('.masonry')
+        .removeClass('masonry')
+        .removeData('masonry');
+
+      $(window).unbind('.masonry');
+
+    }
+
+  };
+
+
+  // ======================= imagesLoaded Plugin ===============================
+  /*!
+   * jQuery imagesLoaded plugin v1.1.0
+   * http://github.com/desandro/imagesloaded
+   *
+   * MIT License. by Paul Irish et al.
+   */
+
+
+  // $('#my-container').imagesLoaded(myFunction)
+  // or
+  // $('img').imagesLoaded(myFunction)
+
+  // execute a callback when all images have loaded.
+  // needed because .load() doesn't work on cached images
+
+  // callback function gets image collection as argument
+  //  `this` is the container
+
+  $.fn.imagesLoaded = function( callback ) {
+    var $this = this,
+        $images = $this.find('img').add( $this.filter('img') ),
+        len = $images.length,
+        blank = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==',
+        loaded = [];
+
+    function triggerCallback() {
+      callback.call( $this, $images );
+    }
+
+    function imgLoaded( event ) {
+      var img = event.target;
+      if ( img.src !== blank && $.inArray( img, loaded ) === -1 ){
+        loaded.push( img );
+        if ( --len <= 0 ){
+          setTimeout( triggerCallback );
+          $images.unbind( '.imagesLoaded', imgLoaded );
+        }
+      }
+    }
+
+    // if no images, trigger immediately
+    if ( !len ) {
+      triggerCallback();
+    }
+
+    $images.bind( 'load.imagesLoaded error.imagesLoaded',  imgLoaded ).each( function() {
+      // cached images don't fire load sometimes, so we reset src.
+      var src = this.src;
+      // webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f
+      // data uri bypasses webkit log warning (thx doug jones)
+      this.src = blank;
+      this.src = src;
+    });
+
+    return $this;
+  };
+
+
+  // helper function for logging errors
+  // $.error breaks jQuery chaining
+  var logError = function( message ) {
+    if ( window.console ) {
+      window.console.error( message );
+    }
+  };
+
+  // =======================  Plugin bridge  ===============================
+  // leverages data method to either create or return $.Mason constructor
+  // A bit from jQuery UI
+  //   https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js
+  // A bit from jcarousel
+  //   https://github.com/jsor/jcarousel/blob/master/lib/jquery.jcarousel.js
+
+  $.fn.masonry = function( options ) {
+    if ( typeof options === 'string' ) {
+      // call method
+      var args = Array.prototype.slice.call( arguments, 1 );
+
+      this.each(function(){
+        var instance = $.data( this, 'masonry' );
+        if ( !instance ) {
+          logError( "cannot call methods on masonry prior to initialization; " +
+            "attempted to call method '" + options + "'" );
+          return;
+        }
+        if ( !$.isFunction( instance[options] ) || options.charAt(0) === "_" ) {
+          logError( "no such method '" + options + "' for masonry instance" );
+          return;
+        }
+        // apply method
+        instance[ options ].apply( instance, args );
+      });
+    } else {
+      this.each(function() {
+        var instance = $.data( this, 'masonry' );
+        if ( instance ) {
+          // apply options & init
+          instance.option( options || {} );
+          instance._init();
+        } else {
+          // initialize new instance
+          $.data( this, 'masonry', new $.Mason( options, this ) );
+        }
+      });
+    }
+    return this;
+  };
+
+})( window, jQuery );
+
+} );
diff --git a/public/js_src/external_libs/jquery.scrollTo.js b/public/js_src/external_libs/jquery.scrollTo.js
new file mode 100644
index 0000000..5ae1bcc
--- /dev/null
+++ b/public/js_src/external_libs/jquery.scrollTo.js
@@ -0,0 +1,221 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+/*!
+ * jQuery.ScrollTo
+ * Copyright (c) 2007-2012 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
+ * Dual licensed under MIT and GPL.
+ * Date: 12/14/2012
+ *
+ * @projectDescription Easy element scrolling using jQuery.
+ * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
+ * @author Ariel Flesler
+ * @version 1.4.5 BETA
+ *
+ * @id jQuery.scrollTo
+ * @id jQuery.fn.scrollTo
+ * @param {String, Number, DOMElement, jQuery, Object} target Where to scroll the matched elements.
+ *	  The different options for target are:
+ *		- A number position (will be applied to all axes).
+ *		- A string position ('44', '100px', '+=90', etc ) will be applied to all axes
+ *		- A jQuery/DOM element ( logically, child of the element to scroll )
+ *		- A string selector, that will be relative to the element to scroll ( 'li:eq(2)', etc )
+ *		- A hash { top:x, left:y }, x and y can be any kind of number/string like above.
+ *		- A percentage of the container's dimension/s, for example: 50% to go to the middle.
+ *		- The string 'max' for go-to-end.
+ * @param {Number, Function} duration The OVERALL length of the animation, this argument can be the settings object instead.
+ * @param {Object,Function} settings Optional set of settings or the onAfter callback.
+ *	 @option {String} axis Which axis must be scrolled, use 'x', 'y', 'xy' or 'yx'.
+ *	 @option {Number, Function} duration The OVERALL length of the animation.
+ *	 @option {String} easing The easing method for the animation.
+ *	 @option {Boolean} margin If true, the margin of the target element will be deducted from the final position.
+ *	 @option {Object, Number} offset Add/deduct from the end position. One number for both axes or { top:x, left:y }.
+ *	 @option {Object, Number} over Add/deduct the height/width multiplied by 'over', can be { top:x, left:y } when using both axes.
+ *	 @option {Boolean} queue If true, and both axis are given, the 2nd axis will only be animated after the first one ends.
+ *	 @option {Function} onAfter Function to be called after the scrolling ends.
+ *	 @option {Function} onAfterFirst If queuing is activated, this function will be called after the first scrolling ends.
+ * @return {jQuery} Returns the same jQuery object, for chaining.
+ *
+ * @desc Scroll to a fixed position
+ * @example $('div').scrollTo( 340 );
+ *
+ * @desc Scroll relatively to the actual position
+ * @example $('div').scrollTo( '+=340px', { axis:'y' } );
+ *
+ * @desc Scroll using a selector (relative to the scrolled element)
+ * @example $('div').scrollTo( 'p.paragraph:eq(2)', 500, { easing:'swing', queue:true, axis:'xy' } );
+ *
+ * @desc Scroll to a DOM element (same for jQuery object)
+ * @example var second_child = document.getElementById('container').firstChild.nextSibling;
+ *			$('#container').scrollTo( second_child, { duration:500, axis:'x', onAfter:function(){
+ *				alert('scrolled!!');
+ *			}});
+ *
+ * @desc Scroll on both axes, to different values
+ * @example $('div').scrollTo( { top: 300, left:'+=200' }, { axis:'xy', offset:-20 } );
+ */
+
+	var $scrollTo = $.scrollTo = function( target, duration, settings ){
+		$(window).scrollTo( target, duration, settings );
+	};
+
+	$scrollTo.defaults = {
+		axis:'xy',
+		duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1,
+		limit:true
+	};
+
+	// Returns the element that needs to be animated to scroll the window.
+	// Kept for backwards compatibility (specially for localScroll & serialScroll)
+	$scrollTo.window = function( scope ){
+		return $(window)._scrollable();
+	};
+
+	// Hack, hack, hack :)
+	// Returns the real elements to scroll (supports window/iframes, documents and regular nodes)
+	$.fn._scrollable = function(){
+		return this.map(function(){
+			var elem = this,
+				isWin = !elem.nodeName || $.inArray( elem.nodeName.toLowerCase(), ['iframe','#document','html','body'] ) != -1;
+
+				if( !isWin )
+					return elem;
+
+			var doc = (elem.contentWindow || elem).document || elem.ownerDocument || elem;
+
+			return /webkit/i.test(navigator.userAgent) || doc.compatMode == 'BackCompat' ?
+				doc.body :
+				doc.documentElement;
+		});
+	};
+
+	$.fn.scrollTo = function( target, duration, settings ){
+		if( typeof duration == 'object' ){
+			settings = duration;
+			duration = 0;
+		}
+		if( typeof settings == 'function' )
+			settings = { onAfter:settings };
+
+		if( target == 'max' )
+			target = 9e9;
+
+		settings = $.extend( {}, $scrollTo.defaults, settings );
+		// Speed is still recognized for backwards compatibility
+		duration = duration || settings.duration;
+		// Make sure the settings are given right
+		settings.queue = settings.queue && settings.axis.length > 1;
+
+		if( settings.queue )
+			// Let's keep the overall duration
+			duration /= 2;
+		settings.offset = both( settings.offset );
+		settings.over = both( settings.over );
+
+		return this._scrollable().each(function(){
+			// Null target yields nothing, just like jQuery does
+			if (target == null) return;
+
+			var elem = this,
+				$elem = $(elem),
+				targ = target, toff, attr = {},
+				win = $elem.is('html,body');
+
+			switch( typeof targ ){
+				// A number will pass the regex
+				case 'number':
+				case 'string':
+					if( /^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ) ){
+						targ = both( targ );
+						// We are done
+						break;
+					}
+					// Relative selector, no break!
+					targ = $(targ,this);
+					if (!targ.length) return;
+				case 'object':
+					// DOMElement / jQuery
+					if( targ.is || targ.style )
+						// Get the real position of the target
+						toff = (targ = $(targ)).offset();
+			}
+			$.each( settings.axis.split(''), function( i, axis ){
+				var Pos	= axis == 'x' ? 'Left' : 'Top',
+					pos = Pos.toLowerCase(),
+					key = 'scroll' + Pos,
+					old = elem[key],
+					max = $scrollTo.max(elem, axis);
+
+				if( toff ){// jQuery / DOMElement
+					attr[key] = toff[pos] + ( win ? 0 : old - $elem.offset()[pos] );
+
+					// If it's a dom element, reduce the margin
+					if( settings.margin ){
+						attr[key] -= parseInt(targ.css('margin'+Pos)) || 0;
+						attr[key] -= parseInt(targ.css('border'+Pos+'Width')) || 0;
+					}
+
+					attr[key] += settings.offset[pos] || 0;
+
+					if( settings.over[pos] )
+						// Scroll to a fraction of its width/height
+						attr[key] += targ[axis=='x'?'width':'height']() * settings.over[pos];
+				}else{
+					var val = targ[pos];
+					// Handle percentage values
+					attr[key] = val.slice && val.slice(-1) == '%' ?
+						parseFloat(val) / 100 * max
+						: val;
+				}
+
+				// Number or 'number'
+				if( settings.limit && /^\d+$/.test(attr[key]) )
+					// Check the limits
+					attr[key] = attr[key] <= 0 ? 0 : Math.min( attr[key], max );
+
+				// Queueing axes
+				if( !i && settings.queue ){
+					// Don't waste time animating, if there's no need.
+					if( old != attr[key] )
+						// Intermediate animation
+						animate( settings.onAfterFirst );
+					// Don't animate this axis again in the next iteration.
+					delete attr[key];
+				}
+			});
+
+			animate( settings.onAfter );
+
+			function animate( callback ){
+				$elem.animate( attr, duration, settings.easing, callback && function(){
+					callback.call(this, target, settings);
+				});
+			};
+
+		}).end();
+	};
+
+	// Max scrolling position, works on quirks mode
+	// It only fails (not too badly) on IE, quirks mode.
+	$scrollTo.max = function( elem, axis ){
+		var Dim = axis == 'x' ? 'Width' : 'Height',
+			scroll = 'scroll'+Dim;
+
+		if( !$(elem).is('html,body') )
+			return elem[scroll] - $(elem)[Dim.toLowerCase()]();
+
+		var size = 'client' + Dim,
+			html = elem.ownerDocument.documentElement,
+			body = elem.ownerDocument.body;
+
+		return Math.max( html[scroll], body[scroll] )
+			 - Math.min( html[size]  , body[size]   );
+	};
+
+	function both( val ){
+		return typeof val == 'object' ? val : { top:val, left:val };
+	};
+
+} );
diff --git a/public/js_src/external_libs/jquery.tablescroller.js b/public/js_src/external_libs/jquery.tablescroller.js
new file mode 100644
index 0000000..de04107
--- /dev/null
+++ b/public/js_src/external_libs/jquery.tablescroller.js
@@ -0,0 +1,187 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+/*
+
+Copyright (c) 2009 Dimas Begunoff, http://www.farinspace.com
+
+Licensed under the MIT license
+http://en.wikipedia.org/wiki/MIT_License
+
+Permission is hereby granted, free of charge, to any person
+obtaining a copy of this software and associated documentation
+files (the "Software"), to deal in the Software without
+restriction, including without limitation the rights to use,
+copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+*/
+
+
+
+var scrollbarWidth = 0;
+
+// http://jdsharp.us/jQuery/minute/calculate-scrollbar-width.php
+function getScrollbarWidth()
+{
+	if (scrollbarWidth) return scrollbarWidth;
+	var div = $('<div style="width:50px;height:50px;overflow:hidden;position:absolute;top:-200px;left:-200px;"><div style="height:100px;"></div></div>');
+	$('body').append(div);
+	var w1 = $('div', div).innerWidth();
+	div.css('overflow-y', 'auto');
+	var w2 = $('div', div).innerWidth();
+	$(div).remove();
+	scrollbarWidth = (w1 - w2);
+	return scrollbarWidth;
+}
+
+$.fn.tableScroll = function(options)
+{
+	if (options == 'undo')
+	{
+		var container = $(this).parent().parent();
+		if (container.hasClass('tablescroll_wrapper'))
+		{
+			container.find('.tablescroll_head thead').prependTo(this);
+			container.find('.tablescroll_foot tfoot').appendTo(this);
+			container.before(this);
+			container.empty();
+		}
+		return;
+	}
+
+	var settings = $.extend({},$.fn.tableScroll.defaults,options);
+
+	// Bail out if there's no vertical overflow
+	//if ($(this).height() <= settings.height)
+	//{
+	//  return this;
+	//}
+
+	settings.scrollbarWidth = getScrollbarWidth();
+
+	this.each(function()
+	{
+		var flush = settings.flush;
+
+		var tb = $(this).addClass('tablescroll_body');
+
+		var wrapper = $('<div class="tablescroll_wrapper ai1ec-popover-boundary"></div>').insertBefore(tb).append(tb);
+
+		// check for a predefined container
+		if (!wrapper.parent('div').hasClass(settings.containerClass))
+		{
+			$('<div></div>').addClass(settings.containerClass).insertBefore(wrapper).append(wrapper);
+		}
+
+		var width = settings.width ? settings.width : tb.outerWidth();
+		var overflow = settings.scroll ? 'auto' : 'hidden';
+
+		wrapper.css
+		({
+			'width': width+'px',
+			'height': settings.height+'px',
+			'overflow': overflow
+		});
+
+		tb.css('width',width+'px');
+
+		// with border difference
+		var wrapper_width = wrapper.outerWidth();
+		var diff = wrapper_width-width;
+
+		// assume table will scroll
+		wrapper.css({width:((width-diff-2))+'px'});
+		tb.css('width',(width-diff-settings.scrollbarWidth)+'px');
+
+		if (tb.outerHeight() <= settings.height)
+		{
+			wrapper.css({height:'auto',width:(width-diff)+'px'});
+			flush = false;
+		}
+
+		// using wrap does not put wrapper in the DOM right
+		// away making it unavailable for use during runtime
+		// tb.wrap(wrapper);
+
+		// possible speed enhancements
+		var has_thead = $('thead',tb).length ? true : false ;
+		var has_tfoot = $('tfoot',tb).length ? true : false ;
+		var thead_tr_first = $('thead tr:first',tb);
+		var tbody_tr_first = $('tbody tr:first',tb);
+		var tfoot_tr_first = $('tfoot tr:first',tb);
+
+		// remember width of last cell
+		var w = 0;
+
+		$('th, td',thead_tr_first).each(function(i)
+		{
+			w  = $(this).width();
+			$('th:eq('+i+'), td:eq('+i+')',thead_tr_first).css('width',w+'px');
+			$('th:eq('+i+'), td:eq('+i+')',tbody_tr_first).css('width',w+'px');
+			if (has_tfoot) $('th:eq('+i+'), td:eq('+i+')',tfoot_tr_first).css('width',w+'px');
+		});
+
+		if (has_thead)
+		{
+			var tbh = $('<table class="tablescroll_head" cellspacing="0"></table>').insertBefore(wrapper).prepend($('thead',tb));
+		}
+
+		if (has_tfoot)
+		{
+			var tbf = $('<table class="tablescroll_foot" cellspacing="0"></table>').insertAfter(wrapper).prepend($('tfoot',tb));
+		}
+
+		if (tbh != undefined)
+		{
+			tbh.css('width',width+'px');
+
+			if (flush)
+			{
+				$('tr:first th:last, tr:first td:last',tbh).css('width',(w+settings.scrollbarWidth)+'px');
+				tbh.css('width',wrapper.outerWidth() + 'px');
+			}
+		}
+
+		if (tbf != undefined)
+		{
+			tbf.css('width',width+'px');
+
+			if (flush)
+			{
+				$('tr:first th:last, tr:first td:last',tbf).css('width',(w+settings.scrollbarWidth)+'px');
+				tbf.css('width',wrapper.outerWidth() + 'px');
+			}
+		}
+	});
+
+	return this;
+};
+
+// public
+$.fn.tableScroll.defaults =
+{
+	flush: true, // makes the last thead and tbody column flush with the scrollbar
+	width: null, // width of the table (head, body and foot), null defaults to the tables natural width
+	height: 100, // height of the scrollable area
+	containerClass: 'tablescroll', // the plugin wraps the table in a div with this css class
+	scroll: true // whether to allow scrolling or not
+};
+
+} );
diff --git a/public/js_src/external_libs/jquery.tools.js b/public/js_src/external_libs/jquery.tools.js
new file mode 100644
index 0000000..ee38f27
--- /dev/null
+++ b/public/js_src/external_libs/jquery.tools.js
@@ -0,0 +1,458 @@
+define( 
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+			
+			$.tools = $.tools || {version: '1.2.7'};
+
+			var tool;
+
+			tool = $.tools.rangeinput = {
+
+				conf: {
+					min: 0,
+					max: 100,		// as defined in the standard
+					step: 'any', 	// granularity of the value. a non-zero float or int (or "any")
+					steps: 0,
+					value: 0,			
+					precision: undefined,
+					vertical: 0,
+					keyboard: true,
+					progress: false,
+					speed: 100,
+
+					// set to null if not needed
+					css: {
+						input:		'range',
+						slider: 		'slider',
+						progress: 	'progress',
+						handle: 		'handle'					
+					}
+
+				} 
+			};
+
+		//{{{ fn.drag
+
+			/* 
+				FULL featured drag and drop. 0.7 kb minified, 0.3 gzipped. done.
+				Who told d'n'd is rocket science? Usage:
+				
+				$(".myelement").drag({y: false}).on("drag", function(event, x, y) {
+					// do your custom thing
+				});
+				 
+				Configuration: 
+					x: true, 		// enable horizontal drag
+					y: true, 		// enable vertical drag 
+					drag: true 		// true = perform drag, false = only fire events 
+					
+				Events: dragStart, drag, dragEnd. 
+			*/
+			var doc, draggable;
+
+			$.fn.drag = function(conf) {
+
+				// disable IE specialities
+				document.ondragstart = function () { return false; };
+
+				conf = $.extend({x: true, y: true, drag: true}, conf);
+
+				doc = doc || $(document).on("mousedown mouseup", function(e) {
+
+					var el = $(e.target);  
+
+					// start 
+					if (e.type == "mousedown" && el.data("drag")) {
+
+						var offset = el.position(),
+							 x0 = e.pageX - offset.left, 
+							 y0 = e.pageY - offset.top,
+							 start = true;    
+
+						doc.on("mousemove.drag", function(e) {  
+							var x = e.pageX -x0, 
+								 y = e.pageY -y0,
+								 props = {};
+
+							if (conf.x) { props.left = x; }
+							if (conf.y) { props.top = y; } 
+
+							if (start) {
+								el.trigger("dragStart");
+								start = false;
+							}
+							if (conf.drag) { el.css(props); }
+							el.trigger("drag", [y, x]);
+							draggable = el;
+						}); 
+
+						e.preventDefault();
+
+					} else {
+
+						try {
+							if (draggable) {  
+								draggable.trigger("dragEnd");  
+							}
+						} finally { 
+							doc.off("mousemove.drag");
+							draggable = null; 
+						}
+					} 
+
+				});
+
+				return this.data("drag", true); 
+			};	
+
+		//}}}
+
+
+
+			function round(value, precision) {
+				var n = Math.pow(10, precision);
+				return Math.round(value * n) / n;
+			}
+
+			// get hidden element's width or height even though it's hidden
+			function dim(el, key) {
+				var v = parseInt(el.css(key), 10);
+				if (v) { return v; }
+				var s = el[0].currentStyle; 
+				return s && s.width && parseInt(s.width, 10);	
+			}
+
+			function hasEvent(el) {
+				var e = el.data("events");
+				return e && e.onSlide;
+			}
+
+			function RangeInput(input, conf) {
+
+				// private variables
+				var self = this,  
+					 css = conf.css, 
+					 root = $("<div><div/><a href='#'/></div>").data("rangeinput", self),	
+					 vertical,		
+					 value,			// current value
+					 origo,			// handle's start point
+					 len,				// length of the range
+					 pos;				// current position of the handle		
+
+				// create range	 
+				input.before(root);	
+
+				var handle = root.addClass(css.slider).find("a").addClass(css.handle), 	
+					 progress = root.find("div").addClass(css.progress);
+
+				// get (HTML5) attributes into configuration
+				$.each("min,max,step,value".split(","), function(i, key) {
+					var val = input.attr(key);
+					if (parseFloat(val)) {
+						conf[key] = parseFloat(val, 10);
+					}
+				});			   
+
+				var range = conf.max - conf.min, 
+					 step = conf.step == 'any' ? 0 : conf.step,
+					 precision = conf.precision;
+
+				if (precision === undefined) {
+					precision = step.toString().split(".");
+					precision = precision.length === 2 ? precision[1].length : 0;
+				}  
+
+				// Replace built-in range input (type attribute cannot be changed)
+				if (input.attr("type") == 'range') {			
+					var def = input.clone().wrap("<div/>").parent().html(),
+						 clone = $(def.replace(/type/i, "type=text data-orig-type"));
+
+					clone.val(conf.value);
+					input.replaceWith(clone);
+					input = clone;
+				}
+
+				input.addClass(css.input);
+
+				var fire = $(self).add(input), fireOnSlide = true;
+
+
+				/**
+				 	The flesh and bone of this tool. All sliding is routed trough this.
+					
+					@param evt types include: click, keydown, blur and api (setValue call)
+					@param isSetValue when called trough setValue() call (keydown, blur, api)
+					
+					vertical configuration gives additional complexity. 
+				 */
+				function slide(evt, x, val, isSetValue) { 
+
+					// calculate value based on slide position
+					if (val === undefined) {
+						val = x / len * range;  
+
+					// x is calculated based on val. we need to strip off min during calculation	
+					} else if (isSetValue) {
+						val -= conf.min;	
+					}
+
+					// increment in steps
+					if (step) {
+						val = Math.round(val / step) * step;
+					}
+
+					// count x based on value or tweak x if stepping is done
+					if (x === undefined || step) {
+						x = val * len / range;	
+					}  
+
+					// crazy value?
+					if (isNaN(val)) { return self; }       
+
+					// stay within range
+					x = Math.max(0, Math.min(x, len));  
+					val = x / len * range;   
+
+					if (isSetValue || !vertical) {
+						val += conf.min;
+					}
+
+					// in vertical ranges value rises upwards
+					if (vertical) {
+						if (isSetValue) {
+							x = len -x;
+						} else {
+							val = conf.max - val;	
+						}
+					}	
+
+					// precision
+					val = round(val, precision); 
+
+					// onSlide
+					var isClick = evt.type == "click";
+					if (fireOnSlide && value !== undefined && !isClick) {
+						evt.type = "onSlide";           
+						fire.trigger(evt, [val, x]); 
+						if (evt.isDefaultPrevented()) { return self; }  
+					}				
+
+					// speed & callback
+					var speed = isClick ? conf.speed : 0,
+						 callback = isClick ? function()  {
+							evt.type = "change";
+							fire.trigger(evt, [val]);
+						 } : null;
+
+					if (vertical) {
+						handle.animate({top: x}, speed, callback);
+						if (conf.progress) { 
+							progress.animate({height: len - x + handle.height() / 2}, speed);	
+						}				
+
+					} else {
+						handle.animate({left: x}, speed, callback);
+						if (conf.progress) { 
+							progress.animate({width: x + handle.width() / 2}, speed); 
+						}
+					}
+
+					// store current value
+					value = val; 
+					pos = x;			 
+
+					// se input field's value
+					input.val(val);
+
+					return self;
+				} 
+
+
+				$.extend(self, {  
+
+					getValue: function() {
+						return value;	
+					},
+
+					setValue: function(val, e) {
+						init();
+						return slide(e || $.Event("api"), undefined, val, true); 
+					}, 			  
+
+					getConf: function() {
+						return conf;	
+					},
+
+					getProgress: function() {
+						return progress;	
+					},
+
+					getHandle: function() {
+						return handle;	
+					},			
+
+					getInput: function() {
+						return input;	
+					}, 
+
+					step: function(am, e) {
+						e = e || $.Event();
+						var step = conf.step == 'any' ? 1 : conf.step;
+						self.setValue(value + step * (am || 1), e);	
+					},
+
+					// HTML5 compatible name
+					stepUp: function(am) { 
+						return self.step(am || 1);
+					},
+
+					// HTML5 compatible name
+					stepDown: function(am) { 
+						return self.step(-am || -1);
+					}
+
+				});
+
+				// callbacks
+				$.each("onSlide,change".split(","), function(i, name) {
+
+					// from configuration
+					if ($.isFunction(conf[name]))  {
+						$(self).on(name, conf[name]);	
+					}
+
+					// API methods
+					self[name] = function(fn) {
+						if (fn) { $(self).on(name, fn); }
+						return self;	
+					};
+				}); 
+
+
+				// dragging		                                  
+				handle.drag({drag: false}).on("dragStart", function() {
+
+					/* do some pre- calculations for seek() function. improves performance */			
+					init();
+
+					// avoid redundant event triggering (= heavy stuff)
+					fireOnSlide = hasEvent($(self)) || hasEvent(input);
+
+
+				}).on("drag", function(e, y, x) {        
+
+					if (input.is(":disabled")) { return false; } 
+					slide(e, vertical ? y : x); 
+
+				}).on("dragEnd", function(e) {
+					if (!e.isDefaultPrevented()) {
+						e.type = "change";
+						fire.trigger(e, [value]);	 
+					}
+
+				}).click(function(e) {
+					return e.preventDefault();	 
+				});		
+
+				// clicking
+				root.click(function(e) { 
+					if (input.is(":disabled") || e.target == handle[0]) { 
+						return e.preventDefault(); 
+					}				  
+					init(); 
+					var fix = vertical ? handle.height() / 2 : handle.width() / 2;
+					slide(e, vertical ? len-origo-fix + e.pageY  : e.pageX -origo -fix);  
+				});
+
+				if (conf.keyboard) {
+
+					input.keydown(function(e) {
+
+						if (input.attr("readonly")) { return; }
+
+						var key = e.keyCode,
+							 up = $([75, 76, 38, 33, 39]).index(key) != -1,
+							 down = $([74, 72, 40, 34, 37]).index(key) != -1;					 
+
+						if ((up || down) && !(e.shiftKey || e.altKey || e.ctrlKey)) {
+
+							// UP: 	k=75, l=76, up=38, pageup=33, right=39			
+							if (up) {
+								self.step(key == 33 ? 10 : 1, e);
+
+							// DOWN:	j=74, h=72, down=40, pagedown=34, left=37
+							} else if (down) {
+								self.step(key == 34 ? -10 : -1, e); 
+							} 
+							return e.preventDefault();
+						} 
+					});
+				}
+
+
+				input.blur(function(e) {	
+					var val = $(this).val();
+					if (val !== value) {
+						self.setValue(val, e);
+					}
+				});    
+
+
+				// HTML5 DOM methods
+				$.extend(input[0], { stepUp: self.stepUp, stepDown: self.stepDown});
+
+
+				// calculate all dimension related stuff
+				function init() { 
+				 	vertical = conf.vertical || dim(root, "height") > dim(root, "width");
+
+					if (vertical) {
+						len = dim(root, "height") - dim(handle, "height");
+						origo = root.offset().top + len; 
+
+					} else {
+						len = dim(root, "width") - dim(handle, "width");
+						origo = root.offset().left;	  
+					} 	  
+				}
+
+				function begin() {
+					init();	
+					self.setValue(conf.value !== undefined ? conf.value : conf.min);
+				} 
+				begin();
+
+				// some browsers cannot get dimensions upon initialization
+				if (!len) {  
+					$(window).load(begin);
+				}
+			}
+
+			$.expr[':'].range = function(el) {
+				var type = el.getAttribute("type");
+				return type && type == 'range' || !!$(el).filter("input").data("rangeinput");
+			};
+
+
+			// jQuery plugin implementation
+			$.fn.rangeinput = function(conf) {
+
+				// already installed
+				if (this.data("rangeinput")) { return this; } 
+
+				// extend configuration with globals
+				conf = $.extend(true, {}, tool.conf, conf);		
+
+				var els;
+
+				this.each(function() {				
+					var el = new RangeInput($(this), $.extend(true, {}, conf));		 
+					var input = el.getInput().data("rangeinput", el);
+					els = els ? els.add(input) : input;	
+				});		
+
+				return els ? els : this; 
+			};	
+		} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/jquery_cookie.js b/public/js_src/external_libs/jquery_cookie.js
new file mode 100644
index 0000000..27fd47d
--- /dev/null
+++ b/public/js_src/external_libs/jquery_cookie.js
@@ -0,0 +1,80 @@
+define( ["jquery_timely"],
+		function( $ ) {
+	var pluses = /\+/g;
+
+	function raw(s) {
+		return s;
+	}
+
+	function decoded(s) {
+		return decodeURIComponent(s.replace(pluses, ' '));
+	}
+
+	function converted(s) {
+		if (s.indexOf('"') === 0) {
+			// This is a quoted cookie as according to RFC2068, unescape
+			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
+		}
+		try {
+			return config.json ? JSON.parse(s) : s;
+		} catch(er) {}
+	}
+
+	var config = $.cookie = function (key, value, options) {
+
+		// write
+		if (value !== undefined) {
+			options = $.extend({}, config.defaults, options);
+
+			if (typeof options.expires === 'number') {
+				var days = options.expires, t = options.expires = new Date();
+				t.setDate(t.getDate() + days);
+			}
+
+			value = config.json ? JSON.stringify(value) : String(value);
+
+			return (document.cookie = [
+				config.raw ? key : encodeURIComponent(key),
+				'=',
+				config.raw ? value : encodeURIComponent(value),
+				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
+				options.path    ? '; path=' + options.path : '',
+				options.domain  ? '; domain=' + options.domain : '',
+				options.secure  ? '; secure' : ''
+			].join(''));
+		}
+
+		// read
+		var decode = config.raw ? raw : decoded;
+		var cookies = document.cookie.split('; ');
+		var result = key ? undefined : {};
+		for (var i = 0, l = cookies.length; i < l; i++) {
+			var parts = cookies[i].split('=');
+			var name = decode(parts.shift());
+			var cookie = decode(parts.join('='));
+
+			if (key && key === name) {
+				result = converted(cookie);
+				break;
+			}
+
+			if (!key) {
+				result[name] = converted(cookie);
+			}
+		}
+
+		return result;
+	};
+
+	config.defaults = {};
+
+	$.removeCookie = function (key, options) {
+		if ($.cookie(key) !== undefined) {
+			// Must not alter options, thus extending a fresh object...
+			$.cookie(key, '', $.extend({}, options, { expires: -1 }));
+			return true;
+		}
+		return false;
+	};
+
+} );
diff --git a/public/js_src/external_libs/jquery_history.js b/public/js_src/external_libs/jquery_history.js
new file mode 100644
index 0000000..33a11db
--- /dev/null
+++ b/public/js_src/external_libs/jquery_history.js
@@ -0,0 +1,2652 @@
+define( 
+		[
+		 "jquery_timely"
+		 ],
+		 function( jQuery ) {
+			try {
+				/**
+				 * History.js jQuery Adapter
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
+				 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
+				 */
+
+				// Closure
+				(function(window,undefined){
+					"use strict";
+
+					// Localise Globals
+					var
+						History = window.History = window.History||{};
+
+					// Check Existence
+					if ( typeof History.Adapter !== 'undefined' ) {
+						throw new Error('History.js Adapter has already been loaded...');
+					}
+
+					// Add the Adapter
+					History.Adapter = {
+						/**
+						 * History.Adapter.bind(el,event,callback)
+						 * @param {Element|string} el
+						 * @param {string} event - custom and standard events
+						 * @param {function} callback
+						 * @return {void}
+						 */
+						bind: function(el,event,callback){
+							jQuery(el).bind(event,callback);
+						},
+
+						/**
+						 * History.Adapter.trigger(el,event)
+						 * @param {Element|string} el
+						 * @param {string} event - custom and standard events
+						 * @param {Object=} extra - a object of extra event data (optional)
+						 * @return {void}
+						 */
+						trigger: function(el,event,extra){
+							jQuery(el).trigger(event,extra);
+						},
+
+						/**
+						 * History.Adapter.extractEventData(key,event,extra)
+						 * @param {string} key - key for the event data to extract
+						 * @param {string} event - custom and standard events
+						 * @param {Object=} extra - a object of extra event data (optional)
+						 * @return {mixed}
+						 */
+						extractEventData: function(key,event,extra){
+							// jQuery Native then jQuery Custom
+							var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;
+
+							// Return
+							return result;
+						},
+
+						/**
+						 * History.Adapter.onDomLoad(callback)
+						 * @param {function} callback
+						 * @return {void}
+						 */
+						onDomLoad: function(callback) {
+							jQuery(callback);
+						}
+					};
+
+					// Try and Initialise History
+					if ( typeof History.init !== 'undefined' ) {
+						History.init();
+					}
+
+				})(window);
+				
+				/**
+				 * History.js HTML4 Support
+				 * Depends on the HTML5 Support
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
+				 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
+				 */
+
+				(function(window,undefined){
+					"use strict";
+
+					// ========================================================================
+					// Initialise
+
+					// Localise Globals
+					var
+						document = window.document, // Make sure we are using the correct document
+						setTimeout = window.setTimeout||setTimeout,
+						clearTimeout = window.clearTimeout||clearTimeout,
+						setInterval = window.setInterval||setInterval,
+						History = window.History = window.History||{}; // Public History Object
+
+					// Check Existence
+					if ( typeof History.initHtml4 !== 'undefined' ) {
+						throw new Error('History.js HTML4 Support has already been loaded...');
+					}
+
+
+					// ========================================================================
+					// Initialise HTML4 Support
+
+					// Initialise HTML4 Support
+					History.initHtml4 = function(){
+						// Initialise
+						if ( typeof History.initHtml4.initialized !== 'undefined' ) {
+							// Already Loaded
+							return false;
+						}
+						else {
+							History.initHtml4.initialized = true;
+						}
+
+
+						// ====================================================================
+						// Properties
+
+						/**
+						 * History.enabled
+						 * Is History enabled?
+						 */
+						History.enabled = true;
+
+
+						// ====================================================================
+						// Hash Storage
+
+						/**
+						 * History.savedHashes
+						 * Store the hashes in an array
+						 */
+						History.savedHashes = [];
+
+						/**
+						 * History.isLastHash(newHash)
+						 * Checks if the hash is the last hash
+						 * @param {string} newHash
+						 * @return {boolean} true
+						 */
+						History.isLastHash = function(newHash){
+							// Prepare
+							var oldHash = History.getHashByIndex(),
+								isLast;
+
+							// Check
+							isLast = newHash === oldHash;
+
+							// Return isLast
+							return isLast;
+						};
+
+						/**
+						 * History.saveHash(newHash)
+						 * Push a Hash
+						 * @param {string} newHash
+						 * @return {boolean} true
+						 */
+						History.saveHash = function(newHash){
+							// Check Hash
+							if ( History.isLastHash(newHash) ) {
+								return false;
+							}
+
+							// Push the Hash
+							History.savedHashes.push(newHash);
+
+							// Return true
+							return true;
+						};
+
+						/**
+						 * History.getHashByIndex()
+						 * Gets a hash by the index
+						 * @param {integer} index
+						 * @return {string}
+						 */
+						History.getHashByIndex = function(index){
+							// Prepare
+							var hash = null;
+
+							// Handle
+							if ( typeof index === 'undefined' ) {
+								// Get the last inserted
+								hash = History.savedHashes[History.savedHashes.length-1];
+							}
+							else if ( index < 0 ) {
+								// Get from the end
+								hash = History.savedHashes[History.savedHashes.length+index];
+							}
+							else {
+								// Get from the beginning
+								hash = History.savedHashes[index];
+							}
+
+							// Return hash
+							return hash;
+						};
+
+
+						// ====================================================================
+						// Discarded States
+
+						/**
+						 * History.discardedHashes
+						 * A hashed array of discarded hashes
+						 */
+						History.discardedHashes = {};
+
+						/**
+						 * History.discardedStates
+						 * A hashed array of discarded states
+						 */
+						History.discardedStates = {};
+
+						/**
+						 * History.discardState(State)
+						 * Discards the state by ignoring it through History
+						 * @param {object} State
+						 * @return {true}
+						 */
+						History.discardState = function(discardedState,forwardState,backState){
+							//History.debug('History.discardState', arguments);
+							// Prepare
+							var discardedStateHash = History.getHashByState(discardedState),
+								discardObject;
+
+							// Create Discard Object
+							discardObject = {
+								'discardedState': discardedState,
+								'backState': backState,
+								'forwardState': forwardState
+							};
+
+							// Add to DiscardedStates
+							History.discardedStates[discardedStateHash] = discardObject;
+
+							// Return true
+							return true;
+						};
+
+						/**
+						 * History.discardHash(hash)
+						 * Discards the hash by ignoring it through History
+						 * @param {string} hash
+						 * @return {true}
+						 */
+						History.discardHash = function(discardedHash,forwardState,backState){
+							//History.debug('History.discardState', arguments);
+							// Create Discard Object
+							var discardObject = {
+								'discardedHash': discardedHash,
+								'backState': backState,
+								'forwardState': forwardState
+							};
+
+							// Add to discardedHash
+							History.discardedHashes[discardedHash] = discardObject;
+
+							// Return true
+							return true;
+						};
+
+						/**
+						 * History.discardState(State)
+						 * Checks to see if the state is discarded
+						 * @param {object} State
+						 * @return {bool}
+						 */
+						History.discardedState = function(State){
+							// Prepare
+							var StateHash = History.getHashByState(State),
+								discarded;
+
+							// Check
+							discarded = History.discardedStates[StateHash]||false;
+
+							// Return true
+							return discarded;
+						};
+
+						/**
+						 * History.discardedHash(hash)
+						 * Checks to see if the state is discarded
+						 * @param {string} State
+						 * @return {bool}
+						 */
+						History.discardedHash = function(hash){
+							// Check
+							var discarded = History.discardedHashes[hash]||false;
+
+							// Return true
+							return discarded;
+						};
+
+						/**
+						 * History.recycleState(State)
+						 * Allows a discarded state to be used again
+						 * @param {object} data
+						 * @param {string} title
+						 * @param {string} url
+						 * @return {true}
+						 */
+						History.recycleState = function(State){
+							//History.debug('History.recycleState', arguments);
+							// Prepare
+							var StateHash = History.getHashByState(State);
+
+							// Remove from DiscardedStates
+							if ( History.discardedState(State) ) {
+								delete History.discardedStates[StateHash];
+							}
+
+							// Return true
+							return true;
+						};
+
+
+						// ====================================================================
+						// HTML4 HashChange Support
+
+						if ( History.emulated.hashChange ) {
+							/*
+							 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
+							 */
+
+							/**
+							 * History.hashChangeInit()
+							 * Init the HashChange Emulation
+							 */
+							History.hashChangeInit = function(){
+								// Define our Checker Function
+								History.checkerFunction = null;
+
+								// Define some variables that will help in our checker function
+								var lastDocumentHash = '',
+									iframeId, iframe,
+									lastIframeHash, checkerRunning;
+
+								// Handle depending on the browser
+								if ( History.isInternetExplorer() ) {
+									// IE6 and IE7
+									// We need to use an iframe to emulate the back and forward buttons
+
+									// Create iFrame
+									iframeId = 'historyjs-iframe';
+									iframe = document.createElement('iframe');
+
+									// Adjust iFarme
+									iframe.setAttribute('id', iframeId);
+									iframe.style.display = 'none';
+
+									// Append iFrame
+									document.body.appendChild(iframe);
+
+									// Create initial history entry
+									iframe.contentWindow.document.open();
+									iframe.contentWindow.document.close();
+
+									// Define some variables that will help in our checker function
+									lastIframeHash = '';
+									checkerRunning = false;
+
+									// Define the checker function
+									History.checkerFunction = function(){
+										// Check Running
+										if ( checkerRunning ) {
+											return false;
+										}
+
+										// Update Running
+										checkerRunning = true;
+
+										// Fetch
+										var documentHash = History.getHash()||'',
+											iframeHash = History.unescapeHash(iframe.contentWindow.document.location.hash)||'';
+
+										// The Document Hash has changed (application caused)
+										if ( documentHash !== lastDocumentHash ) {
+											// Equalise
+											lastDocumentHash = documentHash;
+
+											// Create a history entry in the iframe
+											if ( iframeHash !== documentHash ) {
+												//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);
+
+												// Equalise
+												lastIframeHash = iframeHash = documentHash;
+
+												// Create History Entry
+												iframe.contentWindow.document.open();
+												iframe.contentWindow.document.close();
+
+												// Update the iframe's hash
+												iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
+											}
+
+											// Trigger Hashchange Event
+											History.Adapter.trigger(window,'hashchange');
+										}
+
+										// The iFrame Hash has changed (back button caused)
+										else if ( iframeHash !== lastIframeHash ) {
+											//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);
+
+											// Equalise
+											lastIframeHash = iframeHash;
+
+											// Update the Hash
+											History.setHash(iframeHash,false);
+										}
+
+										// Reset Running
+										checkerRunning = false;
+
+										// Return true
+										return true;
+									};
+								}
+								else {
+									// We are not IE
+									// Firefox 1 or 2, Opera
+
+									// Define the checker function
+									History.checkerFunction = function(){
+										// Prepare
+										var documentHash = History.getHash();
+
+										// The Document Hash has changed (application caused)
+										if ( documentHash !== lastDocumentHash ) {
+											// Equalise
+											lastDocumentHash = documentHash;
+
+											// Trigger Hashchange Event
+											History.Adapter.trigger(window,'hashchange');
+										}
+
+										// Return true
+										return true;
+									};
+								}
+
+								// Apply the checker function
+								History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));
+
+								// Done
+								return true;
+							}; // History.hashChangeInit
+
+							// Bind hashChangeInit
+							History.Adapter.onDomLoad(History.hashChangeInit);
+
+						} // History.emulated.hashChange
+
+
+						// ====================================================================
+						// HTML5 State Support
+
+						// Non-Native pushState Implementation
+						if ( History.emulated.pushState ) {
+							/*
+							 * We must emulate the HTML5 State Management by using HTML4 HashChange
+							 */
+
+							/**
+							 * History.onHashChange(event)
+							 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
+							 */
+							History.onHashChange = function(event){
+								//History.debug('History.onHashChange', arguments);
+
+								// Prepare
+								var currentUrl = ((event && event.newURL) || document.location.href),
+									currentHash = History.getHashByUrl(currentUrl),
+									currentState = null,
+									currentStateHash = null,
+									currentStateHashExits = null,
+									discardObject;
+
+								// Check if we are the same state
+								if ( History.isLastHash(currentHash) ) {
+									// There has been no change (just the page's hash has finally propagated)
+									//History.debug('History.onHashChange: no change');
+									History.busy(false);
+									return false;
+								}
+
+								// Reset the double check
+								History.doubleCheckComplete();
+
+								// Store our location for use in detecting back/forward direction
+								History.saveHash(currentHash);
+
+								// Expand Hash
+								if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
+									//History.debug('History.onHashChange: traditional anchor', currentHash);
+									// Traditional Anchor Hash
+									History.Adapter.trigger(window,'anchorchange');
+									History.busy(false);
+									return false;
+								}
+
+								// Create State
+								currentState = History.extractState(History.getFullUrl(currentHash||document.location.href,false),true);
+
+								// Check if we are the same state
+								if ( History.isLastSavedState(currentState) ) {
+									//History.debug('History.onHashChange: no change');
+									// There has been no change (just the page's hash has finally propagated)
+									History.busy(false);
+									return false;
+								}
+
+								// Create the state Hash
+								currentStateHash = History.getHashByState(currentState);
+
+								// Check if we are DiscardedState
+								discardObject = History.discardedState(currentState);
+								if ( discardObject ) {
+									// Ignore this state as it has been discarded and go back to the state before it
+									if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
+										// We are going backwards
+										//History.debug('History.onHashChange: go backwards');
+										History.back(false);
+									} else {
+										// We are going forwards
+										//History.debug('History.onHashChange: go forwards');
+										History.forward(false);
+									}
+									return false;
+								}
+
+								// Push the new HTML5 State
+								//History.debug('History.onHashChange: success hashchange');
+								History.pushState(currentState.data,currentState.title,currentState.url,false);
+
+								// End onHashChange closure
+								return true;
+							};
+							History.Adapter.bind(window,'hashchange',History.onHashChange);
+
+							/**
+							 * History.pushState(data,title,url)
+							 * Add a new State to the history object, become it, and trigger onpopstate
+							 * We have to trigger for HTML4 compatibility
+							 * @param {object} data
+							 * @param {string} title
+							 * @param {string} url
+							 * @return {true}
+							 */
+							History.pushState = function(data,title,url,queue){
+								//History.debug('History.pushState: called', arguments);
+
+								// Check the State
+								if ( History.getHashByUrl(url) ) {
+									throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
+								}
+
+								// Handle Queueing
+								if ( queue !== false && History.busy() ) {
+									// Wait + Push to Queue
+									//History.debug('History.pushState: we must wait', arguments);
+									History.pushQueue({
+										scope: History,
+										callback: History.pushState,
+										args: arguments,
+										queue: queue
+									});
+									return false;
+								}
+
+								// Make Busy
+								History.busy(true);
+
+								// Fetch the State Object
+								var newState = History.createStateObject(data,title,url),
+									newStateHash = History.getHashByState(newState),
+									oldState = History.getState(false),
+									oldStateHash = History.getHashByState(oldState),
+									html4Hash = History.getHash();
+
+								// Store the newState
+								History.storeState(newState);
+								History.expectedStateId = newState.id;
+
+								// Recycle the State
+								History.recycleState(newState);
+
+								// Force update of the title
+								History.setTitle(newState);
+
+								// Check if we are the same State
+								if ( newStateHash === oldStateHash ) {
+									//History.debug('History.pushState: no change', newStateHash);
+									History.busy(false);
+									return false;
+								}
+
+								// Update HTML4 Hash
+								if ( newStateHash !== html4Hash && newStateHash !== History.getShortUrl(document.location.href) ) {
+									//History.debug('History.pushState: update hash', newStateHash, html4Hash);
+									History.setHash(newStateHash,false);
+									return false;
+								}
+
+								// Update HTML5 State
+								History.saveState(newState);
+
+								// Fire HTML5 Event
+								//History.debug('History.pushState: trigger popstate');
+								History.Adapter.trigger(window,'statechange');
+								History.busy(false);
+
+								// End pushState closure
+								return true;
+							};
+
+							/**
+							 * History.replaceState(data,title,url)
+							 * Replace the State and trigger onpopstate
+							 * We have to trigger for HTML4 compatibility
+							 * @param {object} data
+							 * @param {string} title
+							 * @param {string} url
+							 * @return {true}
+							 */
+							History.replaceState = function(data,title,url,queue){
+								//History.debug('History.replaceState: called', arguments);
+
+								// Check the State
+								if ( History.getHashByUrl(url) ) {
+									throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
+								}
+
+								// Handle Queueing
+								if ( queue !== false && History.busy() ) {
+									// Wait + Push to Queue
+									//History.debug('History.replaceState: we must wait', arguments);
+									History.pushQueue({
+										scope: History,
+										callback: History.replaceState,
+										args: arguments,
+										queue: queue
+									});
+									return false;
+								}
+
+								// Make Busy
+								History.busy(true);
+
+								// Fetch the State Objects
+								var newState        = History.createStateObject(data,title,url),
+									oldState        = History.getState(false),
+									previousState   = History.getStateByIndex(-2);
+
+								// Discard Old State
+								History.discardState(oldState,newState,previousState);
+
+								// Alias to PushState
+								History.pushState(newState.data,newState.title,newState.url,false);
+
+								// End replaceState closure
+								return true;
+							};
+
+						} // History.emulated.pushState
+
+
+
+						// ====================================================================
+						// Initialise
+
+						// Non-Native pushState Implementation
+						if ( History.emulated.pushState ) {
+							/**
+							 * Ensure initial state is handled correctly
+							 */
+							if ( History.getHash() && !History.emulated.hashChange ) {
+								History.Adapter.onDomLoad(function(){
+									History.Adapter.trigger(window,'hashchange');
+								});
+							}
+
+						} // History.emulated.pushState
+
+					}; // History.initHtml4
+
+					// Try and Initialise History
+					if ( typeof History.init !== 'undefined' ) {
+						History.init();
+					}
+
+				})(window);
+		/**
+		 * History.js Core
+		 * @author Benjamin Arthur Lupton <contact@balupton.com>
+		 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
+		 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
+		 */
+		
+		(function(window,undefined){
+			"use strict";
+		
+			// ========================================================================
+			// Initialise
+		
+			// Localise Globals
+			var
+				console = window.console||undefined, // Prevent a JSLint complain
+				document = window.document, // Make sure we are using the correct document
+				navigator = window.navigator, // Make sure we are using the correct navigator
+				sessionStorage = window.sessionStorage||false, // sessionStorage
+				setTimeout = window.setTimeout,
+				clearTimeout = window.clearTimeout,
+				setInterval = window.setInterval,
+				clearInterval = window.clearInterval,
+				JSON = window.JSON,
+				alert = window.alert,
+				History = window.History = window.History||{}, // Public History Object
+				history = window.history; // Old History Object
+		
+			// MooTools Compatibility
+			JSON.stringify = JSON.stringify||JSON.encode;
+			JSON.parse = JSON.parse||JSON.decode;
+		
+			// Check Existence
+			if ( typeof History.init !== 'undefined' ) {
+				throw new Error('History.js Core has already been loaded...');
+			}
+		
+			// Initialise History
+			History.init = function(){
+				// Check Load Status of Adapter
+				if ( typeof History.Adapter === 'undefined' ) {
+					return false;
+				}
+		
+				// Check Load Status of Core
+				if ( typeof History.initCore !== 'undefined' ) {
+					History.initCore();
+				}
+		
+				// Check Load Status of HTML4 Support
+				if ( typeof History.initHtml4 !== 'undefined' ) {
+					History.initHtml4();
+				}
+		
+				// Return true
+				return true;
+			};
+		
+		
+			// ========================================================================
+			// Initialise Core
+		
+			// Initialise Core
+			History.initCore = function(){
+				// Initialise
+				if ( typeof History.initCore.initialized !== 'undefined' ) {
+					// Already Loaded
+					return false;
+				}
+				else {
+					History.initCore.initialized = true;
+				}
+		
+		
+				// ====================================================================
+				// Options
+		
+				/**
+				 * History.options
+				 * Configurable options
+				 */
+				History.options = History.options||{};
+		
+				/**
+				 * History.options.hashChangeInterval
+				 * How long should the interval be before hashchange checks
+				 */
+				History.options.hashChangeInterval = History.options.hashChangeInterval || 100;
+		
+				/**
+				 * History.options.safariPollInterval
+				 * How long should the interval be before safari poll checks
+				 */
+				History.options.safariPollInterval = History.options.safariPollInterval || 500;
+		
+				/**
+				 * History.options.doubleCheckInterval
+				 * How long should the interval be before we perform a double check
+				 */
+				History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;
+		
+				/**
+				 * History.options.storeInterval
+				 * How long should we wait between store calls
+				 */
+				History.options.storeInterval = History.options.storeInterval || 1000;
+		
+				/**
+				 * History.options.busyDelay
+				 * How long should we wait between busy events
+				 */
+				History.options.busyDelay = History.options.busyDelay || 250;
+		
+				/**
+				 * History.options.debug
+				 * If true will enable debug messages to be logged
+				 */
+				History.options.debug = History.options.debug || false;
+		
+				/**
+				 * History.options.initialTitle
+				 * What is the title of the initial state
+				 */
+				History.options.initialTitle = History.options.initialTitle || document.title;
+		
+		
+				// ====================================================================
+				// Interval record
+		
+				/**
+				 * History.intervalList
+				 * List of intervals set, to be cleared when document is unloaded.
+				 */
+				History.intervalList = [];
+		
+				/**
+				 * History.clearAllIntervals
+				 * Clears all setInterval instances.
+				 */
+				History.clearAllIntervals = function(){
+					var i, il = History.intervalList;
+					if (typeof il !== "undefined" && il !== null) {
+						for (i = 0; i < il.length; i++) {
+							clearInterval(il[i]);
+						}
+						History.intervalList = null;
+					}
+				};
+		
+		
+				// ====================================================================
+				// Debug
+		
+				/**
+				 * History.debug(message,...)
+				 * Logs the passed arguments if debug enabled
+				 */
+				History.debug = function(){
+					if ( (History.options.debug||false) ) {
+						History.log.apply(History,arguments);
+					}
+				};
+		
+				/**
+				 * History.log(message,...)
+				 * Logs the passed arguments
+				 */
+				History.log = function(){
+					// Prepare
+					var
+						consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
+						textarea = document.getElementById('log'),
+						message,
+						i,n,
+						args,arg
+						;
+		
+					// Write to Console
+					if ( consoleExists ) {
+						args = Array.prototype.slice.call(arguments);
+						message = args.shift();
+						if ( typeof console.debug !== 'undefined' ) {
+							console.debug.apply(console,[message,args]);
+						}
+						else {
+							console.log.apply(console,[message,args]);
+						}
+					}
+					else {
+						message = ("\n"+arguments[0]+"\n");
+					}
+		
+					// Write to log
+					for ( i=1,n=arguments.length; i<n; ++i ) {
+						arg = arguments[i];
+						if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
+							try {
+								arg = JSON.stringify(arg);
+							}
+							catch ( Exception ) {
+								// Recursive Object
+							}
+						}
+						message += "\n"+arg+"\n";
+					}
+		
+					// Textarea
+					if ( textarea ) {
+						textarea.value += message+"\n-----\n";
+						textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
+					}
+					// No Textarea, No Console
+					else if ( !consoleExists ) {
+						alert(message);
+					}
+		
+					// Return true
+					return true;
+				};
+		
+		
+				// ====================================================================
+				// Emulated Status
+		
+				/**
+				 * History.getInternetExplorerMajorVersion()
+				 * Get's the major version of Internet Explorer
+				 * @return {integer}
+				 * @license Public Domain
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 * @author James Padolsey <https://gist.github.com/527683>
+				 */
+				History.getInternetExplorerMajorVersion = function(){
+					var result = History.getInternetExplorerMajorVersion.cached =
+							(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
+						?	History.getInternetExplorerMajorVersion.cached
+						:	(function(){
+								var v = 3,
+										div = document.createElement('div'),
+										all = div.getElementsByTagName('i');
+								while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
+								return (v > 4) ? v : false;
+							})()
+						;
+					return result;
+				};
+		
+				/**
+				 * History.isInternetExplorer()
+				 * Are we using Internet Explorer?
+				 * @return {boolean}
+				 * @license Public Domain
+				 * @author Benjamin Arthur Lupton <contact@balupton.com>
+				 */
+				History.isInternetExplorer = function(){
+					var result =
+						History.isInternetExplorer.cached =
+						(typeof History.isInternetExplorer.cached !== 'undefined')
+							?	History.isInternetExplorer.cached
+							:	Boolean(History.getInternetExplorerMajorVersion())
+						;
+					return result;
+				};
+		
+				/**
+				 * History.emulated
+				 * Which features require emulating?
+				 */
+				History.emulated = {
+					pushState: !Boolean(
+						window.history && window.history.pushState && window.history.replaceState
+						&& !(
+							(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
+							|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
+						)
+					),
+					hashChange: Boolean(
+						!(('onhashchange' in window) || ('onhashchange' in document))
+						||
+						(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
+					)
+				};
+		
+				/**
+				 * History.enabled
+				 * Is History enabled?
+				 */
+				History.enabled = !History.emulated.pushState;
+		
+				/**
+				 * History.bugs
+				 * Which bugs are present
+				 */
+				History.bugs = {
+					/**
+					 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
+					 * https://bugs.webkit.org/show_bug.cgi?id=56249
+					 */
+					setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),
+		
+					/**
+					 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
+					 * https://bugs.webkit.org/show_bug.cgi?id=42940
+					 */
+					safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),
+		
+					/**
+					 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
+					 */
+					ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),
+		
+					/**
+					 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
+					 */
+					hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
+				};
+		
+				/**
+				 * History.isEmptyObject(obj)
+				 * Checks to see if the Object is Empty
+				 * @param {Object} obj
+				 * @return {boolean}
+				 */
+				History.isEmptyObject = function(obj) {
+					for ( var name in obj ) {
+						return false;
+					}
+					return true;
+				};
+		
+				/**
+				 * History.cloneObject(obj)
+				 * Clones a object and eliminate all references to the original contexts
+				 * @param {Object} obj
+				 * @return {Object}
+				 */
+				History.cloneObject = function(obj) {
+					var hash,newObj;
+					if ( obj ) {
+						hash = JSON.stringify(obj);
+						newObj = JSON.parse(hash);
+					}
+					else {
+						newObj = {};
+					}
+					return newObj;
+				};
+		
+		
+				// ====================================================================
+				// URL Helpers
+		
+				/**
+				 * History.getRootUrl()
+				 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
+				 * @return {String} rootUrl
+				 */
+				History.getRootUrl = function(){
+					// Create
+					var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
+					if ( document.location.port||false ) {
+						rootUrl += ':'+document.location.port;
+					}
+					rootUrl += '/';
+		
+					// Return
+					return rootUrl;
+				};
+		
+				/**
+				 * History.getBaseHref()
+				 * Fetches the `href` attribute of the `<base href="...">` element if it exists
+				 * @return {String} baseHref
+				 */
+				History.getBaseHref = function(){
+					// Create
+					var
+						baseElements = document.getElementsByTagName('base'),
+						baseElement = null,
+						baseHref = '';
+		
+					// Test for Base Element
+					if ( baseElements.length === 1 ) {
+						// Prepare for Base Element
+						baseElement = baseElements[0];
+						baseHref = baseElement.href.replace(/[^\/]+$/,'');
+					}
+		
+					// Adjust trailing slash
+					baseHref = baseHref.replace(/\/+$/,'');
+					if ( baseHref ) baseHref += '/';
+		
+					// Return
+					return baseHref;
+				};
+		
+				/**
+				 * History.getBaseUrl()
+				 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
+				 * @return {String} baseUrl
+				 */
+				History.getBaseUrl = function(){
+					// Create
+					var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();
+		
+					// Return
+					return baseUrl;
+				};
+		
+				/**
+				 * History.getPageUrl()
+				 * Fetches the URL of the current page
+				 * @return {String} pageUrl
+				 */
+				History.getPageUrl = function(){
+					// Fetch
+					var
+						State = History.getState(false,false),
+						stateUrl = (State||{}).url||document.location.href,
+						pageUrl;
+		
+					// Create
+					pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
+						return (/\./).test(part) ? part : part+'/';
+					});
+		
+					// Return
+					return pageUrl;
+				};
+		
+				/**
+				 * History.getBasePageUrl()
+				 * Fetches the Url of the directory of the current page
+				 * @return {String} basePageUrl
+				 */
+				History.getBasePageUrl = function(){
+					// Create
+					var basePageUrl = document.location.href.replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
+						return (/[^\/]$/).test(part) ? '' : part;
+					}).replace(/\/+$/,'')+'/';
+		
+					// Return
+					return basePageUrl;
+				};
+		
+				/**
+				 * History.getFullUrl(url)
+				 * Ensures that we have an absolute URL and not a relative URL
+				 * @param {string} url
+				 * @param {Boolean} allowBaseHref
+				 * @return {string} fullUrl
+				 */
+				History.getFullUrl = function(url,allowBaseHref){
+					// Prepare
+					var fullUrl = url, firstChar = url.substring(0,1);
+					allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;
+		
+					// Check
+					if ( /[a-z]+\:\/\//.test(url) ) {
+						// Full URL
+					}
+					else if ( firstChar === '/' ) {
+						// Root URL
+						fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
+					}
+					else if ( firstChar === '#' ) {
+						// Anchor URL
+						fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
+					}
+					else if ( firstChar === '?' ) {
+						// Query URL
+						fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
+					}
+					else {
+						// Relative URL
+						if ( allowBaseHref ) {
+							fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
+						} else {
+							fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
+						}
+						// We have an if condition above as we do not want hashes
+						// which are relative to the baseHref in our URLs
+						// as if the baseHref changes, then all our bookmarks
+						// would now point to different locations
+						// whereas the basePageUrl will always stay the same
+					}
+		
+					// Return
+					return fullUrl.replace(/\#$/,'');
+				};
+		
+				/**
+				 * History.getShortUrl(url)
+				 * Ensures that we have a relative URL and not a absolute URL
+				 * @param {string} url
+				 * @return {string} url
+				 */
+				History.getShortUrl = function(url){
+					// Prepare
+					var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();
+		
+					// Trim baseUrl
+					if ( History.emulated.pushState ) {
+						// We are in a if statement as when pushState is not emulated
+						// The actual url these short urls are relative to can change
+						// So within the same session, we the url may end up somewhere different
+						shortUrl = shortUrl.replace(baseUrl,'');
+					}
+		
+					// Trim rootUrl
+					shortUrl = shortUrl.replace(rootUrl,'/');
+		
+					// Ensure we can still detect it as a state
+					if ( History.isTraditionalAnchor(shortUrl) ) {
+						shortUrl = './'+shortUrl;
+					}
+		
+					// Clean It
+					shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');
+		
+					// Return
+					return shortUrl;
+				};
+		
+		
+				// ====================================================================
+				// State Storage
+		
+				/**
+				 * History.store
+				 * The store for all session specific data
+				 */
+				History.store = {};
+		
+				/**
+				 * History.idToState
+				 * 1-1: State ID to State Object
+				 */
+				History.idToState = History.idToState||{};
+		
+				/**
+				 * History.stateToId
+				 * 1-1: State String to State ID
+				 */
+				History.stateToId = History.stateToId||{};
+		
+				/**
+				 * History.urlToId
+				 * 1-1: State URL to State ID
+				 */
+				History.urlToId = History.urlToId||{};
+		
+				/**
+				 * History.storedStates
+				 * Store the states in an array
+				 */
+				History.storedStates = History.storedStates||[];
+		
+				/**
+				 * History.savedStates
+				 * Saved the states in an array
+				 */
+				History.savedStates = History.savedStates||[];
+		
+				/**
+				 * History.noramlizeStore()
+				 * Noramlize the store by adding necessary values
+				 */
+				History.normalizeStore = function(){
+					History.store.idToState = History.store.idToState||{};
+					History.store.urlToId = History.store.urlToId||{};
+					History.store.stateToId = History.store.stateToId||{};
+				};
+		
+				/**
+				 * History.getState()
+				 * Get an object containing the data, title and url of the current state
+				 * @param {Boolean} friendly
+				 * @param {Boolean} create
+				 * @return {Object} State
+				 */
+				History.getState = function(friendly,create){
+					// Prepare
+					if ( typeof friendly === 'undefined' ) { friendly = true; }
+					if ( typeof create === 'undefined' ) { create = true; }
+		
+					// Fetch
+					var State = History.getLastSavedState();
+		
+					// Create
+					if ( !State && create ) {
+						State = History.createStateObject();
+					}
+		
+					// Adjust
+					if ( friendly ) {
+						State = History.cloneObject(State);
+						State.url = State.cleanUrl||State.url;
+					}
+		
+					// Return
+					return State;
+				};
+		
+				/**
+				 * History.getIdByState(State)
+				 * Gets a ID for a State
+				 * @param {State} newState
+				 * @return {String} id
+				 */
+				History.getIdByState = function(newState){
+		
+					// Fetch ID
+					var id = History.extractId(newState.url),
+						str;
+					
+					if ( !id ) {
+						// Find ID via State String
+						str = History.getStateString(newState);
+						if ( typeof History.stateToId[str] !== 'undefined' ) {
+							id = History.stateToId[str];
+						}
+						else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
+							id = History.store.stateToId[str];
+						}
+						else {
+							// Generate a new ID
+							while ( true ) {
+								id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
+								if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
+									break;
+								}
+							}
+		
+							// Apply the new State to the ID
+							History.stateToId[str] = id;
+							History.idToState[id] = newState;
+						}
+					}
+		
+					// Return ID
+					return id;
+				};
+		
+				/**
+				 * History.normalizeState(State)
+				 * Expands a State Object
+				 * @param {object} State
+				 * @return {object}
+				 */
+				History.normalizeState = function(oldState){
+					// Variables
+					var newState, dataNotEmpty;
+		
+					// Prepare
+					if ( !oldState || (typeof oldState !== 'object') ) {
+						oldState = {};
+					}
+		
+					// Check
+					if ( typeof oldState.normalized !== 'undefined' ) {
+						return oldState;
+					}
+		
+					// Adjust
+					if ( !oldState.data || (typeof oldState.data !== 'object') ) {
+						oldState.data = {};
+					}
+		
+					// ----------------------------------------------------------------
+		
+					// Create
+					newState = {};
+					newState.normalized = true;
+					newState.title = oldState.title||'';
+					newState.url = History.getFullUrl(History.unescapeString(oldState.url||document.location.href));
+					newState.hash = History.getShortUrl(newState.url);
+					newState.data = History.cloneObject(oldState.data);
+		
+					// Fetch ID
+					newState.id = History.getIdByState(newState);
+		
+					// ----------------------------------------------------------------
+		
+					// Clean the URL
+					newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
+					newState.url = newState.cleanUrl;
+		
+					// Check to see if we have more than just a url
+					dataNotEmpty = !History.isEmptyObject(newState.data);
+		
+					// Apply
+					if ( newState.title || dataNotEmpty ) {
+						// Add ID to Hash
+						newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
+						if ( !/\?/.test(newState.hash) ) {
+							newState.hash += '?';
+						}
+						newState.hash += '&_suid='+newState.id;
+					}
+		
+					// Create the Hashed URL
+					newState.hashedUrl = History.getFullUrl(newState.hash);
+		
+					// ----------------------------------------------------------------
+		
+					// Update the URL if we have a duplicate
+					if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
+						newState.url = newState.hashedUrl;
+					}
+		
+					// ----------------------------------------------------------------
+		
+					// Return
+					return newState;
+				};
+		
+				/**
+				 * History.createStateObject(data,title,url)
+				 * Creates a object based on the data, title and url state params
+				 * @param {object} data
+				 * @param {string} title
+				 * @param {string} url
+				 * @return {object}
+				 */
+				History.createStateObject = function(data,title,url){
+					// Hashify
+					var State = {
+						'data': data,
+						'title': title,
+						'url': url
+					};
+		
+					// Expand the State
+					State = History.normalizeState(State);
+		
+					// Return object
+					return State;
+				};
+		
+				/**
+				 * History.getStateById(id)
+				 * Get a state by it's UID
+				 * @param {String} id
+				 */
+				History.getStateById = function(id){
+					// Prepare
+					id = String(id);
+		
+					// Retrieve
+					var State = History.idToState[id] || History.store.idToState[id] || undefined;
+		
+					// Return State
+					return State;
+				};
+		
+				/**
+				 * Get a State's String
+				 * @param {State} passedState
+				 */
+				History.getStateString = function(passedState){
+					// Prepare
+					var State, cleanedState, str;
+		
+					// Fetch
+					State = History.normalizeState(passedState);
+		
+					// Clean
+					cleanedState = {
+						data: State.data,
+						title: passedState.title,
+						url: passedState.url
+					};
+		
+					// Fetch
+					str = JSON.stringify(cleanedState);
+		
+					// Return
+					return str;
+				};
+		
+				/**
+				 * Get a State's ID
+				 * @param {State} passedState
+				 * @return {String} id
+				 */
+				History.getStateId = function(passedState){
+					// Prepare
+					var State, id;
+					
+					// Fetch
+					State = History.normalizeState(passedState);
+		
+					// Fetch
+					id = State.id;
+		
+					// Return
+					return id;
+				};
+		
+				/**
+				 * History.getHashByState(State)
+				 * Creates a Hash for the State Object
+				 * @param {State} passedState
+				 * @return {String} hash
+				 */
+				History.getHashByState = function(passedState){
+					// Prepare
+					var State, hash;
+					
+					// Fetch
+					State = History.normalizeState(passedState);
+		
+					// Hash
+					hash = State.hash;
+		
+					// Return
+					return hash;
+				};
+		
+				/**
+				 * History.extractId(url_or_hash)
+				 * Get a State ID by it's URL or Hash
+				 * @param {string} url_or_hash
+				 * @return {string} id
+				 */
+				History.extractId = function ( url_or_hash ) {
+					// Prepare
+					var id,parts,url;
+		
+					// Extract
+					parts = /(.*)\&_suid=([0-9]+)$/.exec(url_or_hash);
+					url = parts ? (parts[1]||url_or_hash) : url_or_hash;
+					id = parts ? String(parts[2]||'') : '';
+		
+					// Return
+					return id||false;
+				};
+		
+				/**
+				 * History.isTraditionalAnchor
+				 * Checks to see if the url is a traditional anchor or not
+				 * @param {String} url_or_hash
+				 * @return {Boolean}
+				 */
+				History.isTraditionalAnchor = function(url_or_hash){
+					// Check
+					var isTraditional = !(/[\/\?\.]/.test(url_or_hash));
+		
+					// Return
+					return isTraditional;
+				};
+		
+				/**
+				 * History.extractState
+				 * Get a State by it's URL or Hash
+				 * @param {String} url_or_hash
+				 * @return {State|null}
+				 */
+				History.extractState = function(url_or_hash,create){
+					// Prepare
+					var State = null, id, url;
+					create = create||false;
+		
+					// Fetch SUID
+					id = History.extractId(url_or_hash);
+					if ( id ) {
+						State = History.getStateById(id);
+					}
+		
+					// Fetch SUID returned no State
+					if ( !State ) {
+						// Fetch URL
+						url = History.getFullUrl(url_or_hash);
+		
+						// Check URL
+						id = History.getIdByUrl(url)||false;
+						if ( id ) {
+							State = History.getStateById(id);
+						}
+		
+						// Create State
+						if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
+							State = History.createStateObject(null,null,url);
+						}
+					}
+		
+					// Return
+					return State;
+				};
+		
+				/**
+				 * History.getIdByUrl()
+				 * Get a State ID by a State URL
+				 */
+				History.getIdByUrl = function(url){
+					// Fetch
+					var id = History.urlToId[url] || History.store.urlToId[url] || undefined;
+		
+					// Return
+					return id;
+				};
+		
+				/**
+				 * History.getLastSavedState()
+				 * Get an object containing the data, title and url of the current state
+				 * @return {Object} State
+				 */
+				History.getLastSavedState = function(){
+					return History.savedStates[History.savedStates.length-1]||undefined;
+				};
+		
+				/**
+				 * History.getLastStoredState()
+				 * Get an object containing the data, title and url of the current state
+				 * @return {Object} State
+				 */
+				History.getLastStoredState = function(){
+					return History.storedStates[History.storedStates.length-1]||undefined;
+				};
+		
+				/**
+				 * History.hasUrlDuplicate
+				 * Checks if a Url will have a url conflict
+				 * @param {Object} newState
+				 * @return {Boolean} hasDuplicate
+				 */
+				History.hasUrlDuplicate = function(newState) {
+					// Prepare
+					var hasDuplicate = false,
+						oldState;
+		
+					// Fetch
+					oldState = History.extractState(newState.url);
+		
+					// Check
+					hasDuplicate = oldState && oldState.id !== newState.id;
+		
+					// Return
+					return hasDuplicate;
+				};
+		
+				/**
+				 * History.storeState
+				 * Store a State
+				 * @param {Object} newState
+				 * @return {Object} newState
+				 */
+				History.storeState = function(newState){
+					// Store the State
+					History.urlToId[newState.url] = newState.id;
+		
+					// Push the State
+					History.storedStates.push(History.cloneObject(newState));
+		
+					// Return newState
+					return newState;
+				};
+		
+				/**
+				 * History.isLastSavedState(newState)
+				 * Tests to see if the state is the last state
+				 * @param {Object} newState
+				 * @return {boolean} isLast
+				 */
+				History.isLastSavedState = function(newState){
+					// Prepare
+					var isLast = false,
+						newId, oldState, oldId;
+		
+					// Check
+					if ( History.savedStates.length ) {
+						newId = newState.id;
+						oldState = History.getLastSavedState();
+						oldId = oldState.id;
+		
+						// Check
+						isLast = (newId === oldId);
+					}
+		
+					// Return
+					return isLast;
+				};
+		
+				/**
+				 * History.saveState
+				 * Push a State
+				 * @param {Object} newState
+				 * @return {boolean} changed
+				 */
+				History.saveState = function(newState){
+					// Check Hash
+					if ( History.isLastSavedState(newState) ) {
+						return false;
+					}
+		
+					// Push the State
+					History.savedStates.push(History.cloneObject(newState));
+		
+					// Return true
+					return true;
+				};
+		
+				/**
+				 * History.getStateByIndex()
+				 * Gets a state by the index
+				 * @param {integer} index
+				 * @return {Object}
+				 */
+				History.getStateByIndex = function(index){
+					// Prepare
+					var State = null;
+		
+					// Handle
+					if ( typeof index === 'undefined' ) {
+						// Get the last inserted
+						State = History.savedStates[History.savedStates.length-1];
+					}
+					else if ( index < 0 ) {
+						// Get from the end
+						State = History.savedStates[History.savedStates.length+index];
+					}
+					else {
+						// Get from the beginning
+						State = History.savedStates[index];
+					}
+		
+					// Return State
+					return State;
+				};
+		
+		
+				// ====================================================================
+				// Hash Helpers
+		
+				/**
+				 * History.getHash()
+				 * Gets the current document hash
+				 * @return {string}
+				 */
+				History.getHash = function(){
+					var hash = History.unescapeHash(document.location.hash);
+					return hash;
+				};
+		
+				/**
+				 * History.unescapeString()
+				 * Unescape a string
+				 * @param {String} str
+				 * @return {string}
+				 */
+				History.unescapeString = function(str){
+					// Prepare
+					var result = str,
+						tmp;
+		
+					// Unescape hash
+					while ( true ) {
+						tmp = window.unescape(result);
+						if ( tmp === result ) {
+							break;
+						}
+						result = tmp;
+					}
+		
+					// Return result
+					return result;
+				};
+		
+				/**
+				 * History.unescapeHash()
+				 * normalize and Unescape a Hash
+				 * @param {String} hash
+				 * @return {string}
+				 */
+				History.unescapeHash = function(hash){
+					// Prepare
+					var result = History.normalizeHash(hash);
+		
+					// Unescape hash
+					result = History.unescapeString(result);
+		
+					// Return result
+					return result;
+				};
+		
+				/**
+				 * History.normalizeHash()
+				 * normalize a hash across browsers
+				 * @return {string}
+				 */
+				History.normalizeHash = function(hash){
+					// Prepare
+					var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');
+		
+					// Return result
+					return result;
+				};
+		
+				/**
+				 * History.setHash(hash)
+				 * Sets the document hash
+				 * @param {string} hash
+				 * @return {History}
+				 */
+				History.setHash = function(hash,queue){
+					// Prepare
+					var adjustedHash, State, pageUrl;
+		
+					// Handle Queueing
+					if ( queue !== false && History.busy() ) {
+						// Wait + Push to Queue
+						//History.debug('History.setHash: we must wait', arguments);
+						History.pushQueue({
+							scope: History,
+							callback: History.setHash,
+							args: arguments,
+							queue: queue
+						});
+						return false;
+					}
+		
+					// Log
+					//History.debug('History.setHash: called',hash);
+		
+					// Prepare
+					adjustedHash = History.escapeHash(hash);
+		
+					// Make Busy + Continue
+					History.busy(true);
+		
+					// Check if hash is a state
+					State = History.extractState(hash,true);
+					if ( State && !History.emulated.pushState ) {
+						// Hash is a state so skip the setHash
+						//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);
+		
+						// PushState
+						History.pushState(State.data,State.title,State.url,false);
+					}
+					else if ( document.location.hash !== adjustedHash ) {
+						// Hash is a proper hash, so apply it
+		
+						// Handle browser bugs
+						if ( History.bugs.setHash ) {
+							// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249
+		
+							// Fetch the base page
+							pageUrl = History.getPageUrl();
+		
+							// Safari hash apply
+							History.pushState(null,null,pageUrl+'#'+adjustedHash,false);
+						}
+						else {
+							// Normal hash apply
+							document.location.hash = adjustedHash;
+						}
+					}
+		
+					// Chain
+					return History;
+				};
+		
+				/**
+				 * History.escape()
+				 * normalize and Escape a Hash
+				 * @return {string}
+				 */
+				History.escapeHash = function(hash){
+					// Prepare
+					var result = History.normalizeHash(hash);
+		
+					// Escape hash
+					result = window.escape(result);
+		
+					// IE6 Escape Bug
+					if ( !History.bugs.hashEscape ) {
+						// Restore common parts
+						result = result
+							.replace(/\%21/g,'!')
+							.replace(/\%26/g,'&')
+							.replace(/\%3D/g,'=')
+							.replace(/\%3F/g,'?');
+					}
+		
+					// Return result
+					return result;
+				};
+		
+				/**
+				 * History.getHashByUrl(url)
+				 * Extracts the Hash from a URL
+				 * @param {string} url
+				 * @return {string} url
+				 */
+				History.getHashByUrl = function(url){
+					// Extract the hash
+					var hash = String(url)
+						.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
+						;
+		
+					// Unescape hash
+					hash = History.unescapeHash(hash);
+		
+					// Return hash
+					return hash;
+				};
+		
+				/**
+				 * History.setTitle(title)
+				 * Applies the title to the document
+				 * @param {State} newState
+				 * @return {Boolean}
+				 */
+				History.setTitle = function(newState){
+					// Prepare
+					var title = newState.title,
+						firstState;
+		
+					// Initial
+					if ( !title ) {
+						firstState = History.getStateByIndex(0);
+						if ( firstState && firstState.url === newState.url ) {
+							title = firstState.title||History.options.initialTitle;
+						}
+					}
+		
+					// Apply
+					try {
+						document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
+					}
+					catch ( Exception ) { }
+					document.title = title;
+		
+					// Chain
+					return History;
+				};
+		
+		
+				// ====================================================================
+				// Queueing
+		
+				/**
+				 * History.queues
+				 * The list of queues to use
+				 * First In, First Out
+				 */
+				History.queues = [];
+		
+				/**
+				 * History.busy(value)
+				 * @param {boolean} value [optional]
+				 * @return {boolean} busy
+				 */
+				History.busy = function(value){
+					// Apply
+					if ( typeof value !== 'undefined' ) {
+						//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
+						History.busy.flag = value;
+					}
+					// Default
+					else if ( typeof History.busy.flag === 'undefined' ) {
+						History.busy.flag = false;
+					}
+		
+					// Queue
+					if ( !History.busy.flag ) {
+						// Execute the next item in the queue
+						clearTimeout(History.busy.timeout);
+						var fireNext = function(){
+							var i, queue, item;
+							if ( History.busy.flag ) return;
+							for ( i=History.queues.length-1; i >= 0; --i ) {
+								queue = History.queues[i];
+								if ( queue.length === 0 ) continue;
+								item = queue.shift();
+								History.fireQueueItem(item);
+								History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
+							}
+						};
+						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
+					}
+		
+					// Return
+					return History.busy.flag;
+				};
+		
+				/**
+				 * History.busy.flag
+				 */
+				History.busy.flag = false;
+		
+				/**
+				 * History.fireQueueItem(item)
+				 * Fire a Queue Item
+				 * @param {Object} item
+				 * @return {Mixed} result
+				 */
+				History.fireQueueItem = function(item){
+					return item.callback.apply(item.scope||History,item.args||[]);
+				};
+		
+				/**
+				 * History.pushQueue(callback,args)
+				 * Add an item to the queue
+				 * @param {Object} item [scope,callback,args,queue]
+				 */
+				History.pushQueue = function(item){
+					// Prepare the queue
+					History.queues[item.queue||0] = History.queues[item.queue||0]||[];
+		
+					// Add to the queue
+					History.queues[item.queue||0].push(item);
+		
+					// Chain
+					return History;
+				};
+		
+				/**
+				 * History.queue (item,queue), (func,queue), (func), (item)
+				 * Either firs the item now if not busy, or adds it to the queue
+				 */
+				History.queue = function(item,queue){
+					// Prepare
+					if ( typeof item === 'function' ) {
+						item = {
+							callback: item
+						};
+					}
+					if ( typeof queue !== 'undefined' ) {
+						item.queue = queue;
+					}
+		
+					// Handle
+					if ( History.busy() ) {
+						History.pushQueue(item);
+					} else {
+						History.fireQueueItem(item);
+					}
+		
+					// Chain
+					return History;
+				};
+		
+				/**
+				 * History.clearQueue()
+				 * Clears the Queue
+				 */
+				History.clearQueue = function(){
+					History.busy.flag = false;
+					History.queues = [];
+					return History;
+				};
+		
+		
+				// ====================================================================
+				// IE Bug Fix
+		
+				/**
+				 * History.stateChanged
+				 * States whether or not the state has changed since the last double check was initialised
+				 */
+				History.stateChanged = false;
+		
+				/**
+				 * History.doubleChecker
+				 * Contains the timeout used for the double checks
+				 */
+				History.doubleChecker = false;
+		
+				/**
+				 * History.doubleCheckComplete()
+				 * Complete a double check
+				 * @return {History}
+				 */
+				History.doubleCheckComplete = function(){
+					// Update
+					History.stateChanged = true;
+		
+					// Clear
+					History.doubleCheckClear();
+		
+					// Chain
+					return History;
+				};
+		
+				/**
+				 * History.doubleCheckClear()
+				 * Clear a double check
+				 * @return {History}
+				 */
+				History.doubleCheckClear = function(){
+					// Clear
+					if ( History.doubleChecker ) {
+						clearTimeout(History.doubleChecker);
+						History.doubleChecker = false;
+					}
+		
+					// Chain
+					return History;
+				};
+		
+				/**
+				 * History.doubleCheck()
+				 * Create a double check
+				 * @return {History}
+				 */
+				History.doubleCheck = function(tryAgain){
+					// Reset
+					History.stateChanged = false;
+					History.doubleCheckClear();
+		
+					// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
+					// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
+					if ( History.bugs.ieDoubleCheck ) {
+						// Apply Check
+						History.doubleChecker = setTimeout(
+							function(){
+								History.doubleCheckClear();
+								if ( !History.stateChanged ) {
+									//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
+									// Re-Attempt
+									tryAgain();
+								}
+								return true;
+							},
+							History.options.doubleCheckInterval
+						);
+					}
+		
+					// Chain
+					return History;
+				};
+		
+		
+				// ====================================================================
+				// Safari Bug Fix
+		
+				/**
+				 * History.safariStatePoll()
+				 * Poll the current state
+				 * @return {History}
+				 */
+				History.safariStatePoll = function(){
+					// Poll the URL
+		
+					// Get the Last State which has the new URL
+					var
+						urlState = History.extractState(document.location.href),
+						newState;
+		
+					// Check for a difference
+					if ( !History.isLastSavedState(urlState) ) {
+						newState = urlState;
+					}
+					else {
+						return;
+					}
+		
+					// Check if we have a state with that url
+					// If not create it
+					if ( !newState ) {
+						//History.debug('History.safariStatePoll: new');
+						newState = History.createStateObject();
+					}
+		
+					// Apply the New State
+					//History.debug('History.safariStatePoll: trigger');
+					History.Adapter.trigger(window,'popstate');
+		
+					// Chain
+					return History;
+				};
+		
+		
+				// ====================================================================
+				// State Aliases
+		
+				/**
+				 * History.back(queue)
+				 * Send the browser history back one item
+				 * @param {Integer} queue [optional]
+				 */
+				History.back = function(queue){
+					//History.debug('History.back: called', arguments);
+		
+					// Handle Queueing
+					if ( queue !== false && History.busy() ) {
+						// Wait + Push to Queue
+						//History.debug('History.back: we must wait', arguments);
+						History.pushQueue({
+							scope: History,
+							callback: History.back,
+							args: arguments,
+							queue: queue
+						});
+						return false;
+					}
+		
+					// Make Busy + Continue
+					History.busy(true);
+		
+					// Fix certain browser bugs that prevent the state from changing
+					History.doubleCheck(function(){
+						History.back(false);
+					});
+		
+					// Go back
+					history.go(-1);
+		
+					// End back closure
+					return true;
+				};
+		
+				/**
+				 * History.forward(queue)
+				 * Send the browser history forward one item
+				 * @param {Integer} queue [optional]
+				 */
+				History.forward = function(queue){
+					//History.debug('History.forward: called', arguments);
+		
+					// Handle Queueing
+					if ( queue !== false && History.busy() ) {
+						// Wait + Push to Queue
+						//History.debug('History.forward: we must wait', arguments);
+						History.pushQueue({
+							scope: History,
+							callback: History.forward,
+							args: arguments,
+							queue: queue
+						});
+						return false;
+					}
+		
+					// Make Busy + Continue
+					History.busy(true);
+		
+					// Fix certain browser bugs that prevent the state from changing
+					History.doubleCheck(function(){
+						History.forward(false);
+					});
+		
+					// Go forward
+					history.go(1);
+		
+					// End forward closure
+					return true;
+				};
+		
+				/**
+				 * History.go(index,queue)
+				 * Send the browser history back or forward index times
+				 * @param {Integer} queue [optional]
+				 */
+				History.go = function(index,queue){
+					//History.debug('History.go: called', arguments);
+		
+					// Prepare
+					var i;
+		
+					// Handle
+					if ( index > 0 ) {
+						// Forward
+						for ( i=1; i<=index; ++i ) {
+							History.forward(queue);
+						}
+					}
+					else if ( index < 0 ) {
+						// Backward
+						for ( i=-1; i>=index; --i ) {
+							History.back(queue);
+						}
+					}
+					else {
+						throw new Error('History.go: History.go requires a positive or negative integer passed.');
+					}
+		
+					// Chain
+					return History;
+				};
+		
+		
+				// ====================================================================
+				// HTML5 State Support
+		
+				// Non-Native pushState Implementation
+				if ( History.emulated.pushState ) {
+					/*
+					 * Provide Skeleton for HTML4 Browsers
+					 */
+		
+					// Prepare
+					var emptyFunction = function(){};
+					History.pushState = History.pushState||emptyFunction;
+					History.replaceState = History.replaceState||emptyFunction;
+				} // History.emulated.pushState
+		
+				// Native pushState Implementation
+				else {
+					/*
+					 * Use native HTML5 History API Implementation
+					 */
+		
+					/**
+					 * History.onPopState(event,extra)
+					 * Refresh the Current State
+					 */
+					History.onPopState = function(event,extra){
+						// Prepare
+						var stateId = false, newState = false, currentHash, currentState;
+		
+						// Reset the double check
+						History.doubleCheckComplete();
+		
+						// Check for a Hash, and handle apporiatly
+						currentHash	= History.getHash();
+						if ( currentHash ) {
+							// Expand Hash
+							currentState = History.extractState(currentHash||document.location.href,true);
+							if ( currentState ) {
+								// We were able to parse it, it must be a State!
+								// Let's forward to replaceState
+								//History.debug('History.onPopState: state anchor', currentHash, currentState);
+								History.replaceState(currentState.data, currentState.title, currentState.url, false);
+							}
+							else {
+								// Traditional Anchor
+								//History.debug('History.onPopState: traditional anchor', currentHash);
+								History.Adapter.trigger(window,'anchorchange');
+								History.busy(false);
+							}
+		
+							// We don't care for hashes
+							History.expectedStateId = false;
+							return false;
+						}
+		
+						// Ensure
+						stateId = History.Adapter.extractEventData('state',event,extra) || false;
+		
+						// Fetch State
+						if ( stateId ) {
+							// Vanilla: Back/forward button was used
+							newState = History.getStateById(stateId);
+						}
+						else if ( History.expectedStateId ) {
+							// Vanilla: A new state was pushed, and popstate was called manually
+							newState = History.getStateById(History.expectedStateId);
+						}
+						else {
+							// Initial State
+							newState = History.extractState(document.location.href);
+						}
+		
+						// The State did not exist in our store
+						if ( !newState ) {
+							// Regenerate the State
+							newState = History.createStateObject(null,null,document.location.href);
+						}
+		
+						// Clean
+						History.expectedStateId = false;
+		
+						// Check if we are the same state
+						if ( History.isLastSavedState(newState) ) {
+							// There has been no change (just the page's hash has finally propagated)
+							//History.debug('History.onPopState: no change', newState, History.savedStates);
+							History.busy(false);
+							return false;
+						}
+		
+						// Store the State
+						History.storeState(newState);
+						History.saveState(newState);
+		
+						// Force update of the title
+						History.setTitle(newState);
+		
+						// Fire Our Event
+						History.Adapter.trigger(window,'statechange');
+						History.busy(false);
+		
+						// Return true
+						return true;
+					};
+					History.Adapter.bind(window,'popstate',History.onPopState);
+		
+					/**
+					 * History.pushState(data,title,url)
+					 * Add a new State to the history object, become it, and trigger onpopstate
+					 * We have to trigger for HTML4 compatibility
+					 * @param {object} data
+					 * @param {string} title
+					 * @param {string} url
+					 * @return {true}
+					 */
+					History.pushState = function(data,title,url,queue){
+						//History.debug('History.pushState: called', arguments);
+		
+						// Check the State
+						if ( History.getHashByUrl(url) && History.emulated.pushState ) {
+							throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
+						}
+		
+						// Handle Queueing
+						if ( queue !== false && History.busy() ) {
+							// Wait + Push to Queue
+							//History.debug('History.pushState: we must wait', arguments);
+							History.pushQueue({
+								scope: History,
+								callback: History.pushState,
+								args: arguments,
+								queue: queue
+							});
+							return false;
+						}
+		
+						// Make Busy + Continue
+						History.busy(true);
+		
+						// Create the newState
+						var newState = History.createStateObject(data,title,url);
+		
+						// Check it
+						if ( History.isLastSavedState(newState) ) {
+							// Won't be a change
+							History.busy(false);
+						}
+						else {
+							// Store the newState
+							History.storeState(newState);
+							History.expectedStateId = newState.id;
+		
+							// Push the newState
+							history.pushState(newState.id,newState.title,newState.url);
+		
+							// Fire HTML5 Event
+							History.Adapter.trigger(window,'popstate');
+						}
+		
+						// End pushState closure
+						return true;
+					};
+		
+					/**
+					 * History.replaceState(data,title,url)
+					 * Replace the State and trigger onpopstate
+					 * We have to trigger for HTML4 compatibility
+					 * @param {object} data
+					 * @param {string} title
+					 * @param {string} url
+					 * @return {true}
+					 */
+					History.replaceState = function(data,title,url,queue){
+						//History.debug('History.replaceState: called', arguments);
+		
+						// Check the State
+						if ( History.getHashByUrl(url) && History.emulated.pushState ) {
+							throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
+						}
+		
+						// Handle Queueing
+						if ( queue !== false && History.busy() ) {
+							// Wait + Push to Queue
+							//History.debug('History.replaceState: we must wait', arguments);
+							History.pushQueue({
+								scope: History,
+								callback: History.replaceState,
+								args: arguments,
+								queue: queue
+							});
+							return false;
+						}
+		
+						// Make Busy + Continue
+						History.busy(true);
+		
+						// Create the newState
+						var newState = History.createStateObject(data,title,url);
+		
+						// Check it
+						if ( History.isLastSavedState(newState) ) {
+							// Won't be a change
+							History.busy(false);
+						}
+						else {
+							// Store the newState
+							History.storeState(newState);
+							History.expectedStateId = newState.id;
+		
+							// Push the newState
+							history.replaceState(newState.id,newState.title,newState.url);
+		
+							// Fire HTML5 Event
+							History.Adapter.trigger(window,'popstate');
+						}
+		
+						// End replaceState closure
+						return true;
+					};
+		
+				} // !History.emulated.pushState
+		
+		
+				// ====================================================================
+				// Initialise
+		
+				/**
+				 * Load the Store
+				 */
+				if ( sessionStorage ) {
+					// Fetch
+					try {
+						History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
+					}
+					catch ( err ) {
+						History.store = {};
+					}
+		
+					// Normalize
+					History.normalizeStore();
+				}
+				else {
+					// Default Load
+					History.store = {};
+					History.normalizeStore();
+				}
+		
+				/**
+				 * Clear Intervals on exit to prevent memory leaks
+				 */
+				History.Adapter.bind(window,"beforeunload",History.clearAllIntervals);
+				History.Adapter.bind(window,"unload",History.clearAllIntervals);
+		
+				/**
+				 * Create the initial State
+				 */
+				History.saveState(History.storeState(History.extractState(document.location.href,true)));
+		
+				/**
+				 * Bind for Saving Store
+				 */
+				if ( sessionStorage ) {
+					// When the page is closed
+					History.onUnload = function(){
+						// Prepare
+						var	currentStore, item;
+		
+						// Fetch
+						try {
+							currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
+						}
+						catch ( err ) {
+							currentStore = {};
+						}
+		
+						// Ensure
+						currentStore.idToState = currentStore.idToState || {};
+						currentStore.urlToId = currentStore.urlToId || {};
+						currentStore.stateToId = currentStore.stateToId || {};
+		
+						// Sync
+						for ( item in History.idToState ) {
+							if ( !History.idToState.hasOwnProperty(item) ) {
+								continue;
+							}
+							currentStore.idToState[item] = History.idToState[item];
+						}
+						for ( item in History.urlToId ) {
+							if ( !History.urlToId.hasOwnProperty(item) ) {
+								continue;
+							}
+							currentStore.urlToId[item] = History.urlToId[item];
+						}
+						for ( item in History.stateToId ) {
+							if ( !History.stateToId.hasOwnProperty(item) ) {
+								continue;
+							}
+							currentStore.stateToId[item] = History.stateToId[item];
+						}
+		
+						// Update
+						History.store = currentStore;
+						History.normalizeStore();
+		
+						// Store
+						sessionStorage.setItem('History.store',JSON.stringify(currentStore));
+					};
+		
+					// For Internet Explorer
+					History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));
+					
+					// For Other Browsers
+					History.Adapter.bind(window,'beforeunload',History.onUnload);
+					History.Adapter.bind(window,'unload',History.onUnload);
+					
+					// Both are enabled for consistency
+				}
+		
+				// Non-Native pushState Implementation
+				if ( !History.emulated.pushState ) {
+					// Be aware, the following is only for native pushState implementations
+					// If you are wanting to include something for all browsers
+					// Then include it above this if block
+		
+					/**
+					 * Setup Safari Fix
+					 */
+					if ( History.bugs.safariPoll ) {
+						History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
+					}
+		
+					/**
+					 * Ensure Cross Browser Compatibility
+					 */
+					if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
+						/**
+						 * Fix Safari HashChange Issue
+						 */
+		
+						// Setup Alias
+						History.Adapter.bind(window,'hashchange',function(){
+							History.Adapter.trigger(window,'popstate');
+						});
+		
+						// Initialise Alias
+						if ( History.getHash() ) {
+							History.Adapter.onDomLoad(function(){
+								History.Adapter.trigger(window,'hashchange');
+							});
+						}
+					}
+		
+				} // !History.emulated.pushState
+		
+		
+			}; // History.initCore
+		
+			// Try and Initialise History
+						History.init();
+		
+					})(window);
+			} catch (e) {
+				// already installed.
+				
+			}
+			
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.bg.js b/public/js_src/external_libs/locales/bootstrap-datepicker.bg.js
new file mode 100644
index 0000000..5efe48c
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.bg.js
@@ -0,0 +1,14 @@
+/**
+ * Bulgarian translation for bootstrap-datepicker
+ * Apostol Apostolov <apostol.s.apostolov@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['bg'] = {
+		days: ["", "", "", "", "", "", "", ""],
+		daysShort: ["", "", "", "", "", "", "", ""],
+		daysMin: ["", "", "", "", "", "", "", ""],
+		months: ["", "", "", "", "", "", "", "", "", "", "", ""],
+		monthsShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
+		today: ""
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.br.js b/public/js_src/external_libs/locales/bootstrap-datepicker.br.js
new file mode 100644
index 0000000..fe32457
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.br.js
@@ -0,0 +1,13 @@
+/**
+ * Brazilian translation for bootstrap-datepicker
+ * Cauan Cabral <cauan@radig.com.br>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['br'] = {
+		days: ["Domingo", "Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado", "Domingo"],
+		daysShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb", "Dom"],
+		daysMin: ["Do", "Se", "Te", "Qu", "Qu", "Se", "Sa", "Do"],
+		months: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
+		monthsShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.cs.js b/public/js_src/external_libs/locales/bootstrap-datepicker.cs.js
new file mode 100644
index 0000000..d59a922
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.cs.js
@@ -0,0 +1,14 @@
+/**
+ * Czech translation for bootstrap-datepicker
+ * Matj Koubk <matej@koubik.name>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['cs'] = {
+		days: ["Nedle", "Pondl", "ter", "Steda", "tvrtek", "Ptek", "Sobota", "Nedle"],
+		daysShort: ["Ne", "Po", "t", "St", "t", "P", "So", "Ne"],
+		daysMin: ["N", "P", "", "St", "", "P", "So", "N"],
+		months: ["Leden", "nor", "Bezen", "Duben", "Kvten", "erven", "ervenec", "Srpen", "Z", "jen", "Listopad", "Prosinec"],
+		monthsShort: ["Led", "no", "Be", "Dub", "Kv", "er", "nc", "Srp", "Z", "j", "Lis", "Pro"],
+		today: "Dnes"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.da.js b/public/js_src/external_libs/locales/bootstrap-datepicker.da.js
new file mode 100644
index 0000000..4b53868
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.da.js
@@ -0,0 +1,14 @@
+/**
+ * Danish translation for bootstrap-datepicker
+ * Christian Pedersen <http://github.com/chripede>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['da'] = {
+		days: ["Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag", "Sndag"],
+		daysShort: ["Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr", "Sn"],
+		daysMin: ["S", "Ma", "Ti", "On", "To", "Fr", "L", "S"],
+		months: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"],
+		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
+		today: "I Dag"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.de.js b/public/js_src/external_libs/locales/bootstrap-datepicker.de.js
new file mode 100644
index 0000000..cec746f
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.de.js
@@ -0,0 +1,14 @@
+/**
+ * German translation for bootstrap-datepicker
+ * Sam Zurcher <sam@orelias.ch>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['de'] = {
+		days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag"],
+		daysShort: ["Son", "Mon", "Die", "Mit", "Don", "Fre", "Sam", "Son"],
+		daysMin: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"],
+		months: ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
+		monthsShort: ["Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
+		today: "Heute"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.es.js b/public/js_src/external_libs/locales/bootstrap-datepicker.es.js
new file mode 100644
index 0000000..03601b1
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.es.js
@@ -0,0 +1,14 @@
+/**
+ * Spanish translation for bootstrap-datepicker
+ * Bruno Bonamin <bruno.bonamin@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['es'] = {
+		days: ["Domingo", "Lunes", "Martes", "Mircoles", "Jueves", "Viernes", "Sbado", "Domingo"],
+		daysShort: ["Dom", "Lun", "Mar", "Mi", "Jue", "Vie", "Sb", "Dom"],
+		daysMin: ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa", "Do"],
+		months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
+		monthsShort: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
+		today: "Hoy"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.fi.js b/public/js_src/external_libs/locales/bootstrap-datepicker.fi.js
new file mode 100644
index 0000000..1bf7445
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.fi.js
@@ -0,0 +1,14 @@
+/**
+ * Finnish translation for bootstrap-datepicker
+ * Jaakko Salonen <https://github.com/jsalonen>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['fi'] = {
+		days: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai", "sunnuntai"],
+		daysShort: ["sun", "maa", "tii", "kes", "tor", "per", "lau", "sun"],
+		daysMin: ["su", "ma", "ti", "ke", "to", "pe", "la", "su"],
+		months: ["tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "keskuu", "heinkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu"],
+		monthsShort: ["tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mar", "jou"],
+		today: "tnn"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.fr.js b/public/js_src/external_libs/locales/bootstrap-datepicker.fr.js
new file mode 100644
index 0000000..6d32f1a
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.fr.js
@@ -0,0 +1,14 @@
+/**
+ * French translation for bootstrap-datepicker
+ * Nico Mollet <nico.mollet@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['fr'] = {
+		days: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"],
+		daysShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"],
+		daysMin: ["D", "L", "Ma", "Me", "J", "V", "S", "D"],
+		months: ["Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre"],
+		monthsShort: ["Jan", "Fev", "Mar", "Avr", "Mai", "Jui", "Jul", "Aou", "Sep", "Oct", "Nov", "Dec"],
+		today: "Aujourd'hui"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.id.js b/public/js_src/external_libs/locales/bootstrap-datepicker.id.js
new file mode 100644
index 0000000..39256ca
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.id.js
@@ -0,0 +1,13 @@
+/**
+ * Bahasa translation for bootstrap-datepicker
+ * Azwar Akbar <azwar.akbar@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['id'] = {
+		days: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu", "Minggu"],
+		daysShort: ["Mgu", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab", "Mgu"],
+		daysMin: ["Mg", "Sn", "Sl", "Ra", "Ka", "Ju", "Sa", "Mg"],
+		months: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"],
+		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Ags", "Sep", "Okt", "Nov", "Des"]
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.is.js b/public/js_src/external_libs/locales/bootstrap-datepicker.is.js
new file mode 100644
index 0000000..bf12d97
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.is.js
@@ -0,0 +1,14 @@
+/**
+ * Icelandic translation for bootstrap-datepicker
+ * Hinrik rn Sigursson <hinrik.sig@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['is'] = {
+		days: ["Sunnudagur", "Mnudagur", "rijudagur", "Mivikudagur", "Fimmtudagur", "Fstudagur", "Laugardagur", "Sunnudagur"],
+		daysShort: ["Sun", "Mn", "ri", "Mi", "Fim", "Fs", "Lau", "Sun"],
+		daysMin: ["Su", "M", "r", "Mi", "Fi", "F", "La", "Su"],
+		months: ["Janar", "Febrar", "Mars", "Aprl", "Ma", "Jn", "Jl", "gst", "September", "Oktber", "Nvember", "Desember"],
+		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Ma", "Jn", "Jl", "g", "Sep", "Okt", "Nv", "Des"],
+		today: " Dag"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.it.js b/public/js_src/external_libs/locales/bootstrap-datepicker.it.js
new file mode 100644
index 0000000..388f68d
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.it.js
@@ -0,0 +1,14 @@
+/**
+ * Italian translation for bootstrap-datepicker
+ * Enrico Rubboli <rubboli@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['it'] = {
+		days: ["Domenica", "Lunedi", "Martedi", "Mercoledi", "Giovedi", "Venerdi", "Sabato", "Domenica"],
+		daysShort: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"],
+		daysMin: ["Do", "Lu", "Ma", "Me", "Gi", "Ve", "Sa", "Do"],
+		months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
+		monthsShort: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
+		today: "Oggi"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.ja.js b/public/js_src/external_libs/locales/bootstrap-datepicker.ja.js
new file mode 100644
index 0000000..3c73ca0
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.ja.js
@@ -0,0 +1,13 @@
+/**
+ * Japanese translation for bootstrap-datepicker
+ * Norio Suzuki <https://github.com/suzuki/>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['ja'] = {
+		days: ["", "", "", "", "", "", "", ""],
+		daysShort: ["", "", "", "", "", "", "", ""],
+		daysMin: ["", "", "", "", "", "", "", ""],
+		months: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
+		monthsShort: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.kr.js b/public/js_src/external_libs/locales/bootstrap-datepicker.kr.js
new file mode 100644
index 0000000..875a761
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.kr.js
@@ -0,0 +1,13 @@
+/**
+ * Korean translation for bootstrap-datepicker
+ * Gu Youn <http://github.com/guyoun>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['kr'] = {
+		days: ["", "", "", "", "", "", "", ""],
+		daysShort: ["", "", "", "", "", "", "", ""],
+		daysMin: ["", "", "", "", "", "", "", ""],
+		months: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
+		monthsShort: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.lt.js b/public/js_src/external_libs/locales/bootstrap-datepicker.lt.js
new file mode 100644
index 0000000..343f774
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.lt.js
@@ -0,0 +1,15 @@
+/**
+ * Lithuanian translation for bootstrap-datepicker
+ * arnas Gliebus <ssharunas@yahoo.co.uk>
+ */
+
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['lt'] = {
+        days: ["Sekmadienis", "Pirmadienis", "Antradienis", "Treiadienis", "Ketvirtadienis", "Penktadienis", "etadienis", "Sekmadienis"],
+        daysShort: ["S", "Pr", "A", "T", "K", "Pn", "", "S"],
+        daysMin: ["Sk", "Pr", "An", "Tr", "Ke", "Pn", "t", "Sk"],
+        months: ["Sausis", "Vasaris", "Kovas", "Balandis", "Gegu", "Birelis", "Liepa", "Rugpjtis", "Rugsjis", "Spalis", "Lapkritis", "Gruodis"],
+        monthsShort: ["Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rugp", "Rugs", "Spa", "Lap", "Gru"],
+        weekStart: 1
+    		} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.lv.js b/public/js_src/external_libs/locales/bootstrap-datepicker.lv.js
new file mode 100644
index 0000000..3000f2a
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.lv.js
@@ -0,0 +1,16 @@
+/**
+ * Latvian translation for bootstrap-datepicker
+ * Artis Avotins <artis@apit.lv>
+ */
+
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['lv'] = {
+        days: ["Svtdiena", "Pirmdiena", "Otrdiena", "Trediena", "Ceturtdiena", "Piektdiena", "Sestdiena", "Svtdiena"],
+        daysShort: ["Sv", "P", "O", "T", "C", "Pk", "S", "Sv"],
+        daysMin: ["Sv", "Pr", "Ot", "Tr", "Ce", "Pk", "St", "Sv"],
+        months: ["Janvris", "Februris", "Marts", "Aprlis", "Maijs", "Jnijs", "Jlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"],
+        monthsShort: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec."],
+        today: "odien",
+        weekStart: 1
+    		} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.ms.js b/public/js_src/external_libs/locales/bootstrap-datepicker.ms.js
new file mode 100644
index 0000000..b5ef312
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.ms.js
@@ -0,0 +1,14 @@
+/**
+ * Malay translation for bootstrap-datepicker
+ * Ateman Faiz <noorulfaiz@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['ms'] = {
+		days: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu", "Ahad"],
+		daysShort: ["Aha", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab", "Aha"],
+		daysMin: ["Ah", "Is", "Se", "Ra", "Kh", "Ju", "Sa", "Ah"],
+		months: ["Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember"],
+		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Ogo", "Sep", "Okt", "Nov", "Dis"],
+		today: "Hari Ini"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.nb.js b/public/js_src/external_libs/locales/bootstrap-datepicker.nb.js
new file mode 100644
index 0000000..1a08205
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.nb.js
@@ -0,0 +1,14 @@
+/**
+ * Norwegian (bokml) translation for bootstrap-datepicker
+ * Fredrik Sundmyhr <http://github.com/fsundmyhr>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['nb'] = {
+		days: ["Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag", "Sndag"],
+		daysShort: ["Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr", "Sn"],
+		daysMin: ["S", "Ma", "Ti", "On", "To", "Fr", "L", "S"],
+		months: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
+		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
+		today: "I Dag"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.nl.js b/public/js_src/external_libs/locales/bootstrap-datepicker.nl.js
new file mode 100644
index 0000000..d2641a2
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.nl.js
@@ -0,0 +1,14 @@
+/**
+ * Dutch translation for bootstrap-datepicker
+ * Reinier Goltstein <mrgoltstein@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['nl'] = {
+		days: ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag", "Zondag"],
+		daysShort: ["Zo", "Ma", "Di", "Wo", "Do", "Vr", "Za", "Zo"],
+		daysMin: ["Zo", "Ma", "Di", "Wo", "Do", "Vr", "Za", "Zo"],
+		months: ["Januari", "Februari", "Maart", "April", "Mei", "Juni", "Juli", "Augustus", "September", "Oktober", "November", "December"],
+		monthsShort: ["Jan", "Feb", "Mrt", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
+		today: "Vandaag"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.pl.js b/public/js_src/external_libs/locales/bootstrap-datepicker.pl.js
new file mode 100644
index 0000000..96ce0f5
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.pl.js
@@ -0,0 +1,14 @@
+/**
+ * Polish translation for bootstrap-datepicker
+ * Robert <rtpm@gazeta.pl>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['pl'] = {
+                days: ["Niedziela", "Poniedziaek", "Wtorek", "roda", "Czwartek", "Pitek", "Sobota", "Niedziela"],
+                daysShort: ["Nie", "Pn", "Wt", "r", "Czw", "Pt", "So", "Nie"],
+                daysMin: ["N", "Pn", "Wt", "r", "Cz", "Pt", "So", "N"],
+                months: ["Stycze", "Luty", "Marzec", "Kwiecie", "Maj", "Czerwiec", "Lipiec", "Sierpie", "Wrzesie", "Padziernik", "Listopad", "Grudzie"],
+                monthsShort: ["Sty", "Lu", "Mar", "Kw", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa", "Lis", "Gru"],
+                today: "Dzisiaj"
+        		} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.pt-BR.js b/public/js_src/external_libs/locales/bootstrap-datepicker.pt-BR.js
new file mode 100644
index 0000000..b5b9558
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.pt-BR.js
@@ -0,0 +1,14 @@
+/**
+ * Brazilian translation for bootstrap-datepicker
+ * Cauan Cabral <cauan@radig.com.br>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['pt-BR'] = {
+		days: ["Domingo", "Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado", "Domingo"],
+		daysShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb", "Dom"],
+		daysMin: ["Do", "Se", "Te", "Qu", "Qu", "Se", "Sa", "Do"],
+		months: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
+		monthsShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
+		today: "Hoje"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.pt.js b/public/js_src/external_libs/locales/bootstrap-datepicker.pt.js
new file mode 100644
index 0000000..5898324
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.pt.js
@@ -0,0 +1,14 @@
+/**
+ * Portuguese translation for bootstrap-datepicker
+ * Original code: Cauan Cabral <cauan@radig.com.br>
+ * Tiago Melo <tiago.blackcode@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['pt'] = {
+		days: ["Domingo", "Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado", "Domingo"],
+		daysShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb", "Dom"],
+		daysMin: ["Do", "Se", "Te", "Qu", "Qu", "Se", "Sa", "Do"],
+		months: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
+		monthsShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.ru.js b/public/js_src/external_libs/locales/bootstrap-datepicker.ru.js
new file mode 100644
index 0000000..d77ca50
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.ru.js
@@ -0,0 +1,14 @@
+/**
+ * Russian translation for bootstrap-datepicker
+ * Victor Taranenko <darwin@snowdale.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['ru'] = {
+		days: ["", "", "", "", "", "", "", ""],
+		daysShort: ["", "", "", "", "", "", "", ""],
+		daysMin: ["", "", "", "", "", "", "", ""],
+		months: ["", "", "", "", "", "", "", "", "", "", "", ""],
+		monthsShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
+		today: ""
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.sl.js b/public/js_src/external_libs/locales/bootstrap-datepicker.sl.js
new file mode 100644
index 0000000..b72b052
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.sl.js
@@ -0,0 +1,14 @@
+/**
+ * Slovene translation for bootstrap-datepicker
+ * Gregor Rudolf <gregor.rudolf@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['sl'] = {
+		days: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "etrtek", "Petek", "Sobota", "Nedelja"],
+		daysShort: ["Ned", "Pon", "Tor", "Sre", "et", "Pet", "Sob", "Ned"],
+		daysMin: ["Ne", "Po", "To", "Sr", "e", "Pe", "So", "Ne"],
+		months: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"],
+		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
+		today: "Danes"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.sv.js b/public/js_src/external_libs/locales/bootstrap-datepicker.sv.js
new file mode 100644
index 0000000..b2371f0
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.sv.js
@@ -0,0 +1,14 @@
+/**
+ * Swedish translation for bootstrap-datepicker
+ * Patrik Ragnarsson <patrik@starkast.net>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['sv'] = {
+		days: ["Sndag", "Mndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lrdag", "Sndag"],
+		daysShort: ["Sn", "Mn", "Tis", "Ons", "Tor", "Fre", "Lr", "Sn"],
+		daysMin: ["S", "M", "Ti", "On", "To", "Fr", "L", "S"],
+		months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
+		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
+		today: "I Dag"
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.th.js b/public/js_src/external_libs/locales/bootstrap-datepicker.th.js
new file mode 100644
index 0000000..8930362
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.th.js
@@ -0,0 +1,14 @@
+/**
+ * Thai translation for bootstrap-datepicker
+ * Suchau Jiraprapot <seroz24@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['th'] = {
+		days: ["", "", "", "", "", "", "", ""],
+		daysShort: ["", "", "", "", "", "", "", ""],
+		daysMin: ["", "", "", "", "", "", "", ""],
+		months: ["", "", "", "", "", "", "", "", "", "", "", ""],
+		monthsShort: ["..", "..", "..", "..", "..", "..", "..", "..", "..", "..", "..", ".."],
+		today: ""
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.tr.js b/public/js_src/external_libs/locales/bootstrap-datepicker.tr.js
new file mode 100644
index 0000000..2e3bb14
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.tr.js
@@ -0,0 +1,15 @@
+/**
+ * Turkish translation for bootstrap-datepicker
+ * Serkan Algur <kaisercrazy_2@hotmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['tr'] = {
+		days: ["Pazar", "Pazartesi", "Sal", "aramba", "Perembe", "Cuma", "Cumartesi", "Pazar"],
+		daysShort: ["Pz", "Pzt", "Sal", "r", "Pr", "Cu", "Cts", "Pz"],
+		daysMin: ["Pz", "Pzt", "Sa", "r", "Pr", "Cu", "Ct", "Pz"],
+		months: ["Ocak", "ubat", "Mart", "Nisan", "Mays", "Haziran", "Temmuz", "Austos", "Eyll", "Ekim", "Kasm", "Aralk"],
+		monthsShort: ["Oca", "ub", "Mar", "Nis", "May", "Haz", "Tem", "Au", "Eyl", "Eki", "Kas", "Ara"],
+		today: "Bugn"
+			} } };
+} );
+
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.zh-CN.js b/public/js_src/external_libs/locales/bootstrap-datepicker.zh-CN.js
new file mode 100644
index 0000000..9f3b544
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.zh-CN.js
@@ -0,0 +1,14 @@
+/**
+ * Simplified Chinese translation for bootstrap-datepicker
+ * Yuan Cheung <advanimal@gmail.com>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['zh-CN'] = {
+				days: ["", "", "", "", "", "", "", ""],
+			daysShort: ["", "", "", "", "", "", "", ""],
+			daysMin:  ["", "", "", "", "", "", "", ""],
+			months: ["", "", "", "", "", "", "", "", "", "", "", ""],
+			monthsShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
+			today: ""
+			} } };
+} );
diff --git a/public/js_src/external_libs/locales/bootstrap-datepicker.zh-TW.js b/public/js_src/external_libs/locales/bootstrap-datepicker.zh-TW.js
new file mode 100644
index 0000000..44c0590
--- /dev/null
+++ b/public/js_src/external_libs/locales/bootstrap-datepicker.zh-TW.js
@@ -0,0 +1,13 @@
+/**
+ * Traditional Chinese translation for bootstrap-datepicker
+ * Rung-Sheng Jang <daniel@i-trend.co.cc>
+ */
+define( ["jquery_timely"], function( $ ) {
+	return { localize: function() { $.fn.datepicker.dates['zh-TW'] = {
+				days: ["", "", "", "", "", "", "", ""],
+			daysShort: ["", "", "", "", "", "", "", ""],
+			daysMin:  ["", "", "", "", "", "", "", ""],
+			months: ["", "", "", "", "", "", "", "", "", "", "", ""],
+			monthsShort: ["", "", "", "", "", "", "", "", "", "", "", ""]
+			} } };
+} );
diff --git a/public/js_src/external_libs/modernizr.js b/public/js_src/external_libs/modernizr.js
new file mode 100644
index 0000000..790111c
--- /dev/null
+++ b/public/js_src/external_libs/modernizr.js
@@ -0,0 +1,216 @@
+define( function() {
+	/* Modernizr 2.5.3 (Custom Build) | MIT & BSD
+	 * Build: http://modernizr.com/download/#-touch-cssclasses-teststyles-prefixes-load
+	 */
+
+	var Modernizr = (function( window, document, undefined ) {
+
+	    var version = '2.5.3',
+
+	    Modernizr = {},
+
+	    enableClasses = true,
+
+	    docElement = document.documentElement,
+
+	    mod = 'modernizr',
+	    modElem = document.createElement(mod),
+	    mStyle = modElem.style,
+
+	    inputElem  ,
+
+
+	    toString = {}.toString,
+
+	    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),
+
+
+
+	    tests = {},
+	    inputs = {},
+	    attrs = {},
+
+	    classes = [],
+
+	    slice = classes.slice,
+
+	    featureName, 
+
+
+	    injectElementWithStyles = function( rule, callback, nodes, testnames ) {
+
+	      var style, ret, node,
+	          div = document.createElement('div'),
+	                body = document.body, 
+	                fakeBody = body ? body : document.createElement('body');
+
+	      if ( parseInt(nodes, 10) ) {
+	                      while ( nodes-- ) {
+	              node = document.createElement('div');
+	              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
+	              div.appendChild(node);
+	          }
+	      }
+
+	                style = ['&#173;','<style>', rule, '</style>'].join('');
+	      div.id = mod;
+	          (body ? div : fakeBody).innerHTML += style;
+	      fakeBody.appendChild(div);
+	      if(!body){
+	                fakeBody.style.background = "";
+	          docElement.appendChild(fakeBody);
+	      }
+
+	      ret = callback(div, rule);
+	        !body ? fakeBody.parentNode.removeChild(fakeBody) : div.parentNode.removeChild(div);
+
+	      return !!ret;
+
+	    },
+	    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProperty;
+
+	    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
+	      hasOwnProperty = function (object, property) {
+	        return _hasOwnProperty.call(object, property);
+	      };
+	    }
+	    else {
+	      hasOwnProperty = function (object, property) { 
+	        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
+	      };
+	    }
+
+
+	    if (!Function.prototype.bind) {
+	      Function.prototype.bind = function bind(that) {
+
+	        var target = this;
+
+	        if (typeof target != "function") {
+	            throw new TypeError();
+	        }
+
+	        var args = slice.call(arguments, 1),
+	            bound = function () {
+
+	            if (this instanceof bound) {
+
+	              var F = function(){};
+	              F.prototype = target.prototype;
+	              var self = new F;
+
+	              var result = target.apply(
+	                  self,
+	                  args.concat(slice.call(arguments))
+	              );
+	              if (Object(result) === result) {
+	                  return result;
+	              }
+	              return self;
+
+	            } else {
+
+	              return target.apply(
+	                  that,
+	                  args.concat(slice.call(arguments))
+	              );
+
+	            }
+
+	        };
+
+	        return bound;
+	      };
+	    }
+
+	    function setCss( str ) {
+	        mStyle.cssText = str;
+	    }
+
+	    function setCssAll( str1, str2 ) {
+	        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
+	    }
+
+	    function is( obj, type ) {
+	        return typeof obj === type;
+	    }
+
+	    function contains( str, substr ) {
+	        return !!~('' + str).indexOf(substr);
+	    }
+
+
+	    function testDOMProps( props, obj, elem ) {
+	        for ( var i in props ) {
+	            var item = obj[props[i]];
+	            if ( item !== undefined) {
+
+	                            if (elem === false) return props[i];
+
+	                            if (is(item, 'function')){
+	                                return item.bind(elem || obj);
+	                }
+
+	                            return item;
+	            }
+	        }
+	        return false;
+	    }
+
+
+	    var testBundle = (function( styles, tests ) {
+	        var style = styles.join(''),
+	            len = tests.length;
+
+	        injectElementWithStyles(style, function( node, rule ) {
+	            var style = document.styleSheets[document.styleSheets.length - 1],
+	                                                    cssText = style ? (style.cssRules && style.cssRules[0] ? style.cssRules[0].cssText : style.cssText || '') : '',
+	                children = node.childNodes, hash = {};
+
+	            while ( len-- ) {
+	                hash[children[len].id] = children[len];
+	            }
+
+	                       Modernizr['touch'] = ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch || (hash['touch'] && hash['touch'].offsetTop) === 9; 
+	                                }, len, tests);
+
+	    })([
+	                       ,['@media (',prefixes.join('touch-enabled),('),mod,')',
+	                                '{#touch{top:9px;position:absolute}}'].join('')           ],
+	      [
+	                       ,'touch'                ]);
+
+
+
+	    tests['touch'] = function() {
+	        return Modernizr['touch'];
+	    };
+
+
+
+	    for ( var feature in tests ) {
+	        if ( hasOwnProperty(tests, feature) ) {
+	                                    featureName  = feature.toLowerCase();
+	            Modernizr[featureName] = tests[feature]();
+
+	            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
+	        }
+	    }
+	    setCss('');
+	    modElem = inputElem = null;
+
+
+	    Modernizr._version      = version;
+
+	    Modernizr._prefixes     = prefixes;
+
+	    Modernizr.testStyles    = injectElementWithStyles;    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +
+
+	                                                    (enableClasses ? ' js ' + classes.join(' ') : '');
+
+	    return Modernizr;
+
+	})(window, window.document);
+	
+	return Modernizr;
+} );
\ No newline at end of file
diff --git a/public/js_src/external_libs/moment.js b/public/js_src/external_libs/moment.js
new file mode 100644
index 0000000..9a06c07
--- /dev/null
+++ b/public/js_src/external_libs/moment.js
@@ -0,0 +1,1195 @@
+// moment.js
+// version : 1.7.2
+// author : Tim Wood
+// license : MIT
+// momentjs.com
+define(	function() {
+
+    /************************************
+        Constants
+    ************************************/
+
+    var moment,
+        VERSION = "1.7.2",
+        round = Math.round, i,
+        // internal storage for language config files
+        languages = {},
+        currentLanguage = 'en',
+
+        // check for nodeJS
+        hasModule = (typeof module !== 'undefined' && module.exports),
+
+        // Parameters to check for on the lang config.  This list of properties
+        // will be inherited from English if not provided in a language
+        // definition.  monthsParse is also a lang config property, but it
+        // cannot be inherited and as such cannot be enumerated here.
+        langConfigProperties = 'months|monthsShort|weekdays|weekdaysShort|weekdaysMin|longDateFormat|calendar|relativeTime|ordinal|meridiem'.split('|'),
+
+        // ASP.NET json date format regex
+        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
+
+        // format tokens
+        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|zz?|ZZ?|.)/g,
+        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?)/g,
+
+        // parsing tokens
+        parseMultipleFormatChunker = /([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,
+
+        // parsing token regexes
+        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
+        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
+        parseTokenThreeDigits = /\d{3}/, // 000 - 999
+        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
+        parseTokenWord = /[0-9a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+/i, // any word characters or numbers
+        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
+        parseTokenT = /T/i, // T (ISO seperator)
+
+        // preliminary iso regex
+        // 0000-00-00 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000
+        isoRegex = /^\s*\d{4}-\d\d-\d\d(T(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,
+        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
+
+        // iso time formats and regexes
+        isoTimes = [
+            ['HH:mm:ss.S', /T\d\d:\d\d:\d\d\.\d{1,3}/],
+            ['HH:mm:ss', /T\d\d:\d\d:\d\d/],
+            ['HH:mm', /T\d\d:\d\d/],
+            ['HH', /T\d\d/]
+        ],
+
+        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
+        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
+
+        // getter and setter names
+        proxyGettersAndSetters = 'Month|Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
+        unitMillisecondFactors = {
+            'Milliseconds' : 1,
+            'Seconds' : 1e3,
+            'Minutes' : 6e4,
+            'Hours' : 36e5,
+            'Days' : 864e5,
+            'Months' : 2592e6,
+            'Years' : 31536e6
+        },
+
+        // format function strings
+        formatFunctions = {},
+
+        // tokens to ordinalize and pad
+        ordinalizeTokens = 'DDD w M D d'.split(' '),
+        paddedTokens = 'M D H h m s w'.split(' '),
+
+        /*
+         * moment.fn.format uses new Function() to create an inlined formatting function.
+         * Results are a 3x speed boost
+         * http://jsperf.com/momentjs-cached-format-functions
+         *
+         * These strings are appended into a function using replaceFormatTokens and makeFormatFunction
+         */
+        formatTokenFunctions = {
+            // a = placeholder
+            // b = placeholder
+            // t = the current moment being formatted
+            // v = getValueAtKey function
+            // o = language.ordinal function
+            // p = leftZeroFill function
+            // m = language.meridiem value or function
+            M    : function () {
+                return this.month() + 1;
+            },
+            MMM  : function (format) {
+                return getValueFromArray("monthsShort", this.month(), this, format);
+            },
+            MMMM : function (format) {
+                return getValueFromArray("months", this.month(), this, format);
+            },
+            D    : function () {
+                return this.date();
+            },
+            DDD  : function () {
+                var a = new Date(this.year(), this.month(), this.date()),
+                    b = new Date(this.year(), 0, 1);
+                return ~~(((a - b) / 864e5) + 1.5);
+            },
+            d    : function () {
+                return this.day();
+            },
+            dd   : function (format) {
+                return getValueFromArray("weekdaysMin", this.day(), this, format);
+            },
+            ddd  : function (format) {
+                return getValueFromArray("weekdaysShort", this.day(), this, format);
+            },
+            dddd : function (format) {
+                return getValueFromArray("weekdays", this.day(), this, format);
+            },
+            w    : function () {
+                var a = new Date(this.year(), this.month(), this.date() - this.day() + 5),
+                    b = new Date(a.getFullYear(), 0, 4);
+                return ~~((a - b) / 864e5 / 7 + 1.5);
+            },
+            YY   : function () {
+                return leftZeroFill(this.year() % 100, 2);
+            },
+            YYYY : function () {
+                return leftZeroFill(this.year(), 4);
+            },
+            a    : function () {
+                return this.lang().meridiem(this.hours(), this.minutes(), true);
+            },
+            A    : function () {
+                return this.lang().meridiem(this.hours(), this.minutes(), false);
+            },
+            H    : function () {
+                return this.hours();
+            },
+            h    : function () {
+                return this.hours() % 12 || 12;
+            },
+            m    : function () {
+                return this.minutes();
+            },
+            s    : function () {
+                return this.seconds();
+            },
+            S    : function () {
+                return ~~(this.milliseconds() / 100);
+            },
+            SS   : function () {
+                return leftZeroFill(~~(this.milliseconds() / 10), 2);
+            },
+            SSS  : function () {
+                return leftZeroFill(this.milliseconds(), 3);
+            },
+            Z    : function () {
+                var a = -this.zone(),
+                    b = "+";
+                if (a < 0) {
+                    a = -a;
+                    b = "-";
+                }
+                return b + leftZeroFill(~~(a / 60), 2) + ":" + leftZeroFill(~~a % 60, 2);
+            },
+            ZZ   : function () {
+                var a = -this.zone(),
+                    b = "+";
+                if (a < 0) {
+                    a = -a;
+                    b = "-";
+                }
+                return b + leftZeroFill(~~(10 * a / 6), 4);
+            }
+        };
+
+    function getValueFromArray(key, index, m, format) {
+        var lang = m.lang();
+        return lang[key].call ? lang[key](m, format) : lang[key][index];
+    }
+
+    function padToken(func, count) {
+        return function (a) {
+            return leftZeroFill(func.call(this, a), count);
+        };
+    }
+    function ordinalizeToken(func) {
+        return function (a) {
+            var b = func.call(this, a);
+            return b + this.lang().ordinal(b);
+        };
+    }
+
+    while (ordinalizeTokens.length) {
+        i = ordinalizeTokens.pop();
+        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i]);
+    }
+    while (paddedTokens.length) {
+        i = paddedTokens.pop();
+        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
+    }
+    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
+
+
+    /************************************
+        Constructors
+    ************************************/
+
+
+    // Moment prototype object
+    function Moment(date, isUTC, lang) {
+        this._d = date;
+        this._isUTC = !!isUTC;
+        this._a = date._a || null;
+        this._lang = lang || false;
+    }
+
+    // Duration Constructor
+    function Duration(duration) {
+        var data = this._data = {},
+            years = duration.years || duration.y || 0,
+            months = duration.months || duration.M || 0,
+            weeks = duration.weeks || duration.w || 0,
+            days = duration.days || duration.d || 0,
+            hours = duration.hours || duration.h || 0,
+            minutes = duration.minutes || duration.m || 0,
+            seconds = duration.seconds || duration.s || 0,
+            milliseconds = duration.milliseconds || duration.ms || 0;
+
+        // representation for dateAddRemove
+        this._milliseconds = milliseconds +
+            seconds * 1e3 + // 1000
+            minutes * 6e4 + // 1000 * 60
+            hours * 36e5; // 1000 * 60 * 60
+        // Because of dateAddRemove treats 24 hours as different from a
+        // day when working around DST, we need to store them separately
+        this._days = days +
+            weeks * 7;
+        // It is impossible translate months into days without knowing
+        // which months you are are talking about, so we have to store
+        // it separately.
+        this._months = months +
+            years * 12;
+
+        // The following code bubbles up values, see the tests for
+        // examples of what that means.
+        data.milliseconds = milliseconds % 1000;
+        seconds += absRound(milliseconds / 1000);
+
+        data.seconds = seconds % 60;
+        minutes += absRound(seconds / 60);
+
+        data.minutes = minutes % 60;
+        hours += absRound(minutes / 60);
+
+        data.hours = hours % 24;
+        days += absRound(hours / 24);
+
+        days += weeks * 7;
+        data.days = days % 30;
+
+        months += absRound(days / 30);
+
+        data.months = months % 12;
+        years += absRound(months / 12);
+
+        data.years = years;
+
+        this._lang = false;
+    }
+
+
+    /************************************
+        Helpers
+    ************************************/
+
+
+    function absRound(number) {
+        if (number < 0) {
+            return Math.ceil(number);
+        } else {
+            return Math.floor(number);
+        }
+    }
+
+    // left zero fill a number
+    // see http://jsperf.com/left-zero-filling for performance comparison
+    function leftZeroFill(number, targetLength) {
+        var output = number + '';
+        while (output.length < targetLength) {
+            output = '0' + output;
+        }
+        return output;
+    }
+
+    // helper function for _.addTime and _.subtractTime
+    function addOrSubtractDurationFromMoment(mom, duration, isAdding) {
+        var ms = duration._milliseconds,
+            d = duration._days,
+            M = duration._months,
+            currentDate;
+
+        if (ms) {
+            mom._d.setTime(+mom + ms * isAdding);
+        }
+        if (d) {
+            mom.date(mom.date() + d * isAdding);
+        }
+        if (M) {
+            currentDate = mom.date();
+            mom.date(1)
+                .month(mom.month() + M * isAdding)
+                .date(Math.min(currentDate, mom.daysInMonth()));
+        }
+    }
+
+    // check if is an array
+    function isArray(input) {
+        return Object.prototype.toString.call(input) === '[object Array]';
+    }
+
+    // compare two arrays, return the number of differences
+    function compareArrays(array1, array2) {
+        var len = Math.min(array1.length, array2.length),
+            lengthDiff = Math.abs(array1.length - array2.length),
+            diffs = 0,
+            i;
+        for (i = 0; i < len; i++) {
+            if (~~array1[i] !== ~~array2[i]) {
+                diffs++;
+            }
+        }
+        return diffs + lengthDiff;
+    }
+
+    // convert an array to a date.
+    // the array should mirror the parameters below
+    // note: all values past the year are optional and will default to the lowest possible value.
+    // [year, month, day , hour, minute, second, millisecond]
+    function dateFromArray(input, asUTC, hoursOffset, minutesOffset) {
+        var i, date, forValid = [];
+        for (i = 0; i < 7; i++) {
+            forValid[i] = input[i] = (input[i] == null) ? (i === 2 ? 1 : 0) : input[i];
+        }
+        // we store whether we used utc or not in the input array
+        input[7] = forValid[7] = asUTC;
+        // if the parser flagged the input as invalid, we pass the value along
+        if (input[8] != null) {
+            forValid[8] = input[8];
+        }
+        // add the offsets to the time to be parsed so that we can have a clean array
+        // for checking isValid
+        input[3] += hoursOffset || 0;
+        input[4] += minutesOffset || 0;
+        date = new Date(0);
+        if (asUTC) {
+            date.setUTCFullYear(input[0], input[1], input[2]);
+            date.setUTCHours(input[3], input[4], input[5], input[6]);
+        } else {
+            date.setFullYear(input[0], input[1], input[2]);
+            date.setHours(input[3], input[4], input[5], input[6]);
+        }
+        date._a = forValid;
+        return date;
+    }
+
+    // Loads a language definition into the `languages` cache.  The function
+    // takes a key and optionally values.  If not in the browser and no values
+    // are provided, it will load the language file module.  As a convenience,
+    // this function also returns the language values.
+    function loadLang(key, values) {
+        var i, m,
+            parse = [];
+
+        if (!values && hasModule) {
+            values = require('./lang/' + key);
+        }
+
+        for (i = 0; i < langConfigProperties.length; i++) {
+            // If a language definition does not provide a value, inherit
+            // from English
+            values[langConfigProperties[i]] = values[langConfigProperties[i]] ||
+              languages.en[langConfigProperties[i]];
+        }
+
+        for (i = 0; i < 12; i++) {
+            m = moment([2000, i]);
+            parse[i] = new RegExp('^' + (values.months[i] || values.months(m, '')) +
+                '|^' + (values.monthsShort[i] || values.monthsShort(m, '')).replace('.', ''), 'i');
+        }
+        values.monthsParse = values.monthsParse || parse;
+
+        languages[key] = values;
+
+        return values;
+    }
+
+    // Determines which language definition to use and returns it.
+    //
+    // With no parameters, it will return the global language.  If you
+    // pass in a language key, such as 'en', it will return the
+    // definition for 'en', so long as 'en' has already been loaded using
+    // moment.lang.  If you pass in a moment or duration instance, it
+    // will decide the language based on that, or default to the global
+    // language.
+    function getLangDefinition(m) {
+        var langKey = (typeof m === 'string') && m ||
+                      m && m._lang ||
+                      null;
+
+        return langKey ? (languages[langKey] || loadLang(langKey)) : moment;
+    }
+
+
+    /************************************
+        Formatting
+    ************************************/
+
+
+    function removeFormattingTokens(input) {
+        if (input.match(/\[.*\]/)) {
+            return input.replace(/^\[|\]$/g, "");
+        }
+        return input.replace(/\\/g, "");
+    }
+
+    function makeFormatFunction(format) {
+        var array = format.match(formattingTokens), i, length;
+
+        for (i = 0, length = array.length; i < length; i++) {
+            if (formatTokenFunctions[array[i]]) {
+                array[i] = formatTokenFunctions[array[i]];
+            } else {
+                array[i] = removeFormattingTokens(array[i]);
+            }
+        }
+
+        return function (mom) {
+            var output = "";
+            for (i = 0; i < length; i++) {
+                output += typeof array[i].call === 'function' ? array[i].call(mom, format) : array[i];
+            }
+            return output;
+        };
+    }
+
+    // format date using native date object
+    function formatMoment(m, format) {
+        var i = 5;
+
+        function replaceLongDateFormatTokens(input) {
+            return m.lang().longDateFormat[input] || input;
+        }
+
+        while (i-- && localFormattingTokens.test(format)) {
+            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
+        }
+
+        if (!formatFunctions[format]) {
+            formatFunctions[format] = makeFormatFunction(format);
+        }
+
+        return formatFunctions[format](m);
+    }
+
+
+    /************************************
+        Parsing
+    ************************************/
+
+
+    // get the regex to find the next token
+    function getParseRegexForToken(token) {
+        switch (token) {
+        case 'DDDD':
+            return parseTokenThreeDigits;
+        case 'YYYY':
+            return parseTokenFourDigits;
+        case 'S':
+        case 'SS':
+        case 'SSS':
+        case 'DDD':
+            return parseTokenOneToThreeDigits;
+        case 'MMM':
+        case 'MMMM':
+        case 'dd':
+        case 'ddd':
+        case 'dddd':
+        case 'a':
+        case 'A':
+            return parseTokenWord;
+        case 'Z':
+        case 'ZZ':
+            return parseTokenTimezone;
+        case 'T':
+            return parseTokenT;
+        case 'MM':
+        case 'DD':
+        case 'YY':
+        case 'HH':
+        case 'hh':
+        case 'mm':
+        case 'ss':
+        case 'M':
+        case 'D':
+        case 'd':
+        case 'H':
+        case 'h':
+        case 'm':
+        case 's':
+            return parseTokenOneOrTwoDigits;
+        default :
+            return new RegExp(token.replace('\\', ''));
+        }
+    }
+
+    // function to convert string input to date
+    function addTimeToArrayFromToken(token, input, datePartArray, config) {
+        var a, b;
+
+        switch (token) {
+        // MONTH
+        case 'M' : // fall through to MM
+        case 'MM' :
+            datePartArray[1] = (input == null) ? 0 : ~~input - 1;
+            break;
+        case 'MMM' : // fall through to MMMM
+        case 'MMMM' :
+            for (a = 0; a < 12; a++) {
+                if (getLangDefinition().monthsParse[a].test(input)) {
+                    datePartArray[1] = a;
+                    b = true;
+                    break;
+                }
+            }
+            // if we didn't find a month name, mark the date as invalid.
+            if (!b) {
+                datePartArray[8] = false;
+            }
+            break;
+        // DAY OF MONTH
+        case 'D' : // fall through to DDDD
+        case 'DD' : // fall through to DDDD
+        case 'DDD' : // fall through to DDDD
+        case 'DDDD' :
+            if (input != null) {
+                datePartArray[2] = ~~input;
+            }
+            break;
+        // YEAR
+        case 'YY' :
+            datePartArray[0] = ~~input + (~~input > 70 ? 1900 : 2000);
+            break;
+        case 'YYYY' :
+            datePartArray[0] = ~~Math.abs(input);
+            break;
+        // AM / PM
+        case 'a' : // fall through to A
+        case 'A' :
+            config.isPm = ((input + '').toLowerCase() === 'pm');
+            break;
+        // 24 HOUR
+        case 'H' : // fall through to hh
+        case 'HH' : // fall through to hh
+        case 'h' : // fall through to hh
+        case 'hh' :
+            datePartArray[3] = ~~input;
+            break;
+        // MINUTE
+        case 'm' : // fall through to mm
+        case 'mm' :
+            datePartArray[4] = ~~input;
+            break;
+        // SECOND
+        case 's' : // fall through to ss
+        case 'ss' :
+            datePartArray[5] = ~~input;
+            break;
+        // MILLISECOND
+        case 'S' :
+        case 'SS' :
+        case 'SSS' :
+            datePartArray[6] = ~~ (('0.' + input) * 1000);
+            break;
+        // TIMEZONE
+        case 'Z' : // fall through to ZZ
+        case 'ZZ' :
+            config.isUTC = true;
+            a = (input + '').match(parseTimezoneChunker);
+            if (a && a[1]) {
+                config.tzh = ~~a[1];
+            }
+            if (a && a[2]) {
+                config.tzm = ~~a[2];
+            }
+            // reverse offsets
+            if (a && a[0] === '+') {
+                config.tzh = -config.tzh;
+                config.tzm = -config.tzm;
+            }
+            break;
+        }
+
+        // if the input is null, the date is not valid
+        if (input == null) {
+            datePartArray[8] = false;
+        }
+    }
+
+    // date from string and format string
+    function makeDateFromStringAndFormat(string, format) {
+        // This array is used to make a Date, either with `new Date` or `Date.UTC`
+        // We store some additional data on the array for validation
+        // datePartArray[7] is true if the Date was created with `Date.UTC` and false if created with `new Date`
+        // datePartArray[8] is false if the Date is invalid, and undefined if the validity is unknown.
+        var datePartArray = [0, 0, 1, 0, 0, 0, 0],
+            config = {
+                tzh : 0, // timezone hour offset
+                tzm : 0  // timezone minute offset
+            },
+            tokens = format.match(formattingTokens),
+            i, parsedInput;
+
+        for (i = 0; i < tokens.length; i++) {
+            parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];
+            if (parsedInput) {
+                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
+            }
+            // don't parse if its not a known token
+            if (formatTokenFunctions[tokens[i]]) {
+                addTimeToArrayFromToken(tokens[i], parsedInput, datePartArray, config);
+            }
+        }
+        // handle am pm
+        if (config.isPm && datePartArray[3] < 12) {
+            datePartArray[3] += 12;
+        }
+        // if is 12 am, change hours to 0
+        if (config.isPm === false && datePartArray[3] === 12) {
+            datePartArray[3] = 0;
+        }
+        // return
+        return dateFromArray(datePartArray, config.isUTC, config.tzh, config.tzm);
+    }
+
+    // date from string and array of format strings
+    function makeDateFromStringAndArray(string, formats) {
+        var output,
+            inputParts = string.match(parseMultipleFormatChunker) || [],
+            formattedInputParts,
+            scoreToBeat = 99,
+            i,
+            currentDate,
+            currentScore;
+        for (i = 0; i < formats.length; i++) {
+            currentDate = makeDateFromStringAndFormat(string, formats[i]);
+            formattedInputParts = formatMoment(new Moment(currentDate), formats[i]).match(parseMultipleFormatChunker) || [];
+            currentScore = compareArrays(inputParts, formattedInputParts);
+            if (currentScore < scoreToBeat) {
+                scoreToBeat = currentScore;
+                output = currentDate;
+            }
+        }
+        return output;
+    }
+
+    // date from iso format
+    function makeDateFromString(string) {
+        var format = 'YYYY-MM-DDT',
+            i;
+        if (isoRegex.exec(string)) {
+            for (i = 0; i < 4; i++) {
+                if (isoTimes[i][1].exec(string)) {
+                    format += isoTimes[i][0];
+                    break;
+                }
+            }
+            return parseTokenTimezone.exec(string) ?
+                makeDateFromStringAndFormat(string, format + ' Z') :
+                makeDateFromStringAndFormat(string, format);
+        }
+        return new Date(string);
+    }
+
+
+    /************************************
+        Relative Time
+    ************************************/
+
+
+    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
+    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
+        var rt = lang.relativeTime[string];
+        return (typeof rt === 'function') ?
+            rt(number || 1, !!withoutSuffix, string, isFuture) :
+            rt.replace(/%d/i, number || 1);
+    }
+
+    function relativeTime(milliseconds, withoutSuffix, lang) {
+        var seconds = round(Math.abs(milliseconds) / 1000),
+            minutes = round(seconds / 60),
+            hours = round(minutes / 60),
+            days = round(hours / 24),
+            years = round(days / 365),
+            args = seconds < 45 && ['s', seconds] ||
+                minutes === 1 && ['m'] ||
+                minutes < 45 && ['mm', minutes] ||
+                hours === 1 && ['h'] ||
+                hours < 22 && ['hh', hours] ||
+                days === 1 && ['d'] ||
+                days <= 25 && ['dd', days] ||
+                days <= 45 && ['M'] ||
+                days < 345 && ['MM', round(days / 30)] ||
+                years === 1 && ['y'] || ['yy', years];
+        args[2] = withoutSuffix;
+        args[3] = milliseconds > 0;
+        args[4] = lang;
+        return substituteTimeAgo.apply({}, args);
+    }
+
+
+    /************************************
+        Top Level Functions
+    ************************************/
+
+
+    moment = function (input, format) {
+        if (input === null || input === '') {
+            return null;
+        }
+        var date,
+            matched;
+        // parse Moment object
+        if (moment.isMoment(input)) {
+            return new Moment(new Date(+input._d), input._isUTC, input._lang);
+        // parse string and format
+        } else if (format) {
+            if (isArray(format)) {
+                date = makeDateFromStringAndArray(input, format);
+            } else {
+                date = makeDateFromStringAndFormat(input, format);
+            }
+        // evaluate it as a JSON-encoded date
+        } else {
+            matched = aspNetJsonRegex.exec(input);
+            date = input === undefined ? new Date() :
+                matched ? new Date(+matched[1]) :
+                input instanceof Date ? input :
+                isArray(input) ? dateFromArray(input) :
+                typeof input === 'string' ? makeDateFromString(input) :
+                new Date(input);
+        }
+
+        return new Moment(date);
+    };
+
+    // creating with utc
+    moment.utc = function (input, format) {
+        if (isArray(input)) {
+            return new Moment(dateFromArray(input, true), true);
+        }
+        // if we don't have a timezone, we need to add one to trigger parsing into utc
+        if (typeof input === 'string' && !parseTokenTimezone.exec(input)) {
+            input += ' +0000';
+            if (format) {
+                format += ' Z';
+            }
+        }
+        return moment(input, format).utc();
+    };
+
+    // creating with unix timestamp (in seconds)
+    moment.unix = function (input) {
+        return moment(input * 1000);
+    };
+
+    // duration
+    moment.duration = function (input, key) {
+        var isDuration = moment.isDuration(input),
+            isNumber = (typeof input === 'number'),
+            duration = (isDuration ? input._data : (isNumber ? {} : input)),
+            ret;
+
+        if (isNumber) {
+            if (key) {
+                duration[key] = input;
+            } else {
+                duration.milliseconds = input;
+            }
+        }
+
+        ret = new Duration(duration);
+
+        if (isDuration) {
+            ret._lang = input._lang;
+        }
+
+        return ret;
+    };
+
+    // humanizeDuration
+    // This method is deprecated in favor of the new Duration object.  Please
+    // see the moment.duration method.
+    moment.humanizeDuration = function (num, type, withSuffix) {
+        return moment.duration(num, type === true ? null : type).humanize(type === true ? true : withSuffix);
+    };
+
+    // version number
+    moment.version = VERSION;
+
+    // default format
+    moment.defaultFormat = isoFormat;
+
+    // This function will load languages and then set the global language.  If
+    // no arguments are passed in, it will simply return the current global
+    // language key.
+    moment.lang = function (key, values) {
+        var i;
+
+        if (!key) {
+            return currentLanguage;
+        }
+        if (values || !languages[key]) {
+            loadLang(key, values);
+        }
+        if (languages[key]) {
+            // deprecated, to get the language definition variables, use the
+            // moment.fn.lang method or the getLangDefinition function.
+            for (i = 0; i < langConfigProperties.length; i++) {
+                moment[langConfigProperties[i]] = languages[key][langConfigProperties[i]];
+            }
+            moment.monthsParse = languages[key].monthsParse;
+            currentLanguage = key;
+        }
+    };
+
+    // returns language data
+    moment.langData = getLangDefinition;
+
+    // compare moment object
+    moment.isMoment = function (obj) {
+        return obj instanceof Moment;
+    };
+
+    // for typechecking Duration objects
+    moment.isDuration = function (obj) {
+        return obj instanceof Duration;
+    };
+
+    // Set default language, other languages will inherit from English.
+    moment.lang('en', {
+        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
+        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
+        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
+        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
+        weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
+        longDateFormat : {
+            LT : "h:mm A",
+            L : "MM/DD/YYYY",
+            LL : "MMMM D YYYY",
+            LLL : "MMMM D YYYY LT",
+            LLLL : "dddd, MMMM D YYYY LT"
+        },
+        meridiem : function (hours, minutes, isLower) {
+            if (hours > 11) {
+                return isLower ? 'pm' : 'PM';
+            } else {
+                return isLower ? 'am' : 'AM';
+            }
+        },
+        calendar : {
+            sameDay : '[Today at] LT',
+            nextDay : '[Tomorrow at] LT',
+            nextWeek : 'dddd [at] LT',
+            lastDay : '[Yesterday at] LT',
+            lastWeek : '[last] dddd [at] LT',
+            sameElse : 'L'
+        },
+        relativeTime : {
+            future : "in %s",
+            past : "%s ago",
+            s : "a few seconds",
+            m : "a minute",
+            mm : "%d minutes",
+            h : "an hour",
+            hh : "%d hours",
+            d : "a day",
+            dd : "%d days",
+            M : "a month",
+            MM : "%d months",
+            y : "a year",
+            yy : "%d years"
+        },
+        ordinal : function (number) {
+            var b = number % 10;
+            return (~~ (number % 100 / 10) === 1) ? 'th' :
+                (b === 1) ? 'st' :
+                (b === 2) ? 'nd' :
+                (b === 3) ? 'rd' : 'th';
+        }
+    });
+
+
+    /************************************
+        Moment Prototype
+    ************************************/
+
+
+    moment.fn = Moment.prototype = {
+
+        clone : function () {
+            return moment(this);
+        },
+
+        valueOf : function () {
+            return +this._d;
+        },
+
+        unix : function () {
+            return Math.floor(+this._d / 1000);
+        },
+
+        toString : function () {
+            return this._d.toString();
+        },
+
+        toDate : function () {
+            return this._d;
+        },
+
+        toArray : function () {
+            var m = this;
+            return [
+                m.year(),
+                m.month(),
+                m.date(),
+                m.hours(),
+                m.minutes(),
+                m.seconds(),
+                m.milliseconds(),
+                !!this._isUTC
+            ];
+        },
+
+        isValid : function () {
+            if (this._a) {
+                // if the parser finds that the input is invalid, it sets
+                // the eighth item in the input array to false.
+                if (this._a[8] != null) {
+                    return !!this._a[8];
+                }
+                return !compareArrays(this._a, (this._a[7] ? moment.utc(this._a) : moment(this._a)).toArray());
+            }
+            return !isNaN(this._d.getTime());
+        },
+
+        utc : function () {
+            this._isUTC = true;
+            return this;
+        },
+
+        local : function () {
+            this._isUTC = false;
+            return this;
+        },
+
+        format : function (inputString) {
+            return formatMoment(this, inputString ? inputString : moment.defaultFormat);
+        },
+
+        add : function (input, val) {
+            var dur = val ? moment.duration(+val, input) : moment.duration(input);
+            addOrSubtractDurationFromMoment(this, dur, 1);
+            return this;
+        },
+
+        subtract : function (input, val) {
+            var dur = val ? moment.duration(+val, input) : moment.duration(input);
+            addOrSubtractDurationFromMoment(this, dur, -1);
+            return this;
+        },
+
+        diff : function (input, val, asFloat) {
+            var inputMoment = this._isUTC ? moment(input).utc() : moment(input).local(),
+                zoneDiff = (this.zone() - inputMoment.zone()) * 6e4,
+                diff = this._d - inputMoment._d - zoneDiff,
+                year = this.year() - inputMoment.year(),
+                month = this.month() - inputMoment.month(),
+                date = this.date() - inputMoment.date(),
+                output;
+            if (val === 'months') {
+                output = year * 12 + month + date / 30;
+            } else if (val === 'years') {
+                output = year + (month + date / 30) / 12;
+            } else {
+                output = val === 'seconds' ? diff / 1e3 : // 1000
+                    val === 'minutes' ? diff / 6e4 : // 1000 * 60
+                    val === 'hours' ? diff / 36e5 : // 1000 * 60 * 60
+                    val === 'days' ? diff / 864e5 : // 1000 * 60 * 60 * 24
+                    val === 'weeks' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7
+                    diff;
+            }
+            return asFloat ? output : round(output);
+        },
+
+        from : function (time, withoutSuffix) {
+            return moment.duration(this.diff(time)).lang(this._lang).humanize(!withoutSuffix);
+        },
+
+        fromNow : function (withoutSuffix) {
+            return this.from(moment(), withoutSuffix);
+        },
+
+        calendar : function () {
+            var diff = this.diff(moment().sod(), 'days', true),
+                calendar = this.lang().calendar,
+                allElse = calendar.sameElse,
+                format = diff < -6 ? allElse :
+                diff < -1 ? calendar.lastWeek :
+                diff < 0 ? calendar.lastDay :
+                diff < 1 ? calendar.sameDay :
+                diff < 2 ? calendar.nextDay :
+                diff < 7 ? calendar.nextWeek : allElse;
+            return this.format(typeof format === 'function' ? format.apply(this) : format);
+        },
+
+        isLeapYear : function () {
+            var year = this.year();
+            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
+        },
+
+        isDST : function () {
+            return (this.zone() < moment([this.year()]).zone() ||
+                this.zone() < moment([this.year(), 5]).zone());
+        },
+
+        day : function (input) {
+            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
+            return input == null ? day :
+                this.add({ d : input - day });
+        },
+
+        startOf: function (val) {
+            // the following switch intentionally omits break keywords
+            // to utilize falling through the cases.
+            switch (val.replace(/s$/, '')) {
+            case 'year':
+                this.month(0);
+                /* falls through */
+            case 'month':
+                this.date(1);
+                /* falls through */
+            case 'day':
+                this.hours(0);
+                /* falls through */
+            case 'hour':
+                this.minutes(0);
+                /* falls through */
+            case 'minute':
+                this.seconds(0);
+                /* falls through */
+            case 'second':
+                this.milliseconds(0);
+                /* falls through */
+            }
+            return this;
+        },
+
+        endOf: function (val) {
+            return this.startOf(val).add(val.replace(/s?$/, 's'), 1).subtract('ms', 1);
+        },
+
+        sod: function () {
+            return this.clone().startOf('day');
+        },
+
+        eod: function () {
+            // end of day = start of day plus 1 day, minus 1 millisecond
+            return this.clone().endOf('day');
+        },
+
+        zone : function () {
+            return this._isUTC ? 0 : this._d.getTimezoneOffset();
+        },
+
+        daysInMonth : function () {
+            return moment.utc([this.year(), this.month() + 1, 0]).date();
+        },
+
+        // If passed a language key, it will set the language for this
+        // instance.  Otherwise, it will return the language configuration
+        // variables for this instance.
+        lang : function (lang) {
+            if (lang === undefined) {
+                return getLangDefinition(this);
+            } else {
+                this._lang = lang;
+                return this;
+            }
+        }
+    };
+
+    // helper for adding shortcuts
+    function makeGetterAndSetter(name, key) {
+        moment.fn[name] = function (input) {
+            var utc = this._isUTC ? 'UTC' : '';
+            if (input != null) {
+                this._d['set' + utc + key](input);
+                return this;
+            } else {
+                return this._d['get' + utc + key]();
+            }
+        };
+    }
+
+    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
+    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
+        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase(), proxyGettersAndSetters[i]);
+    }
+
+    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
+    makeGetterAndSetter('year', 'FullYear');
+
+
+    /************************************
+        Duration Prototype
+    ************************************/
+
+
+    moment.duration.fn = Duration.prototype = {
+        weeks : function () {
+            return absRound(this.days() / 7);
+        },
+
+        valueOf : function () {
+            return this._milliseconds +
+              this._days * 864e5 +
+              this._months * 2592e6;
+        },
+
+        humanize : function (withSuffix) {
+            var difference = +this,
+                rel = this.lang().relativeTime,
+                output = relativeTime(difference, !withSuffix, this.lang()),
+                fromNow = difference <= 0 ? rel.past : rel.future;
+
+            if (withSuffix) {
+                if (typeof fromNow === 'function') {
+                    output = fromNow(output);
+                } else {
+                    output = fromNow.replace(/%s/i, output);
+                }
+            }
+
+            return output;
+        },
+
+        lang : moment.fn.lang
+    };
+
+    function makeDurationGetter(name) {
+        moment.duration.fn[name] = function () {
+            return this._data[name];
+        };
+    }
+
+    function makeDurationAsGetter(name, factor) {
+        moment.duration.fn['as' + name] = function () {
+            return +this / factor;
+        };
+    }
+
+    for (i in unitMillisecondFactors) {
+        if (unitMillisecondFactors.hasOwnProperty(i)) {
+            makeDurationAsGetter(i, unitMillisecondFactors[i]);
+            makeDurationGetter(i.toLowerCase());
+        }
+    }
+
+    makeDurationAsGetter('Weeks', 6048e5);
+
+
+    /************************************
+        Exposing Moment
+    ************************************/
+
+    return moment;
+} );
diff --git a/public/js_src/external_libs/select2.js b/public/js_src/external_libs/select2.js
new file mode 100755
index 0000000..155f24b
--- /dev/null
+++ b/public/js_src/external_libs/select2.js
@@ -0,0 +1,2698 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+function( jQuery ) {
+
+/*
+Copyright 2012 Igor Vaynberg
+
+Version: 3.3.1 Timestamp: Wed Feb 20 09:57:22 PST 2013
+
+This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
+General Public License version 2 (the "GPL License"). You may choose either license to govern your
+use of this software only upon the condition that you accept all of the terms of either the Apache
+License or the GPL License.
+
+You may obtain a copy of the Apache License and the GPL License at:
+
+    http://www.apache.org/licenses/LICENSE-2.0
+    http://www.gnu.org/licenses/gpl-2.0.html
+
+Unless required by applicable law or agreed to in writing, software distributed under the
+Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
+the specific language governing permissions and limitations under the Apache License and the GPL License.
+*/
+ (function ($) {
+ 	if(typeof $.fn.each2 == "undefined"){
+ 		$.fn.extend({
+ 			/*
+			* 4-10 times faster .each replacement
+			* use it carefully, as it overrides jQuery context of element on each iteration
+			*/
+			each2 : function (c) {
+				var j = $([0]), i = -1, l = this.length;
+				while (
+					++i < l
+					&& (j.context = j[0] = this[i])
+					&& c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
+				);
+				return this;
+			}
+ 		});
+ 	}
+})(jQuery);
+
+(function ($, undefined) {
+    "use strict";
+    /*global document, window, jQuery, console */
+
+    var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
+        lastMousePosition, $document;
+
+    KEY = {
+        TAB: 9,
+        ENTER: 13,
+        ESC: 27,
+        SPACE: 32,
+        LEFT: 37,
+        UP: 38,
+        RIGHT: 39,
+        DOWN: 40,
+        SHIFT: 16,
+        CTRL: 17,
+        ALT: 18,
+        PAGE_UP: 33,
+        PAGE_DOWN: 34,
+        HOME: 36,
+        END: 35,
+        BACKSPACE: 8,
+        DELETE: 46,
+        isArrow: function (k) {
+            k = k.which ? k.which : k;
+            switch (k) {
+            case KEY.LEFT:
+            case KEY.RIGHT:
+            case KEY.UP:
+            case KEY.DOWN:
+                return true;
+            }
+            return false;
+        },
+        isControl: function (e) {
+            var k = e.which;
+            switch (k) {
+            case KEY.SHIFT:
+            case KEY.CTRL:
+            case KEY.ALT:
+                return true;
+            }
+
+            if (e.metaKey) return true;
+
+            return false;
+        },
+        isFunctionKey: function (k) {
+            k = k.which ? k.which : k;
+            return k >= 112 && k <= 123;
+        }
+    };
+
+    $document = $(document);
+
+    nextUid=(function() { var counter=1; return function() { return counter++; }; }());
+
+    function indexOf(value, array) {
+        var i = 0, l = array.length;
+        for (; i < l; i = i + 1) {
+            if (equal(value, array[i])) return i;
+        }
+        return -1;
+    }
+
+    /**
+     * Compares equality of a and b
+     * @param a
+     * @param b
+     */
+    function equal(a, b) {
+        if (a === b) return true;
+        if (a === undefined || b === undefined) return false;
+        if (a === null || b === null) return false;
+        if (a.constructor === String) return a === b+'';
+        if (b.constructor === String) return b === a+'';
+        return false;
+    }
+
+    /**
+     * Splits the string into an array of values, trimming each value. An empty array is returned for nulls or empty
+     * strings
+     * @param string
+     * @param separator
+     */
+    function splitVal(string, separator) {
+        var val, i, l;
+        if (string === null || string.length < 1) return [];
+        val = string.split(separator);
+        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
+        return val;
+    }
+
+    function getSideBorderPadding(element) {
+        return element.outerWidth(false) - element.width();
+    }
+
+    function installKeyUpChangeEvent(element) {
+        var key="keyup-change-value";
+        element.bind("keydown", function () {
+            if ($.data(element, key) === undefined) {
+                $.data(element, key, element.val());
+            }
+        });
+        element.bind("keyup", function () {
+            var val= $.data(element, key);
+            if (val !== undefined && element.val() !== val) {
+                $.removeData(element, key);
+                element.trigger("keyup-change");
+            }
+        });
+    }
+
+    $document.bind("mousemove", function (e) {
+        lastMousePosition = {x: e.pageX, y: e.pageY};
+    });
+
+    /**
+     * filters mouse events so an event is fired only if the mouse moved.
+     *
+     * filters out mouse events that occur when mouse is stationary but
+     * the elements under the pointer are scrolled.
+     */
+    function installFilteredMouseMove(element) {
+	    element.bind("mousemove", function (e) {
+            var lastpos = lastMousePosition;
+            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
+                $(e.target).trigger("mousemove-filtered", e);
+            }
+        });
+    }
+
+    /**
+     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
+     * within the last quietMillis milliseconds.
+     *
+     * @param quietMillis number of milliseconds to wait before invoking fn
+     * @param fn function to be debounced
+     * @param ctx object to be used as this reference within fn
+     * @return debounced version of fn
+     */
+    function debounce(quietMillis, fn, ctx) {
+        ctx = ctx || undefined;
+        var timeout;
+        return function () {
+            var args = arguments;
+            window.clearTimeout(timeout);
+            timeout = window.setTimeout(function() {
+                fn.apply(ctx, args);
+            }, quietMillis);
+        };
+    }
+
+    /**
+     * A simple implementation of a thunk
+     * @param formula function used to lazily initialize the thunk
+     * @return {Function}
+     */
+    function thunk(formula) {
+        var evaluated = false,
+            value;
+        return function() {
+            if (evaluated === false) { value = formula(); evaluated = true; }
+            return value;
+        };
+    };
+
+    function installDebouncedScroll(threshold, element) {
+        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
+        element.bind("scroll", function (e) {
+            if (indexOf(e.target, element.get()) >= 0) notify(e);
+        });
+    }
+
+    function focus($el) {
+        if ($el[0] === document.activeElement) return;
+
+        /* set the focus in a 0 timeout - that way the focus is set after the processing
+            of the current event has finished - which seems like the only reliable way
+            to set focus */
+        window.setTimeout(function() {
+            var el=$el[0], pos=$el.val().length, range;
+
+            $el.focus();
+
+            /* after the focus is set move the caret to the end, necessary when we val()
+                just before setting focus */
+            if(el.setSelectionRange)
+            {
+                el.setSelectionRange(pos, pos);
+            }
+            else if (el.createTextRange) {
+                range = el.createTextRange();
+                range.collapse(true);
+                range.moveEnd('character', pos);
+                range.moveStart('character', pos);
+                range.select();
+            }
+
+        }, 0);
+    }
+
+    function killEvent(event) {
+        event.preventDefault();
+        event.stopPropagation();
+    }
+    function killEventImmediately(event) {
+        event.preventDefault();
+        event.stopImmediatePropagation();
+    }
+
+    function measureTextWidth(e) {
+        if (!sizer){
+        	var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
+        	sizer = $(document.createElement("div")).css({
+	            position: "absolute",
+	            left: "-10000px",
+	            top: "-10000px",
+	            display: "none",
+	            fontSize: style.fontSize,
+	            fontFamily: style.fontFamily,
+	            fontStyle: style.fontStyle,
+	            fontWeight: style.fontWeight,
+	            letterSpacing: style.letterSpacing,
+	            textTransform: style.textTransform,
+	            whiteSpace: "nowrap"
+	        });
+            sizer.attr("class","select2-sizer");
+        	$("body").append(sizer);
+        }
+        sizer.text(e.val());
+        return sizer.width();
+    }
+
+    function syncCssClasses(dest, src, adapter) {
+        var classes, replacements = [], adapted;
+
+        classes = dest.attr("class");
+        if (typeof classes === "string") {
+            $(classes.split(" ")).each2(function() {
+                if (this.indexOf("select2-") === 0) {
+                    replacements.push(this);
+                }
+            });
+        }
+        classes = src.attr("class");
+        if (typeof classes === "string") {
+            $(classes.split(" ")).each2(function() {
+                if (this.indexOf("select2-") !== 0) {
+                    adapted = adapter(this);
+                    if (typeof adapted === "string" && adapted.length > 0) {
+                        replacements.push(this);
+                    }
+                }
+            });
+        }
+        dest.attr("class", replacements.join(" "));
+    }
+
+
+    function markMatch(text, term, markup, escapeMarkup) {
+        var match=text.toUpperCase().indexOf(term.toUpperCase()),
+            tl=term.length;
+
+        if (match<0) {
+            markup.push(escapeMarkup(text));
+            return;
+        }
+
+        markup.push(escapeMarkup(text.substring(0, match)));
+        markup.push("<span class='select2-match'>");
+        markup.push(escapeMarkup(text.substring(match, match + tl)));
+        markup.push("</span>");
+        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
+    }
+
+    /**
+     * Produces an ajax-based query function
+     *
+     * @param options object containing configuration paramters
+     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
+     * @param options.url url for the data
+     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
+     * @param options.dataType request data type: ajax, jsonp, other datatatypes supported by jQuery's $.ajax function or the transport function if specified
+     * @param options.traditional a boolean flag that should be true if you wish to use the traditional style of param serialization for the ajax request
+     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
+     * @param options.results a function(remoteData, pageNumber) that converts data returned form the remote request to the format expected by Select2.
+     *      The expected format is an object containing the following keys:
+     *      results array of objects that will be used as choices
+     *      more (optional) boolean indicating whether there are more results available
+     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
+     */
+    function ajax(options) {
+        var timeout, // current scheduled but not yet executed request
+            requestSequence = 0, // sequence used to drop out-of-order responses
+            handler = null,
+            quietMillis = options.quietMillis || 100,
+            ajaxUrl = options.url,
+            self = this;
+
+        return function (query) {
+            window.clearTimeout(timeout);
+            timeout = window.setTimeout(function () {
+                requestSequence += 1; // increment the sequence
+                var requestNumber = requestSequence, // this request's sequence number
+                    data = options.data, // ajax data function
+                    url = ajaxUrl, // ajax url string or function
+                    transport = options.transport || $.ajax,
+                    type = options.type || 'GET', // set type of request (GET or POST)
+                    params = {};
+
+                data = data ? data.call(self, query.term, query.page, query.context) : null;
+                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;
+
+                if( null !== handler) { handler.abort(); }
+
+                if (options.params) {
+                    if ($.isFunction(options.params)) {
+                        $.extend(params, options.params.call(self));
+                    } else {
+                        $.extend(params, options.params);
+                    }
+                }
+
+                $.extend(params, {
+                    url: url,
+                    dataType: options.dataType,
+                    data: data,
+                    type: type,
+                    cache: false,
+                    success: function (data) {
+                        if (requestNumber < requestSequence) {
+                            return;
+                        }
+                        // TODO - replace query.page with query so users have access to term, page, etc.
+                        var results = options.results(data, query.page);
+                        query.callback(results);
+                    }
+                });
+                handler = transport.call(self, params);
+            }, quietMillis);
+        };
+    }
+
+    /**
+     * Produces a query function that works with a local array
+     *
+     * @param options object containing configuration parameters. The options parameter can either be an array or an
+     * object.
+     *
+     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
+     *
+     * If the object form is used ti is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
+     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
+     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
+     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
+     * the text.
+     */
+    function local(options) {
+        var data = options, // data elements
+            dataText,
+            tmp,
+            text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search
+
+		 if ($.isArray(data)) {
+            tmp = data;
+            data = { results: tmp };
+        }
+
+		 if ($.isFunction(data) === false) {
+            tmp = data;
+            data = function() { return tmp; };
+        }
+
+        var dataItem = data();
+        if (dataItem.text) {
+            text = dataItem.text;
+            // if text is not a function we assume it to be a key name
+            if (!$.isFunction(text)) {
+                dataText = data.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
+                text = function (item) { return item[dataText]; };
+            }
+        }
+
+        return function (query) {
+            var t = query.term, filtered = { results: [] }, process;
+            if (t === "") {
+                query.callback(data());
+                return;
+            }
+
+            process = function(datum, collection) {
+                var group, attr;
+                datum = datum[0];
+                if (datum.children) {
+                    group = {};
+                    for (attr in datum) {
+                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
+                    }
+                    group.children=[];
+                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
+                    if (group.children.length || query.matcher(t, text(group), datum)) {
+                        collection.push(group);
+                    }
+                } else {
+                    if (query.matcher(t, text(datum), datum)) {
+                        collection.push(datum);
+                    }
+                }
+            };
+
+            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
+            query.callback(filtered);
+        };
+    }
+
+    // TODO javadoc
+    function tags(data) {
+        var isFunc = $.isFunction(data);
+        return function (query) {
+            var t = query.term, filtered = {results: []};
+            $(isFunc ? data() : data).each(function () {
+                var isObject = this.text !== undefined,
+                    text = isObject ? this.text : this;
+                if (t === "" || query.matcher(t, text)) {
+                    filtered.results.push(isObject ? this : {id: this, text: this});
+                }
+            });
+            query.callback(filtered);
+        };
+    }
+
+    /**
+     * Checks if the formatter function should be used.
+     *
+     * Throws an error if it is not a function. Returns true if it should be used,
+     * false if no formatting should be performed.
+     *
+     * @param formatter
+     */
+    function checkFormatter(formatter, formatterName) {
+        if ($.isFunction(formatter)) return true;
+        if (!formatter) return false;
+        throw new Error("formatterName must be a function or a falsy value");
+    }
+
+    function evaluate(val) {
+        return $.isFunction(val) ? val() : val;
+    }
+
+    function countResults(results) {
+        var count = 0;
+        $.each(results, function(i, item) {
+            if (item.children) {
+                count += countResults(item.children);
+            } else {
+                count++;
+            }
+        });
+        return count;
+    }
+
+    /**
+     * Default tokenizer. This function uses breaks the input on substring match of any string from the
+     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
+     * two options have to be defined in order for the tokenizer to work.
+     *
+     * @param input text user has typed so far or pasted into the search field
+     * @param selection currently selected choices
+     * @param selectCallback function(choice) callback tho add the choice to selection
+     * @param opts select2's opts
+     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
+     */
+    function defaultTokenizer(input, selection, selectCallback, opts) {
+        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
+            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
+            token, // token
+            index, // position at which the separator was found
+            i, l, // looping variables
+            separator; // the matched separator
+
+        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;
+
+        while (true) {
+            index = -1;
+
+            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
+                separator = opts.tokenSeparators[i];
+                index = input.indexOf(separator);
+                if (index >= 0) break;
+            }
+
+            if (index < 0) break; // did not find any token separator in the input string, bail
+
+            token = input.substring(0, index);
+            input = input.substring(index + separator.length);
+
+            if (token.length > 0) {
+                token = opts.createSearchChoice(token, selection);
+                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
+                    dupe = false;
+                    for (i = 0, l = selection.length; i < l; i++) {
+                        if (equal(opts.id(token), opts.id(selection[i]))) {
+                            dupe = true; break;
+                        }
+                    }
+
+                    if (!dupe) selectCallback(token);
+                }
+            }
+        }
+
+        if (original!==input) return input;
+    }
+
+    /**
+     * Creates a new class
+     *
+     * @param superClass
+     * @param methods
+     */
+    function clazz(SuperClass, methods) {
+        var constructor = function () {};
+        constructor.prototype = new SuperClass;
+        constructor.prototype.constructor = constructor;
+        constructor.prototype.parent = SuperClass.prototype;
+        constructor.prototype = $.extend(constructor.prototype, methods);
+        return constructor;
+    }
+
+    AbstractSelect2 = clazz(Object, {
+
+        // abstract
+        bind: function (func) {
+            var self = this;
+            return function () {
+                func.apply(self, arguments);
+            };
+        },
+
+        // abstract
+        init: function (opts) {
+            var results, search, resultsSelector = ".select2-results", mask;
+
+            // prepare options
+            this.opts = opts = this.prepareOpts(opts);
+
+            this.id=opts.id;
+
+            // destroy if called on an existing component
+            if (opts.element.data("select2") !== undefined &&
+                opts.element.data("select2") !== null) {
+                this.destroy();
+            }
+
+            this.enabled=true;
+            this.container = this.createContainer();
+
+            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
+            this.containerSelector="#"+this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
+            this.container.attr("id", this.containerId);
+
+            // cache the body so future lookups are cheap
+            this.body = thunk(function() { return opts.element.closest("body"); });
+
+            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
+
+            this.container.css(evaluate(opts.containerCss));
+            this.container.addClass(evaluate(opts.containerCssClass));
+
+            this.elementTabIndex = this.opts.element.attr("tabIndex");
+
+            // swap container for the element
+            this.opts.element
+                .data("select2", this)
+                .addClass("select2-offscreen")
+                .bind("focus.select2", function() { $(this).select2("focus"); })
+                .attr("tabIndex", "-1")
+                .before(this.container);
+            this.container.data("select2", this);
+
+            this.dropdown = this.container.find(".select2-drop");
+            this.dropdown.addClass(evaluate(opts.dropdownCssClass));
+            this.dropdown.data("select2", this);
+
+            this.results = results = this.container.find(resultsSelector);
+            this.search = search = this.container.find("input.select2-input");
+
+            search.attr("tabIndex", this.elementTabIndex);
+
+            this.resultsPage = 0;
+            this.context = null;
+
+            // initialize the container
+            this.initContainer();
+
+            installFilteredMouseMove(this.results);
+            this.dropdown.delegate(resultsSelector, "mousemove-filtered touchstart touchmove touchend", this.bind(this.highlightUnderEvent));
+
+            installDebouncedScroll(80, this.results);
+            this.dropdown.delegate(resultsSelector, "scroll-debounced", this.bind(this.loadMoreIfNeeded));
+
+            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
+            if ($.fn.mousewheel) {
+                results.mousewheel(function (e, delta, deltaX, deltaY) {
+                    var top = results.scrollTop(), height;
+                    if (deltaY > 0 && top - deltaY <= 0) {
+                        results.scrollTop(0);
+                        killEvent(e);
+                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
+                        results.scrollTop(results.get(0).scrollHeight - results.height());
+                        killEvent(e);
+                    }
+                });
+            }
+
+            installKeyUpChangeEvent(search);
+            search.bind("keyup-change input paste", this.bind(this.updateResults));
+            search.bind("focus", function () { search.addClass("select2-focused"); });
+            search.bind("blur", function () { search.removeClass("select2-focused");});
+
+            this.dropdown.delegate(resultsSelector, "mouseup", this.bind(function (e) {
+                if ($(e.target).closest(".select2-result-selectable").length > 0) {
+                    this.highlightUnderEvent(e);
+                    this.selectHighlighted(e);
+                }
+            }));
+
+            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
+            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
+            // dom it will trigger the popup close, which is not what we want
+            this.dropdown.bind("click mouseup mousedown", function (e) { e.stopPropagation(); });
+
+            if ($.isFunction(this.opts.initSelection)) {
+                // initialize selection based on the current value of the source element
+                this.initSelection();
+
+                // if the user has provided a function that can set selection based on the value of the source element
+                // we monitor the change event on the element and trigger it, allowing for two way synchronization
+                this.monitorSource();
+            }
+
+            if (opts.element.is(":disabled") || opts.element.is("[readonly='readonly']")) this.disable();
+        },
+
+        // abstract
+        destroy: function () {
+            var select2 = this.opts.element.data("select2");
+
+            if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
+
+            if (select2 !== undefined) {
+
+                select2.container.remove();
+                select2.dropdown.remove();
+                select2.opts.element
+                    .removeClass("select2-offscreen")
+                    .removeData("select2")
+                    .unbind(".select2")
+                    .attr({"tabIndex": this.elementTabIndex})
+                    .show();
+            }
+        },
+
+        // abstract
+        prepareOpts: function (opts) {
+            var element, select, idKey, ajaxUrl;
+
+            element = opts.element;
+
+            if (element.get(0).tagName.toLowerCase() === "select") {
+                this.select = select = opts.element;
+            }
+
+            if (select) {
+                // these options are not allowed when attached to a select because they are picked up off the element itself
+                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
+                    if (this in opts) {
+                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
+                    }
+                });
+            }
+
+            opts = $.extend({}, {
+                populateResults: function(container, results, query) {
+                    var populate,  data, result, children, id=this.opts.id, self=this;
+
+                    populate=function(results, container, depth) {
+
+                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;
+
+                        results = opts.sortResults(results, container, query);
+
+                        for (i = 0, l = results.length; i < l; i = i + 1) {
+
+                            result=results[i];
+
+                            disabled = (result.disabled === true);
+                            selectable = (!disabled) && (id(result) !== undefined);
+
+                            compound=result.children && result.children.length > 0;
+
+                            node=$("<li></li>");
+                            node.addClass("select2-results-dept-"+depth);
+                            node.addClass("select2-result");
+                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
+                            if (disabled) { node.addClass("select2-disabled"); }
+                            if (compound) { node.addClass("select2-result-with-children"); }
+                            node.addClass(self.opts.formatResultCssClass(result));
+
+                            label=$(document.createElement("div"));
+                            label.addClass("select2-result-label");
+
+                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
+                            if (formatted!==undefined) {
+                                label.html(formatted);
+                            }
+
+                            node.append(label);
+
+                            if (compound) {
+
+                                innerContainer=$("<ul></ul>");
+                                innerContainer.addClass("select2-result-sub");
+                                populate(result.children, innerContainer, depth+1);
+                                node.append(innerContainer);
+                            }
+
+                            node.data("select2-data", result);
+                            container.append(node);
+                        }
+                    };
+
+                    populate(results, container, 0);
+                }
+            }, $.fn.select2.defaults, opts);
+
+            if (typeof(opts.id) !== "function") {
+                idKey = opts.id;
+                opts.id = function (e) { return e[idKey]; };
+            }
+
+            if ($.isArray(opts.element.data("select2Tags"))) {
+                if ("tags" in opts) {
+                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
+                }
+                opts.tags=opts.element.attr("data-select2-tags");
+            }
+
+            if (select) {
+                opts.query = this.bind(function (query) {
+                    var data = { results: [], more: false },
+                        term = query.term,
+                        children, firstChild, process;
+
+                    process=function(element, collection) {
+                        var group;
+                        if (element.is("option")) {
+                            if (query.matcher(term, element.text(), element)) {
+                                collection.push({id:element.attr("value"), text:element.text(), element: element.get(), css: element.attr("class"), disabled: equal(element.attr("disabled"), "disabled") });
+                            }
+                        } else if (element.is("optgroup")) {
+                            group={text:element.attr("label"), children:[], element: element.get(), css: element.attr("class")};
+                            element.children().each2(function(i, elm) { process(elm, group.children); });
+                            if (group.children.length>0) {
+                                collection.push(group);
+                            }
+                        }
+                    };
+
+                    children=element.children();
+
+                    // ignore the placeholder option if there is one
+                    if (this.getPlaceholder() !== undefined && children.length > 0) {
+                        firstChild = children[0];
+                        if ($(firstChild).text() === "") {
+                            children=children.not(firstChild);
+                        }
+                    }
+
+                    children.each2(function(i, elm) { process(elm, data.results); });
+
+                    query.callback(data);
+                });
+                // this is needed because inside val() we construct choices from options and there id is hardcoded
+                opts.id=function(e) { return e.id; };
+                opts.formatResultCssClass = function(data) { return data.css; };
+            } else {
+                if (!("query" in opts)) {
+
+                    if ("ajax" in opts) {
+                        ajaxUrl = opts.element.data("ajax-url");
+                        if (ajaxUrl && ajaxUrl.length > 0) {
+                            opts.ajax.url = ajaxUrl;
+                        }
+                        opts.query = ajax.call(opts.element, opts.ajax);
+                    } else if ("data" in opts) {
+                        opts.query = local(opts.data);
+                    } else if ("tags" in opts) {
+                        opts.query = tags(opts.tags);
+                        if (opts.createSearchChoice === undefined) {
+                            opts.createSearchChoice = function (term) { return {id: term, text: term}; };
+                        }
+                        if (opts.initSelection === undefined) {
+                            opts.initSelection = function (element, callback) {
+                                var data = [];
+                                $(splitVal(element.val(), opts.separator)).each(function () {
+                                    var id = this, text = this, tags=opts.tags;
+                                    if ($.isFunction(tags)) tags=tags();
+                                    $(tags).each(function() { if (equal(this.id, id)) { text = this.text; return false; } });
+                                    data.push({id: id, text: text});
+                                });
+
+                                callback(data);
+                            };
+                        }
+                    }
+                }
+            }
+            if (typeof(opts.query) !== "function") {
+                throw "query function not defined for Select2 " + opts.element.attr("id");
+            }
+
+            return opts;
+        },
+
+        /**
+         * Monitor the original element for changes and update select2 accordingly
+         */
+        // abstract
+        monitorSource: function () {
+            var el = this.opts.element, sync;
+
+            el.bind("change.select2", this.bind(function (e) {
+                if (this.opts.element.data("select2-change-triggered") !== true) {
+                    this.initSelection();
+                }
+            }));
+
+            sync = this.bind(function () {
+
+                var enabled, readonly, self = this;
+
+                // sync enabled state
+
+                enabled = this.opts.element.attr("disabled") !== "disabled";
+                readonly = this.opts.element.attr("readonly") === "readonly";
+
+                enabled = enabled && !readonly;
+
+                if (this.enabled !== enabled) {
+                    if (enabled) {
+                        this.enable();
+                    } else {
+                        this.disable();
+                    }
+                }
+
+
+                syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
+                this.container.addClass(evaluate(this.opts.containerCssClass));
+
+                syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
+                this.dropdown.addClass(evaluate(this.opts.dropdownCssClass));
+
+            });
+
+            // mozilla and IE
+            el.bind("propertychange.select2 DOMAttrModified.select2", sync);
+            // safari and chrome
+            if (typeof WebKitMutationObserver !== "undefined") {
+                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
+                this.propertyObserver = new WebKitMutationObserver(function (mutations) {
+                    mutations.forEach(sync);
+                });
+                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
+            }
+        },
+
+        /**
+         * Triggers the change event on the source element
+         */
+        // abstract
+        triggerChange: function (details) {
+
+            details = details || {};
+            details= $.extend({}, details, { type: "change", val: this.val() });
+            // prevents recursive triggering
+            this.opts.element.data("select2-change-triggered", true);
+            this.opts.element.trigger(details);
+            this.opts.element.data("select2-change-triggered", false);
+
+            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
+            // so here we trigger the click event manually
+            this.opts.element.click();
+
+            // ValidationEngine ignorea the change event and listens instead to blur
+            // so here we trigger the blur event manually if so desired
+            if (this.opts.blurOnChange)
+                this.opts.element.blur();
+        },
+
+        // abstract
+        enable: function() {
+            if (this.enabled) return;
+
+            this.enabled=true;
+            this.container.removeClass("select2-container-disabled");
+            this.opts.element.removeAttr("disabled");
+        },
+
+        // abstract
+        disable: function() {
+            if (!this.enabled) return;
+
+            this.close();
+
+            this.enabled=false;
+            this.container.addClass("select2-container-disabled");
+            this.opts.element.attr("disabled", "disabled");
+        },
+
+        // abstract
+        opened: function () {
+            return this.container.hasClass("select2-dropdown-open");
+        },
+
+        // abstract
+        positionDropdown: function() {
+            var offset = this.container.offset(),
+                height = this.container.outerHeight(false),
+                width = this.container.outerWidth(false),
+                dropHeight = this.dropdown.outerHeight(false),
+	            viewPortRight = $(window).scrollLeft() + $(window).width(),
+                viewportBottom = $(window).scrollTop() + $(window).height(),
+                dropTop = offset.top + height,
+                dropLeft = offset.left,
+                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
+                enoughRoomAbove = (offset.top - dropHeight) >= this.body().scrollTop(),
+	            dropWidth = this.dropdown.outerWidth(false),
+	            enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
+                aboveNow = this.dropdown.hasClass("select2-drop-above"),
+                bodyOffset,
+                above,
+                css;
+
+            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
+            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body().scrollTop(), "enough?", enoughRoomAbove);
+
+            // fix positioning when body has an offset and is not position: static
+
+            if (this.body().css('position') !== 'static') {
+                bodyOffset = this.body().offset();
+                dropTop -= bodyOffset.top;
+                dropLeft -= bodyOffset.left;
+            }
+
+            // always prefer the current above/below alignment, unless there is not enough room
+
+            if (aboveNow) {
+                above = true;
+                if (!enoughRoomAbove && enoughRoomBelow) above = false;
+            } else {
+                above = false;
+                if (!enoughRoomBelow && enoughRoomAbove) above = true;
+            }
+
+            if (!enoughRoomOnRight) {
+               dropLeft = offset.left + width - dropWidth;
+            }
+
+            if (above) {
+                dropTop = offset.top - dropHeight;
+                this.container.addClass("select2-drop-above");
+                this.dropdown.addClass("select2-drop-above");
+            }
+            else {
+                this.container.removeClass("select2-drop-above");
+                this.dropdown.removeClass("select2-drop-above");
+            }
+
+            css = $.extend({
+                top: dropTop,
+                left: dropLeft,
+                width: width
+            }, evaluate(this.opts.dropdownCss));
+
+            this.dropdown.css(css);
+        },
+
+        // abstract
+        shouldOpen: function() {
+            var event;
+
+            if (this.opened()) return false;
+
+            event = $.Event("opening");
+            this.opts.element.trigger(event);
+            return !event.isDefaultPrevented();
+        },
+
+        // abstract
+        clearDropdownAlignmentPreference: function() {
+            // clear the classes used to figure out the preference of where the dropdown should be opened
+            this.container.removeClass("select2-drop-above");
+            this.dropdown.removeClass("select2-drop-above");
+        },
+
+        /**
+         * Opens the dropdown
+         *
+         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
+         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
+         */
+        // abstract
+        open: function () {
+
+            if (!this.shouldOpen()) return false;
+
+            window.setTimeout(this.bind(this.opening), 1);
+
+            return true;
+        },
+
+        /**
+         * Performs the opening of the dropdown
+         */
+        // abstract
+        opening: function() {
+            var cid = this.containerId,
+                scroll = "scroll." + cid,
+                resize = "resize."+cid,
+                orient = "orientationchange."+cid,
+                mask;
+
+            this.clearDropdownAlignmentPreference();
+
+            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");
+
+
+            if(this.dropdown[0] !== this.body().children().last()[0]) {
+                this.dropdown.detach().appendTo(this.body());
+            }
+
+            this.updateResults(true);
+
+            // create the dropdown mask if doesnt already exist
+            mask = $("#select2-drop-mask");
+            if (mask.length == 0) {
+                mask = $(document.createElement("div"));
+                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
+                mask.hide();
+                mask.appendTo(this.body());
+                mask.bind("mousedown touchstart", function (e) {
+                    var dropdown = $("#select2-drop"), self;
+                    if (dropdown.length > 0) {
+                        self=dropdown.data("select2");
+                        if (self.opts.selectOnBlur) {
+                            self.selectHighlighted({noFocus: true});
+                        }
+                        self.close();
+                    }
+                });
+            }
+
+            // ensure the mask is always right before the dropdown
+            if (this.dropdown.prev()[0] !== mask[0]) {
+                this.dropdown.before(mask);
+            }
+
+            // move the global id to the correct dropdown
+            $("#select2-drop").removeAttr("id");
+            this.dropdown.attr("id", "select2-drop");
+
+            // show the elements
+            mask.css({
+                width: document.documentElement.scrollWidth,
+                height: document.documentElement.scrollHeight});
+            mask.show();
+            this.dropdown.show();
+            this.positionDropdown();
+
+            this.dropdown.addClass("select2-drop-active");
+            this.ensureHighlightVisible();
+
+            // attach listeners to events that can change the position of the container and thus require
+            // the position of the dropdown to be updated as well so it does not come unglued from the container
+            var that = this;
+            this.container.parents().add(window).each(function () {
+                $(this).bind(resize+" "+scroll+" "+orient, function (e) {
+                    $("#select2-drop-mask").css({
+                        width:document.documentElement.scrollWidth,
+                        height:document.documentElement.scrollHeight});
+                    that.positionDropdown();
+                });
+            });
+
+            this.focusSearch();
+        },
+
+        // abstract
+        close: function () {
+            if (!this.opened()) return;
+
+            var cid = this.containerId,
+                scroll = "scroll." + cid,
+                resize = "resize."+cid,
+                orient = "orientationchange."+cid;
+
+            // unbind event listeners
+            this.container.parents().add(window).each(function () { $(this).unbind(scroll).unbind(resize).unbind(orient); });
+
+            this.clearDropdownAlignmentPreference();
+
+            $("#select2-drop-mask").hide();
+            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
+            this.dropdown.hide();
+            this.container.removeClass("select2-dropdown-open");
+            this.results.empty();
+            this.clearSearch();
+
+            this.opts.element.trigger($.Event("close"));
+        },
+
+        // abstract
+        clearSearch: function () {
+
+        },
+
+        //abstract
+        getMaximumSelectionSize: function() {
+            return evaluate(this.opts.maximumSelectionSize);
+        },
+
+        // abstract
+        ensureHighlightVisible: function () {
+            var results = this.results, children, index, child, hb, rb, y, more;
+
+            index = this.highlight();
+
+            if (index < 0) return;
+
+            if (index == 0) {
+
+                // if the first element is highlighted scroll all the way to the top,
+                // that way any unselectable headers above it will also be scrolled
+                // into view
+
+                results.scrollTop(0);
+                return;
+            }
+
+            children = this.findHighlightableChoices();
+
+            child = $(children[index]);
+
+            hb = child.offset().top + child.outerHeight(true);
+
+            // if this is the last child lets also make sure select2-more-results is visible
+            if (index === children.length - 1) {
+                more = results.find("li.select2-more-results");
+                if (more.length > 0) {
+                    hb = more.offset().top + more.outerHeight(true);
+                }
+            }
+
+            rb = results.offset().top + results.outerHeight(true);
+            if (hb > rb) {
+                results.scrollTop(results.scrollTop() + (hb - rb));
+            }
+            y = child.offset().top - results.offset().top;
+
+            // make sure the top of the element is visible
+            if (y < 0 && child.css('display') != 'none' ) {
+                results.scrollTop(results.scrollTop() + y); // y is negative
+            }
+        },
+
+        // abstract
+        findHighlightableChoices: function() {
+            var h=this.results.find(".select2-result-selectable:not(.select2-selected):not(.select2-disabled)");
+            return this.results.find(".select2-result-selectable:not(.select2-selected):not(.select2-disabled)");
+        },
+
+        // abstract
+        moveHighlight: function (delta) {
+            var choices = this.findHighlightableChoices(),
+                index = this.highlight();
+
+            while (index > -1 && index < choices.length) {
+                index += delta;
+                var choice = $(choices[index]);
+                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
+                    this.highlight(index);
+                    break;
+                }
+            }
+        },
+
+        // abstract
+        highlight: function (index) {
+            var choices = this.findHighlightableChoices(),
+                choice,
+                data;
+
+            if (arguments.length === 0) {
+                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
+            }
+
+            if (index >= choices.length) index = choices.length - 1;
+            if (index < 0) index = 0;
+
+            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
+
+            choice = $(choices[index]);
+            choice.addClass("select2-highlighted");
+
+            this.ensureHighlightVisible();
+
+            data = choice.data("select2-data");
+            if (data) {
+                this.opts.element.trigger({ type: "highlight", val: this.id(data), choice: data });
+            }
+        },
+
+        // abstract
+        countSelectableResults: function() {
+            return this.findHighlightableChoices().length;
+        },
+
+        // abstract
+        highlightUnderEvent: function (event) {
+            var el = $(event.target).closest(".select2-result-selectable");
+            if (el.length > 0 && !el.is(".select2-highlighted")) {
+        		var choices = this.findHighlightableChoices();
+                this.highlight(choices.index(el));
+            } else if (el.length == 0) {
+                // if we are over an unselectable item remove al highlights
+                this.results.find(".select2-highlighted").removeClass("select2-highlighted");
+            }
+        },
+
+        // abstract
+        loadMoreIfNeeded: function () {
+            var results = this.results,
+                more = results.find("li.select2-more-results"),
+                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
+                offset = -1, // index of first element without data
+                page = this.resultsPage + 1,
+                self=this,
+                term=this.search.val(),
+                context=this.context;
+
+            if (more.length === 0) return;
+            below = more.offset().top - results.offset().top - results.height();
+
+            if (below <= this.opts.loadMorePadding) {
+                more.addClass("select2-active");
+                this.opts.query({
+                        element: this.opts.element,
+                        term: term,
+                        page: page,
+                        context: context,
+                        matcher: this.opts.matcher,
+                        callback: this.bind(function (data) {
+
+                    // ignore a response if the select2 has been closed before it was received
+                    if (!self.opened()) return;
+
+
+                    self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
+
+                    if (data.more===true) {
+                        more.detach().appendTo(results).text(self.opts.formatLoadMore(page+1));
+                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
+                    } else {
+                        more.remove();
+                    }
+                    self.positionDropdown();
+                    self.resultsPage = page;
+                    self.context = data.context;
+                })});
+            }
+        },
+
+        /**
+         * Default tokenizer function which does nothing
+         */
+        tokenize: function() {
+
+        },
+
+        /**
+         * @param initial whether or not this is the call to this method right after the dropdown has been opened
+         */
+        // abstract
+        updateResults: function (initial) {
+            var search = this.search, results = this.results, opts = this.opts, data, self=this, input;
+
+            // if the search is currently hidden we do not alter the results
+            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
+                return;
+            }
+
+            search.addClass("select2-active");
+
+            function postRender() {
+                results.scrollTop(0);
+                search.removeClass("select2-active");
+                self.positionDropdown();
+            }
+
+            function render(html) {
+                results.html(html);
+                postRender();
+            }
+
+            var maxSelSize = this.getMaximumSelectionSize();
+            if (maxSelSize >=1) {
+                data = this.data();
+                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
+            	    render("<li class='select2-selection-limit'>" + opts.formatSelectionTooBig(maxSelSize) + "</li>");
+            	    return;
+                }
+            }
+
+            if (search.val().length < opts.minimumInputLength) {
+                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
+                    render("<li class='select2-no-results'>" + opts.formatInputTooShort(search.val(), opts.minimumInputLength) + "</li>");
+                } else {
+                    render("");
+                }
+                return;
+            }
+            else if (opts.formatSearching() && initial===true) {
+                render("<li class='select2-searching'>" + opts.formatSearching() + "</li>");
+            }
+
+            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
+                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
+                    render("<li class='select2-no-results'>" + opts.formatInputTooLong(search.val(), opts.maximumInputLength) + "</li>");
+                } else {
+                    render("");
+                }
+                return;
+            }
+
+            // give the tokenizer a chance to pre-process the input
+            input = this.tokenize();
+            if (input != undefined && input != null) {
+                search.val(input);
+            }
+
+            this.resultsPage = 1;
+
+            opts.query({
+                element: opts.element,
+                    term: search.val(),
+                    page: this.resultsPage,
+                    context: null,
+                    matcher: opts.matcher,
+                    callback: this.bind(function (data) {
+                var def; // default choice
+
+                // ignore a response if the select2 has been closed before it was received
+                if (!this.opened()) return;
+
+                // save context, if any
+                this.context = (data.context===undefined) ? null : data.context;
+                // create a default choice and prepend it to the list
+                if (this.opts.createSearchChoice && search.val() !== "") {
+                    def = this.opts.createSearchChoice.call(null, search.val(), data.results);
+                    if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
+                        if ($(data.results).filter(
+                            function () {
+                                return equal(self.id(this), self.id(def));
+                            }).length === 0) {
+                            data.results.unshift(def);
+                        }
+                    }
+                }
+
+                if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
+                    render("<li class='select2-no-results'>" + opts.formatNoMatches(search.val()) + "</li>");
+                    return;
+                }
+
+                results.empty();
+                self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});
+
+                if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
+                    results.append("<li class='select2-more-results'>" + self.opts.escapeMarkup(opts.formatLoadMore(this.resultsPage)) + "</li>");
+                    window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
+                }
+
+                this.postprocessResults(data, initial);
+
+                postRender();
+            })});
+        },
+
+        // abstract
+        cancel: function () {
+            this.close();
+        },
+
+        // abstract
+        blur: function () {
+            // if selectOnBlur == true, select the currently highlighted option
+            if (this.opts.selectOnBlur)
+                this.selectHighlighted({noFocus: true});
+
+            this.close();
+            this.container.removeClass("select2-container-active");
+            // synonymous to .is(':focus'), which is available in jquery >= 1.6
+            if (this.search[0] === document.activeElement) { this.search.blur(); }
+            this.clearSearch();
+            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
+        },
+
+        // abstract
+        focusSearch: function () {
+            focus(this.search);
+        },
+
+        // abstract
+        selectHighlighted: function (options) {
+            var index=this.highlight(),
+                highlighted=this.results.find(".select2-highlighted"),
+                data = highlighted.closest('.select2-result').data("select2-data");
+
+            if (data) {
+                this.highlight(index);
+                this.onSelect(data, options);
+            }
+        },
+
+        // abstract
+        getPlaceholder: function () {
+            return this.opts.element.attr("placeholder") ||
+                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
+                this.opts.element.data("placeholder") ||
+                this.opts.placeholder;
+        },
+
+        /**
+         * Get the desired width for the container element.  This is
+         * derived first from option `width` passed to select2, then
+         * the inline 'style' on the original element, and finally
+         * falls back to the jQuery calculated element width.
+         */
+        // abstract
+        initContainerWidth: function () {
+            function resolveContainerWidth() {
+                var style, attrs, matches, i, l;
+
+                if (this.opts.width === "off") {
+                    return null;
+                } else if (this.opts.width === "element"){
+                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
+                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
+                    // check if there is inline style on the element that contains width
+                    style = this.opts.element.attr('style');
+                    if (style !== undefined) {
+                        attrs = style.split(';');
+                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
+                            matches = attrs[i].replace(/\s/g, '')
+                                .match(/width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/);
+                            if (matches !== null && matches.length >= 1)
+                                return matches[1];
+                        }
+                    }
+
+                    if (this.opts.width === "resolve") {
+                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
+                        // when attached to input type=hidden or elements hidden via css
+                        style = this.opts.element.css('width');
+                        if (style.indexOf("%") > 0) return style;
+
+                        // finally, fallback on the calculated width of the element
+                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
+                    }
+
+                    return null;
+                } else if ($.isFunction(this.opts.width)) {
+                    return this.opts.width();
+                } else {
+                    return this.opts.width;
+               }
+            };
+
+            var width = resolveContainerWidth.call(this);
+            if (width !== null) {
+                this.container.css("width", width);
+            }
+        }
+    });
+
+    SingleSelect2 = clazz(AbstractSelect2, {
+
+        // single
+
+		createContainer: function () {
+            var container = $(document.createElement("div")).attr({
+                "class": "select2-container"
+            }).html([
+                "<a href='javascript:void(0)' onclick='return false;' class='select2-choice' tabindex='-1'>",
+                "   <span></span><abbr class='select2-search-choice-close' style='display:none;'></abbr>",
+                "   <div><b></b></div>" ,
+                "</a>",
+                "<input class='select2-focusser select2-offscreen' type='text'/>",
+                "<div class='select2-drop' style='display:none'>" ,
+                "   <div class='select2-search'>" ,
+                "       <input type='text' autocomplete='off' class='select2-input'/>" ,
+                "   </div>" ,
+                "   <ul class='select2-results'>" ,
+                "   </ul>" ,
+                "</div>"].join(""));
+            return container;
+        },
+
+        // single
+        disable: function() {
+            if (!this.enabled) return;
+
+            this.parent.disable.apply(this, arguments);
+
+            this.focusser.attr("disabled", "disabled");
+        },
+
+        // single
+        enable: function() {
+            if (this.enabled) return;
+
+            this.parent.enable.apply(this, arguments);
+
+            this.focusser.removeAttr("disabled");
+        },
+
+        // single
+        opening: function () {
+            this.parent.opening.apply(this, arguments);
+            this.focusser.attr("disabled", "disabled");
+
+            this.opts.element.trigger($.Event("open"));
+        },
+
+        // single
+        close: function () {
+            if (!this.opened()) return;
+            this.parent.close.apply(this, arguments);
+            this.focusser.removeAttr("disabled");
+            focus(this.focusser);
+        },
+
+        // single
+        focus: function () {
+            if (this.opened()) {
+                this.close();
+            } else {
+                this.focusser.removeAttr("disabled");
+                this.focusser.focus();
+            }
+        },
+
+        // single
+        isFocused: function () {
+            return this.container.hasClass("select2-container-active");
+        },
+
+        // single
+        cancel: function () {
+            this.parent.cancel.apply(this, arguments);
+            this.focusser.removeAttr("disabled");
+            this.focusser.focus();
+        },
+
+        // single
+        initContainer: function () {
+
+            var selection,
+                container = this.container,
+                dropdown = this.dropdown,
+                clickingInside = false;
+
+            this.showSearch(this.opts.minimumResultsForSearch >= 0);
+
+            this.selection = selection = container.find(".select2-choice");
+
+            this.focusser = container.find(".select2-focusser");
+
+            this.search.bind("keydown", this.bind(function (e) {
+                if (!this.enabled) return;
+
+                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
+                    // prevent the page from scrolling
+                    killEvent(e);
+                    return;
+                }
+
+                switch (e.which) {
+                    case KEY.UP:
+                    case KEY.DOWN:
+                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
+                        killEvent(e);
+                        return;
+                    case KEY.TAB:
+                    case KEY.ENTER:
+                        this.selectHighlighted();
+                        killEvent(e);
+                        return;
+                    case KEY.ESC:
+                        this.cancel(e);
+                        killEvent(e);
+                        return;
+                }
+            }));
+
+            this.focusser.bind("keydown", this.bind(function (e) {
+                if (!this.enabled) return;
+
+                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
+                    return;
+                }
+
+                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
+                    killEvent(e);
+                    return;
+                }
+
+                if (e.which == KEY.DOWN || e.which == KEY.UP
+                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {
+                    this.open();
+                    killEvent(e);
+                    return;
+                }
+
+                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
+                    if (this.opts.allowClear) {
+                        this.clear();
+                    }
+                    killEvent(e);
+                    return;
+                }
+            }));
+
+
+            installKeyUpChangeEvent(this.focusser);
+            this.focusser.bind("keyup-change input", this.bind(function(e) {
+                if (this.opened()) return;
+                this.open();
+                if (this.showSearchInput !== false) {
+                    this.search.val(this.focusser.val());
+                }
+                this.focusser.val("");
+                killEvent(e);
+            }));
+
+            selection.delegate("abbr", "mousedown", this.bind(function (e) {
+                if (!this.enabled) return;
+                this.clear();
+                killEventImmediately(e);
+                this.close();
+                this.selection.focus();
+            }));
+
+            selection.bind("mousedown", this.bind(function (e) {
+                clickingInside = true;
+
+                if (this.opened()) {
+                    this.close();
+                } else if (this.enabled) {
+                    this.open();
+                }
+
+                killEvent(e);
+
+                clickingInside = false;
+            }));
+
+            dropdown.bind("mousedown", this.bind(function() { this.search.focus(); }));
+
+            selection.bind("focus", this.bind(function(e) {
+                killEvent(e);
+            }));
+
+            this.focusser.bind("focus", this.bind(function(){
+                this.container.addClass("select2-container-active");
+            })).bind("blur", this.bind(function() {
+                if (!this.opened()) {
+                    this.container.removeClass("select2-container-active");
+                }
+            }));
+            this.search.bind("focus", this.bind(function(){
+                this.container.addClass("select2-container-active");
+            }))
+
+            this.initContainerWidth();
+            this.setPlaceholder();
+
+        },
+
+        // single
+        clear: function() {
+            var data=this.selection.data("select2-data");
+            this.opts.element.val("");
+            this.selection.find("span").empty();
+            this.selection.removeData("select2-data");
+            this.setPlaceholder();
+
+            this.opts.element.trigger({ type: "removed", val: this.id(data), choice: data });
+            this.triggerChange({removed:data});
+        },
+
+        /**
+         * Sets selection based on source element's value
+         */
+        // single
+        initSelection: function () {
+            var selected;
+            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
+                this.close();
+                this.setPlaceholder();
+            } else {
+                var self = this;
+                this.opts.initSelection.call(null, this.opts.element, function(selected){
+                    if (selected !== undefined && selected !== null) {
+                        self.updateSelection(selected);
+                        self.close();
+                        self.setPlaceholder();
+                    }
+                });
+            }
+        },
+
+        // single
+        prepareOpts: function () {
+            var opts = this.parent.prepareOpts.apply(this, arguments);
+
+            if (opts.element.get(0).tagName.toLowerCase() === "select") {
+                // install the selection initializer
+                opts.initSelection = function (element, callback) {
+                    var selected = element.find(":selected");
+                    // a single select box always has a value, no need to null check 'selected'
+                    if ($.isFunction(callback))
+                        callback({id: selected.attr("value"), text: selected.text(), element:selected});
+                };
+            } else if ("data" in opts) {
+                // install default initSelection when applied to hidden input and data is local
+                opts.initSelection = opts.initSelection || function (element, callback) {
+                    var id = element.val();
+                    //search in data by id
+                    opts.query({
+                        matcher: function(term, text, el){
+                            return equal(id, opts.id(el));
+                        },
+                        callback: !$.isFunction(callback) ? $.noop : function(filtered) {
+                            callback(filtered.results.length ? filtered.results[0] : null);
+                        }
+                    });
+                };
+            }
+
+            return opts;
+        },
+
+        // single
+        getPlaceholder: function() {
+            // if a placeholder is specified on a single select without the first empty option ignore it
+            if (this.select) {
+                if (this.select.find("option").first().text() !== "") {
+                    return undefined;
+                }
+            }
+
+            return this.parent.getPlaceholder.apply(this, arguments);
+        },
+
+        // single
+        setPlaceholder: function () {
+            var placeholder = this.getPlaceholder();
+
+            if (this.opts.element.val() === "" && placeholder !== undefined) {
+
+                // check for a first blank option if attached to a select
+                if (this.select && this.select.find("option:first").text() !== "") return;
+
+                this.selection.find("span").html(this.opts.escapeMarkup(placeholder));
+
+                this.selection.addClass("select2-default");
+
+                this.selection.find("abbr").hide();
+            }
+        },
+
+        // single
+        postprocessResults: function (data, initial) {
+            var selected = 0, self = this, showSearchInput = true;
+
+            // find the selected element in the result list
+
+            this.findHighlightableChoices().each2(function (i, elm) {
+                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
+                    selected = i;
+                    return false;
+                }
+            });
+
+            // and highlight it
+
+            this.highlight(selected);
+
+            // hide the search box if this is the first we got the results and there are a few of them
+
+            if (initial === true) {
+                var min=this.opts.minimumResultsForSearch;
+                showSearchInput  = min < 0 ? false : countResults(data.results) >= min;
+                this.showSearch(showSearchInput);
+            }
+
+        },
+
+        // single
+        showSearch: function(showSearchInput) {
+            this.showSearchInput = showSearchInput;
+
+            this.dropdown.find(".select2-search")[showSearchInput ? "removeClass" : "addClass"]("select2-search-hidden");
+            //add "select2-with-searchbox" to the container if search box is shown
+            $(this.dropdown, this.container)[showSearchInput ? "addClass" : "removeClass"]("select2-with-searchbox");
+        },
+
+        // single
+        onSelect: function (data, options) {
+            var old = this.opts.element.val();
+
+            this.opts.element.val(this.id(data));
+            this.updateSelection(data);
+
+            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });
+
+            this.close();
+
+            if (!options || !options.noFocus)
+                this.selection.focus();
+
+            if (!equal(old, this.id(data))) { this.triggerChange(); }
+        },
+
+        // single
+        updateSelection: function (data) {
+
+            var container=this.selection.find("span"), formatted;
+
+            this.selection.data("select2-data", data);
+
+            container.empty();
+            formatted=this.opts.formatSelection(data, container);
+            if (formatted !== undefined) {
+                container.append(this.opts.escapeMarkup(formatted));
+            }
+
+            this.selection.removeClass("select2-default");
+
+            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
+                this.selection.find("abbr").show();
+            }
+        },
+
+        // single
+        val: function () {
+            var val, triggerChange = false, data = null, self = this;
+
+            if (arguments.length === 0) {
+                return this.opts.element.val();
+            }
+
+            val = arguments[0];
+
+            if (arguments.length > 1) {
+                triggerChange = arguments[1];
+            }
+
+            if (this.select) {
+                this.select
+                    .val(val)
+                    .find(":selected").each2(function (i, elm) {
+                        data = {id: elm.attr("value"), text: elm.text()};
+                        return false;
+                    });
+                this.updateSelection(data);
+                this.setPlaceholder();
+                if (triggerChange) {
+                    this.triggerChange();
+                }
+            } else {
+                if (this.opts.initSelection === undefined) {
+                    throw new Error("cannot call val() if initSelection() is not defined");
+                }
+                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
+                if (!val && val !== 0) {
+                    this.clear();
+                    if (triggerChange) {
+                        this.triggerChange();
+                    }
+                    return;
+                }
+                this.opts.element.val(val);
+                this.opts.initSelection(this.opts.element, function(data){
+                    self.opts.element.val(!data ? "" : self.id(data));
+                    self.updateSelection(data);
+                    self.setPlaceholder();
+                    if (triggerChange) {
+                        self.triggerChange();
+                    }
+                });
+            }
+        },
+
+        // single
+        clearSearch: function () {
+            this.search.val("");
+            this.focusser.val("");
+        },
+
+        // single
+        data: function(value) {
+            var data;
+
+            if (arguments.length === 0) {
+                data = this.selection.data("select2-data");
+                if (data == undefined) data = null;
+                return data;
+            } else {
+                if (!value || value === "") {
+                    this.clear();
+                } else {
+                    this.opts.element.val(!value ? "" : this.id(value));
+                    this.updateSelection(value);
+                }
+            }
+        }
+    });
+
+    MultiSelect2 = clazz(AbstractSelect2, {
+
+        // multi
+        createContainer: function () {
+            var container = $(document.createElement("div")).attr({
+                "class": "select2-container select2-container-multi"
+            }).html([
+                "    <ul class='select2-choices'>",
+                //"<li class='select2-search-choice'><span>California</span><a href="javascript:void(0)" class="select2-search-choice-close"></a></li>" ,
+                "  <li class='select2-search-field'>" ,
+                "    <input type='text' autocomplete='off' class='select2-input'>" ,
+                "  </li>" ,
+                "</ul>" ,
+                "<div class='select2-drop select2-drop-multi' style='display:none;'>" ,
+                "   <ul class='select2-results'>" ,
+                "   </ul>" ,
+                "</div>"].join(""));
+			return container;
+        },
+
+        // multi
+        prepareOpts: function () {
+            var opts = this.parent.prepareOpts.apply(this, arguments);
+
+            // TODO validate placeholder is a string if specified
+
+            if (opts.element.get(0).tagName.toLowerCase() === "select") {
+                // install sthe selection initializer
+                opts.initSelection = function (element, callback) {
+
+                    var data = [];
+
+                    element.find(":selected").each2(function (i, elm) {
+                        data.push({id: elm.attr("value"), text: elm.text(), element: elm[0]});
+                    });
+                    callback(data);
+                };
+            } else if ("data" in opts) {
+                // install default initSelection when applied to hidden input and data is local
+                opts.initSelection = opts.initSelection || function (element, callback) {
+                    var ids = splitVal(element.val(), opts.separator);
+                    //search in data by array of ids
+                    opts.query({
+                        matcher: function(term, text, el){
+                            return $.grep(ids, function(id) {
+                                return equal(id, opts.id(el));
+                            }).length;
+                        },
+                        callback: !$.isFunction(callback) ? $.noop : function(filtered) {
+                            callback(filtered.results);
+                        }
+                    });
+                };
+            }
+
+            return opts;
+        },
+
+        // multi
+        initContainer: function () {
+
+            var selector = ".select2-choices", selection;
+
+            this.searchContainer = this.container.find(".select2-search-field");
+            this.selection = selection = this.container.find(selector);
+
+            this.search.bind("input paste", this.bind(function() {
+                if (!this.enabled) return;
+                if (!this.opened()) {
+                    this.open();
+                }
+            }));
+
+            this.search.bind("keydown", this.bind(function (e) {
+                if (!this.enabled) return;
+
+                if (e.which === KEY.BACKSPACE && this.search.val() === "") {
+                    this.close();
+
+                    var choices,
+                        selected = selection.find(".select2-search-choice-focus");
+                    if (selected.length > 0) {
+                        this.unselect(selected.first());
+                        this.search.width(10);
+                        killEvent(e);
+                        return;
+                    }
+
+                    choices = selection.find(".select2-search-choice:not(.select2-locked)");
+                    if (choices.length > 0) {
+                        choices.last().addClass("select2-search-choice-focus");
+                    }
+                } else {
+                    selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
+                }
+
+                if (this.opened()) {
+                    switch (e.which) {
+                    case KEY.UP:
+                    case KEY.DOWN:
+                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
+                        killEvent(e);
+                        return;
+                    case KEY.ENTER:
+                    case KEY.TAB:
+                        this.selectHighlighted();
+                        killEvent(e);
+                        return;
+                    case KEY.ESC:
+                        this.cancel(e);
+                        killEvent(e);
+                        return;
+                    }
+                }
+
+                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
+                 || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
+                    return;
+                }
+
+                if (e.which === KEY.ENTER) {
+                    if (this.opts.openOnEnter === false) {
+                        return;
+                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
+                        return;
+                    }
+                }
+
+                this.open();
+
+                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
+                    // prevent the page from scrolling
+                    killEvent(e);
+                }
+            }));
+
+            this.search.bind("keyup", this.bind(this.resizeSearch));
+
+            this.search.bind("blur", this.bind(function(e) {
+                this.container.removeClass("select2-container-active");
+                this.search.removeClass("select2-focused");
+                if (!this.opened()) this.clearSearch();
+                e.stopImmediatePropagation();
+            }));
+
+            this.container.delegate(selector, "mousedown", this.bind(function (e) {
+                if (!this.enabled) return;
+                if ($(e.target).closest(".select2-search-choice").length > 0) {
+                    // clicked inside a select2 search choice, do not open
+                    return;
+                }
+                this.clearPlaceholder();
+                this.open();
+                this.focusSearch();
+                e.preventDefault();
+            }));
+
+            this.container.delegate(selector, "focus", this.bind(function () {
+                if (!this.enabled) return;
+                this.container.addClass("select2-container-active");
+                this.dropdown.addClass("select2-drop-active");
+                this.clearPlaceholder();
+            }));
+
+            this.initContainerWidth();
+
+            // set the placeholder if necessary
+            this.clearSearch();
+        },
+
+        // multi
+        enable: function() {
+            if (this.enabled) return;
+
+            this.parent.enable.apply(this, arguments);
+
+            this.search.removeAttr("disabled");
+        },
+
+        // multi
+        disable: function() {
+            if (!this.enabled) return;
+
+            this.parent.disable.apply(this, arguments);
+
+            this.search.attr("disabled", true);
+        },
+
+        // multi
+        initSelection: function () {
+            var data;
+            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
+                this.updateSelection([]);
+                this.close();
+                // set the placeholder if necessary
+                this.clearSearch();
+            }
+            if (this.select || this.opts.element.val() !== "") {
+                var self = this;
+                this.opts.initSelection.call(null, this.opts.element, function(data){
+                    if (data !== undefined && data !== null) {
+                        self.updateSelection(data);
+                        self.close();
+                        // set the placeholder if necessary
+                        self.clearSearch();
+                    }
+                });
+            }
+        },
+
+        // multi
+        clearSearch: function () {
+            var placeholder = this.getPlaceholder();
+
+            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
+                this.search.val(placeholder).addClass("select2-default");
+                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
+                this.resizeSearch();
+            } else {
+                this.search.val("").width(10);
+            }
+        },
+
+        // multi
+        clearPlaceholder: function () {
+            if (this.search.hasClass("select2-default")) {
+                this.search.val("").removeClass("select2-default");
+            }
+        },
+
+        // multi
+        opening: function () {
+            this.parent.opening.apply(this, arguments);
+
+            this.clearPlaceholder();
+			this.resizeSearch();
+            this.focusSearch();
+
+            this.opts.element.trigger($.Event("open"));
+        },
+
+        // multi
+        close: function () {
+            if (!this.opened()) return;
+            this.parent.close.apply(this, arguments);
+        },
+
+        // multi
+        focus: function () {
+            this.close();
+            this.search.focus();
+            this.opts.element.triggerHandler("focus");
+        },
+
+        // multi
+        isFocused: function () {
+            return this.search.hasClass("select2-focused");
+        },
+
+        // multi
+        updateSelection: function (data) {
+            var ids = [], filtered = [], self = this;
+
+            // filter out duplicates
+            $(data).each(function () {
+                if (indexOf(self.id(this), ids) < 0) {
+                    ids.push(self.id(this));
+                    filtered.push(this);
+                }
+            });
+            data = filtered;
+
+            this.selection.find(".select2-search-choice").remove();
+            $(data).each(function () {
+                self.addSelectedChoice(this);
+            });
+            self.postprocessResults();
+        },
+
+        tokenize: function() {
+            var input = this.search.val();
+            input = this.opts.tokenizer(input, this.data(), this.bind(this.onSelect), this.opts);
+            if (input != null && input != undefined) {
+                this.search.val(input);
+                if (input.length > 0) {
+                    this.open();
+                }
+            }
+
+        },
+
+        // multi
+        onSelect: function (data, options) {
+            this.addSelectedChoice(data);
+
+            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });
+
+            if (this.select || !this.opts.closeOnSelect) this.postprocessResults();
+
+            if (this.opts.closeOnSelect) {
+                this.close();
+                this.search.width(10);
+            } else {
+                if (this.countSelectableResults()>0) {
+                    this.search.width(10);
+                    this.resizeSearch();
+                    if (this.val().length >= this.getMaximumSelectionSize()) {
+                        // if we reached max selection size repaint the results so choices
+                        // are replaced with the max selection reached message
+                        this.updateResults(true);
+                    }
+                    this.positionDropdown();
+                } else {
+                    // if nothing left to select close
+                    this.close();
+                    this.search.width(10);
+                }
+            }
+
+            // since its not possible to select an element that has already been
+            // added we do not need to check if this is a new element before firing change
+            this.triggerChange({ added: data });
+
+            if (!options || !options.noFocus)
+                this.focusSearch();
+        },
+
+        // multi
+        cancel: function () {
+            this.close();
+            this.focusSearch();
+        },
+
+        addSelectedChoice: function (data) {
+            var enableChoice = !data.locked,
+                enabledItem = $(
+                    "<li class='select2-search-choice'>" +
+                    "    <div></div>" +
+                    "    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a>" +
+                    "</li>"),
+                disabledItem = $(
+                    "<li class='select2-search-choice select2-locked'>" +
+                    "<div></div>" +
+                    "</li>");
+            var choice = enableChoice ? enabledItem : disabledItem,
+                id = this.id(data),
+                val = this.getVal(),
+                formatted;
+
+            formatted=this.opts.formatSelection(data, choice.find("div"));
+            if (formatted != undefined) {
+                choice.find("div").replaceWith("<div>"+this.opts.escapeMarkup(formatted)+"</div>");
+            }
+
+            if(enableChoice){
+              choice.find(".select2-search-choice-close")
+                  .bind("mousedown", killEvent)
+                  .bind("click dblclick", this.bind(function (e) {
+                  if (!this.enabled) return;
+
+                  $(e.target).closest(".select2-search-choice").fadeOut('fast', this.bind(function(){
+                      this.unselect($(e.target));
+                      this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
+                      this.close();
+                      this.focusSearch();
+                  })).dequeue();
+                  killEvent(e);
+              })).bind("focus", this.bind(function () {
+                  if (!this.enabled) return;
+                  this.container.addClass("select2-container-active");
+                  this.dropdown.addClass("select2-drop-active");
+              }));
+            }
+
+            choice.data("select2-data", data);
+            choice.insertBefore(this.searchContainer);
+
+            val.push(id);
+            this.setVal(val);
+        },
+
+        // multi
+        unselect: function (selected) {
+            var val = this.getVal(),
+                data,
+                index;
+
+            selected = selected.closest(".select2-search-choice");
+
+            if (selected.length === 0) {
+                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
+            }
+
+            data = selected.data("select2-data");
+
+            if (!data) {
+                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
+                // and invoked on an element already removed
+                return;
+            }
+
+            index = indexOf(this.id(data), val);
+
+            if (index >= 0) {
+                val.splice(index, 1);
+                this.setVal(val);
+                if (this.select) this.postprocessResults();
+            }
+            selected.remove();
+
+            this.opts.element.trigger({ type: "removed", val: this.id(data), choice: data });
+            this.triggerChange({ removed: data });
+        },
+
+        // multi
+        postprocessResults: function () {
+            var val = this.getVal(),
+                choices = this.results.find(".select2-result"),
+                compound = this.results.find(".select2-result-with-children"),
+                self = this;
+
+            choices.each2(function (i, choice) {
+                var id = self.id(choice.data("select2-data"));
+                if (indexOf(id, val) >= 0) {
+                    choice.addClass("select2-selected");
+                    // mark all children of the selected parent as selected
+                    choice.find(".select2-result-selectable").addClass("select2-selected");
+                }
+            });
+
+            compound.each2(function(i, choice) {
+                // hide an optgroup if it doesnt have any selectable children
+                if (!choice.is('.select2-result-selectable')
+                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
+                    choice.addClass("select2-selected");
+                }
+            });
+
+            if (this.highlight() == -1){
+                self.highlight(0);
+            }
+
+        },
+
+        // multi
+        resizeSearch: function () {
+            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
+            	sideBorderPadding = getSideBorderPadding(this.search);
+
+            minimumWidth = measureTextWidth(this.search) + 10;
+
+            left = this.search.offset().left;
+
+            maxWidth = this.selection.width();
+            containerLeft = this.selection.offset().left;
+
+            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;
+
+            if (searchWidth < minimumWidth) {
+                searchWidth = maxWidth - sideBorderPadding;
+            }
+
+            if (searchWidth < 40) {
+                searchWidth = maxWidth - sideBorderPadding;
+            }
+
+            if (searchWidth <= 0) {
+              searchWidth = minimumWidth;
+            }
+
+            this.search.width(searchWidth);
+        },
+
+        // multi
+        getVal: function () {
+            var val;
+            if (this.select) {
+                val = this.select.val();
+                return val === null ? [] : val;
+            } else {
+                val = this.opts.element.val();
+                return splitVal(val, this.opts.separator);
+            }
+        },
+
+        // multi
+        setVal: function (val) {
+            var unique;
+            if (this.select) {
+                this.select.val(val);
+            } else {
+                unique = [];
+                // filter out duplicates
+                $(val).each(function () {
+                    if (indexOf(this, unique) < 0) unique.push(this);
+                });
+                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
+            }
+        },
+
+        // multi
+        val: function () {
+            var val, triggerChange = false, data = [], self=this;
+
+            if (arguments.length === 0) {
+                return this.getVal();
+            }
+
+            val = arguments[0];
+
+            if (arguments.length > 1) {
+                triggerChange = arguments[1];
+            }
+
+            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
+            if (!val && val !== 0) {
+                this.opts.element.val("");
+                this.updateSelection([]);
+                this.clearSearch();
+                if (triggerChange) {
+                    this.triggerChange();
+                }
+                return;
+            }
+
+            // val is a list of ids
+            this.setVal(val);
+
+            if (this.select) {
+                this.opts.initSelection(this.select, this.bind(this.updateSelection));
+                if (triggerChange) {
+                    this.triggerChange();
+                }
+            } else {
+                if (this.opts.initSelection === undefined) {
+                    throw new Error("val() cannot be called if initSelection() is not defined");
+                }
+
+                this.opts.initSelection(this.opts.element, function(data){
+                    var ids=$(data).map(self.id);
+                    self.setVal(ids);
+                    self.updateSelection(data);
+                    self.clearSearch();
+                    if (triggerChange) {
+                        self.triggerChange();
+                    }
+                });
+            }
+            this.clearSearch();
+        },
+
+        // multi
+        onSortStart: function() {
+            if (this.select) {
+                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
+            }
+
+            // collapse search field into 0 width so its container can be collapsed as well
+            this.search.width(0);
+            // hide the container
+            this.searchContainer.hide();
+        },
+
+        // multi
+        onSortEnd:function() {
+
+            var val=[], self=this;
+
+            // show search and move it to the end of the list
+            this.searchContainer.show();
+            // make sure the search container is the last item in the list
+            this.searchContainer.appendTo(this.searchContainer.parent());
+            // since we collapsed the width in dragStarted, we resize it here
+            this.resizeSearch();
+
+            // update selection
+
+            this.selection.find(".select2-search-choice").each(function() {
+                val.push(self.opts.id($(this).data("select2-data")));
+            });
+            this.setVal(val);
+            this.triggerChange();
+        },
+
+        // multi
+        data: function(values) {
+            var self=this, ids;
+            if (arguments.length === 0) {
+                 return this.selection
+                     .find(".select2-search-choice")
+                     .map(function() { return $(this).data("select2-data"); })
+                     .get();
+            } else {
+                if (!values) { values = []; }
+                ids = $.map(values, function(e) { return self.opts.id(e); });
+                this.setVal(ids);
+                this.updateSelection(values);
+                this.clearSearch();
+            }
+        }
+    });
+
+    $.fn.select2 = function () {
+
+        var args = Array.prototype.slice.call(arguments, 0),
+            opts,
+            select2,
+            value, multiple, allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "onSortStart", "onSortEnd", "enable", "disable", "positionDropdown", "data"];
+
+        this.each(function () {
+            if (args.length === 0 || typeof(args[0]) === "object") {
+                opts = args.length === 0 ? {} : $.extend({}, args[0]);
+                opts.element = $(this);
+
+                if (opts.element.get(0).tagName.toLowerCase() === "select") {
+                    multiple = opts.element.attr("multiple");
+                } else {
+                    multiple = opts.multiple || false;
+                    if ("tags" in opts) {opts.multiple = multiple = true;}
+                }
+
+                select2 = multiple ? new MultiSelect2() : new SingleSelect2();
+                select2.init(opts);
+            } else if (typeof(args[0]) === "string") {
+
+                if (indexOf(args[0], allowedMethods) < 0) {
+                    throw "Unknown method: " + args[0];
+                }
+
+                value = undefined;
+                select2 = $(this).data("select2");
+                if (select2 === undefined) return;
+                if (args[0] === "container") {
+                    value=select2.container;
+                } else {
+                    value = select2[args[0]].apply(select2, args.slice(1));
+                }
+                if (value !== undefined) {return false;}
+            } else {
+                throw "Invalid arguments to select2 plugin: " + args;
+            }
+        });
+        return (value === undefined) ? this : value;
+    };
+
+    // plugin defaults, accessible to users
+    $.fn.select2.defaults = {
+        width: "copy",
+        loadMorePadding: 0,
+        closeOnSelect: true,
+        openOnEnter: true,
+        containerCss: {},
+        dropdownCss: {},
+        containerCssClass: "",
+        dropdownCssClass: "",
+        formatResult: function(result, container, query, escapeMarkup) {
+            var markup=[];
+            markMatch(result.text, query.term, markup, escapeMarkup);
+            return markup.join("");
+        },
+        formatSelection: function (data, container) {
+            return data ? data.text : undefined;
+        },
+        sortResults: function (results, container, query) {
+            return results;
+        },
+        formatResultCssClass: function(data) {return undefined;},
+        formatNoMatches: function () { return "No matches found"; },
+        formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " more character" + (n == 1? "" : "s"); },
+        formatInputTooLong: function (input, max) { var n = input.length - max; return "Please enter " + n + " less character" + (n == 1? "" : "s"); },
+        formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
+        formatLoadMore: function (pageNumber) { return "Loading more results..."; },
+        formatSearching: function () { return "Searching..."; },
+        minimumResultsForSearch: 0,
+        minimumInputLength: 0,
+        maximumInputLength: null,
+        maximumSelectionSize: 0,
+        id: function (e) { return e.id; },
+        matcher: function(term, text) {
+            return text.toUpperCase().indexOf(term.toUpperCase()) >= 0;
+        },
+        separator: ",",
+        tokenSeparators: [],
+        tokenizer: defaultTokenizer,
+        escapeMarkup: function (markup) {
+            var replace_map = {
+                '\\': '&#92;',
+                '&': '&amp;',
+                '<': '&lt;',
+                '>': '&gt;',
+                '"': '&quot;',
+                "'": '&apos;',
+                "/": '&#47;'
+            };
+
+            return String(markup).replace(/[&<>"'/\\]/g, function (match) {
+                    return replace_map[match[0]];
+            });
+        },
+        blurOnChange: false,
+        selectOnBlur: false,
+        adaptContainerCssClass: function(c) { return c; },
+        adaptDropdownCssClass: function(c) { return null; }
+    };
+
+}(jQuery));
+} );
diff --git a/public/js_src/external_libs/tax_meta_class.js b/public/js_src/external_libs/tax_meta_class.js
new file mode 100644
index 0000000..6f7f03a
--- /dev/null
+++ b/public/js_src/external_libs/tax_meta_class.js
@@ -0,0 +1,306 @@
+define(
+		[
+		 "jquery_timely",
+		 "domReady"
+		 ],
+		 function( $, domReady ) {
+	function update_repeater_fields(){
+
+
+		/**
+		 * Datepicker Field.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-date').each( function() {
+
+			var $this  = $(this),
+			format = $this.attr('rel');
+
+			$this.datepicker( { showButtonPanel: true, dateFormat: format } );
+
+		});
+
+		/**
+		 * Timepicker Field.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-time').each( function() {
+
+			var $this   = $(this),
+			format   = $this.attr('rel');
+
+			$this.timepicker( { showSecond: true, timeFormat: format } );
+
+		});
+
+		/**
+		 * Colorpicker Field.
+		 *
+		 * @since 1.0
+		 */
+		/*
+
+
+
+/**
+		 * Select Color Field.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-color-select').click( function(){
+			var $this = $(this);
+			var id = $this.attr('rel');
+			$(this).siblings('.at-color-picker').farbtastic("#" + id).toggle();
+			return false;
+		});
+
+		/**
+		 * Delete File.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-upload').delegate( '.at-delete-file', 'click' , function() {
+
+			var $this   = $(this),
+			$parent = $this.parent(),
+			data = $this.attr('rel');
+
+			$.post( ajaxurl, { action: 'at_delete_file', data: data }, function(response) {
+				response == '0' ? ( alert( 'File has been successfully deleted.' ), $parent.remove() ) : alert( 'You do NOT have permission to delete this file.' );
+			});
+
+			return false;
+
+		});
+
+		/**
+		 * Reorder Images.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-images').each( function() {
+
+			var $this = $(this), order, data;
+
+			$this.sortable( {
+				placeholder: 'ui-state-highlight',
+				update: function (){
+					order = $this.sortable('serialize');
+					data   = order + '|' + $this.siblings('.at-images-data').val();
+
+					$.post(ajaxurl, {action: 'at_reorder_images', data: data}, function(response){
+						response == '0' ? alert( 'Order saved!' ) : alert( "You don't have permission to reorder images." );
+					});
+				}
+			});
+
+		});
+
+	}
+	domReady( function() {
+
+		/**
+		 * repater Field
+		 * @since 1.1
+		 */
+		/*$( ".at-repeater-item" ).live('click', function() {
+		    var $this  = $(this);
+		    $this.siblings().toggle();
+		  });
+		  jQuery(".at-repater-block").click(function(){
+		    jQuery(this).find('table').toggle();
+		  });
+
+		 */
+		//edit
+		$( document ).on('click', ".at-re-toggle", function() {
+			$(this).prev().toggle('slow');
+		});
+
+
+		/**
+		 * Datepicker Field.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-date').each( function() {
+
+			var $this  = $(this),
+			format = $this.attr('rel');
+
+			$this.datepicker( { showButtonPanel: true, dateFormat: format } );
+
+		});
+
+		/**
+		 * Timepicker Field.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-time').each( function() {
+
+			var $this   = $(this),
+			format   = $this.attr('rel');
+
+			$this.timepicker( { showSecond: true, timeFormat: format } );
+
+		});
+
+		/**
+		 * Colorpicker Field.
+		 *
+		 * @since 1.0
+		 * better handler for color picker with repeater fields support
+		 * which now works both when button is clicked and when field gains focus.
+		 */
+		$(document).on('focus', '.at-color', function() {
+			var $this = $(this);
+			$(this).siblings('.at-color-picker').farbtastic($this).toggle();
+		});
+
+		$(document).on('focusout', '.at-color', function() {
+			var $this = $(this);
+			$(this).siblings('.at-color-picker').farbtastic($this).toggle();
+		});
+
+		/**
+		 * Add Files.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-add-file').click( function() {
+			var $first = $(this).parent().find('.file-input:first');
+			$first.clone().insertAfter($first).show();
+			return false;
+		});
+
+		/**
+		 * Delete File.
+		 *
+		 * @since 1.0
+		 */
+		$('.at-upload').delegate( '.at-delete-file', 'click' , function() {
+
+			var $this   = $(this),
+			$parent = $this.parent(),
+			data = $this.attr('rel');
+
+			var ind = $(this).index()
+			$.post( ajaxurl, { action: 'at_delete_file', data: data, tag_id: get_query_var('tag_ID') }, function(response) {
+				response == '0' ? ( alert( 'File has been successfully deleted.' ), $parent.remove() ) : alert( 'You do NOT have permission to delete this file.' );
+			});
+
+			return false;
+
+		});
+
+
+		/**
+		 * Helper Function
+		 *
+		 * Get Query string value by name.
+		 *
+		 * @since 1.0
+		 */
+		function get_query_var( name ) {
+
+			var match = RegExp('[?&]' + name + '=([^&#]*)').exec(location.href);
+			return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
+
+		}
+
+		//new image upload field
+		function load_images_muploader(){
+			jQuery(".mupload_img_holder").each(function(i,v){
+				if (jQuery(this).next().next().val() != ''){
+					if (!jQuery(this).children().size() > 0){
+						jQuery(this).append('<img src="' + jQuery(this).next().next().val() + '" style="height: 150px;width: 150px;" />');
+						jQuery(this).next().next().next().val("Delete");
+						jQuery(this).next().next().next().removeClass('at-upload_image_button').addClass('at-delete_image_button');
+					}
+				}
+			});
+		}
+
+		load_images_muploader();
+		//delete img button
+		jQuery( document ).on('click', '.at-delete_image_button', function(e){
+			var field_id = jQuery(this).attr("rel");
+			var at_id = jQuery(this).prev().prev();
+			var at_src = jQuery(this).prev();
+			var t_button = jQuery(this);
+			data = {
+					action: 'at_delete_mupload',
+					_wpnonce: $('#nonce-delete-mupload_' + field_id).val(),
+					post_id: get_query_var('tag_ID'),
+					field_id: field_id,
+					attachment_id: jQuery(at_id).val()
+			};
+
+			$.getJSON(ajaxurl, data, function(response) {
+				if ('success' == response.status){
+					jQuery(t_button).val("Add Image");
+					jQuery(t_button).removeClass('at-delete_image_button').addClass('at-upload_image_button');
+					//clear html values
+					jQuery(at_id).val('');
+					jQuery(at_src).val('');
+					jQuery(at_id).prev().html('');
+					load_images_muploader();
+				}else{
+					alert(response.message);
+				}
+			});
+
+			return false;
+		});
+
+
+		//upload button
+		var formfield1;
+		var formfield2;
+		jQuery(document).on('click', '.at-upload_image_button', function(e){
+			formfield1 = jQuery(this).prev();
+			formfield2 = jQuery(this).prev().prev();      
+			tb_show('', 'media-upload.php?post_id=0&type=image&amp;TB_iframe=true&tax_meta_c=instopo');
+
+			//cleanup the meadi uploader
+			tbframe_interval = setInterval(function() {
+
+				//remove url, alignment and size fields- auto set to null, none and full respectively                        
+				$('#TB_iframeContent').contents().find('.url').hide();
+				$('#TB_iframeContent').contents().find('.align').hide();
+				$('#TB_iframeContent').contents().find('.image_alt').hide();
+				$('#TB_iframeContent').contents().find('.post_excerpt').hide();
+				$('#TB_iframeContent').contents().find('.post_content').hide();
+				$('#TB_iframeContent').contents().find('.image-size').hide();
+				$('#TB_iframeContent').contents().find('[value="Insert into Post"]').val('Use this image');
+
+			}, 2000);
+
+			//store old send to editor function
+			window.restore_send_to_editor = window.send_to_editor;
+			//overwrite send to editor function
+			window.send_to_editor = function(html) {
+				imgurl = jQuery('img',html).attr('src');
+				img_calsses = jQuery('img',html).attr('class').split(" ");
+				att_id = '';
+				jQuery.each(img_calsses,function(i,val){
+					if (val.indexOf("wp-image") != -1){
+						att_id = val.replace('wp-image-', "");
+					}
+				});
+
+				jQuery(formfield2).val(att_id);
+				jQuery(formfield1).val(imgurl);
+				load_images_muploader();
+				tb_remove();
+				//restore old send to editor function
+				window.send_to_editor = window.restore_send_to_editor;
+			}
+			return false;
+		});
+
+	} );
+});
\ No newline at end of file
diff --git a/public/js_src/external_libs/webfont.js b/public/js_src/external_libs/webfont.js
new file mode 100644
index 0000000..677cb38
--- /dev/null
+++ b/public/js_src/external_libs/webfont.js
@@ -0,0 +1,33 @@
+define( function() {
+	;(function(window,document,undefined){
+		var i=void 0,j=!0,m=null,n=!1;function p(a){return function(){return this[a]}}var q;function r(a,c,b){var d=2<arguments.length?Array.prototype.slice.call(arguments,2):[];return function(){d.push.apply(d,arguments);return c.apply(a,d)}};function s(a){this.L=a;this.ca=i}s.prototype.createElement=function(a,c,b){a=this.L.createElement(a);if(c)for(var d in c)if(c.hasOwnProperty(d))if("style"==d){var e=a,f=c[d];aa(this)?e.setAttribute("style",f):e.style.cssText=f}else a.setAttribute(d,c[d]);b&&a.appendChild(this.L.createTextNode(b));return a};function t(a,c,b){a=a.L.getElementsByTagName(c)[0];a||(a=document.documentElement);a&&a.lastChild&&a.insertBefore(b,a.lastChild)}
+		function ba(a){function c(){document.body?a():setTimeout(c,0)}c()}function w(a,c){return a.createElement("link",{rel:"stylesheet",href:c})}function x(a,c){return a.createElement("script",{src:c})}function y(a,c){for(var b=a.className.split(/\s+/),d=0,e=b.length;d<e;d++)if(b[d]==c)return;b.push(c);a.className=b.join(" ").replace(/^\s+/,"")}
+		function z(a,c){for(var b=a.className.split(/\s+/),d=[],e=0,f=b.length;e<f;e++)b[e]!=c&&d.push(b[e]);a.className=d.join(" ").replace(/^\s+/,"").replace(/\s+$/,"")}function ca(a,c){for(var b=a.className.split(/\s+/),d=0,e=b.length;d<e;d++)if(b[d]==c)return j;return n}function aa(a){if(a.ca===i){var c=a.L.createElement("p");c.innerHTML='<a style="top:1px;">w</a>';a.ca=/top/.test(c.getElementsByTagName("a")[0].getAttribute("style"))}return a.ca};function A(a,c,b,d,e,f,g,k){this.Ea=a;this.Ka=c;this.ra=b;this.qa=d;this.Ha=e;this.Ga=f;this.pa=g;this.La=k}q=A.prototype;q.getName=p("Ea");q.ya=p("Ka");q.W=p("ra");q.va=p("qa");q.wa=p("Ha");q.xa=p("Ga");q.ua=p("pa");q.D=p("La");function B(a,c){this.a=a;this.k=c}var da=new A("Unknown","Unknown","Unknown","Unknown","Unknown","Unknown",i,n);
+		B.prototype.parse=function(){var a;if(-1!=this.a.indexOf("MSIE")){a=C(this);var c=D(this),b=E(this.a,/(MSIE [\d\w\.]+)/,1);if(""!=b){var d=b.split(" "),b=d[0],d=d[1],e=F(d),f=F(c);a=new A(b,d,b,d,a,c,G(this.k),"Windows"==a&&6<=e||"Windows Phone"==a&&8<=f)}else a=new A("MSIE","Unknown","MSIE","Unknown",a,c,G(this.k),n)}else if(-1!=this.a.indexOf("Opera"))a:if(c=a="Unknown",b=E(this.a,/(Presto\/[\d\w\.]+)/,1),""!=b?(c=b.split("/"),a=c[0],c=c[1]):(-1!=this.a.indexOf("Gecko")&&(a="Gecko"),b=E(this.a,
+		/rv:([^\)]+)/,1),""!=b&&(c=b)),-1!=this.a.indexOf("Opera Mini/"))b=E(this.a,/Opera Mini\/([\d\.]+)/,1),""==b&&(b="Unknown"),a=new A("OperaMini",b,a,c,C(this),D(this),G(this.k),n);else{if(-1!=this.a.indexOf("Version/")&&(b=E(this.a,/Version\/([\d\.]+)/,1),""!=b)){a=new A("Opera",b,a,c,C(this),D(this),G(this.k),10<=F(b));break a}b=E(this.a,/Opera[\/ ]([\d\.]+)/,1);a=""!=b?new A("Opera",b,a,c,C(this),D(this),G(this.k),10<=F(b)):new A("Opera","Unknown",a,c,C(this),D(this),G(this.k),n)}else-1!=this.a.indexOf("AppleWebKit")?
+		(a=C(this),c=D(this),b=E(this.a,/AppleWebKit\/([\d\.\+]+)/,1),""==b&&(b="Unknown"),d="Unknown",-1!=this.a.indexOf("Chrome")||-1!=this.a.indexOf("CrMo")||-1!=this.a.indexOf("CriOS")?d="Chrome":-1!=this.a.indexOf("Safari")?d="Safari":-1!=this.a.indexOf("AdobeAIR")&&(d="AdobeAIR"),e="Unknown",-1!=this.a.indexOf("Version/")?e=E(this.a,/Version\/([\d\.\w]+)/,1):"Chrome"==d?e=E(this.a,/(Chrome|CrMo|CriOS)\/([\d\.]+)/,2):"AdobeAIR"==d&&(e=E(this.a,/AdobeAIR\/([\d\.]+)/,1)),f=n,"AdobeAIR"==d?(f=E(e,/\d+\.(\d+)/,
+		1),f=2<F(e)||2==F(e)&&5<=parseInt(f,10)):(f=E(b,/\d+\.(\d+)/,1),f=526<=F(b)||525<=F(b)&&13<=parseInt(f,10)),a=new A(d,e,"AppleWebKit",b,a,c,G(this.k),f)):-1!=this.a.indexOf("Gecko")?(c=a="Unknown",d=n,-1!=this.a.indexOf("Firefox")?(a="Firefox",b=E(this.a,/Firefox\/([\d\w\.]+)/,1),""!=b&&(d=E(b,/\d+\.(\d+)/,1),c=b,d=""!=b&&3<=F(b)&&5<=parseInt(d,10))):-1!=this.a.indexOf("Mozilla")&&(a="Mozilla"),b=E(this.a,/rv:([^\)]+)/,1),""==b?b="Unknown":d||(d=F(b),e=parseInt(E(b,/\d+\.(\d+)/,1),10),f=parseInt(E(b,
+		/\d+\.\d+\.(\d+)/,1),10),d=1<d||1==d&&9<e||1==d&&9==e&&2<=f||b.match(/1\.9\.1b[123]/)!=m||b.match(/1\.9\.1\.[\d\.]+/)!=m),a=new A(a,c,"Gecko",b,C(this),D(this),G(this.k),d)):a=da;return a};function C(a){var c=E(a.a,/(iPod|iPad|iPhone|Android|Windows Phone)/,1);if(""!=c)return c;a=E(a.a,/(Linux|Mac_PowerPC|Macintosh|Windows|CrOS)/,1);return""!=a?("Mac_PowerPC"==a&&(a="Macintosh"),a):"Unknown"}
+		function D(a){var c=E(a.a,/(OS X|Windows NT|Android|CrOS) ([^;)]+)/,2);if(c||(c=E(a.a,/Windows Phone( OS)? ([^;)]+)/,2)))return c;if(c=E(a.a,/(iPhone )?OS ([\d_]+)/,2))return c;return(a=E(a.a,/Linux ([i\d]+)/,1))?a:"Unknown"}function F(a){a=E(a,/(\d+)/,1);return""!=a?parseInt(a,10):-1}function E(a,c,b){return(a=a.match(c))&&a[b]?a[b]:""}function G(a){if(a.documentMode)return a.documentMode};function ea(a,c,b){this.c=a;this.g=c;this.da=b;this.m="wf";this.j=new fa("-")}function ha(a){y(a.g,a.j.e(a.m,"loading"));H(a,"loading")}function I(a){z(a.g,a.j.e(a.m,"loading"));ca(a.g,a.j.e(a.m,"active"))||y(a.g,a.j.e(a.m,"inactive"));H(a,"inactive")}function H(a,c,b,d){if(a.da[c])a.da[c](b,d)};function ia(){this.ja={}}function ja(a,c){var b=[],d;for(d in c)if(c.hasOwnProperty(d)){var e=a.ja[d];e&&b.push(e(c[d]))}return b};function J(a,c,b,d,e,f){this.c=c;this.H=b;this.u=d;this.A=e;this.C=f;this.V=0;"AppleWebKit"===a.W()?(a=this.c.createElement("style",m,"@font-face{font-family:'__webfontloader_test__';src:url(data:application/x-font-woff;base64,) format('woff'),url(data:font/truetype;base64,) format('truetype');}"),c=new K(this.c,this.u,"iii"),t(this.c,"head",a),L(c,"monospace"),M(c),b=c.h().width,L(c,"'__webfontloader_test__', monospace, sans-serif"),b=b!==c.h().width,a.parentNode&&a.parentNode.removeChild(a),c.remove(),
+		a=b):a=n;this.K=a;this.ma=this.ia=n}J.prototype.watch=function(a,c,b,d,e){for(var f=a.length,g=0;g<f;g++){var k=a[g];c[k]||(c[k]=["n4"]);this.V+=c[k].length}e&&(this.ia=e);for(g=0;g<f;g++)for(var k=a[g],e=c[k],l=b[k],h=0,o=e.length;h<o;h++){var u=e[h],v=this.H,S=k,ga=u;y(v.g,v.j.e(v.m,S,ga,"loading"));H(v,"fontloading",S,ga);v=r(this,this.sa);S=r(this,this.ta);(new d(v,S,this.c,this.u,this.A,this.C,k,u,this.K,l)).start()}};
+		J.prototype.sa=function(a,c){var b=this.H;z(b.g,b.j.e(b.m,a,c,"loading"));z(b.g,b.j.e(b.m,a,c,"inactive"));y(b.g,b.j.e(b.m,a,c,"active"));H(b,"fontactive",a,c);this.ma=j;ka(this)};J.prototype.ta=function(a,c){var b=this.H;z(b.g,b.j.e(b.m,a,c,"loading"));ca(b.g,b.j.e(b.m,a,c,"active"))||y(b.g,b.j.e(b.m,a,c,"inactive"));H(b,"fontinactive",a,c);ka(this)};
+		function ka(a){0==--a.V&&a.ia&&(a.ma?(a=a.H,z(a.g,a.j.e(a.m,"loading")),z(a.g,a.j.e(a.m,"inactive")),y(a.g,a.j.e(a.m,"active")),H(a,"active")):I(a.H))};function N(a,c,b,d,e,f,g,k,l,h){this.G=a;this.P=c;this.c=b;this.u=d;this.A=e;this.C=f;this.N=g;this.p=k;this.I=h||"BESbswy";this.K=l;this.S=this.R=m;this.s=new K(this.c,this.u,this.I);M(this.s);L(this.s,"arial,'URW Gothic L',sans-serif",this.p);this.Z=this.s.h();this.t=new K(this.c,this.u,this.I);M(this.t);L(this.t,"Georgia,'Century Schoolbook L',serif",this.p);this.$=this.t.h()}
+		N.prototype.start=function(){this.aa=this.C();L(this.s,this.N+",arial,'URW Gothic L',sans-serif",this.p);this.K&&(this.R=this.s.h());L(this.t,this.N+",Georgia,'Century Schoolbook L',serif",this.p);this.K&&(this.S=this.t.h());this.U()};function O(a,c){return!!a&&!!c&&a.width===c.width&&a.height===c.height}
+		N.prototype.U=function(){var a=this.s.h(),c=this.t.h();this.K?this.R&&this.S?5E3<=this.C()-this.aa?O(a,this.R)&&O(c,this.S)?P(this,this.G):P(this,this.P):O(a,this.R)&&O(c,this.S)?Q(this):O(a,this.Z)&&O(c,this.$)?P(this,this.P):P(this,this.G):Q(this):5E3<=this.C()-this.aa?P(this,this.P):O(a,this.Z)&&O(c,this.$)?Q(this):P(this,this.G)};function Q(a){a.A(function(a,b){return function(){b.call(a)}}(a,a.U),25)}function P(a,c){a.s.remove();a.t.remove();c(a.N,a.p)};function K(a,c,b){this.c=a;this.u=c;this.I=b;this.Da=new la;this.B=new R;this.M=this.c.createElement("span",{},this.I)}function L(a,c,b){var d=a.c,e=a.M,b=a.B.expand(b||""),a="position:absolute;top:-999px;left:-999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;font-family:"+a.Da.quote(c)+";"+b;aa(d)?e.setAttribute("style",a):e.style.cssText=a}function M(a){t(a.c,"body",a.M)}K.prototype.h=function(){return this.u.h(this.M)};
+		K.prototype.remove=function(){var a=this.M;a.parentNode&&a.parentNode.removeChild(a)};function T(a,c,b,d,e){this.c=a;this.ea=c;this.g=b;this.A=d;this.a=e;this.X=this.Y=0}T.prototype.v=function(a,c){this.ea.ja[a]=c};T.prototype.load=function(a){var c=new ea(this.c,this.g,a);this.a.D()?ma(this,c,a):I(c)};T.prototype.za=function(a,c,b,d){var e=a.fa?a.fa():N;d?a.load(r(this,this.Fa,c,b,e)):(a=0==--this.Y,this.X--,a&&(0==this.X?I(c):ha(c)),b.watch([],{},{},e,a))};
+		T.prototype.Fa=function(a,c,b,d,e,f){var g=0==--this.Y;g&&ha(a);this.A(r(this,function(a,b,c,d,e,f){a.watch(b,c||{},d||{},e,f)},c,d,e,f,b,g))};function ma(a,c,b){b=ja(a.ea,b);a.X=a.Y=b.length;for(var d=new J(a.a,a.c,c,{h:function(a){return{width:a.offsetWidth,height:a.offsetHeight}}},a.A,function(){return(new Date).getTime()}),e=0,f=b.length;e<f;e++){var g=b[e];g.F(a.a,r(a,a.za,g,c,d))}};function fa(a){this.Aa=a||"-"}fa.prototype.e=function(a){for(var c=[],b=0;b<arguments.length;b++)c.push(arguments[b].replace(/[\W_]+/g,"").toLowerCase());return c.join(this.Aa)};function la(){this.la="'"}la.prototype.quote=function(a){for(var c=[],a=a.split(/,\s*/),b=0;b<a.length;b++){var d=a[b].replace(/['"]/g,"");-1==d.indexOf(" ")?c.push(d):c.push(this.la+d+this.la)}return c.join(",")};function R(){this.Q=na;this.q=oa}var na=["font-style","font-weight"],oa={"font-style":[["n","normal"],["i","italic"],["o","oblique"]],"font-weight":[["1","100"],["2","200"],["3","300"],["4","400"],["5","500"],["6","600"],["7","700"],["8","800"],["9","900"],["4","normal"],["7","bold"]]};function U(a,c,b){this.ga=a;this.Ia=c;this.q=b}U.prototype.compact=function(a,c){for(var b=0;b<this.q.length;b++)if(c==this.q[b][1]){a[this.ga]=this.q[b][0];break}};
+		U.prototype.expand=function(a,c){for(var b=0;b<this.q.length;b++)if(c==this.q[b][0]){a[this.ga]=this.Ia+":"+this.q[b][1];break}};R.prototype.compact=function(a){for(var c=["n","4"],a=a.split(";"),b=0,d=a.length;b<d;b++){var e=a[b].replace(/\s+/g,"").split(":");if(2==e.length){var f=e[1];a:{for(var e=e[0],g=0;g<this.Q.length;g++)if(e==this.Q[g]){e=new U(g,e,this.q[e]);break a}e=m}e&&e.compact(c,f)}}return c.join("")};
+		R.prototype.expand=function(a){if(2!=a.length)return m;for(var c=[m,m],b=0,d=this.Q.length;b<d;b++){var e=this.Q[b];(new U(b,e,this.q[e])).expand(c,a.substr(b,1))}return c[0]&&c[1]?c.join(";")+";":m};var V=window.WebFont=function(){var a=(new B(navigator.userAgent,document)).parse();return new T(new s(document),new ia,document.documentElement,function(a,b){setTimeout(a,b)},a)}();V.load=V.load;V.addModule=V.v;A.prototype.getName=A.prototype.getName;A.prototype.getVersion=A.prototype.ya;A.prototype.getEngine=A.prototype.W;A.prototype.getEngineVersion=A.prototype.va;A.prototype.getPlatform=A.prototype.wa;A.prototype.getPlatformVersion=A.prototype.xa;A.prototype.getDocumentMode=A.prototype.ua;
+		A.prototype.isSupportingWebFont=A.prototype.D;function pa(a,c){this.c=a;this.d=c}var qa={regular:"n4",bold:"n7",italic:"i4",bolditalic:"i7",r:"n4",b:"n7",i:"i4",bi:"i7"};pa.prototype.F=function(a,c){return c(a.D())};
+		pa.prototype.load=function(a){var c,b;t(this.c,"head",w(this.c,("https:"==document.location.protocol?"https:":"http:")+"//webfonts.fontslive.com/css/"+this.d.key+".css"));var d=this.d.families,e,f;e=[];f={};for(var g=0,k=d.length;g<k;g++){b=b=c=i;b=d[g].split(":");c=b[0];if(b[1]){b=b[1].split(",");for(var l=[],h=0,o=b.length;h<o;h++){var u=b[h];if(u){var v=qa[u];l.push(v?v:u)}}b=l}else b=["n4"];e.push(c);f[c]=b}a(e,f)};V.v("ascender",function(a){return new pa(new s(document),a)});function W(a,c,b){this.o=a;this.c=c;this.d=b;this.f=[];this.w={};this.B=new R}W.prototype.J=function(a){return("https:"==this.o.location.protocol?"https:":"http:")+(this.d.api||"//f.fontdeck.com/s/css/js/")+this.o.document.location.hostname+"/"+a+".js"};
+		W.prototype.F=function(a,c){var b=this.d.id,d=this;b?(this.o.__webfontfontdeckmodule__||(this.o.__webfontfontdeckmodule__={}),this.o.__webfontfontdeckmodule__[b]=function(a,b){for(var g=0,k=b.fonts.length;g<k;++g){var l=b.fonts[g];d.f.push(l.name);d.w[l.name]=[d.B.compact("font-weight:"+l.weight+";font-style:"+l.style)]}c(a)},t(this.c,"head",x(this.c,this.J(b)))):c(j)};W.prototype.load=function(a){a(this.f,this.w)};V.v("fontdeck",function(a){return new W(window,new s(document),a)});function X(a,c,b,d,e){this.o=a;this.a=c;this.c=b;this.k=d;this.d=e;this.f=[];this.w={}}X.prototype.F=function(a,c){var b=this,d=b.d.projectId;if(d){var e=x(b.c,b.J(d));e.id="__MonotypeAPIScript__"+d;e.onreadystatechange=function(a){if("loaded"===e.readyState||"complete"===e.readyState)e.onreadystatechange=m,e.onload(a)};e.onload=function(){if(b.o["__mti_fntLst"+d]){var e=b.o["__mti_fntLst"+d]();if(e&&e.length){var g;for(g=0;g<e.length;g++)b.f.push(e[g].fontfamily)}}c(a.D())};t(this.c,"head",e)}else c(j)};
+		X.prototype.J=function(a){var c=this.protocol(),b=(this.d.api||"fast.fonts.com/jsapi").replace(/^.*http(s?):(\/\/)?/,"");return c+"//"+b+"/"+a+".js"};X.prototype.load=function(a){a(this.f,this.w)};X.prototype.protocol=function(){var a=["http:","https:"],c=a[0];if(this.k&&this.k.location&&this.k.location.protocol)for(var b=0,b=0;b<a.length;b++)if(this.k.location.protocol===a[b])return this.k.location.protocol;return c};
+		V.v("monotype",function(a){var c=(new B(navigator.userAgent,document)).parse();return new X(window,c,new s(document),document,a)});function Y(a,c,b){this.o=a;this.c=c;this.d=b;this.f=[];this.w={}}Y.prototype.J=function(a){var c="https:"==window.location.protocol?"https:":"http:";return(this.d.api||c+"//use.typekit.com")+"/"+a+".js"};Y.prototype.F=function(a,c){var b=this.d.id,d=this.d,e=this;b?(this.o.__webfonttypekitmodule__||(this.o.__webfonttypekitmodule__={}),this.o.__webfonttypekitmodule__[b]=function(b){b(a,d,function(a,b,d){e.f=b;e.w=d;c(a)})},t(this.c,"head",x(this.c,this.J(b)))):c(j)};
+		Y.prototype.load=function(a){a(this.f,this.w)};V.v("typekit",function(a){return new Y(window,new s(document),a)});function ra(a,c){this.c=a;this.d=c}ra.prototype.load=function(a){for(var c=this.d.urls||[],b=this.d.families||[],d=0,e=c.length;d<e;d++)t(this.c,"head",w(this.c,c[d]));a(b)};ra.prototype.F=function(a,c){return c(a.D())};V.v("custom",function(a){return new ra(new s(document),a)});function Z(a,c,b,d,e,f,g,k,l,h){Z.Ja.call(this,a,c,b,d,e,f,g,k,l,h);a=["Times New Roman","Arial","Times","Sans","Serif"];c=a.length;b={};d=new K(this.c,this.u,this.I);M(d);L(d,a[0],this.p);b[d.h().width]=j;for(e=1;e<c;e++)f=a[e],L(d,f,this.p),b[d.h().width]=j,"4"!=this.p[1]&&(L(d,f,this.p[0]+"4"),b[d.h().width]=j);d.remove();this.z=b;this.oa=n;this.Ba=this.Z;this.Ca=this.$}(function(a,c){function b(){}b.prototype=a.prototype;c.prototype=new b;c.Ja=a;c.Ma=a.prototype})(N,Z);
+		var sa={Arimo:j,Cousine:j,Tinos:j};Z.prototype.U=function(){var a=this.s.h(),c=this.t.h();!this.oa&&a.width==c.width&&this.z[a.width]&&(this.z={},this.oa=this.z[a.width]=j);(this.Ba.width!=a.width||this.Ca.width!=c.width)&&!this.z[a.width]&&!this.z[c.width]?P(this,this.G):5E3<=this.C()-this.aa?this.z[a.width]&&this.z[c.width]&&sa[this.N]?P(this,this.G):P(this,this.P):Q(this)};function ta(a){this.T=a?a:("https:"==window.location.protocol?"https:":"http:")+ua;this.f=[];this.ba=[]}var ua="//fonts.googleapis.com/css";ta.prototype.e=function(){if(0==this.f.length)throw Error("No fonts to load !");if(-1!=this.T.indexOf("kit="))return this.T;for(var a=this.f.length,c=[],b=0;b<a;b++)c.push(this.f[b].replace(/ /g,"+"));a=this.T+"?family="+c.join("%7C");0<this.ba.length&&(a+="&subset="+this.ba.join(","));return a};function va(a){this.f=a;this.ka=[];this.na={};this.O={};this.B=new R}
+		var wa={latin:"BESbswy",cyrillic:"&#1081;&#1103;&#1046;",greek:"&#945;&#946;&#931;",khmer:"&#x1780;&#x1781;&#x1782;",Hanuman:"&#x1780;&#x1781;&#x1782;"},xa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},ya={i:"i",italic:"i",n:"n",normal:"n"},za=RegExp("^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$");
+		va.prototype.parse=function(){for(var a=this.f.length,c=0;c<a;c++){var b=this.f[c].split(":"),d=b[0].replace(/\+/g," "),e=["n4"];if(2<=b.length){var f;var g=b[1];f=[];if(g)for(var g=g.split(","),k=g.length,l=0;l<k;l++){var h;h=g[l];if(h.match(/^[\w]+$/))if(h=za.exec(h.toLowerCase()),h==m)h="";else{var o=i;o=h[1];if(o==m)o="4";else var u=xa[o],o=u?u:isNaN(o)?"4":o.substr(0,1);h=(h=this.B.expand([h[2]==m?"n":ya[h[2]],o].join("")))?this.B.compact(h):m}else h="";h&&f.push(h)}0<f.length&&(e=f);3==b.length&&
+		(b=b[2],f=[],b=!b?f:b.split(","),0<b.length&&(b=wa[b[0]])&&(this.O[d]=b))}this.O[d]||(b=wa[d])&&(this.O[d]=b);this.ka.push(d);this.na[d]=e}};function $(a,c,b){this.a=a;this.c=c;this.d=b}$.prototype.F=function(a,c){c(a.D())};$.prototype.fa=function(){return"AppleWebKit"==this.a.W()?Z:N};$.prototype.load=function(a){"MSIE"==this.a.getName()&&this.d.blocking!=j?ba(r(this,this.ha,a)):this.ha(a)};
+		$.prototype.ha=function(a){for(var c=this.c,b=new ta(this.d.api),d=this.d.families,e=d.length,f=0;f<e;f++){var g=d[f].split(":");3==g.length&&b.ba.push(g.pop());var k="";2==g.length&&""!=g[1]&&(k=":");b.f.push(g.join(k))}d=new va(d);d.parse();t(c,"head",w(c,b.e()));a(d.ka,d.na,d.O)};V.v("google",function(a){var c=(new B(navigator.userAgent,document)).parse();return new $(c,new s(document),a)});window.WebFontConfig&&V.load(window.WebFontConfig);
+		})(this,document);
+} );
diff --git a/public/js_src/jquery_timely19.js b/public/js_src/jquery_timely19.js
new file mode 100644
index 0000000..7fa6a0a
--- /dev/null
+++ b/public/js_src/jquery_timely19.js
@@ -0,0 +1,9590 @@
+define( "jquery_timely", function() {
+	/*global jQuery: true */
+	"use strict"; // jshint ;_;
+	/*!
+	 * jQuery JavaScript Library v1.9.1
+	 * http://jquery.com/
+	 *
+	 * Includes Sizzle.js
+	 * http://sizzlejs.com/
+	 *
+	 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors
+	 * Released under the MIT license
+	 * http://jquery.org/license
+	 *
+	 * Date: 2013-2-4
+	 */
+	(function( window, undefined ) {
+
+	// Can't do this because several apps including ASP.NET trace
+	// the stack via arguments.caller.callee and Firefox dies if
+	// you try to trace through "use strict" call chains. (#13335)
+	// Support: Firefox 18+
+	//"use strict";
+	var
+		// The deferred used on DOM ready
+		readyList,
+
+		// A central reference to the root jQuery(document)
+		rootjQuery,
+
+		// Support: IE<9
+		// For `typeof node.method` instead of `node.method !== undefined`
+		core_strundefined = typeof undefined,
+
+		// Use the correct document accordingly with window argument (sandbox)
+		document = window.document,
+		location = window.location,
+
+		// Map over jQuery in case of overwrite
+		_jQuery = window.jQuery,
+
+		// Map over the $ in case of overwrite
+		_$ = window.$,
+
+		// [[Class]] -> type pairs
+		class2type = {},
+
+		// List of deleted data cache ids, so we can reuse them
+		core_deletedIds = [],
+
+		core_version = "1.9.1-ai1ec",
+
+		// Save a reference to some core methods
+		core_concat = core_deletedIds.concat,
+		core_push = core_deletedIds.push,
+		core_slice = core_deletedIds.slice,
+		core_indexOf = core_deletedIds.indexOf,
+		core_toString = class2type.toString,
+		core_hasOwn = class2type.hasOwnProperty,
+		core_trim = core_version.trim,
+
+		// Define a local copy of jQuery
+		jQuery = function( selector, context ) {
+			// The jQuery object is actually just the init constructor 'enhanced'
+			return new jQuery.fn.init( selector, context, rootjQuery );
+		},
+
+		// Used for matching numbers
+		core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
+
+		// Used for splitting on whitespace
+		core_rnotwhite = /\S+/g,
+
+		// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
+		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
+
+		// A simple way to check for HTML strings
+		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
+		// Strict HTML recognition (#11290: must start with <)
+		rquickExpr = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,
+
+		// Match a standalone tag
+		rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
+
+		// JSON RegExp
+		rvalidchars = /^[\],:{}\s]*$/,
+		rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
+		rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
+		rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,
+
+		// Matches dashed string for camelizing
+		rmsPrefix = /^-ms-/,
+		rdashAlpha = /-([\da-z])/gi,
+
+		// Used by jQuery.camelCase as callback to replace()
+		fcamelCase = function( all, letter ) {
+			return letter.toUpperCase();
+		},
+
+		// The ready event handler
+		completed = function( event ) {
+
+			// readyState === "complete" is good enough for us to call the dom ready in oldIE
+			if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
+				detach();
+				jQuery.ready();
+			}
+		},
+		// Clean-up method for dom ready events
+		detach = function() {
+			if ( document.addEventListener ) {
+				document.removeEventListener( "DOMContentLoaded", completed, false );
+				window.removeEventListener( "load", completed, false );
+
+			} else {
+				document.detachEvent( "onreadystatechange", completed );
+				window.detachEvent( "onload", completed );
+			}
+		};
+
+	jQuery.fn = jQuery.prototype = {
+		// The current version of jQuery being used
+		jquery: core_version,
+
+		constructor: jQuery,
+		init: function( selector, context, rootjQuery ) {
+			var match, elem;
+
+			// HANDLE: $(""), $(null), $(undefined), $(false)
+			if ( !selector ) {
+				return this;
+			}
+
+			// Handle HTML strings
+			if ( typeof selector === "string" ) {
+				if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
+					// Assume that strings that start and end with <> are HTML and skip the regex check
+					match = [ null, selector, null ];
+
+				} else {
+					match = rquickExpr.exec( selector );
+				}
+
+				// Match html or make sure no context is specified for #id
+				if ( match && (match[1] || !context) ) {
+
+					// HANDLE: $(html) -> $(array)
+					if ( match[1] ) {
+						context = context instanceof jQuery ? context[0] : context;
+
+						// scripts is true for back-compat
+						jQuery.merge( this, jQuery.parseHTML(
+							match[1],
+							context && context.nodeType ? context.ownerDocument || context : document,
+							true
+						) );
+
+						// HANDLE: $(html, props)
+						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
+							for ( match in context ) {
+								// Properties of context are called as methods if possible
+								if ( jQuery.isFunction( this[ match ] ) ) {
+									this[ match ]( context[ match ] );
+
+								// ...and otherwise set as attributes
+								} else {
+									this.attr( match, context[ match ] );
+								}
+							}
+						}
+
+						return this;
+
+					// HANDLE: $(#id)
+					} else {
+						elem = document.getElementById( match[2] );
+
+						// Check parentNode to catch when Blackberry 4.6 returns
+						// nodes that are no longer in the document #6963
+						if ( elem && elem.parentNode ) {
+							// Handle the case where IE and Opera return items
+							// by name instead of ID
+							if ( elem.id !== match[2] ) {
+								return rootjQuery.find( selector );
+							}
+
+							// Otherwise, we inject the element directly into the jQuery object
+							this.length = 1;
+							this[0] = elem;
+						}
+
+						this.context = document;
+						this.selector = selector;
+						return this;
+					}
+
+				// HANDLE: $(expr, $(...))
+				} else if ( !context || context.jquery ) {
+					return ( context || rootjQuery ).find( selector );
+
+				// HANDLE: $(expr, context)
+				// (which is just equivalent to: $(context).find(expr)
+				} else {
+					return this.constructor( context ).find( selector );
+				}
+
+			// HANDLE: $(DOMElement)
+			} else if ( selector.nodeType ) {
+				this.context = this[0] = selector;
+				this.length = 1;
+				return this;
+
+			// HANDLE: $(function)
+			// Shortcut for document ready
+			} else if ( jQuery.isFunction( selector ) ) {
+				return rootjQuery.ready( selector );
+			}
+
+			if ( selector.selector !== undefined ) {
+				this.selector = selector.selector;
+				this.context = selector.context;
+			}
+
+			return jQuery.makeArray( selector, this );
+		},
+
+		// Start with an empty selector
+		selector: "",
+
+		// The default length of a jQuery object is 0
+		length: 0,
+
+		// The number of elements contained in the matched element set
+		size: function() {
+			return this.length;
+		},
+
+		toArray: function() {
+			return core_slice.call( this );
+		},
+
+		// Get the Nth element in the matched element set OR
+		// Get the whole matched element set as a clean array
+		get: function( num ) {
+			return num == null ?
+
+				// Return a 'clean' array
+				this.toArray() :
+
+				// Return just the object
+				( num < 0 ? this[ this.length + num ] : this[ num ] );
+		},
+
+		// Take an array of elements and push it onto the stack
+		// (returning the new matched element set)
+		pushStack: function( elems ) {
+
+			// Build a new jQuery matched element set
+			var ret = jQuery.merge( this.constructor(), elems );
+
+			// Add the old object onto the stack (as a reference)
+			ret.prevObject = this;
+			ret.context = this.context;
+
+			// Return the newly-formed element set
+			return ret;
+		},
+
+		// Execute a callback for every element in the matched set.
+		// (You can seed the arguments with an array of args, but this is
+		// only used internally.)
+		each: function( callback, args ) {
+			return jQuery.each( this, callback, args );
+		},
+
+		ready: function( fn ) {
+			// Add the callback
+			jQuery.ready.promise().done( fn );
+
+			return this;
+		},
+
+		slice: function() {
+			return this.pushStack( core_slice.apply( this, arguments ) );
+		},
+
+		first: function() {
+			return this.eq( 0 );
+		},
+
+		last: function() {
+			return this.eq( -1 );
+		},
+
+		eq: function( i ) {
+			var len = this.length,
+				j = +i + ( i < 0 ? len : 0 );
+			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
+		},
+
+		map: function( callback ) {
+			return this.pushStack( jQuery.map(this, function( elem, i ) {
+				return callback.call( elem, i, elem );
+			}));
+		},
+
+		end: function() {
+			return this.prevObject || this.constructor(null);
+		},
+
+		// For internal use only.
+		// Behaves like an Array's method, not like a jQuery method.
+		push: core_push,
+		sort: [].sort,
+		splice: [].splice
+	};
+
+	// Give the init function the jQuery prototype for later instantiation
+	jQuery.fn.init.prototype = jQuery.fn;
+
+	jQuery.extend = jQuery.fn.extend = function() {
+		var src, copyIsArray, copy, name, options, clone,
+			target = arguments[0] || {},
+			i = 1,
+			length = arguments.length,
+			deep = false;
+
+		// Handle a deep copy situation
+		if ( typeof target === "boolean" ) {
+			deep = target;
+			target = arguments[1] || {};
+			// skip the boolean and the target
+			i = 2;
+		}
+
+		// Handle case when target is a string or something (possible in deep copy)
+		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
+			target = {};
+		}
+
+		// extend jQuery itself if only one argument is passed
+		if ( length === i ) {
+			target = this;
+			--i;
+		}
+
+		for ( ; i < length; i++ ) {
+			// Only deal with non-null/undefined values
+			if ( (options = arguments[ i ]) != null ) {
+				// Extend the base object
+				for ( name in options ) {
+					src = target[ name ];
+					copy = options[ name ];
+
+					// Prevent never-ending loop
+					if ( target === copy ) {
+						continue;
+					}
+
+					// Recurse if we're merging plain objects or arrays
+					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
+						if ( copyIsArray ) {
+							copyIsArray = false;
+							clone = src && jQuery.isArray(src) ? src : [];
+
+						} else {
+							clone = src && jQuery.isPlainObject(src) ? src : {};
+						}
+
+						// Never move original objects, clone them
+						target[ name ] = jQuery.extend( deep, clone, copy );
+
+					// Don't bring in undefined values
+					} else if ( copy !== undefined ) {
+						target[ name ] = copy;
+					}
+				}
+			}
+		}
+
+		// Return the modified object
+		return target;
+	};
+
+	jQuery.extend({
+		noConflict: function( deep ) {
+			if ( window.$ === jQuery ) {
+				window.$ = _$;
+			}
+
+			if ( deep && window.jQuery === jQuery ) {
+				window.jQuery = _jQuery;
+			}
+
+			return jQuery;
+		},
+
+		// Is the DOM ready to be used? Set to true once it occurs.
+		isReady: false,
+
+		// A counter to track how many items to wait for before
+		// the ready event fires. See #6781
+		readyWait: 1,
+
+		// Hold (or release) the ready event
+		holdReady: function( hold ) {
+			if ( hold ) {
+				jQuery.readyWait++;
+			} else {
+				jQuery.ready( true );
+			}
+		},
+
+		// Handle when the DOM is ready
+		ready: function( wait ) {
+
+			// Abort if there are pending holds or we're already ready
+			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
+				return;
+			}
+
+			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
+			if ( !document.body ) {
+				return setTimeout( jQuery.ready );
+			}
+
+			// Remember that the DOM is ready
+			jQuery.isReady = true;
+
+			// If a normal DOM Ready event fired, decrement, and wait if need be
+			if ( wait !== true && --jQuery.readyWait > 0 ) {
+				return;
+			}
+
+			// If there are functions bound, to execute
+			readyList.resolveWith( document, [ jQuery ] );
+
+			// Trigger any bound ready events
+			if ( jQuery.fn.trigger ) {
+				jQuery( document ).trigger("ready").off("ready");
+			}
+		},
+
+		// See test/unit/core.js for details concerning isFunction.
+		// Since version 1.3, DOM methods and functions like alert
+		// aren't supported. They return false on IE (#2968).
+		isFunction: function( obj ) {
+			return jQuery.type(obj) === "function";
+		},
+
+		isArray: Array.isArray || function( obj ) {
+			return jQuery.type(obj) === "array";
+		},
+
+		isWindow: function( obj ) {
+			return obj != null && obj == obj.window;
+		},
+
+		isNumeric: function( obj ) {
+			return !isNaN( parseFloat(obj) ) && isFinite( obj );
+		},
+
+		type: function( obj ) {
+			if ( obj == null ) {
+				return String( obj );
+			}
+			return typeof obj === "object" || typeof obj === "function" ?
+				class2type[ core_toString.call(obj) ] || "object" :
+				typeof obj;
+		},
+
+		isPlainObject: function( obj ) {
+			// Must be an Object.
+			// Because of IE, we also have to check the presence of the constructor property.
+			// Make sure that DOM nodes and window objects don't pass through, as well
+			if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
+				return false;
+			}
+
+			try {
+				// Not own constructor property must be Object
+				if ( obj.constructor &&
+					!core_hasOwn.call(obj, "constructor") &&
+					!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
+					return false;
+				}
+			} catch ( e ) {
+				// IE8,9 Will throw exceptions on certain host objects #9897
+				return false;
+			}
+
+			// Own properties are enumerated firstly, so to speed up,
+			// if last one is own, then all properties are own.
+
+			var key;
+			for ( key in obj ) {}
+
+			return key === undefined || core_hasOwn.call( obj, key );
+		},
+
+		isEmptyObject: function( obj ) {
+			var name;
+			for ( name in obj ) {
+				return false;
+			}
+			return true;
+		},
+
+		error: function( msg ) {
+			throw new Error( msg );
+		},
+
+		// data: string of html
+		// context (optional): If specified, the fragment will be created in this context, defaults to document
+		// keepScripts (optional): If true, will include scripts passed in the html string
+		parseHTML: function( data, context, keepScripts ) {
+			if ( !data || typeof data !== "string" ) {
+				return null;
+			}
+			if ( typeof context === "boolean" ) {
+				keepScripts = context;
+				context = false;
+			}
+			context = context || document;
+
+			var parsed = rsingleTag.exec( data ),
+				scripts = !keepScripts && [];
+
+			// Single tag
+			if ( parsed ) {
+				return [ context.createElement( parsed[1] ) ];
+			}
+
+			parsed = jQuery.buildFragment( [ data ], context, scripts );
+			if ( scripts ) {
+				jQuery( scripts ).remove();
+			}
+			return jQuery.merge( [], parsed.childNodes );
+		},
+
+		parseJSON: function( data ) {
+			// Attempt to parse using the native JSON parser first
+			if ( window.JSON && window.JSON.parse ) {
+				return window.JSON.parse( data );
+			}
+
+			if ( data === null ) {
+				return data;
+			}
+
+			if ( typeof data === "string" ) {
+
+				// Make sure leading/trailing whitespace is removed (IE can't handle it)
+				data = jQuery.trim( data );
+
+				if ( data ) {
+					// Make sure the incoming data is actual JSON
+					// Logic borrowed from http://json.org/json2.js
+					if ( rvalidchars.test( data.replace( rvalidescape, "@" )
+						.replace( rvalidtokens, "]" )
+						.replace( rvalidbraces, "")) ) {
+
+						return ( new Function( "return " + data ) )();
+					}
+				}
+			}
+
+			jQuery.error( "Invalid JSON: " + data );
+		},
+
+		// Cross-browser xml parsing
+		parseXML: function( data ) {
+			var xml, tmp;
+			if ( !data || typeof data !== "string" ) {
+				return null;
+			}
+			try {
+				if ( window.DOMParser ) { // Standard
+					tmp = new DOMParser();
+					xml = tmp.parseFromString( data , "text/xml" );
+				} else { // IE
+					xml = new ActiveXObject( "Microsoft.XMLDOM" );
+					xml.async = "false";
+					xml.loadXML( data );
+				}
+			} catch( e ) {
+				xml = undefined;
+			}
+			if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
+				jQuery.error( "Invalid XML: " + data );
+			}
+			return xml;
+		},
+
+		noop: function() {},
+
+		// Evaluates a script in a global context
+		// Workarounds based on findings by Jim Driscoll
+		// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
+		globalEval: function( data ) {
+			if ( data && jQuery.trim( data ) ) {
+				// We use execScript on Internet Explorer
+				// We use an anonymous function so that context is window
+				// rather than jQuery in Firefox
+				( window.execScript || function( data ) {
+					window[ "eval" ].call( window, data );
+				} )( data );
+			}
+		},
+
+		// Convert dashed to camelCase; used by the css and data modules
+		// Microsoft forgot to hump their vendor prefix (#9572)
+		camelCase: function( string ) {
+			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
+		},
+
+		nodeName: function( elem, name ) {
+			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
+		},
+
+		// args is for internal usage only
+		each: function( obj, callback, args ) {
+			var value,
+				i = 0,
+				length = obj.length,
+				isArray = isArraylike( obj );
+
+			if ( args ) {
+				if ( isArray ) {
+					for ( ; i < length; i++ ) {
+						value = callback.apply( obj[ i ], args );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				} else {
+					for ( i in obj ) {
+						value = callback.apply( obj[ i ], args );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				}
+
+			// A special, fast, case for the most common use of each
+			} else {
+				if ( isArray ) {
+					for ( ; i < length; i++ ) {
+						value = callback.call( obj[ i ], i, obj[ i ] );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				} else {
+					for ( i in obj ) {
+						value = callback.call( obj[ i ], i, obj[ i ] );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				}
+			}
+
+			return obj;
+		},
+
+		// Use native String.trim function wherever possible
+		trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
+			function( text ) {
+				return text == null ?
+					"" :
+					core_trim.call( text );
+			} :
+
+			// Otherwise use our own trimming functionality
+			function( text ) {
+				return text == null ?
+					"" :
+					( text + "" ).replace( rtrim, "" );
+			},
+
+		// results is for internal usage only
+		makeArray: function( arr, results ) {
+			var ret = results || [];
+
+			if ( arr != null ) {
+				if ( isArraylike( Object(arr) ) ) {
+					jQuery.merge( ret,
+						typeof arr === "string" ?
+						[ arr ] : arr
+					);
+				} else {
+					core_push.call( ret, arr );
+				}
+			}
+
+			return ret;
+		},
+
+		inArray: function( elem, arr, i ) {
+			var len;
+
+			if ( arr ) {
+				if ( core_indexOf ) {
+					return core_indexOf.call( arr, elem, i );
+				}
+
+				len = arr.length;
+				i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
+
+				for ( ; i < len; i++ ) {
+					// Skip accessing in sparse arrays
+					if ( i in arr && arr[ i ] === elem ) {
+						return i;
+					}
+				}
+			}
+
+			return -1;
+		},
+
+		merge: function( first, second ) {
+			var l = second.length,
+				i = first.length,
+				j = 0;
+
+			if ( typeof l === "number" ) {
+				for ( ; j < l; j++ ) {
+					first[ i++ ] = second[ j ];
+				}
+			} else {
+				while ( second[j] !== undefined ) {
+					first[ i++ ] = second[ j++ ];
+				}
+			}
+
+			first.length = i;
+
+			return first;
+		},
+
+		grep: function( elems, callback, inv ) {
+			var retVal,
+				ret = [],
+				i = 0,
+				length = elems.length;
+			inv = !!inv;
+
+			// Go through the array, only saving the items
+			// that pass the validator function
+			for ( ; i < length; i++ ) {
+				retVal = !!callback( elems[ i ], i );
+				if ( inv !== retVal ) {
+					ret.push( elems[ i ] );
+				}
+			}
+
+			return ret;
+		},
+
+		// arg is for internal usage only
+		map: function( elems, callback, arg ) {
+			var value,
+				i = 0,
+				length = elems.length,
+				isArray = isArraylike( elems ),
+				ret = [];
+
+			// Go through the array, translating each of the items to their
+			if ( isArray ) {
+				for ( ; i < length; i++ ) {
+					value = callback( elems[ i ], i, arg );
+
+					if ( value != null ) {
+						ret[ ret.length ] = value;
+					}
+				}
+
+			// Go through every key on the object,
+			} else {
+				for ( i in elems ) {
+					value = callback( elems[ i ], i, arg );
+
+					if ( value != null ) {
+						ret[ ret.length ] = value;
+					}
+				}
+			}
+
+			// Flatten any nested arrays
+			return core_concat.apply( [], ret );
+		},
+
+		// A global GUID counter for objects
+		guid: 1,
+
+		// Bind a function to a context, optionally partially applying any
+		// arguments.
+		proxy: function( fn, context ) {
+			var args, proxy, tmp;
+
+			if ( typeof context === "string" ) {
+				tmp = fn[ context ];
+				context = fn;
+				fn = tmp;
+			}
+
+			// Quick check to determine if target is callable, in the spec
+			// this throws a TypeError, but we will just return undefined.
+			if ( !jQuery.isFunction( fn ) ) {
+				return undefined;
+			}
+
+			// Simulated bind
+			args = core_slice.call( arguments, 2 );
+			proxy = function() {
+				return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
+			};
+
+			// Set the guid of unique handler to the same of original handler, so it can be removed
+			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
+
+			return proxy;
+		},
+
+		// Multifunctional method to get and set values of a collection
+		// The value/s can optionally be executed if it's a function
+		access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
+			var i = 0,
+				length = elems.length,
+				bulk = key == null;
+
+			// Sets many values
+			if ( jQuery.type( key ) === "object" ) {
+				chainable = true;
+				for ( i in key ) {
+					jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
+				}
+
+			// Sets one value
+			} else if ( value !== undefined ) {
+				chainable = true;
+
+				if ( !jQuery.isFunction( value ) ) {
+					raw = true;
+				}
+
+				if ( bulk ) {
+					// Bulk operations run against the entire set
+					if ( raw ) {
+						fn.call( elems, value );
+						fn = null;
+
+					// ...except when executing function values
+					} else {
+						bulk = fn;
+						fn = function( elem, key, value ) {
+							return bulk.call( jQuery( elem ), value );
+						};
+					}
+				}
+
+				if ( fn ) {
+					for ( ; i < length; i++ ) {
+						fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
+					}
+				}
+			}
+
+			return chainable ?
+				elems :
+
+				// Gets
+				bulk ?
+					fn.call( elems ) :
+					length ? fn( elems[0], key ) : emptyGet;
+		},
+
+		now: function() {
+			return ( new Date() ).getTime();
+		}
+	});
+
+	jQuery.ready.promise = function( obj ) {
+		if ( !readyList ) {
+
+			readyList = jQuery.Deferred();
+
+			// Catch cases where $(document).ready() is called after the browser event has already occurred.
+			// we once tried to use readyState "interactive" here, but it caused issues like the one
+			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
+			if ( document.readyState === "complete" ) {
+				// Handle it asynchronously to allow scripts the opportunity to delay ready
+				setTimeout( jQuery.ready );
+
+			// Standards-based browsers support DOMContentLoaded
+			} else if ( document.addEventListener ) {
+				// Use the handy event callback
+				document.addEventListener( "DOMContentLoaded", completed, false );
+
+				// A fallback to window.onload, that will always work
+				window.addEventListener( "load", completed, false );
+
+			// If IE event model is used
+			} else {
+				// Ensure firing before onload, maybe late but safe also for iframes
+				document.attachEvent( "onreadystatechange", completed );
+
+				// A fallback to window.onload, that will always work
+				window.attachEvent( "onload", completed );
+
+				// If IE and not a frame
+				// continually check to see if the document is ready
+				var top = false;
+
+				try {
+					top = window.frameElement == null && document.documentElement;
+				} catch(e) {}
+
+				if ( top && top.doScroll ) {
+					(function doScrollCheck() {
+						if ( !jQuery.isReady ) {
+
+							try {
+								// Use the trick by Diego Perini
+								// http://javascript.nwbox.com/IEContentLoaded/
+								top.doScroll("left");
+							} catch(e) {
+								return setTimeout( doScrollCheck, 50 );
+							}
+
+							// detach all dom ready events
+							detach();
+
+							// and execute any waiting functions
+							jQuery.ready();
+						}
+					})();
+				}
+			}
+		}
+		return readyList.promise( obj );
+	};
+
+	// Populate the class2type map
+	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
+		class2type[ "[object " + name + "]" ] = name.toLowerCase();
+	});
+
+	function isArraylike( obj ) {
+		var length = obj.length,
+			type = jQuery.type( obj );
+
+		if ( jQuery.isWindow( obj ) ) {
+			return false;
+		}
+
+		if ( obj.nodeType === 1 && length ) {
+			return true;
+		}
+
+		return type === "array" || type !== "function" &&
+			( length === 0 ||
+			typeof length === "number" && length > 0 && ( length - 1 ) in obj );
+	}
+
+	// All jQuery objects should point back to these
+	rootjQuery = jQuery(document);
+	// String to Object options format cache
+	var optionsCache = {};
+
+	// Convert String-formatted options into Object-formatted ones and store in cache
+	function createOptions( options ) {
+		var object = optionsCache[ options ] = {};
+		jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
+			object[ flag ] = true;
+		});
+		return object;
+	}
+
+	/*
+	 * Create a callback list using the following parameters:
+	 *
+	 *	options: an optional list of space-separated options that will change how
+	 *			the callback list behaves or a more traditional option object
+	 *
+	 * By default a callback list will act like an event callback list and can be
+	 * "fired" multiple times.
+	 *
+	 * Possible options:
+	 *
+	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
+	 *
+	 *	memory:			will keep track of previous values and will call any callback added
+	 *					after the list has been fired right away with the latest "memorized"
+	 *					values (like a Deferred)
+	 *
+	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
+	 *
+	 *	stopOnFalse:	interrupt callings when a callback returns false
+	 *
+	 */
+	jQuery.Callbacks = function( options ) {
+
+		// Convert options from String-formatted to Object-formatted if needed
+		// (we check in cache first)
+		options = typeof options === "string" ?
+			( optionsCache[ options ] || createOptions( options ) ) :
+			jQuery.extend( {}, options );
+
+		var // Flag to know if list is currently firing
+			firing,
+			// Last fire value (for non-forgettable lists)
+			memory,
+			// Flag to know if list was already fired
+			fired,
+			// End of the loop when firing
+			firingLength,
+			// Index of currently firing callback (modified by remove if needed)
+			firingIndex,
+			// First callback to fire (used internally by add and fireWith)
+			firingStart,
+			// Actual callback list
+			list = [],
+			// Stack of fire calls for repeatable lists
+			stack = !options.once && [],
+			// Fire callbacks
+			fire = function( data ) {
+				memory = options.memory && data;
+				fired = true;
+				firingIndex = firingStart || 0;
+				firingStart = 0;
+				firingLength = list.length;
+				firing = true;
+				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
+					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
+						memory = false; // To prevent further calls using add
+						break;
+					}
+				}
+				firing = false;
+				if ( list ) {
+					if ( stack ) {
+						if ( stack.length ) {
+							fire( stack.shift() );
+						}
+					} else if ( memory ) {
+						list = [];
+					} else {
+						self.disable();
+					}
+				}
+			},
+			// Actual Callbacks object
+			self = {
+				// Add a callback or a collection of callbacks to the list
+				add: function() {
+					if ( list ) {
+						// First, we save the current length
+						var start = list.length;
+						(function add( args ) {
+							jQuery.each( args, function( _, arg ) {
+								var type = jQuery.type( arg );
+								if ( type === "function" ) {
+									if ( !options.unique || !self.has( arg ) ) {
+										list.push( arg );
+									}
+								} else if ( arg && arg.length && type !== "string" ) {
+									// Inspect recursively
+									add( arg );
+								}
+							});
+						})( arguments );
+						// Do we need to add the callbacks to the
+						// current firing batch?
+						if ( firing ) {
+							firingLength = list.length;
+						// With memory, if we're not firing then
+						// we should call right away
+						} else if ( memory ) {
+							firingStart = start;
+							fire( memory );
+						}
+					}
+					return this;
+				},
+				// Remove a callback from the list
+				remove: function() {
+					if ( list ) {
+						jQuery.each( arguments, function( _, arg ) {
+							var index;
+							while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
+								list.splice( index, 1 );
+								// Handle firing indexes
+								if ( firing ) {
+									if ( index <= firingLength ) {
+										firingLength--;
+									}
+									if ( index <= firingIndex ) {
+										firingIndex--;
+									}
+								}
+							}
+						});
+					}
+					return this;
+				},
+				// Check if a given callback is in the list.
+				// If no argument is given, return whether or not list has callbacks attached.
+				has: function( fn ) {
+					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
+				},
+				// Remove all callbacks from the list
+				empty: function() {
+					list = [];
+					return this;
+				},
+				// Have the list do nothing anymore
+				disable: function() {
+					list = stack = memory = undefined;
+					return this;
+				},
+				// Is it disabled?
+				disabled: function() {
+					return !list;
+				},
+				// Lock the list in its current state
+				lock: function() {
+					stack = undefined;
+					if ( !memory ) {
+						self.disable();
+					}
+					return this;
+				},
+				// Is it locked?
+				locked: function() {
+					return !stack;
+				},
+				// Call all callbacks with the given context and arguments
+				fireWith: function( context, args ) {
+					args = args || [];
+					args = [ context, args.slice ? args.slice() : args ];
+					if ( list && ( !fired || stack ) ) {
+						if ( firing ) {
+							stack.push( args );
+						} else {
+							fire( args );
+						}
+					}
+					return this;
+				},
+				// Call all the callbacks with the given arguments
+				fire: function() {
+					self.fireWith( this, arguments );
+					return this;
+				},
+				// To know if the callbacks have already been called at least once
+				fired: function() {
+					return !!fired;
+				}
+			};
+
+		return self;
+	};
+	jQuery.extend({
+
+		Deferred: function( func ) {
+			var tuples = [
+					// action, add listener, listener list, final state
+					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
+					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
+					[ "notify", "progress", jQuery.Callbacks("memory") ]
+				],
+				state = "pending",
+				promise = {
+					state: function() {
+						return state;
+					},
+					always: function() {
+						deferred.done( arguments ).fail( arguments );
+						return this;
+					},
+					then: function( /* fnDone, fnFail, fnProgress */ ) {
+						var fns = arguments;
+						return jQuery.Deferred(function( newDefer ) {
+							jQuery.each( tuples, function( i, tuple ) {
+								var action = tuple[ 0 ],
+									fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
+								// deferred[ done | fail | progress ] for forwarding actions to newDefer
+								deferred[ tuple[1] ](function() {
+									var returned = fn && fn.apply( this, arguments );
+									if ( returned && jQuery.isFunction( returned.promise ) ) {
+										returned.promise()
+											.done( newDefer.resolve )
+											.fail( newDefer.reject )
+											.progress( newDefer.notify );
+									} else {
+										newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
+									}
+								});
+							});
+							fns = null;
+						}).promise();
+					},
+					// Get a promise for this deferred
+					// If obj is provided, the promise aspect is added to the object
+					promise: function( obj ) {
+						return obj != null ? jQuery.extend( obj, promise ) : promise;
+					}
+				},
+				deferred = {};
+
+			// Keep pipe for back-compat
+			promise.pipe = promise.then;
+
+			// Add list-specific methods
+			jQuery.each( tuples, function( i, tuple ) {
+				var list = tuple[ 2 ],
+					stateString = tuple[ 3 ];
+
+				// promise[ done | fail | progress ] = list.add
+				promise[ tuple[1] ] = list.add;
+
+				// Handle state
+				if ( stateString ) {
+					list.add(function() {
+						// state = [ resolved | rejected ]
+						state = stateString;
+
+					// [ reject_list | resolve_list ].disable; progress_list.lock
+					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
+				}
+
+				// deferred[ resolve | reject | notify ]
+				deferred[ tuple[0] ] = function() {
+					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
+					return this;
+				};
+				deferred[ tuple[0] + "With" ] = list.fireWith;
+			});
+
+			// Make the deferred a promise
+			promise.promise( deferred );
+
+			// Call given func if any
+			if ( func ) {
+				func.call( deferred, deferred );
+			}
+
+			// All done!
+			return deferred;
+		},
+
+		// Deferred helper
+		when: function( subordinate /* , ..., subordinateN */ ) {
+			var i = 0,
+				resolveValues = core_slice.call( arguments ),
+				length = resolveValues.length,
+
+				// the count of uncompleted subordinates
+				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
+
+				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
+				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
+
+				// Update function for both resolve and progress values
+				updateFunc = function( i, contexts, values ) {
+					return function( value ) {
+						contexts[ i ] = this;
+						values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
+						if( values === progressValues ) {
+							deferred.notifyWith( contexts, values );
+						} else if ( !( --remaining ) ) {
+							deferred.resolveWith( contexts, values );
+						}
+					};
+				},
+
+				progressValues, progressContexts, resolveContexts;
+
+			// add listeners to Deferred subordinates; treat others as resolved
+			if ( length > 1 ) {
+				progressValues = new Array( length );
+				progressContexts = new Array( length );
+				resolveContexts = new Array( length );
+				for ( ; i < length; i++ ) {
+					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
+						resolveValues[ i ].promise()
+							.done( updateFunc( i, resolveContexts, resolveValues ) )
+							.fail( deferred.reject )
+							.progress( updateFunc( i, progressContexts, progressValues ) );
+					} else {
+						--remaining;
+					}
+				}
+			}
+
+			// if we're not waiting on anything, resolve the master
+			if ( !remaining ) {
+				deferred.resolveWith( resolveContexts, resolveValues );
+			}
+
+			return deferred.promise();
+		}
+	});
+	jQuery.support = (function() {
+
+		var support, all, a,
+			input, select, fragment,
+			opt, eventName, isSupported, i,
+			div = document.createElement("div");
+
+		// Setup
+		div.setAttribute( "className", "t" );
+		div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
+
+		// Support tests won't run in some limited or non-browser environments
+		all = div.getElementsByTagName("*");
+		a = div.getElementsByTagName("a")[ 0 ];
+		if ( !all || !a || !all.length ) {
+			return {};
+		}
+
+		// First batch of tests
+		select = document.createElement("select");
+		opt = select.appendChild( document.createElement("option") );
+		input = div.getElementsByTagName("input")[ 0 ];
+
+		a.style.cssText = "top:1px;float:left;opacity:.5";
+		support = {
+			// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
+			getSetAttribute: div.className !== "t",
+
+			// IE strips leading whitespace when .innerHTML is used
+			leadingWhitespace: div.firstChild.nodeType === 3,
+
+			// Make sure that tbody elements aren't automatically inserted
+			// IE will insert them into empty tables
+			tbody: !div.getElementsByTagName("tbody").length,
+
+			// Make sure that link elements get serialized correctly by innerHTML
+			// This requires a wrapper element in IE
+			htmlSerialize: !!div.getElementsByTagName("link").length,
+
+			// Get the style information from getAttribute
+			// (IE uses .cssText instead)
+			style: /top/.test( a.getAttribute("style") ),
+
+			// Make sure that URLs aren't manipulated
+			// (IE normalizes it by default)
+			hrefNormalized: a.getAttribute("href") === "/a",
+
+			// Make sure that element opacity exists
+			// (IE uses filter instead)
+			// Use a regex to work around a WebKit issue. See #5145
+			opacity: /^0.5/.test( a.style.opacity ),
+
+			// Verify style float existence
+			// (IE uses styleFloat instead of cssFloat)
+			cssFloat: !!a.style.cssFloat,
+
+			// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
+			checkOn: !!input.value,
+
+			// Make sure that a selected-by-default option has a working selected property.
+			// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
+			optSelected: opt.selected,
+
+			// Tests for enctype support on a form (#6743)
+			enctype: !!document.createElement("form").enctype,
+
+			// Makes sure cloning an html5 element does not cause problems
+			// Where outerHTML is undefined, this still works
+			html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
+
+			// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
+			boxModel: document.compatMode === "CSS1Compat",
+
+			// Will be defined later
+			deleteExpando: true,
+			noCloneEvent: true,
+			inlineBlockNeedsLayout: false,
+			shrinkWrapBlocks: false,
+			reliableMarginRight: true,
+			boxSizingReliable: true,
+			pixelPosition: false
+		};
+
+		// Make sure checked status is properly cloned
+		input.checked = true;
+		support.noCloneChecked = input.cloneNode( true ).checked;
+
+		// Make sure that the options inside disabled selects aren't marked as disabled
+		// (WebKit marks them as disabled)
+		select.disabled = true;
+		support.optDisabled = !opt.disabled;
+
+		// Support: IE<9
+		try {
+			delete div.test;
+		} catch( e ) {
+			support.deleteExpando = false;
+		}
+
+		// Check if we can trust getAttribute("value")
+		input = document.createElement("input");
+		input.setAttribute( "value", "" );
+		support.input = input.getAttribute( "value" ) === "";
+
+		// Check if an input maintains its value after becoming a radio
+		input.value = "t";
+		input.setAttribute( "type", "radio" );
+		support.radioValue = input.value === "t";
+
+		// #11217 - WebKit loses check when the name is after the checked attribute
+		input.setAttribute( "checked", "t" );
+		input.setAttribute( "name", "t" );
+
+		fragment = document.createDocumentFragment();
+		fragment.appendChild( input );
+
+		// Check if a disconnected checkbox will retain its checked
+		// value of true after appended to the DOM (IE6/7)
+		support.appendChecked = input.checked;
+
+		// WebKit doesn't clone checked state correctly in fragments
+		support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
+
+		// Support: IE<9
+		// Opera does not clone events (and typeof div.attachEvent === undefined).
+		// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
+		if ( div.attachEvent ) {
+			div.attachEvent( "onclick", function() {
+				support.noCloneEvent = false;
+			});
+
+			div.cloneNode( true ).click();
+		}
+
+		// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
+		// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php
+		for ( i in { submit: true, change: true, focusin: true }) {
+			div.setAttribute( eventName = "on" + i, "t" );
+
+			support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
+		}
+
+		div.style.backgroundClip = "content-box";
+		div.cloneNode( true ).style.backgroundClip = "";
+		support.clearCloneStyle = div.style.backgroundClip === "content-box";
+
+		// Run tests that need a body at doc ready
+		jQuery(function() {
+			var container, marginDiv, tds,
+				divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
+				body = document.getElementsByTagName("body")[0];
+
+			if ( !body ) {
+				// Return for frameset docs that don't have a body
+				return;
+			}
+
+			container = document.createElement("div");
+			container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";
+
+			body.appendChild( container ).appendChild( div );
+
+			// Support: IE8
+			// Check if table cells still have offsetWidth/Height when they are set
+			// to display:none and there are still other visible table cells in a
+			// table row; if so, offsetWidth/Height are not reliable for use when
+			// determining if an element has been hidden directly using
+			// display:none (it is still safe to use offsets if a parent element is
+			// hidden; don safety goggles and see bug #4512 for more information).
+			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
+			tds = div.getElementsByTagName("td");
+			tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
+			isSupported = ( tds[ 0 ].offsetHeight === 0 );
+
+			tds[ 0 ].style.display = "";
+			tds[ 1 ].style.display = "none";
+
+			// Support: IE8
+			// Check if empty table cells still have offsetWidth/Height
+			support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
+
+			// Check box-sizing and margin behavior
+			div.innerHTML = "";
+			div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
+			support.boxSizing = ( div.offsetWidth === 4 );
+			support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );
+
+			// Use window.getComputedStyle because jsdom on node.js will break without it.
+			if ( window.getComputedStyle ) {
+				support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
+				support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
+
+				// Check if div with explicit width and no margin-right incorrectly
+				// gets computed margin-right based on width of container. (#3333)
+				// Fails in WebKit before Feb 2011 nightlies
+				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
+				marginDiv = div.appendChild( document.createElement("div") );
+				marginDiv.style.cssText = div.style.cssText = divReset;
+				marginDiv.style.marginRight = marginDiv.style.width = "0";
+				div.style.width = "1px";
+
+				support.reliableMarginRight =
+					!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
+			}
+
+			if ( typeof div.style.zoom !== core_strundefined ) {
+				// Support: IE<8
+				// Check if natively block-level elements act like inline-block
+				// elements when setting their display to 'inline' and giving
+				// them layout
+				div.innerHTML = "";
+				div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
+				support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );
+
+				// Support: IE6
+				// Check if elements with layout shrink-wrap their children
+				div.style.display = "block";
+				div.innerHTML = "<div></div>";
+				div.firstChild.style.width = "5px";
+				support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
+
+				if ( support.inlineBlockNeedsLayout ) {
+					// Prevent IE 6 from affecting layout for positioned elements #11048
+					// Prevent IE from shrinking the body in IE 7 mode #12869
+					// Support: IE<8
+					body.style.zoom = 1;
+				}
+			}
+
+			body.removeChild( container );
+
+			// Null elements to avoid leaks in IE
+			container = div = tds = marginDiv = null;
+		});
+
+		// Null elements to avoid leaks in IE
+		all = select = fragment = opt = a = input = null;
+
+		return support;
+	})();
+
+	var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
+		rmultiDash = /([A-Z])/g;
+
+	function internalData( elem, name, data, pvt /* Internal Use Only */ ){
+		if ( !jQuery.acceptData( elem ) ) {
+			return;
+		}
+
+		var thisCache, ret,
+			internalKey = jQuery.expando,
+			getByName = typeof name === "string",
+
+			// We have to handle DOM nodes and JS objects differently because IE6-7
+			// can't GC object references properly across the DOM-JS boundary
+			isNode = elem.nodeType,
+
+			// Only DOM nodes need the global jQuery cache; JS object data is
+			// attached directly to the object so GC can occur automatically
+			cache = isNode ? jQuery.cache : elem,
+
+			// Only defining an ID for JS objects if its cache already exists allows
+			// the code to shortcut on the same path as a DOM node with no cache
+			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;
+
+		// Avoid doing any more work than we need to when trying to get data on an
+		// object that has no data at all
+		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
+			return;
+		}
+
+		if ( !id ) {
+			// Only DOM nodes need a new unique ID for each element since their data
+			// ends up in the global cache
+			if ( isNode ) {
+				elem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;
+			} else {
+				id = internalKey;
+			}
+		}
+
+		if ( !cache[ id ] ) {
+			cache[ id ] = {};
+
+			// Avoids exposing jQuery metadata on plain JS objects when the object
+			// is serialized using JSON.stringify
+			if ( !isNode ) {
+				cache[ id ].toJSON = jQuery.noop;
+			}
+		}
+
+		// An object can be passed to jQuery.data instead of a key/value pair; this gets
+		// shallow copied over onto the existing cache
+		if ( typeof name === "object" || typeof name === "function" ) {
+			if ( pvt ) {
+				cache[ id ] = jQuery.extend( cache[ id ], name );
+			} else {
+				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
+			}
+		}
+
+		thisCache = cache[ id ];
+
+		// jQuery data() is stored in a separate object inside the object's internal data
+		// cache in order to avoid key collisions between internal data and user-defined
+		// data.
+		if ( !pvt ) {
+			if ( !thisCache.data ) {
+				thisCache.data = {};
+			}
+
+			thisCache = thisCache.data;
+		}
+
+		if ( data !== undefined ) {
+			thisCache[ jQuery.camelCase( name ) ] = data;
+		}
+
+		// Check for both converted-to-camel and non-converted data property names
+		// If a data property was specified
+		if ( getByName ) {
+
+			// First Try to find as-is property data
+			ret = thisCache[ name ];
+
+			// Test for null|undefined property data
+			if ( ret == null ) {
+
+				// Try to find the camelCased property
+				ret = thisCache[ jQuery.camelCase( name ) ];
+			}
+		} else {
+			ret = thisCache;
+		}
+
+		return ret;
+	}
+
+	function internalRemoveData( elem, name, pvt ) {
+		if ( !jQuery.acceptData( elem ) ) {
+			return;
+		}
+
+		var i, l, thisCache,
+			isNode = elem.nodeType,
+
+			// See jQuery.data for more information
+			cache = isNode ? jQuery.cache : elem,
+			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
+
+		// If there is already no cache entry for this object, there is no
+		// purpose in continuing
+		if ( !cache[ id ] ) {
+			return;
+		}
+
+		if ( name ) {
+
+			thisCache = pvt ? cache[ id ] : cache[ id ].data;
+
+			if ( thisCache ) {
+
+				// Support array or space separated string names for data keys
+				if ( !jQuery.isArray( name ) ) {
+
+					// try the string as a key before any manipulation
+					if ( name in thisCache ) {
+						name = [ name ];
+					} else {
+
+						// split the camel cased version by spaces unless a key with the spaces exists
+						name = jQuery.camelCase( name );
+						if ( name in thisCache ) {
+							name = [ name ];
+						} else {
+							name = name.split(" ");
+						}
+					}
+				} else {
+					// If "name" is an array of keys...
+					// When data is initially created, via ("key", "val") signature,
+					// keys will be converted to camelCase.
+					// Since there is no way to tell _how_ a key was added, remove
+					// both plain key and camelCase key. #12786
+					// This will only penalize the array argument path.
+					name = name.concat( jQuery.map( name, jQuery.camelCase ) );
+				}
+
+				for ( i = 0, l = name.length; i < l; i++ ) {
+					delete thisCache[ name[i] ];
+				}
+
+				// If there is no data left in the cache, we want to continue
+				// and let the cache object itself get destroyed
+				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
+					return;
+				}
+			}
+		}
+
+		// See jQuery.data for more information
+		if ( !pvt ) {
+			delete cache[ id ].data;
+
+			// Don't destroy the parent cache unless the internal data object
+			// had been the only thing left in it
+			if ( !isEmptyDataObject( cache[ id ] ) ) {
+				return;
+			}
+		}
+
+		// Destroy the cache
+		if ( isNode ) {
+			jQuery.cleanData( [ elem ], true );
+
+		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
+		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
+			delete cache[ id ];
+
+		// When all else fails, null
+		} else {
+			cache[ id ] = null;
+		}
+	}
+
+	jQuery.extend({
+		cache: {},
+
+		// Unique for each copy of jQuery on the page
+		// Non-digits removed to match rinlinejQuery
+		expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),
+
+		// The following elements throw uncatchable exceptions if you
+		// attempt to add expando properties to them.
+		noData: {
+			"embed": true,
+			// Ban all objects except for Flash (which handle expandos)
+			"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
+			"applet": true
+		},
+
+		hasData: function( elem ) {
+			elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
+			return !!elem && !isEmptyDataObject( elem );
+		},
+
+		data: function( elem, name, data ) {
+			return internalData( elem, name, data );
+		},
+
+		removeData: function( elem, name ) {
+			return internalRemoveData( elem, name );
+		},
+
+		// For internal use only.
+		_data: function( elem, name, data ) {
+			return internalData( elem, name, data, true );
+		},
+
+		_removeData: function( elem, name ) {
+			return internalRemoveData( elem, name, true );
+		},
+
+		// A method for determining if a DOM node can handle the data expando
+		acceptData: function( elem ) {
+			// Do not set data on non-element because it will not be cleared (#8335).
+			if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
+				return false;
+			}
+
+			var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];
+
+			// nodes accept data unless otherwise specified; rejection can be conditional
+			return !noData || noData !== true && elem.getAttribute("classid") === noData;
+		}
+	});
+
+	jQuery.fn.extend({
+		data: function( key, value ) {
+			var attrs, name,
+				elem = this[0],
+				i = 0,
+				data = null;
+
+			// Gets all values
+			if ( key === undefined ) {
+				if ( this.length ) {
+					data = jQuery.data( elem );
+
+					if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
+						attrs = elem.attributes;
+						for ( ; i < attrs.length; i++ ) {
+							name = attrs[i].name;
+
+							if ( !name.indexOf( "data-" ) ) {
+								name = jQuery.camelCase( name.slice(5) );
+
+								dataAttr( elem, name, data[ name ] );
+							}
+						}
+						jQuery._data( elem, "parsedAttrs", true );
+					}
+				}
+
+				return data;
+			}
+
+			// Sets multiple values
+			if ( typeof key === "object" ) {
+				return this.each(function() {
+					jQuery.data( this, key );
+				});
+			}
+
+			return jQuery.access( this, function( value ) {
+
+				if ( value === undefined ) {
+					// Try to fetch any internally stored data first
+					return elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
+				}
+
+				this.each(function() {
+					jQuery.data( this, key, value );
+				});
+			}, null, value, arguments.length > 1, null, true );
+		},
+
+		removeData: function( key ) {
+			return this.each(function() {
+				jQuery.removeData( this, key );
+			});
+		}
+	});
+
+	function dataAttr( elem, key, data ) {
+		// If nothing was found internally, try to fetch any
+		// data from the HTML5 data-* attribute
+		if ( data === undefined && elem.nodeType === 1 ) {
+
+			var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
+
+			data = elem.getAttribute( name );
+
+			if ( typeof data === "string" ) {
+				try {
+					data = data === "true" ? true :
+						data === "false" ? false :
+						data === "null" ? null :
+						// Only convert to a number if it doesn't change the string
+						+data + "" === data ? +data :
+						rbrace.test( data ) ? jQuery.parseJSON( data ) :
+							data;
+				} catch( e ) {}
+
+				// Make sure we set the data so it isn't changed later
+				jQuery.data( elem, key, data );
+
+			} else {
+				data = undefined;
+			}
+		}
+
+		return data;
+	}
+
+	// checks a cache object for emptiness
+	function isEmptyDataObject( obj ) {
+		var name;
+		for ( name in obj ) {
+
+			// if the public data object is empty, the private is still empty
+			if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
+				continue;
+			}
+			if ( name !== "toJSON" ) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+	jQuery.extend({
+		queue: function( elem, type, data ) {
+			var queue;
+
+			if ( elem ) {
+				type = ( type || "fx" ) + "queue";
+				queue = jQuery._data( elem, type );
+
+				// Speed up dequeue by getting out quickly if this is just a lookup
+				if ( data ) {
+					if ( !queue || jQuery.isArray(data) ) {
+						queue = jQuery._data( elem, type, jQuery.makeArray(data) );
+					} else {
+						queue.push( data );
+					}
+				}
+				return queue || [];
+			}
+		},
+
+		dequeue: function( elem, type ) {
+			type = type || "fx";
+
+			var queue = jQuery.queue( elem, type ),
+				startLength = queue.length,
+				fn = queue.shift(),
+				hooks = jQuery._queueHooks( elem, type ),
+				next = function() {
+					jQuery.dequeue( elem, type );
+				};
+
+			// If the fx queue is dequeued, always remove the progress sentinel
+			if ( fn === "inprogress" ) {
+				fn = queue.shift();
+				startLength--;
+			}
+
+			hooks.cur = fn;
+			if ( fn ) {
+
+				// Add a progress sentinel to prevent the fx queue from being
+				// automatically dequeued
+				if ( type === "fx" ) {
+					queue.unshift( "inprogress" );
+				}
+
+				// clear up the last queue stop function
+				delete hooks.stop;
+				fn.call( elem, next, hooks );
+			}
+
+			if ( !startLength && hooks ) {
+				hooks.empty.fire();
+			}
+		},
+
+		// not intended for public consumption - generates a queueHooks object, or returns the current one
+		_queueHooks: function( elem, type ) {
+			var key = type + "queueHooks";
+			return jQuery._data( elem, key ) || jQuery._data( elem, key, {
+				empty: jQuery.Callbacks("once memory").add(function() {
+					jQuery._removeData( elem, type + "queue" );
+					jQuery._removeData( elem, key );
+				})
+			});
+		}
+	});
+
+	jQuery.fn.extend({
+		queue: function( type, data ) {
+			var setter = 2;
+
+			if ( typeof type !== "string" ) {
+				data = type;
+				type = "fx";
+				setter--;
+			}
+
+			if ( arguments.length < setter ) {
+				return jQuery.queue( this[0], type );
+			}
+
+			return data === undefined ?
+				this :
+				this.each(function() {
+					var queue = jQuery.queue( this, type, data );
+
+					// ensure a hooks for this queue
+					jQuery._queueHooks( this, type );
+
+					if ( type === "fx" && queue[0] !== "inprogress" ) {
+						jQuery.dequeue( this, type );
+					}
+				});
+		},
+		dequeue: function( type ) {
+			return this.each(function() {
+				jQuery.dequeue( this, type );
+			});
+		},
+		// Based off of the plugin by Clint Helfers, with permission.
+		// http://blindsignals.com/index.php/2009/07/jquery-delay/
+		delay: function( time, type ) {
+			time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
+			type = type || "fx";
+
+			return this.queue( type, function( next, hooks ) {
+				var timeout = setTimeout( next, time );
+				hooks.stop = function() {
+					clearTimeout( timeout );
+				};
+			});
+		},
+		clearQueue: function( type ) {
+			return this.queue( type || "fx", [] );
+		},
+		// Get a promise resolved when queues of a certain type
+		// are emptied (fx is the type by default)
+		promise: function( type, obj ) {
+			var tmp,
+				count = 1,
+				defer = jQuery.Deferred(),
+				elements = this,
+				i = this.length,
+				resolve = function() {
+					if ( !( --count ) ) {
+						defer.resolveWith( elements, [ elements ] );
+					}
+				};
+
+			if ( typeof type !== "string" ) {
+				obj = type;
+				type = undefined;
+			}
+			type = type || "fx";
+
+			while( i-- ) {
+				tmp = jQuery._data( elements[ i ], type + "queueHooks" );
+				if ( tmp && tmp.empty ) {
+					count++;
+					tmp.empty.add( resolve );
+				}
+			}
+			resolve();
+			return defer.promise( obj );
+		}
+	});
+	var nodeHook, boolHook,
+		rclass = /[\t\r\n]/g,
+		rreturn = /\r/g,
+		rfocusable = /^(?:input|select|textarea|button|object)$/i,
+		rclickable = /^(?:a|area)$/i,
+		rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,
+		ruseDefault = /^(?:checked|selected)$/i,
+		getSetAttribute = jQuery.support.getSetAttribute,
+		getSetInput = jQuery.support.input;
+
+	jQuery.fn.extend({
+		attr: function( name, value ) {
+			return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
+		},
+
+		removeAttr: function( name ) {
+			return this.each(function() {
+				jQuery.removeAttr( this, name );
+			});
+		},
+
+		prop: function( name, value ) {
+			return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
+		},
+
+		removeProp: function( name ) {
+			name = jQuery.propFix[ name ] || name;
+			return this.each(function() {
+				// try/catch handles cases where IE balks (such as removing a property on window)
+				try {
+					this[ name ] = undefined;
+					delete this[ name ];
+				} catch( e ) {}
+			});
+		},
+
+		addClass: function( value ) {
+			var classes, elem, cur, clazz, j,
+				i = 0,
+				len = this.length,
+				proceed = typeof value === "string" && value;
+
+			if ( jQuery.isFunction( value ) ) {
+				return this.each(function( j ) {
+					jQuery( this ).addClass( value.call( this, j, this.className ) );
+				});
+			}
+
+			if ( proceed ) {
+				// The disjunction here is for better compressibility (see removeClass)
+				classes = ( value || "" ).match( core_rnotwhite ) || [];
+
+				for ( ; i < len; i++ ) {
+					elem = this[ i ];
+					cur = elem.nodeType === 1 && ( elem.className ?
+						( " " + elem.className + " " ).replace( rclass, " " ) :
+						" "
+					);
+
+					if ( cur ) {
+						j = 0;
+						while ( (clazz = classes[j++]) ) {
+							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
+								cur += clazz + " ";
+							}
+						}
+						elem.className = jQuery.trim( cur );
+
+					}
+				}
+			}
+
+			return this;
+		},
+
+		removeClass: function( value ) {
+			var classes, elem, cur, clazz, j,
+				i = 0,
+				len = this.length,
+				proceed = arguments.length === 0 || typeof value === "string" && value;
+
+			if ( jQuery.isFunction( value ) ) {
+				return this.each(function( j ) {
+					jQuery( this ).removeClass( value.call( this, j, this.className ) );
+				});
+			}
+			if ( proceed ) {
+				classes = ( value || "" ).match( core_rnotwhite ) || [];
+
+				for ( ; i < len; i++ ) {
+					elem = this[ i ];
+					// This expression is here for better compressibility (see addClass)
+					cur = elem.nodeType === 1 && ( elem.className ?
+						( " " + elem.className + " " ).replace( rclass, " " ) :
+						""
+					);
+
+					if ( cur ) {
+						j = 0;
+						while ( (clazz = classes[j++]) ) {
+							// Remove *all* instances
+							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
+								cur = cur.replace( " " + clazz + " ", " " );
+							}
+						}
+						elem.className = value ? jQuery.trim( cur ) : "";
+					}
+				}
+			}
+
+			return this;
+		},
+
+		toggleClass: function( value, stateVal ) {
+			var type = typeof value,
+				isBool = typeof stateVal === "boolean";
+
+			if ( jQuery.isFunction( value ) ) {
+				return this.each(function( i ) {
+					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
+				});
+			}
+
+			return this.each(function() {
+				if ( type === "string" ) {
+					// toggle individual class names
+					var className,
+						i = 0,
+						self = jQuery( this ),
+						state = stateVal,
+						classNames = value.match( core_rnotwhite ) || [];
+
+					while ( (className = classNames[ i++ ]) ) {
+						// check each className given, space separated list
+						state = isBool ? state : !self.hasClass( className );
+						self[ state ? "addClass" : "removeClass" ]( className );
+					}
+
+				// Toggle whole class name
+				} else if ( type === core_strundefined || type === "boolean" ) {
+					if ( this.className ) {
+						// store className if set
+						jQuery._data( this, "__className__", this.className );
+					}
+
+					// If the element has a class name or if we're passed "false",
+					// then remove the whole classname (if there was one, the above saved it).
+					// Otherwise bring back whatever was previously saved (if anything),
+					// falling back to the empty string if nothing was stored.
+					this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
+				}
+			});
+		},
+
+		hasClass: function( selector ) {
+			var className = " " + selector + " ",
+				i = 0,
+				l = this.length;
+			for ( ; i < l; i++ ) {
+				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
+					return true;
+				}
+			}
+
+			return false;
+		},
+
+		val: function( value ) {
+			var ret, hooks, isFunction,
+				elem = this[0];
+
+			if ( !arguments.length ) {
+				if ( elem ) {
+					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
+
+					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
+						return ret;
+					}
+
+					ret = elem.value;
+
+					return typeof ret === "string" ?
+						// handle most common string cases
+						ret.replace(rreturn, "") :
+						// handle cases where value is null/undef or number
+						ret == null ? "" : ret;
+				}
+
+				return;
+			}
+
+			isFunction = jQuery.isFunction( value );
+
+			return this.each(function( i ) {
+				var val,
+					self = jQuery(this);
+
+				if ( this.nodeType !== 1 ) {
+					return;
+				}
+
+				if ( isFunction ) {
+					val = value.call( this, i, self.val() );
+				} else {
+					val = value;
+				}
+
+				// Treat null/undefined as ""; convert numbers to string
+				if ( val == null ) {
+					val = "";
+				} else if ( typeof val === "number" ) {
+					val += "";
+				} else if ( jQuery.isArray( val ) ) {
+					val = jQuery.map(val, function ( value ) {
+						return value == null ? "" : value + "";
+					});
+				}
+
+				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
+
+				// If set returns undefined, fall back to normal setting
+				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
+					this.value = val;
+				}
+			});
+		}
+	});
+
+	jQuery.extend({
+		valHooks: {
+			option: {
+				get: function( elem ) {
+					// attributes.value is undefined in Blackberry 4.7 but
+					// uses .value. See #6932
+					var val = elem.attributes.value;
+					return !val || val.specified ? elem.value : elem.text;
+				}
+			},
+			select: {
+				get: function( elem ) {
+					var value, option,
+						options = elem.options,
+						index = elem.selectedIndex,
+						one = elem.type === "select-one" || index < 0,
+						values = one ? null : [],
+						max = one ? index + 1 : options.length,
+						i = index < 0 ?
+							max :
+							one ? index : 0;
+
+					// Loop through all the selected options
+					for ( ; i < max; i++ ) {
+						option = options[ i ];
+
+						// oldIE doesn't update selected after form reset (#2551)
+						if ( ( option.selected || i === index ) &&
+								// Don't return options that are disabled or in a disabled optgroup
+								( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
+								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
+
+							// Get the specific value for the option
+							value = jQuery( option ).val();
+
+							// We don't need an array for one selects
+							if ( one ) {
+								return value;
+							}
+
+							// Multi-Selects return an array
+							values.push( value );
+						}
+					}
+
+					return values;
+				},
+
+				set: function( elem, value ) {
+					var values = jQuery.makeArray( value );
+
+					jQuery(elem).find("option").each(function() {
+						this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
+					});
+
+					if ( !values.length ) {
+						elem.selectedIndex = -1;
+					}
+					return values;
+				}
+			}
+		},
+
+		attr: function( elem, name, value ) {
+			var hooks, notxml, ret,
+				nType = elem.nodeType;
+
+			// don't get/set attributes on text, comment and attribute nodes
+			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
+				return;
+			}
+
+			// Fallback to prop when attributes are not supported
+			if ( typeof elem.getAttribute === core_strundefined ) {
+				return jQuery.prop( elem, name, value );
+			}
+
+			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
+
+			// All attributes are lowercase
+			// Grab necessary hook if one is defined
+			if ( notxml ) {
+				name = name.toLowerCase();
+				hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
+			}
+
+			if ( value !== undefined ) {
+
+				if ( value === null ) {
+					jQuery.removeAttr( elem, name );
+
+				} else if ( hooks && notxml && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
+					return ret;
+
+				} else {
+					elem.setAttribute( name, value + "" );
+					return value;
+				}
+
+			} else if ( hooks && notxml && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
+				return ret;
+
+			} else {
+
+				// In IE9+, Flash objects don't have .getAttribute (#12945)
+				// Support: IE9+
+				if ( typeof elem.getAttribute !== core_strundefined ) {
+					ret =  elem.getAttribute( name );
+				}
+
+				// Non-existent attributes return null, we normalize to undefined
+				return ret == null ?
+					undefined :
+					ret;
+			}
+		},
+
+		removeAttr: function( elem, value ) {
+			var name, propName,
+				i = 0,
+				attrNames = value && value.match( core_rnotwhite );
+
+			if ( attrNames && elem.nodeType === 1 ) {
+				while ( (name = attrNames[i++]) ) {
+					propName = jQuery.propFix[ name ] || name;
+
+					// Boolean attributes get special treatment (#10870)
+					if ( rboolean.test( name ) ) {
+						// Set corresponding property to false for boolean attributes
+						// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8
+						if ( !getSetAttribute && ruseDefault.test( name ) ) {
+							elem[ jQuery.camelCase( "default-" + name ) ] =
+								elem[ propName ] = false;
+						} else {
+							elem[ propName ] = false;
+						}
+
+					// See #9699 for explanation of this approach (setting first, then removal)
+					} else {
+						jQuery.attr( elem, name, "" );
+					}
+
+					elem.removeAttribute( getSetAttribute ? name : propName );
+				}
+			}
+		},
+
+		attrHooks: {
+			type: {
+				set: function( elem, value ) {
+					if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
+						// Setting the type on a radio button after the value resets the value in IE6-9
+						// Reset value to default in case type is set after value during creation
+						var val = elem.value;
+						elem.setAttribute( "type", value );
+						if ( val ) {
+							elem.value = val;
+						}
+						return value;
+					}
+				}
+			}
+		},
+
+		propFix: {
+			tabindex: "tabIndex",
+			readonly: "readOnly",
+			"for": "htmlFor",
+			"class": "className",
+			maxlength: "maxLength",
+			cellspacing: "cellSpacing",
+			cellpadding: "cellPadding",
+			rowspan: "rowSpan",
+			colspan: "colSpan",
+			usemap: "useMap",
+			frameborder: "frameBorder",
+			contenteditable: "contentEditable"
+		},
+
+		prop: function( elem, name, value ) {
+			var ret, hooks, notxml,
+				nType = elem.nodeType;
+
+			// don't get/set properties on text, comment and attribute nodes
+			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
+				return;
+			}
+
+			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
+
+			if ( notxml ) {
+				// Fix name and attach hooks
+				name = jQuery.propFix[ name ] || name;
+				hooks = jQuery.propHooks[ name ];
+			}
+
+			if ( value !== undefined ) {
+				if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
+					return ret;
+
+				} else {
+					return ( elem[ name ] = value );
+				}
+
+			} else {
+				if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
+					return ret;
+
+				} else {
+					return elem[ name ];
+				}
+			}
+		},
+
+		propHooks: {
+			tabIndex: {
+				get: function( elem ) {
+					// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
+					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
+					var attributeNode = elem.getAttributeNode("tabindex");
+
+					return attributeNode && attributeNode.specified ?
+						parseInt( attributeNode.value, 10 ) :
+						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
+							0 :
+							undefined;
+				}
+			}
+		}
+	});
+
+	// Hook for boolean attributes
+	boolHook = {
+		get: function( elem, name ) {
+			var
+				// Use .prop to determine if this attribute is understood as boolean
+				prop = jQuery.prop( elem, name ),
+
+				// Fetch it accordingly
+				attr = typeof prop === "boolean" && elem.getAttribute( name ),
+				detail = typeof prop === "boolean" ?
+
+					getSetInput && getSetAttribute ?
+						attr != null :
+						// oldIE fabricates an empty string for missing boolean attributes
+						// and conflates checked/selected into attroperties
+						ruseDefault.test( name ) ?
+							elem[ jQuery.camelCase( "default-" + name ) ] :
+							!!attr :
+
+					// fetch an attribute node for properties not recognized as boolean
+					elem.getAttributeNode( name );
+
+			return detail && detail.value !== false ?
+				name.toLowerCase() :
+				undefined;
+		},
+		set: function( elem, value, name ) {
+			if ( value === false ) {
+				// Remove boolean attributes when set to false
+				jQuery.removeAttr( elem, name );
+			} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
+				// IE<8 needs the *property* name
+				elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );
+
+			// Use defaultChecked and defaultSelected for oldIE
+			} else {
+				elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
+			}
+
+			return name;
+		}
+	};
+
+	// fix oldIE value attroperty
+	if ( !getSetInput || !getSetAttribute ) {
+		jQuery.attrHooks.value = {
+			get: function( elem, name ) {
+				var ret = elem.getAttributeNode( name );
+				return jQuery.nodeName( elem, "input" ) ?
+
+					// Ignore the value *property* by using defaultValue
+					elem.defaultValue :
+
+					ret && ret.specified ? ret.value : undefined;
+			},
+			set: function( elem, value, name ) {
+				if ( jQuery.nodeName( elem, "input" ) ) {
+					// Does not return so that setAttribute is also used
+					elem.defaultValue = value;
+				} else {
+					// Use nodeHook if defined (#1954); otherwise setAttribute is fine
+					return nodeHook && nodeHook.set( elem, value, name );
+				}
+			}
+		};
+	}
+
+	// IE6/7 do not support getting/setting some attributes with get/setAttribute
+	if ( !getSetAttribute ) {
+
+		// Use this for any attribute in IE6/7
+		// This fixes almost every IE6/7 issue
+		nodeHook = jQuery.valHooks.button = {
+			get: function( elem, name ) {
+				var ret = elem.getAttributeNode( name );
+				return ret && ( name === "id" || name === "name" || name === "coords" ? ret.value !== "" : ret.specified ) ?
+					ret.value :
+					undefined;
+			},
+			set: function( elem, value, name ) {
+				// Set the existing or create a new attribute node
+				var ret = elem.getAttributeNode( name );
+				if ( !ret ) {
+					elem.setAttributeNode(
+						(ret = elem.ownerDocument.createAttribute( name ))
+					);
+				}
+
+				ret.value = value += "";
+
+				// Break association with cloned elements by also using setAttribute (#9646)
+				return name === "value" || value === elem.getAttribute( name ) ?
+					value :
+					undefined;
+			}
+		};
+
+		// Set contenteditable to false on removals(#10429)
+		// Setting to empty string throws an error as an invalid value
+		jQuery.attrHooks.contenteditable = {
+			get: nodeHook.get,
+			set: function( elem, value, name ) {
+				nodeHook.set( elem, value === "" ? false : value, name );
+			}
+		};
+
+		// Set width and height to auto instead of 0 on empty string( Bug #8150 )
+		// This is for removals
+		jQuery.each([ "width", "height" ], function( i, name ) {
+			jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
+				set: function( elem, value ) {
+					if ( value === "" ) {
+						elem.setAttribute( name, "auto" );
+						return value;
+					}
+				}
+			});
+		});
+	}
+
+
+	// Some attributes require a special call on IE
+	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
+	if ( !jQuery.support.hrefNormalized ) {
+		jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
+			jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
+				get: function( elem ) {
+					var ret = elem.getAttribute( name, 2 );
+					return ret == null ? undefined : ret;
+				}
+			});
+		});
+
+		// href/src property should get the full normalized URL (#10299/#12915)
+		jQuery.each([ "href", "src" ], function( i, name ) {
+			jQuery.propHooks[ name ] = {
+				get: function( elem ) {
+					return elem.getAttribute( name, 4 );
+				}
+			};
+		});
+	}
+
+	if ( !jQuery.support.style ) {
+		jQuery.attrHooks.style = {
+			get: function( elem ) {
+				// Return undefined in the case of empty string
+				// Note: IE uppercases css property names, but if we were to .toLowerCase()
+				// .cssText, that would destroy case senstitivity in URL's, like in "background"
+				return elem.style.cssText || undefined;
+			},
+			set: function( elem, value ) {
+				return ( elem.style.cssText = value + "" );
+			}
+		};
+	}
+
+	// Safari mis-reports the default selected property of an option
+	// Accessing the parent's selectedIndex property fixes it
+	if ( !jQuery.support.optSelected ) {
+		jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
+			get: function( elem ) {
+				var parent = elem.parentNode;
+
+				if ( parent ) {
+					parent.selectedIndex;
+
+					// Make sure that it also works with optgroups, see #5701
+					if ( parent.parentNode ) {
+						parent.parentNode.selectedIndex;
+					}
+				}
+				return null;
+			}
+		});
+	}
+
+	// IE6/7 call enctype encoding
+	if ( !jQuery.support.enctype ) {
+		jQuery.propFix.enctype = "encoding";
+	}
+
+	// Radios and checkboxes getter/setter
+	if ( !jQuery.support.checkOn ) {
+		jQuery.each([ "radio", "checkbox" ], function() {
+			jQuery.valHooks[ this ] = {
+				get: function( elem ) {
+					// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
+					return elem.getAttribute("value") === null ? "on" : elem.value;
+				}
+			};
+		});
+	}
+	jQuery.each([ "radio", "checkbox" ], function() {
+		jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
+			set: function( elem, value ) {
+				if ( jQuery.isArray( value ) ) {
+					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
+				}
+			}
+		});
+	});
+	var rformElems = /^(?:input|select|textarea)$/i,
+		rkeyEvent = /^key/,
+		rmouseEvent = /^(?:mouse|contextmenu)|click/,
+		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
+		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
+
+	function returnTrue() {
+		return true;
+	}
+
+	function returnFalse() {
+		return false;
+	}
+
+	/*
+	 * Helper functions for managing events -- not part of the public interface.
+	 * Props to Dean Edwards' addEvent library for many of the ideas.
+	 */
+	jQuery.event = {
+
+		global: {},
+
+		add: function( elem, types, handler, data, selector ) {
+			var tmp, events, t, handleObjIn,
+				special, eventHandle, handleObj,
+				handlers, type, namespaces, origType,
+				elemData = jQuery._data( elem );
+
+			// Don't attach events to noData or text/comment nodes (but allow plain objects)
+			if ( !elemData ) {
+				return;
+			}
+
+			// Caller can pass in an object of custom data in lieu of the handler
+			if ( handler.handler ) {
+				handleObjIn = handler;
+				handler = handleObjIn.handler;
+				selector = handleObjIn.selector;
+			}
+
+			// Make sure that the handler has a unique ID, used to find/remove it later
+			if ( !handler.guid ) {
+				handler.guid = jQuery.guid++;
+			}
+
+			// Init the element's event structure and main handler, if this is the first
+			if ( !(events = elemData.events) ) {
+				events = elemData.events = {};
+			}
+			if ( !(eventHandle = elemData.handle) ) {
+				eventHandle = elemData.handle = function( e ) {
+					// Discard the second event of a jQuery.event.trigger() and
+					// when an event is called after a page has unloaded
+					return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
+						jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
+						undefined;
+				};
+				// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
+				eventHandle.elem = elem;
+			}
+
+			// Handle multiple events separated by a space
+			// jQuery(...).bind("mouseover mouseout", fn);
+			types = ( types || "" ).match( core_rnotwhite ) || [""];
+			t = types.length;
+			while ( t-- ) {
+				tmp = rtypenamespace.exec( types[t] ) || [];
+				type = origType = tmp[1];
+				namespaces = ( tmp[2] || "" ).split( "." ).sort();
+
+				// If event changes its type, use the special event handlers for the changed type
+				special = jQuery.event.special[ type ] || {};
+
+				// If selector defined, determine special event api type, otherwise given type
+				type = ( selector ? special.delegateType : special.bindType ) || type;
+
+				// Update special based on newly reset type
+				special = jQuery.event.special[ type ] || {};
+
+				// handleObj is passed to all event handlers
+				handleObj = jQuery.extend({
+					type: type,
+					origType: origType,
+					data: data,
+					handler: handler,
+					guid: handler.guid,
+					selector: selector,
+					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
+					namespace: namespaces.join(".")
+				}, handleObjIn );
+
+				// Init the event handler queue if we're the first
+				if ( !(handlers = events[ type ]) ) {
+					handlers = events[ type ] = [];
+					handlers.delegateCount = 0;
+
+					// Only use addEventListener/attachEvent if the special events handler returns false
+					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
+						// Bind the global event handler to the element
+						if ( elem.addEventListener ) {
+							elem.addEventListener( type, eventHandle, false );
+
+						} else if ( elem.attachEvent ) {
+							elem.attachEvent( "on" + type, eventHandle );
+						}
+					}
+				}
+
+				if ( special.add ) {
+					special.add.call( elem, handleObj );
+
+					if ( !handleObj.handler.guid ) {
+						handleObj.handler.guid = handler.guid;
+					}
+				}
+
+				// Add to the element's handler list, delegates in front
+				if ( selector ) {
+					handlers.splice( handlers.delegateCount++, 0, handleObj );
+				} else {
+					handlers.push( handleObj );
+				}
+
+				// Keep track of which events have ever been used, for event optimization
+				jQuery.event.global[ type ] = true;
+			}
+
+			// Nullify elem to prevent memory leaks in IE
+			elem = null;
+		},
+
+		// Detach an event or set of events from an element
+		remove: function( elem, types, handler, selector, mappedTypes ) {
+			var j, handleObj, tmp,
+				origCount, t, events,
+				special, handlers, type,
+				namespaces, origType,
+				elemData = jQuery.hasData( elem ) && jQuery._data( elem );
+
+			if ( !elemData || !(events = elemData.events) ) {
+				return;
+			}
+
+			// Once for each type.namespace in types; type may be omitted
+			types = ( types || "" ).match( core_rnotwhite ) || [""];
+			t = types.length;
+			while ( t-- ) {
+				tmp = rtypenamespace.exec( types[t] ) || [];
+				type = origType = tmp[1];
+				namespaces = ( tmp[2] || "" ).split( "." ).sort();
+
+				// Unbind all events (on this namespace, if provided) for the element
+				if ( !type ) {
+					for ( type in events ) {
+						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
+					}
+					continue;
+				}
+
+				special = jQuery.event.special[ type ] || {};
+				type = ( selector ? special.delegateType : special.bindType ) || type;
+				handlers = events[ type ] || [];
+				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
+
+				// Remove matching events
+				origCount = j = handlers.length;
+				while ( j-- ) {
+					handleObj = handlers[ j ];
+
+					if ( ( mappedTypes || origType === handleObj.origType ) &&
+						( !handler || handler.guid === handleObj.guid ) &&
+						( !tmp || tmp.test( handleObj.namespace ) ) &&
+						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
+						handlers.splice( j, 1 );
+
+						if ( handleObj.selector ) {
+							handlers.delegateCount--;
+						}
+						if ( special.remove ) {
+							special.remove.call( elem, handleObj );
+						}
+					}
+				}
+
+				// Remove generic event handler if we removed something and no more handlers exist
+				// (avoids potential for endless recursion during removal of special event handlers)
+				if ( origCount && !handlers.length ) {
+					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
+						jQuery.removeEvent( elem, type, elemData.handle );
+					}
+
+					delete events[ type ];
+				}
+			}
+
+			// Remove the expando if it's no longer used
+			if ( jQuery.isEmptyObject( events ) ) {
+				delete elemData.handle;
+
+				// removeData also checks for emptiness and clears the expando if empty
+				// so use it instead of delete
+				jQuery._removeData( elem, "events" );
+			}
+		},
+
+		trigger: function( event, data, elem, onlyHandlers ) {
+			var handle, ontype, cur,
+				bubbleType, special, tmp, i,
+				eventPath = [ elem || document ],
+				type = core_hasOwn.call( event, "type" ) ? event.type : event,
+				namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
+
+			cur = tmp = elem = elem || document;
+
+			// Don't do events on text and comment nodes
+			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
+				return;
+			}
+
+			// focus/blur morphs to focusin/out; ensure we're not firing them right now
+			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
+				return;
+			}
+
+			if ( type.indexOf(".") >= 0 ) {
+				// Namespaced trigger; create a regexp to match event type in handle()
+				namespaces = type.split(".");
+				type = namespaces.shift();
+				namespaces.sort();
+			}
+			ontype = type.indexOf(":") < 0 && "on" + type;
+
+			// Caller can pass in a jQuery.Event object, Object, or just an event type string
+			event = event[ jQuery.expando ] ?
+				event :
+				new jQuery.Event( type, typeof event === "object" && event );
+
+			event.isTrigger = true;
+			event.namespace = namespaces.join(".");
+			event.namespace_re = event.namespace ?
+				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
+				null;
+
+			// Clean up the event in case it is being reused
+			event.result = undefined;
+			if ( !event.target ) {
+				event.target = elem;
+			}
+
+			// Clone any incoming data and prepend the event, creating the handler arg list
+			data = data == null ?
+				[ event ] :
+				jQuery.makeArray( data, [ event ] );
+
+			// Allow special events to draw outside the lines
+			special = jQuery.event.special[ type ] || {};
+			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
+				return;
+			}
+
+			// Determine event propagation path in advance, per W3C events spec (#9951)
+			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
+			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
+
+				bubbleType = special.delegateType || type;
+				if ( !rfocusMorph.test( bubbleType + type ) ) {
+					cur = cur.parentNode;
+				}
+				for ( ; cur; cur = cur.parentNode ) {
+					eventPath.push( cur );
+					tmp = cur;
+				}
+
+				// Only add window if we got to document (e.g., not plain obj or detached DOM)
+				if ( tmp === (elem.ownerDocument || document) ) {
+					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
+				}
+			}
+
+			// Fire handlers on the event path
+			i = 0;
+			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
+
+				event.type = i > 1 ?
+					bubbleType :
+					special.bindType || type;
+
+				// jQuery handler
+				handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
+				if ( handle ) {
+					handle.apply( cur, data );
+				}
+
+				// Native handler
+				handle = ontype && cur[ ontype ];
+				if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
+					event.preventDefault();
+				}
+			}
+			event.type = type;
+
+			// If nobody prevented the default action, do it now
+			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
+
+				if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
+					!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
+
+					// Call a native DOM method on the target with the same name name as the event.
+					// Can't use an .isFunction() check here because IE6/7 fails that test.
+					// Don't do default actions on window, that's where global variables be (#6170)
+					if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {
+
+						// Don't re-trigger an onFOO event when we call its FOO() method
+						tmp = elem[ ontype ];
+
+						if ( tmp ) {
+							elem[ ontype ] = null;
+						}
+
+						// Prevent re-triggering of the same event, since we already bubbled it above
+						jQuery.event.triggered = type;
+						try {
+							elem[ type ]();
+						} catch ( e ) {
+							// IE<9 dies on focus/blur to hidden element (#1486,#12518)
+							// only reproducible on winXP IE8 native, not IE9 in IE8 mode
+						}
+						jQuery.event.triggered = undefined;
+
+						if ( tmp ) {
+							elem[ ontype ] = tmp;
+						}
+					}
+				}
+			}
+
+			return event.result;
+		},
+
+		dispatch: function( event ) {
+
+			// Make a writable jQuery.Event from the native event object
+			event = jQuery.event.fix( event );
+
+			var i, ret, handleObj, matched, j,
+				handlerQueue = [],
+				args = core_slice.call( arguments ),
+				handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
+				special = jQuery.event.special[ event.type ] || {};
+
+			// Use the fix-ed jQuery.Event rather than the (read-only) native event
+			args[0] = event;
+			event.delegateTarget = this;
+
+			// Call the preDispatch hook for the mapped type, and let it bail if desired
+			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
+				return;
+			}
+
+			// Determine handlers
+			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
+
+			// Run delegates first; they may want to stop propagation beneath us
+			i = 0;
+			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
+				event.currentTarget = matched.elem;
+
+				j = 0;
+				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
+
+					// Triggered event must either 1) have no namespace, or
+					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
+					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
+
+						event.handleObj = handleObj;
+						event.data = handleObj.data;
+
+						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
+								.apply( matched.elem, args );
+
+						if ( ret !== undefined ) {
+							if ( (event.result = ret) === false ) {
+								event.preventDefault();
+								event.stopPropagation();
+							}
+						}
+					}
+				}
+			}
+
+			// Call the postDispatch hook for the mapped type
+			if ( special.postDispatch ) {
+				special.postDispatch.call( this, event );
+			}
+
+			return event.result;
+		},
+
+		handlers: function( event, handlers ) {
+			var sel, handleObj, matches, i,
+				handlerQueue = [],
+				delegateCount = handlers.delegateCount,
+				cur = event.target;
+
+			// Find delegate handlers
+			// Black-hole SVG <use> instance trees (#13180)
+			// Avoid non-left-click bubbling in Firefox (#3861)
+			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
+
+				for ( ; cur != this; cur = cur.parentNode || this ) {
+
+					// Don't check non-elements (#13208)
+					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
+					if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
+						matches = [];
+						for ( i = 0; i < delegateCount; i++ ) {
+							handleObj = handlers[ i ];
+
+							// Don't conflict with Object.prototype properties (#13203)
+							sel = handleObj.selector + " ";
+
+							if ( matches[ sel ] === undefined ) {
+								matches[ sel ] = handleObj.needsContext ?
+									jQuery( sel, this ).index( cur ) >= 0 :
+									jQuery.find( sel, this, null, [ cur ] ).length;
+							}
+							if ( matches[ sel ] ) {
+								matches.push( handleObj );
+							}
+						}
+						if ( matches.length ) {
+							handlerQueue.push({ elem: cur, handlers: matches });
+						}
+					}
+				}
+			}
+
+			// Add the remaining (directly-bound) handlers
+			if ( delegateCount < handlers.length ) {
+				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
+			}
+
+			return handlerQueue;
+		},
+
+		fix: function( event ) {
+			if ( event[ jQuery.expando ] ) {
+				return event;
+			}
+
+			// Create a writable copy of the event object and normalize some properties
+			var i, prop, copy,
+				type = event.type,
+				originalEvent = event,
+				fixHook = this.fixHooks[ type ];
+
+			if ( !fixHook ) {
+				this.fixHooks[ type ] = fixHook =
+					rmouseEvent.test( type ) ? this.mouseHooks :
+					rkeyEvent.test( type ) ? this.keyHooks :
+					{};
+			}
+			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
+
+			event = new jQuery.Event( originalEvent );
+
+			i = copy.length;
+			while ( i-- ) {
+				prop = copy[ i ];
+				event[ prop ] = originalEvent[ prop ];
+			}
+
+			// Support: IE<9
+			// Fix target property (#1925)
+			if ( !event.target ) {
+				event.target = originalEvent.srcElement || document;
+			}
+
+			// Support: Chrome 23+, Safari?
+			// Target should not be a text node (#504, #13143)
+			if ( event.target.nodeType === 3 ) {
+				event.target = event.target.parentNode;
+			}
+
+			// Support: IE<9
+			// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
+			event.metaKey = !!event.metaKey;
+
+			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
+		},
+
+		// Includes some event props shared by KeyEvent and MouseEvent
+		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
+
+		fixHooks: {},
+
+		keyHooks: {
+			props: "char charCode key keyCode".split(" "),
+			filter: function( event, original ) {
+
+				// Add which for key events
+				if ( event.which == null ) {
+					event.which = original.charCode != null ? original.charCode : original.keyCode;
+				}
+
+				return event;
+			}
+		},
+
+		mouseHooks: {
+			props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
+			filter: function( event, original ) {
+				var body, eventDoc, doc,
+					button = original.button,
+					fromElement = original.fromElement;
+
+				// Calculate pageX/Y if missing and clientX/Y available
+				if ( event.pageX == null && original.clientX != null ) {
+					eventDoc = event.target.ownerDocument || document;
+					doc = eventDoc.documentElement;
+					body = eventDoc.body;
+
+					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
+					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
+				}
+
+				// Add relatedTarget, if necessary
+				if ( !event.relatedTarget && fromElement ) {
+					event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
+				}
+
+				// Add which for click: 1 === left; 2 === middle; 3 === right
+				// Note: button is not normalized, so don't use it
+				if ( !event.which && button !== undefined ) {
+					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
+				}
+
+				return event;
+			}
+		},
+
+		special: {
+			load: {
+				// Prevent triggered image.load events from bubbling to window.load
+				noBubble: true
+			},
+			click: {
+				// For checkbox, fire native event so checked state will be right
+				trigger: function() {
+					if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
+						this.click();
+						return false;
+					}
+				}
+			},
+			focus: {
+				// Fire native event if possible so blur/focus sequence is correct
+				trigger: function() {
+					if ( this !== document.activeElement && this.focus ) {
+						try {
+							this.focus();
+							return false;
+						} catch ( e ) {
+							// Support: IE<9
+							// If we error on focus to hidden element (#1486, #12518),
+							// let .trigger() run the handlers
+						}
+					}
+				},
+				delegateType: "focusin"
+			},
+			blur: {
+				trigger: function() {
+					if ( this === document.activeElement && this.blur ) {
+						this.blur();
+						return false;
+					}
+				},
+				delegateType: "focusout"
+			},
+
+			beforeunload: {
+				postDispatch: function( event ) {
+
+					// Even when returnValue equals to undefined Firefox will still show alert
+					if ( event.result !== undefined ) {
+						event.originalEvent.returnValue = event.result;
+					}
+				}
+			}
+		},
+
+		simulate: function( type, elem, event, bubble ) {
+			// Piggyback on a donor event to simulate a different one.
+			// Fake originalEvent to avoid donor's stopPropagation, but if the
+			// simulated event prevents default then we do the same on the donor.
+			var e = jQuery.extend(
+				new jQuery.Event(),
+				event,
+				{ type: type,
+					isSimulated: true,
+					originalEvent: {}
+				}
+			);
+			if ( bubble ) {
+				jQuery.event.trigger( e, null, elem );
+			} else {
+				jQuery.event.dispatch.call( elem, e );
+			}
+			if ( e.isDefaultPrevented() ) {
+				event.preventDefault();
+			}
+		}
+	};
+
+	jQuery.removeEvent = document.removeEventListener ?
+		function( elem, type, handle ) {
+			if ( elem.removeEventListener ) {
+				elem.removeEventListener( type, handle, false );
+			}
+		} :
+		function( elem, type, handle ) {
+			var name = "on" + type;
+
+			if ( elem.detachEvent ) {
+
+				// #8545, #7054, preventing memory leaks for custom events in IE6-8
+				// detachEvent needed property on element, by name of that event, to properly expose it to GC
+				if ( typeof elem[ name ] === core_strundefined ) {
+					elem[ name ] = null;
+				}
+
+				elem.detachEvent( name, handle );
+			}
+		};
+
+	jQuery.Event = function( src, props ) {
+		// Allow instantiation without the 'new' keyword
+		if ( !(this instanceof jQuery.Event) ) {
+			return new jQuery.Event( src, props );
+		}
+
+		// Event object
+		if ( src && src.type ) {
+			this.originalEvent = src;
+			this.type = src.type;
+
+			// Events bubbling up the document may have been marked as prevented
+			// by a handler lower down the tree; reflect the correct value.
+			this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
+				src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
+
+		// Event type
+		} else {
+			this.type = src;
+		}
+
+		// Put explicitly provided properties onto the event object
+		if ( props ) {
+			jQuery.extend( this, props );
+		}
+
+		// Create a timestamp if incoming event doesn't have one
+		this.timeStamp = src && src.timeStamp || jQuery.now();
+
+		// Mark it as fixed
+		this[ jQuery.expando ] = true;
+	};
+
+	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
+	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
+	jQuery.Event.prototype = {
+		isDefaultPrevented: returnFalse,
+		isPropagationStopped: returnFalse,
+		isImmediatePropagationStopped: returnFalse,
+
+		preventDefault: function() {
+			var e = this.originalEvent;
+
+			this.isDefaultPrevented = returnTrue;
+			if ( !e ) {
+				return;
+			}
+
+			// If preventDefault exists, run it on the original event
+			if ( e.preventDefault ) {
+				e.preventDefault();
+
+			// Support: IE
+			// Otherwise set the returnValue property of the original event to false
+			} else {
+				e.returnValue = false;
+			}
+		},
+		stopPropagation: function() {
+			var e = this.originalEvent;
+
+			this.isPropagationStopped = returnTrue;
+			if ( !e ) {
+				return;
+			}
+			// If stopPropagation exists, run it on the original event
+			if ( e.stopPropagation ) {
+				e.stopPropagation();
+			}
+
+			// Support: IE
+			// Set the cancelBubble property of the original event to true
+			e.cancelBubble = true;
+		},
+		stopImmediatePropagation: function() {
+			this.isImmediatePropagationStopped = returnTrue;
+			this.stopPropagation();
+		}
+	};
+
+	// Create mouseenter/leave events using mouseover/out and event-time checks
+	jQuery.each({
+		mouseenter: "mouseover",
+		mouseleave: "mouseout"
+	}, function( orig, fix ) {
+		jQuery.event.special[ orig ] = {
+			delegateType: fix,
+			bindType: fix,
+
+			handle: function( event ) {
+				var ret,
+					target = this,
+					related = event.relatedTarget,
+					handleObj = event.handleObj;
+
+				// For mousenter/leave call the handler if related is outside the target.
+				// NB: No relatedTarget if the mouse left/entered the browser window
+				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
+					event.type = handleObj.origType;
+					ret = handleObj.handler.apply( this, arguments );
+					event.type = fix;
+				}
+				return ret;
+			}
+		};
+	});
+
+	// IE submit delegation
+	if ( !jQuery.support.submitBubbles ) {
+
+		jQuery.event.special.submit = {
+			setup: function() {
+				// Only need this for delegated form submit events
+				if ( jQuery.nodeName( this, "form" ) ) {
+					return false;
+				}
+
+				// Lazy-add a submit handler when a descendant form may potentially be submitted
+				jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
+					// Node name check avoids a VML-related crash in IE (#9807)
+					var elem = e.target,
+						form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
+					if ( form && !jQuery._data( form, "submitBubbles" ) ) {
+						jQuery.event.add( form, "submit._submit", function( event ) {
+							event._submit_bubble = true;
+						});
+						jQuery._data( form, "submitBubbles", true );
+					}
+				});
+				// return undefined since we don't need an event listener
+			},
+
+			postDispatch: function( event ) {
+				// If form was submitted by the user, bubble the event up the tree
+				if ( event._submit_bubble ) {
+					delete event._submit_bubble;
+					if ( this.parentNode && !event.isTrigger ) {
+						jQuery.event.simulate( "submit", this.parentNode, event, true );
+					}
+				}
+			},
+
+			teardown: function() {
+				// Only need this for delegated form submit events
+				if ( jQuery.nodeName( this, "form" ) ) {
+					return false;
+				}
+
+				// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
+				jQuery.event.remove( this, "._submit" );
+			}
+		};
+	}
+
+	// IE change delegation and checkbox/radio fix
+	if ( !jQuery.support.changeBubbles ) {
+
+		jQuery.event.special.change = {
+
+			setup: function() {
+
+				if ( rformElems.test( this.nodeName ) ) {
+					// IE doesn't fire change on a check/radio until blur; trigger it on click
+					// after a propertychange. Eat the blur-change in special.change.handle.
+					// This still fires onchange a second time for check/radio after blur.
+					if ( this.type === "checkbox" || this.type === "radio" ) {
+						jQuery.event.add( this, "propertychange._change", function( event ) {
+							if ( event.originalEvent.propertyName === "checked" ) {
+								this._just_changed = true;
+							}
+						});
+						jQuery.event.add( this, "click._change", function( event ) {
+							if ( this._just_changed && !event.isTrigger ) {
+								this._just_changed = false;
+							}
+							// Allow triggered, simulated change events (#11500)
+							jQuery.event.simulate( "change", this, event, true );
+						});
+					}
+					return false;
+				}
+				// Delegated event; lazy-add a change handler on descendant inputs
+				jQuery.event.add( this, "beforeactivate._change", function( e ) {
+					var elem = e.target;
+
+					if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
+						jQuery.event.add( elem, "change._change", function( event ) {
+							if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
+								jQuery.event.simulate( "change", this.parentNode, event, true );
+							}
+						});
+						jQuery._data( elem, "changeBubbles", true );
+					}
+				});
+			},
+
+			handle: function( event ) {
+				var elem = event.target;
+
+				// Swallow native change events from checkbox/radio, we already triggered them above
+				if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
+					return event.handleObj.handler.apply( this, arguments );
+				}
+			},
+
+			teardown: function() {
+				jQuery.event.remove( this, "._change" );
+
+				return !rformElems.test( this.nodeName );
+			}
+		};
+	}
+
+	// Create "bubbling" focus and blur events
+	if ( !jQuery.support.focusinBubbles ) {
+		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
+
+			// Attach a single capturing handler while someone wants focusin/focusout
+			var attaches = 0,
+				handler = function( event ) {
+					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
+				};
+
+			jQuery.event.special[ fix ] = {
+				setup: function() {
+					if ( attaches++ === 0 ) {
+						document.addEventListener( orig, handler, true );
+					}
+				},
+				teardown: function() {
+					if ( --attaches === 0 ) {
+						document.removeEventListener( orig, handler, true );
+					}
+				}
+			};
+		});
+	}
+
+	jQuery.fn.extend({
+
+		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
+			var type, origFn;
+
+			// Types can be a map of types/handlers
+			if ( typeof types === "object" ) {
+				// ( types-Object, selector, data )
+				if ( typeof selector !== "string" ) {
+					// ( types-Object, data )
+					data = data || selector;
+					selector = undefined;
+				}
+				for ( type in types ) {
+					this.on( type, selector, data, types[ type ], one );
+				}
+				return this;
+			}
+
+			if ( data == null && fn == null ) {
+				// ( types, fn )
+				fn = selector;
+				data = selector = undefined;
+			} else if ( fn == null ) {
+				if ( typeof selector === "string" ) {
+					// ( types, selector, fn )
+					fn = data;
+					data = undefined;
+				} else {
+					// ( types, data, fn )
+					fn = data;
+					data = selector;
+					selector = undefined;
+				}
+			}
+			if ( fn === false ) {
+				fn = returnFalse;
+			} else if ( !fn ) {
+				return this;
+			}
+
+			if ( one === 1 ) {
+				origFn = fn;
+				fn = function( event ) {
+					// Can use an empty set, since event contains the info
+					jQuery().off( event );
+					return origFn.apply( this, arguments );
+				};
+				// Use same guid so caller can remove using origFn
+				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
+			}
+			return this.each( function() {
+				jQuery.event.add( this, types, fn, data, selector );
+			});
+		},
+		one: function( types, selector, data, fn ) {
+			return this.on( types, selector, data, fn, 1 );
+		},
+		off: function( types, selector, fn ) {
+			var handleObj, type;
+			if ( types && types.preventDefault && types.handleObj ) {
+				// ( event )  dispatched jQuery.Event
+				handleObj = types.handleObj;
+				jQuery( types.delegateTarget ).off(
+					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
+					handleObj.selector,
+					handleObj.handler
+				);
+				return this;
+			}
+			if ( typeof types === "object" ) {
+				// ( types-object [, selector] )
+				for ( type in types ) {
+					this.off( type, selector, types[ type ] );
+				}
+				return this;
+			}
+			if ( selector === false || typeof selector === "function" ) {
+				// ( types [, fn] )
+				fn = selector;
+				selector = undefined;
+			}
+			if ( fn === false ) {
+				fn = returnFalse;
+			}
+			return this.each(function() {
+				jQuery.event.remove( this, types, fn, selector );
+			});
+		},
+
+		bind: function( types, data, fn ) {
+			return this.on( types, null, data, fn );
+		},
+		unbind: function( types, fn ) {
+			return this.off( types, null, fn );
+		},
+
+		delegate: function( selector, types, data, fn ) {
+			return this.on( types, selector, data, fn );
+		},
+		undelegate: function( selector, types, fn ) {
+			// ( namespace ) or ( selector, types [, fn] )
+			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
+		},
+
+		trigger: function( type, data ) {
+			return this.each(function() {
+				jQuery.event.trigger( type, data, this );
+			});
+		},
+		triggerHandler: function( type, data ) {
+			var elem = this[0];
+			if ( elem ) {
+				return jQuery.event.trigger( type, data, elem, true );
+			}
+		}
+	});
+	/*!
+	 * Sizzle CSS Selector Engine
+	 * Copyright 2012 jQuery Foundation and other contributors
+	 * Released under the MIT license
+	 * http://sizzlejs.com/
+	 */
+	(function( window, undefined ) {
+
+	var i,
+		cachedruns,
+		Expr,
+		getText,
+		isXML,
+		compile,
+		hasDuplicate,
+		outermostContext,
+
+		// Local document vars
+		setDocument,
+		document,
+		docElem,
+		documentIsXML,
+		rbuggyQSA,
+		rbuggyMatches,
+		matches,
+		contains,
+		sortOrder,
+
+		// Instance-specific data
+		expando = "sizzle" + -(new Date()),
+		preferredDoc = window.document,
+		support = {},
+		dirruns = 0,
+		done = 0,
+		classCache = createCache(),
+		tokenCache = createCache(),
+		compilerCache = createCache(),
+
+		// General-purpose constants
+		strundefined = typeof undefined,
+		MAX_NEGATIVE = 1 << 31,
+
+		// Array methods
+		arr = [],
+		pop = arr.pop,
+		push = arr.push,
+		slice = arr.slice,
+		// Use a stripped-down indexOf if we can't use a native one
+		indexOf = arr.indexOf || function( elem ) {
+			var i = 0,
+				len = this.length;
+			for ( ; i < len; i++ ) {
+				if ( this[i] === elem ) {
+					return i;
+				}
+			}
+			return -1;
+		},
+
+
+		// Regular expressions
+
+		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
+		whitespace = "[\\x20\\t\\r\\n\\f]",
+		// http://www.w3.org/TR/css3-syntax/#characters
+		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
+
+		// Loosely modeled on CSS identifier characters
+		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
+		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
+		identifier = characterEncoding.replace( "w", "w#" ),
+
+		// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
+		operators = "([*^$|!~]?=)",
+		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
+			"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
+
+		// Prefer arguments quoted,
+		//   then not containing pseudos/brackets,
+		//   then attribute selectors/non-parenthetical expressions,
+		//   then anything else
+		// These preferences are here to reduce the number of selectors
+		//   needing tokenize in the PSEUDO preFilter
+		pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",
+
+		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
+		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
+
+		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
+		rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
+		rpseudo = new RegExp( pseudos ),
+		ridentifier = new RegExp( "^" + identifier + "$" ),
+
+		matchExpr = {
+			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
+			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
+			"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
+			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
+			"ATTR": new RegExp( "^" + attributes ),
+			"PSEUDO": new RegExp( "^" + pseudos ),
+			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
+				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
+				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
+			// For use in libraries implementing .is()
+			// We use this for POS matching in `select`
+			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
+				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
+		},
+
+		rsibling = /[\x20\t\r\n\f]*[+~]/,
+
+		rnative = /^[^{]+\{\s*\[native code/,
+
+		// Easily-parseable/retrievable ID or TAG or CLASS selectors
+		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
+
+		rinputs = /^(?:input|select|textarea|button)$/i,
+		rheader = /^h\d$/i,
+
+		rescape = /'|\\/g,
+		rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,
+
+		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
+		runescape = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,
+		funescape = function( _, escaped ) {
+			var high = "0x" + escaped - 0x10000;
+			// NaN means non-codepoint
+			return high !== high ?
+				escaped :
+				// BMP codepoint
+				high < 0 ?
+					String.fromCharCode( high + 0x10000 ) :
+					// Supplemental Plane codepoint (surrogate pair)
+					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
+		};
+
+	// Use a stripped-down slice if we can't use a native one
+	try {
+		slice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;
+	} catch ( e ) {
+		slice = function( i ) {
+			var elem,
+				results = [];
+			while ( (elem = this[i++]) ) {
+				results.push( elem );
+			}
+			return results;
+		};
+	}
+
+	/**
+	 * For feature detection
+	 * @param {Function} fn The function to test for native support
+	 */
+	function isNative( fn ) {
+		return rnative.test( fn + "" );
+	}
+
+	/**
+	 * Create key-value caches of limited size
+	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
+	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
+	 *	deleting the oldest entry
+	 */
+	function createCache() {
+		var cache,
+			keys = [];
+
+		return (cache = function( key, value ) {
+			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
+			if ( keys.push( key += " " ) > Expr.cacheLength ) {
+				// Only keep the most recent entries
+				delete cache[ keys.shift() ];
+			}
+			return (cache[ key ] = value);
+		});
+	}
+
+	/**
+	 * Mark a function for special use by Sizzle
+	 * @param {Function} fn The function to mark
+	 */
+	function markFunction( fn ) {
+		fn[ expando ] = true;
+		return fn;
+	}
+
+	/**
+	 * Support testing using an element
+	 * @param {Function} fn Passed the created div and expects a boolean result
+	 */
+	function assert( fn ) {
+		var div = document.createElement("div");
+
+		try {
+			return fn( div );
+		} catch (e) {
+			return false;
+		} finally {
+			// release memory in IE
+			div = null;
+		}
+	}
+
+	function Sizzle( selector, context, results, seed ) {
+		var match, elem, m, nodeType,
+			// QSA vars
+			i, groups, old, nid, newContext, newSelector;
+
+		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
+			setDocument( context );
+		}
+
+		context = context || document;
+		results = results || [];
+
+		if ( !selector || typeof selector !== "string" ) {
+			return results;
+		}
+
+		if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
+			return [];
+		}
+
+		if ( !documentIsXML && !seed ) {
+
+			// Shortcuts
+			if ( (match = rquickExpr.exec( selector )) ) {
+				// Speed-up: Sizzle("#ID")
+				if ( (m = match[1]) ) {
+					if ( nodeType === 9 ) {
+						elem = context.getElementById( m );
+						// Check parentNode to catch when Blackberry 4.6 returns
+						// nodes that are no longer in the document #6963
+						if ( elem && elem.parentNode ) {
+							// Handle the case where IE, Opera, and Webkit return items
+							// by name instead of ID
+							if ( elem.id === m ) {
+								results.push( elem );
+								return results;
+							}
+						} else {
+							return results;
+						}
+					} else {
+						// Context is not a document
+						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
+							contains( context, elem ) && elem.id === m ) {
+							results.push( elem );
+							return results;
+						}
+					}
+
+				// Speed-up: Sizzle("TAG")
+				} else if ( match[2] ) {
+					push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
+					return results;
+
+				// Speed-up: Sizzle(".CLASS")
+				} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {
+					push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
+					return results;
+				}
+			}
+
+			// QSA path
+			if ( support.qsa && !rbuggyQSA.test(selector) ) {
+				old = true;
+				nid = expando;
+				newContext = context;
+				newSelector = nodeType === 9 && selector;
+
+				// qSA works strangely on Element-rooted queries
+				// We can work around this by specifying an extra ID on the root
+				// and working up from there (Thanks to Andrew Dupont for the technique)
+				// IE 8 doesn't work on object elements
+				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
+					groups = tokenize( selector );
+
+					if ( (old = context.getAttribute("id")) ) {
+						nid = old.replace( rescape, "\\$&" );
+					} else {
+						context.setAttribute( "id", nid );
+					}
+					nid = "[id='" + nid + "'] ";
+
+					i = groups.length;
+					while ( i-- ) {
+						groups[i] = nid + toSelector( groups[i] );
+					}
+					newContext = rsibling.test( selector ) && context.parentNode || context;
+					newSelector = groups.join(",");
+				}
+
+				if ( newSelector ) {
+					try {
+						push.apply( results, slice.call( newContext.querySelectorAll(
+							newSelector
+						), 0 ) );
+						return results;
+					} catch(qsaError) {
+					} finally {
+						if ( !old ) {
+							context.removeAttribute("id");
+						}
+					}
+				}
+			}
+		}
+
+		// All others
+		return select( selector.replace( rtrim, "$1" ), context, results, seed );
+	}
+
+	/**
+	 * Detect xml
+	 * @param {Element|Object} elem An element or a document
+	 */
+	isXML = Sizzle.isXML = function( elem ) {
+		// documentElement is verified for cases where it doesn't yet exist
+		// (such as loading iframes in IE - #4833)
+		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
+		return documentElement ? documentElement.nodeName !== "HTML" : false;
+	};
+
+	/**
+	 * Sets document-related variables once based on the current document
+	 * @param {Element|Object} [doc] An element or document object to use to set the document
+	 * @returns {Object} Returns the current document
+	 */
+	setDocument = Sizzle.setDocument = function( node ) {
+		var doc = node ? node.ownerDocument || node : preferredDoc;
+
+		// If no document and documentElement is available, return
+		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
+			return document;
+		}
+
+		// Set our document
+		document = doc;
+		docElem = doc.documentElement;
+
+		// Support tests
+		documentIsXML = isXML( doc );
+
+		// Check if getElementsByTagName("*") returns only elements
+		support.tagNameNoComments = assert(function( div ) {
+			div.appendChild( doc.createComment("") );
+			return !div.getElementsByTagName("*").length;
+		});
+
+		// Check if attributes should be retrieved by attribute nodes
+		support.attributes = assert(function( div ) {
+			div.innerHTML = "<select></select>";
+			var type = typeof div.lastChild.getAttribute("multiple");
+			// IE8 returns a string for some attributes even when not present
+			return type !== "boolean" && type !== "string";
+		});
+
+		// Check if getElementsByClassName can be trusted
+		support.getByClassName = assert(function( div ) {
+			// Opera can't find a second classname (in 9.6)
+			div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
+			if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
+				return false;
+			}
+
+			// Safari 3.2 caches class attributes and doesn't catch changes
+			div.lastChild.className = "e";
+			return div.getElementsByClassName("e").length === 2;
+		});
+
+		// Check if getElementById returns elements by name
+		// Check if getElementsByName privileges form controls or returns elements by ID
+		support.getByName = assert(function( div ) {
+			// Inject content
+			div.id = expando + 0;
+			div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
+			docElem.insertBefore( div, docElem.firstChild );
+
+			// Test
+			var pass = doc.getElementsByName &&
+				// buggy browsers will return fewer than the correct 2
+				doc.getElementsByName( expando ).length === 2 +
+				// buggy browsers will return more than the correct 0
+				doc.getElementsByName( expando + 0 ).length;
+			support.getIdNotName = !doc.getElementById( expando );
+
+			// Cleanup
+			docElem.removeChild( div );
+
+			return pass;
+		});
+
+		// IE6/7 return modified attributes
+		Expr.attrHandle = assert(function( div ) {
+			div.innerHTML = "<a href='#'></a>";
+			return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
+				div.firstChild.getAttribute("href") === "#";
+		}) ?
+			{} :
+			{
+				"href": function( elem ) {
+					return elem.getAttribute( "href", 2 );
+				},
+				"type": function( elem ) {
+					return elem.getAttribute("type");
+				}
+			};
+
+		// ID find and filter
+		if ( support.getIdNotName ) {
+			Expr.find["ID"] = function( id, context ) {
+				if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
+					var m = context.getElementById( id );
+					// Check parentNode to catch when Blackberry 4.6 returns
+					// nodes that are no longer in the document #6963
+					return m && m.parentNode ? [m] : [];
+				}
+			};
+			Expr.filter["ID"] = function( id ) {
+				var attrId = id.replace( runescape, funescape );
+				return function( elem ) {
+					return elem.getAttribute("id") === attrId;
+				};
+			};
+		} else {
+			Expr.find["ID"] = function( id, context ) {
+				if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
+					var m = context.getElementById( id );
+
+					return m ?
+						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
+							[m] :
+							undefined :
+						[];
+				}
+			};
+			Expr.filter["ID"] =  function( id ) {
+				var attrId = id.replace( runescape, funescape );
+				return function( elem ) {
+					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
+					return node && node.value === attrId;
+				};
+			};
+		}
+
+		// Tag
+		Expr.find["TAG"] = support.tagNameNoComments ?
+			function( tag, context ) {
+				if ( typeof context.getElementsByTagName !== strundefined ) {
+					return context.getElementsByTagName( tag );
+				}
+			} :
+			function( tag, context ) {
+				var elem,
+					tmp = [],
+					i = 0,
+					results = context.getElementsByTagName( tag );
+
+				// Filter out possible comments
+				if ( tag === "*" ) {
+					while ( (elem = results[i++]) ) {
+						if ( elem.nodeType === 1 ) {
+							tmp.push( elem );
+						}
+					}
+
+					return tmp;
+				}
+				return results;
+			};
+
+		// Name
+		Expr.find["NAME"] = support.getByName && function( tag, context ) {
+			if ( typeof context.getElementsByName !== strundefined ) {
+				return context.getElementsByName( name );
+			}
+		};
+
+		// Class
+		Expr.find["CLASS"] = support.getByClassName && function( className, context ) {
+			if ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {
+				return context.getElementsByClassName( className );
+			}
+		};
+
+		// QSA and matchesSelector support
+
+		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
+		rbuggyMatches = [];
+
+		// qSa(:focus) reports false when true (Chrome 21),
+		// no need to also add to buggyMatches since matches checks buggyQSA
+		// A support test would require too much code (would include document ready)
+		rbuggyQSA = [ ":focus" ];
+
+		if ( (support.qsa = isNative(doc.querySelectorAll)) ) {
+			// Build QSA regex
+			// Regex strategy adopted from Diego Perini
+			assert(function( div ) {
+				// Select is set to empty string on purpose
+				// This is to test IE's treatment of not explictly
+				// setting a boolean content attribute,
+				// since its presence should be enough
+				// http://bugs.jquery.com/ticket/12359
+				div.innerHTML = "<select><option selected=''></option></select>";
+
+				// IE8 - Some boolean attributes are not treated correctly
+				if ( !div.querySelectorAll("[selected]").length ) {
+					rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
+				}
+
+				// Webkit/Opera - :checked should return selected option elements
+				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
+				// IE8 throws error here and will not see later tests
+				if ( !div.querySelectorAll(":checked").length ) {
+					rbuggyQSA.push(":checked");
+				}
+			});
+
+			assert(function( div ) {
+
+				// Opera 10-12/IE8 - ^= $= *= and empty values
+				// Should not select anything
+				div.innerHTML = "<input type='hidden' i=''/>";
+				if ( div.querySelectorAll("[i^='']").length ) {
+					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
+				}
+
+				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
+				// IE8 throws error here and will not see later tests
+				if ( !div.querySelectorAll(":enabled").length ) {
+					rbuggyQSA.push( ":enabled", ":disabled" );
+				}
+
+				// Opera 10-11 does not throw on post-comma invalid pseudos
+				div.querySelectorAll("*,:x");
+				rbuggyQSA.push(",.*:");
+			});
+		}
+
+		if ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||
+			docElem.mozMatchesSelector ||
+			docElem.webkitMatchesSelector ||
+			docElem.oMatchesSelector ||
+			docElem.msMatchesSelector) )) ) {
+
+			assert(function( div ) {
+				// Check to see if it's possible to do matchesSelector
+				// on a disconnected node (IE 9)
+				support.disconnectedMatch = matches.call( div, "div" );
+
+				// This should fail with an exception
+				// Gecko does not error, returns false instead
+				matches.call( div, "[s!='']:x" );
+				rbuggyMatches.push( "!=", pseudos );
+			});
+		}
+
+		rbuggyQSA = new RegExp( rbuggyQSA.join("|") );
+		rbuggyMatches = new RegExp( rbuggyMatches.join("|") );
+
+		// Element contains another
+		// Purposefully does not implement inclusive descendent
+		// As in, an element does not contain itself
+		contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
+			function( a, b ) {
+				var adown = a.nodeType === 9 ? a.documentElement : a,
+					bup = b && b.parentNode;
+				return a === bup || !!( bup && bup.nodeType === 1 && (
+					adown.contains ?
+						adown.contains( bup ) :
+						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
+				));
+			} :
+			function( a, b ) {
+				if ( b ) {
+					while ( (b = b.parentNode) ) {
+						if ( b === a ) {
+							return true;
+						}
+					}
+				}
+				return false;
+			};
+
+		// Document order sorting
+		sortOrder = docElem.compareDocumentPosition ?
+		function( a, b ) {
+			var compare;
+
+			if ( a === b ) {
+				hasDuplicate = true;
+				return 0;
+			}
+
+			if ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {
+				if ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {
+					if ( a === doc || contains( preferredDoc, a ) ) {
+						return -1;
+					}
+					if ( b === doc || contains( preferredDoc, b ) ) {
+						return 1;
+					}
+					return 0;
+				}
+				return compare & 4 ? -1 : 1;
+			}
+
+			return a.compareDocumentPosition ? -1 : 1;
+		} :
+		function( a, b ) {
+			var cur,
+				i = 0,
+				aup = a.parentNode,
+				bup = b.parentNode,
+				ap = [ a ],
+				bp = [ b ];
+
+			// Exit early if the nodes are identical
+			if ( a === b ) {
+				hasDuplicate = true;
+				return 0;
+
+			// Parentless nodes are either documents or disconnected
+			} else if ( !aup || !bup ) {
+				return a === doc ? -1 :
+					b === doc ? 1 :
+					aup ? -1 :
+					bup ? 1 :
+					0;
+
+			// If the nodes are siblings, we can do a quick check
+			} else if ( aup === bup ) {
+				return siblingCheck( a, b );
+			}
+
+			// Otherwise we need full lists of their ancestors for comparison
+			cur = a;
+			while ( (cur = cur.parentNode) ) {
+				ap.unshift( cur );
+			}
+			cur = b;
+			while ( (cur = cur.parentNode) ) {
+				bp.unshift( cur );
+			}
+
+			// Walk down the tree looking for a discrepancy
+			while ( ap[i] === bp[i] ) {
+				i++;
+			}
+
+			return i ?
+				// Do a sibling check if the nodes have a common ancestor
+				siblingCheck( ap[i], bp[i] ) :
+
+				// Otherwise nodes in our document sort first
+				ap[i] === preferredDoc ? -1 :
+				bp[i] === preferredDoc ? 1 :
+				0;
+		};
+
+		// Always assume the presence of duplicates if sort doesn't
+		// pass them to our comparison function (as in Google Chrome).
+		hasDuplicate = false;
+		[0, 0].sort( sortOrder );
+		support.detectDuplicates = hasDuplicate;
+
+		return document;
+	};
+
+	Sizzle.matches = function( expr, elements ) {
+		return Sizzle( expr, null, null, elements );
+	};
+
+	Sizzle.matchesSelector = function( elem, expr ) {
+		// Set document vars if needed
+		if ( ( elem.ownerDocument || elem ) !== document ) {
+			setDocument( elem );
+		}
+
+		// Make sure that attribute selectors are quoted
+		expr = expr.replace( rattributeQuotes, "='$1']" );
+
+		// rbuggyQSA always contains :focus, so no need for an existence check
+		if ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {
+			try {
+				var ret = matches.call( elem, expr );
+
+				// IE 9's matchesSelector returns false on disconnected nodes
+				if ( ret || support.disconnectedMatch ||
+						// As well, disconnected nodes are said to be in a document
+						// fragment in IE 9
+						elem.document && elem.document.nodeType !== 11 ) {
+					return ret;
+				}
+			} catch(e) {}
+		}
+
+		return Sizzle( expr, document, null, [elem] ).length > 0;
+	};
+
+	Sizzle.contains = function( context, elem ) {
+		// Set document vars if needed
+		if ( ( context.ownerDocument || context ) !== document ) {
+			setDocument( context );
+		}
+		return contains( context, elem );
+	};
+
+	Sizzle.attr = function( elem, name ) {
+		var val;
+
+		// Set document vars if needed
+		if ( ( elem.ownerDocument || elem ) !== document ) {
+			setDocument( elem );
+		}
+
+		if ( !documentIsXML ) {
+			name = name.toLowerCase();
+		}
+		if ( (val = Expr.attrHandle[ name ]) ) {
+			return val( elem );
+		}
+		if ( documentIsXML || support.attributes ) {
+			return elem.getAttribute( name );
+		}
+		return ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?
+			name :
+			val && val.specified ? val.value : null;
+	};
+
+	Sizzle.error = function( msg ) {
+		throw new Error( "Syntax error, unrecognized expression: " + msg );
+	};
+
+	// Document sorting and removing duplicates
+	Sizzle.uniqueSort = function( results ) {
+		var elem,
+			duplicates = [],
+			i = 1,
+			j = 0;
+
+		// Unless we *know* we can detect duplicates, assume their presence
+		hasDuplicate = !support.detectDuplicates;
+		results.sort( sortOrder );
+
+		if ( hasDuplicate ) {
+			for ( ; (elem = results[i]); i++ ) {
+				if ( elem === results[ i - 1 ] ) {
+					j = duplicates.push( i );
+				}
+			}
+			while ( j-- ) {
+				results.splice( duplicates[ j ], 1 );
+			}
+		}
+
+		return results;
+	};
+
+	function siblingCheck( a, b ) {
+		var cur = b && a,
+			diff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );
+
+		// Use IE sourceIndex if available on both nodes
+		if ( diff ) {
+			return diff;
+		}
+
+		// Check if b follows a
+		if ( cur ) {
+			while ( (cur = cur.nextSibling) ) {
+				if ( cur === b ) {
+					return -1;
+				}
+			}
+		}
+
+		return a ? 1 : -1;
+	}
+
+	// Returns a function to use in pseudos for input types
+	function createInputPseudo( type ) {
+		return function( elem ) {
+			var name = elem.nodeName.toLowerCase();
+			return name === "input" && elem.type === type;
+		};
+	}
+
+	// Returns a function to use in pseudos for buttons
+	function createButtonPseudo( type ) {
+		return function( elem ) {
+			var name = elem.nodeName.toLowerCase();
+			return (name === "input" || name === "button") && elem.type === type;
+		};
+	}
+
+	// Returns a function to use in pseudos for positionals
+	function createPositionalPseudo( fn ) {
+		return markFunction(function( argument ) {
+			argument = +argument;
+			return markFunction(function( seed, matches ) {
+				var j,
+					matchIndexes = fn( [], seed.length, argument ),
+					i = matchIndexes.length;
+
+				// Match elements found at the specified indexes
+				while ( i-- ) {
+					if ( seed[ (j = matchIndexes[i]) ] ) {
+						seed[j] = !(matches[j] = seed[j]);
+					}
+				}
+			});
+		});
+	}
+
+	/**
+	 * Utility function for retrieving the text value of an array of DOM nodes
+	 * @param {Array|Element} elem
+	 */
+	getText = Sizzle.getText = function( elem ) {
+		var node,
+			ret = "",
+			i = 0,
+			nodeType = elem.nodeType;
+
+		if ( !nodeType ) {
+			// If no nodeType, this is expected to be an array
+			for ( ; (node = elem[i]); i++ ) {
+				// Do not traverse comment nodes
+				ret += getText( node );
+			}
+		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
+			// Use textContent for elements
+			// innerText usage removed for consistency of new lines (see #11153)
+			if ( typeof elem.textContent === "string" ) {
+				return elem.textContent;
+			} else {
+				// Traverse its children
+				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
+					ret += getText( elem );
+				}
+			}
+		} else if ( nodeType === 3 || nodeType === 4 ) {
+			return elem.nodeValue;
+		}
+		// Do not include comment or processing instruction nodes
+
+		return ret;
+	};
+
+	Expr = Sizzle.selectors = {
+
+		// Can be adjusted by the user
+		cacheLength: 50,
+
+		createPseudo: markFunction,
+
+		match: matchExpr,
+
+		find: {},
+
+		relative: {
+			">": { dir: "parentNode", first: true },
+			" ": { dir: "parentNode" },
+			"+": { dir: "previousSibling", first: true },
+			"~": { dir: "previousSibling" }
+		},
+
+		preFilter: {
+			"ATTR": function( match ) {
+				match[1] = match[1].replace( runescape, funescape );
+
+				// Move the given value to match[3] whether quoted or unquoted
+				match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );
+
+				if ( match[2] === "~=" ) {
+					match[3] = " " + match[3] + " ";
+				}
+
+				return match.slice( 0, 4 );
+			},
+
+			"CHILD": function( match ) {
+				/* matches from matchExpr["CHILD"]
+					1 type (only|nth|...)
+					2 what (child|of-type)
+					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
+					4 xn-component of xn+y argument ([+-]?\d*n|)
+					5 sign of xn-component
+					6 x of xn-component
+					7 sign of y-component
+					8 y of y-component
+				*/
+				match[1] = match[1].toLowerCase();
+
+				if ( match[1].slice( 0, 3 ) === "nth" ) {
+					// nth-* requires argument
+					if ( !match[3] ) {
+						Sizzle.error( match[0] );
+					}
+
+					// numeric x and y parameters for Expr.filter.CHILD
+					// remember that false/true cast respectively to 0/1
+					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
+					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
+
+				// other types prohibit arguments
+				} else if ( match[3] ) {
+					Sizzle.error( match[0] );
+				}
+
+				return match;
+			},
+
+			"PSEUDO": function( match ) {
+				var excess,
+					unquoted = !match[5] && match[2];
+
+				if ( matchExpr["CHILD"].test( match[0] ) ) {
+					return null;
+				}
+
+				// Accept quoted arguments as-is
+				if ( match[4] ) {
+					match[2] = match[4];
+
+				// Strip excess characters from unquoted arguments
+				} else if ( unquoted && rpseudo.test( unquoted ) &&
+					// Get excess from tokenize (recursively)
+					(excess = tokenize( unquoted, true )) &&
+					// advance to the next closing parenthesis
+					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
+
+					// excess is a negative index
+					match[0] = match[0].slice( 0, excess );
+					match[2] = unquoted.slice( 0, excess );
+				}
+
+				// Return only captures needed by the pseudo filter method (type and argument)
+				return match.slice( 0, 3 );
+			}
+		},
+
+		filter: {
+
+			"TAG": function( nodeName ) {
+				if ( nodeName === "*" ) {
+					return function() { return true; };
+				}
+
+				nodeName = nodeName.replace( runescape, funescape ).toLowerCase();
+				return function( elem ) {
+					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
+				};
+			},
+
+			"CLASS": function( className ) {
+				var pattern = classCache[ className + " " ];
+
+				return pattern ||
+					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
+					classCache( className, function( elem ) {
+						return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
+					});
+			},
+
+			"ATTR": function( name, operator, check ) {
+				return function( elem ) {
+					var result = Sizzle.attr( elem, name );
+
+					if ( result == null ) {
+						return operator === "!=";
+					}
+					if ( !operator ) {
+						return true;
+					}
+
+					result += "";
+
+					return operator === "=" ? result === check :
+						operator === "!=" ? result !== check :
+						operator === "^=" ? check && result.indexOf( check ) === 0 :
+						operator === "*=" ? check && result.indexOf( check ) > -1 :
+						operator === "$=" ? check && result.slice( -check.length ) === check :
+						operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
+						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
+						false;
+				};
+			},
+
+			"CHILD": function( type, what, argument, first, last ) {
+				var simple = type.slice( 0, 3 ) !== "nth",
+					forward = type.slice( -4 ) !== "last",
+					ofType = what === "of-type";
+
+				return first === 1 && last === 0 ?
+
+					// Shortcut for :nth-*(n)
+					function( elem ) {
+						return !!elem.parentNode;
+					} :
+
+					function( elem, context, xml ) {
+						var cache, outerCache, node, diff, nodeIndex, start,
+							dir = simple !== forward ? "nextSibling" : "previousSibling",
+							parent = elem.parentNode,
+							name = ofType && elem.nodeName.toLowerCase(),
+							useCache = !xml && !ofType;
+
+						if ( parent ) {
+
+							// :(first|last|only)-(child|of-type)
+							if ( simple ) {
+								while ( dir ) {
+									node = elem;
+									while ( (node = node[ dir ]) ) {
+										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
+											return false;
+										}
+									}
+									// Reverse direction for :only-* (if we haven't yet done so)
+									start = dir = type === "only" && !start && "nextSibling";
+								}
+								return true;
+							}
+
+							start = [ forward ? parent.firstChild : parent.lastChild ];
+
+							// non-xml :nth-child(...) stores cache data on `parent`
+							if ( forward && useCache ) {
+								// Seek `elem` from a previously-cached index
+								outerCache = parent[ expando ] || (parent[ expando ] = {});
+								cache = outerCache[ type ] || [];
+								nodeIndex = cache[0] === dirruns && cache[1];
+								diff = cache[0] === dirruns && cache[2];
+								node = nodeIndex && parent.childNodes[ nodeIndex ];
+
+								while ( (node = ++nodeIndex && node && node[ dir ] ||
+
+									// Fallback to seeking `elem` from the start
+									(diff = nodeIndex = 0) || start.pop()) ) {
+
+									// When found, cache indexes on `parent` and break
+									if ( node.nodeType === 1 && ++diff && node === elem ) {
+										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
+										break;
+									}
+								}
+
+							// Use previously-cached element index if available
+							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
+								diff = cache[1];
+
+							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
+							} else {
+								// Use the same loop as above to seek `elem` from the start
+								while ( (node = ++nodeIndex && node && node[ dir ] ||
+									(diff = nodeIndex = 0) || start.pop()) ) {
+
+									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
+										// Cache the index of each encountered element
+										if ( useCache ) {
+											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
+										}
+
+										if ( node === elem ) {
+											break;
+										}
+									}
+								}
+							}
+
+							// Incorporate the offset, then check against cycle size
+							diff -= last;
+							return diff === first || ( diff % first === 0 && diff / first >= 0 );
+						}
+					};
+			},
+
+			"PSEUDO": function( pseudo, argument ) {
+				// pseudo-class names are case-insensitive
+				// http://www.w3.org/TR/selectors/#pseudo-classes
+				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
+				// Remember that setFilters inherits from pseudos
+				var args,
+					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
+						Sizzle.error( "unsupported pseudo: " + pseudo );
+
+				// The user may use createPseudo to indicate that
+				// arguments are needed to create the filter function
+				// just as Sizzle does
+				if ( fn[ expando ] ) {
+					return fn( argument );
+				}
+
+				// But maintain support for old signatures
+				if ( fn.length > 1 ) {
+					args = [ pseudo, pseudo, "", argument ];
+					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
+						markFunction(function( seed, matches ) {
+							var idx,
+								matched = fn( seed, argument ),
+								i = matched.length;
+							while ( i-- ) {
+								idx = indexOf.call( seed, matched[i] );
+								seed[ idx ] = !( matches[ idx ] = matched[i] );
+							}
+						}) :
+						function( elem ) {
+							return fn( elem, 0, args );
+						};
+				}
+
+				return fn;
+			}
+		},
+
+		pseudos: {
+			// Potentially complex pseudos
+			"not": markFunction(function( selector ) {
+				// Trim the selector passed to compile
+				// to avoid treating leading and trailing
+				// spaces as combinators
+				var input = [],
+					results = [],
+					matcher = compile( selector.replace( rtrim, "$1" ) );
+
+				return matcher[ expando ] ?
+					markFunction(function( seed, matches, context, xml ) {
+						var elem,
+							unmatched = matcher( seed, null, xml, [] ),
+							i = seed.length;
+
+						// Match elements unmatched by `matcher`
+						while ( i-- ) {
+							if ( (elem = unmatched[i]) ) {
+								seed[i] = !(matches[i] = elem);
+							}
+						}
+					}) :
+					function( elem, context, xml ) {
+						input[0] = elem;
+						matcher( input, null, xml, results );
+						return !results.pop();
+					};
+			}),
+
+			"has": markFunction(function( selector ) {
+				return function( elem ) {
+					return Sizzle( selector, elem ).length > 0;
+				};
+			}),
+
+			"contains": markFunction(function( text ) {
+				return function( elem ) {
+					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
+				};
+			}),
+
+			// "Whether an element is represented by a :lang() selector
+			// is based solely on the element's language value
+			// being equal to the identifier C,
+			// or beginning with the identifier C immediately followed by "-".
+			// The matching of C against the element's language value is performed case-insensitively.
+			// The identifier C does not have to be a valid language name."
+			// http://www.w3.org/TR/selectors/#lang-pseudo
+			"lang": markFunction( function( lang ) {
+				// lang value must be a valid identifider
+				if ( !ridentifier.test(lang || "") ) {
+					Sizzle.error( "unsupported lang: " + lang );
+				}
+				lang = lang.replace( runescape, funescape ).toLowerCase();
+				return function( elem ) {
+					var elemLang;
+					do {
+						if ( (elemLang = documentIsXML ?
+							elem.getAttribute("xml:lang") || elem.getAttribute("lang") :
+							elem.lang) ) {
+
+							elemLang = elemLang.toLowerCase();
+							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
+						}
+					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
+					return false;
+				};
+			}),
+
+			// Miscellaneous
+			"target": function( elem ) {
+				var hash = window.location && window.location.hash;
+				return hash && hash.slice( 1 ) === elem.id;
+			},
+
+			"root": function( elem ) {
+				return elem === docElem;
+			},
+
+			"focus": function( elem ) {
+				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
+			},
+
+			// Boolean properties
+			"enabled": function( elem ) {
+				return elem.disabled === false;
+			},
+
+			"disabled": function( elem ) {
+				return elem.disabled === true;
+			},
+
+			"checked": function( elem ) {
+				// In CSS3, :checked should return both checked and selected elements
+				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
+				var nodeName = elem.nodeName.toLowerCase();
+				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
+			},
+
+			"selected": function( elem ) {
+				// Accessing this property makes selected-by-default
+				// options in Safari work properly
+				if ( elem.parentNode ) {
+					elem.parentNode.selectedIndex;
+				}
+
+				return elem.selected === true;
+			},
+
+			// Contents
+			"empty": function( elem ) {
+				// http://www.w3.org/TR/selectors/#empty-pseudo
+				// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
+				//   not comment, processing instructions, or others
+				// Thanks to Diego Perini for the nodeName shortcut
+				//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
+				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
+					if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
+						return false;
+					}
+				}
+				return true;
+			},
+
+			"parent": function( elem ) {
+				return !Expr.pseudos["empty"]( elem );
+			},
+
+			// Element/input types
+			"header": function( elem ) {
+				return rheader.test( elem.nodeName );
+			},
+
+			"input": function( elem ) {
+				return rinputs.test( elem.nodeName );
+			},
+
+			"button": function( elem ) {
+				var name = elem.nodeName.toLowerCase();
+				return name === "input" && elem.type === "button" || name === "button";
+			},
+
+			"text": function( elem ) {
+				var attr;
+				// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
+				// use getAttribute instead to test this case
+				return elem.nodeName.toLowerCase() === "input" &&
+					elem.type === "text" &&
+					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
+			},
+
+			// Position-in-collection
+			"first": createPositionalPseudo(function() {
+				return [ 0 ];
+			}),
+
+			"last": createPositionalPseudo(function( matchIndexes, length ) {
+				return [ length - 1 ];
+			}),
+
+			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
+				return [ argument < 0 ? argument + length : argument ];
+			}),
+
+			"even": createPositionalPseudo(function( matchIndexes, length ) {
+				var i = 0;
+				for ( ; i < length; i += 2 ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			}),
+
+			"odd": createPositionalPseudo(function( matchIndexes, length ) {
+				var i = 1;
+				for ( ; i < length; i += 2 ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			}),
+
+			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
+				var i = argument < 0 ? argument + length : argument;
+				for ( ; --i >= 0; ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			}),
+
+			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
+				var i = argument < 0 ? argument + length : argument;
+				for ( ; ++i < length; ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			})
+		}
+	};
+
+	// Add button/input type pseudos
+	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
+		Expr.pseudos[ i ] = createInputPseudo( i );
+	}
+	for ( i in { submit: true, reset: true } ) {
+		Expr.pseudos[ i ] = createButtonPseudo( i );
+	}
+
+	function tokenize( selector, parseOnly ) {
+		var matched, match, tokens, type,
+			soFar, groups, preFilters,
+			cached = tokenCache[ selector + " " ];
+
+		if ( cached ) {
+			return parseOnly ? 0 : cached.slice( 0 );
+		}
+
+		soFar = selector;
+		groups = [];
+		preFilters = Expr.preFilter;
+
+		while ( soFar ) {
+
+			// Comma and first run
+			if ( !matched || (match = rcomma.exec( soFar )) ) {
+				if ( match ) {
+					// Don't consume trailing commas as valid
+					soFar = soFar.slice( match[0].length ) || soFar;
+				}
+				groups.push( tokens = [] );
+			}
+
+			matched = false;
+
+			// Combinators
+			if ( (match = rcombinators.exec( soFar )) ) {
+				matched = match.shift();
+				tokens.push( {
+					value: matched,
+					// Cast descendant combinators to space
+					type: match[0].replace( rtrim, " " )
+				} );
+				soFar = soFar.slice( matched.length );
+			}
+
+			// Filters
+			for ( type in Expr.filter ) {
+				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
+					(match = preFilters[ type ]( match ))) ) {
+					matched = match.shift();
+					tokens.push( {
+						value: matched,
+						type: type,
+						matches: match
+					} );
+					soFar = soFar.slice( matched.length );
+				}
+			}
+
+			if ( !matched ) {
+				break;
+			}
+		}
+
+		// Return the length of the invalid excess
+		// if we're just parsing
+		// Otherwise, throw an error or return tokens
+		return parseOnly ?
+			soFar.length :
+			soFar ?
+				Sizzle.error( selector ) :
+				// Cache the tokens
+				tokenCache( selector, groups ).slice( 0 );
+	}
+
+	function toSelector( tokens ) {
+		var i = 0,
+			len = tokens.length,
+			selector = "";
+		for ( ; i < len; i++ ) {
+			selector += tokens[i].value;
+		}
+		return selector;
+	}
+
+	function addCombinator( matcher, combinator, base ) {
+		var dir = combinator.dir,
+			checkNonElements = base && dir === "parentNode",
+			doneName = done++;
+
+		return combinator.first ?
+			// Check against closest ancestor/preceding element
+			function( elem, context, xml ) {
+				while ( (elem = elem[ dir ]) ) {
+					if ( elem.nodeType === 1 || checkNonElements ) {
+						return matcher( elem, context, xml );
+					}
+				}
+			} :
+
+			// Check against all ancestor/preceding elements
+			function( elem, context, xml ) {
+				var data, cache, outerCache,
+					dirkey = dirruns + " " + doneName;
+
+				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
+				if ( xml ) {
+					while ( (elem = elem[ dir ]) ) {
+						if ( elem.nodeType === 1 || checkNonElements ) {
+							if ( matcher( elem, context, xml ) ) {
+								return true;
+							}
+						}
+					}
+				} else {
+					while ( (elem = elem[ dir ]) ) {
+						if ( elem.nodeType === 1 || checkNonElements ) {
+							outerCache = elem[ expando ] || (elem[ expando ] = {});
+							if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
+								if ( (data = cache[1]) === true || data === cachedruns ) {
+									return data === true;
+								}
+							} else {
+								cache = outerCache[ dir ] = [ dirkey ];
+								cache[1] = matcher( elem, context, xml ) || cachedruns;
+								if ( cache[1] === true ) {
+									return true;
+								}
+							}
+						}
+					}
+				}
+			};
+	}
+
+	function elementMatcher( matchers ) {
+		return matchers.length > 1 ?
+			function( elem, context, xml ) {
+				var i = matchers.length;
+				while ( i-- ) {
+					if ( !matchers[i]( elem, context, xml ) ) {
+						return false;
+					}
+				}
+				return true;
+			} :
+			matchers[0];
+	}
+
+	function condense( unmatched, map, filter, context, xml ) {
+		var elem,
+			newUnmatched = [],
+			i = 0,
+			len = unmatched.length,
+			mapped = map != null;
+
+		for ( ; i < len; i++ ) {
+			if ( (elem = unmatched[i]) ) {
+				if ( !filter || filter( elem, context, xml ) ) {
+					newUnmatched.push( elem );
+					if ( mapped ) {
+						map.push( i );
+					}
+				}
+			}
+		}
+
+		return newUnmatched;
+	}
+
+	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
+		if ( postFilter && !postFilter[ expando ] ) {
+			postFilter = setMatcher( postFilter );
+		}
+		if ( postFinder && !postFinder[ expando ] ) {
+			postFinder = setMatcher( postFinder, postSelector );
+		}
+		return markFunction(function( seed, results, context, xml ) {
+			var temp, i, elem,
+				preMap = [],
+				postMap = [],
+				preexisting = results.length,
+
+				// Get initial elements from seed or context
+				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
+
+				// Prefilter to get matcher input, preserving a map for seed-results synchronization
+				matcherIn = preFilter && ( seed || !selector ) ?
+					condense( elems, preMap, preFilter, context, xml ) :
+					elems,
+
+				matcherOut = matcher ?
+					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
+					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
+
+						// ...intermediate processing is necessary
+						[] :
+
+						// ...otherwise use results directly
+						results :
+					matcherIn;
+
+			// Find primary matches
+			if ( matcher ) {
+				matcher( matcherIn, matcherOut, context, xml );
+			}
+
+			// Apply postFilter
+			if ( postFilter ) {
+				temp = condense( matcherOut, postMap );
+				postFilter( temp, [], context, xml );
+
+				// Un-match failing elements by moving them back to matcherIn
+				i = temp.length;
+				while ( i-- ) {
+					if ( (elem = temp[i]) ) {
+						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
+					}
+				}
+			}
+
+			if ( seed ) {
+				if ( postFinder || preFilter ) {
+					if ( postFinder ) {
+						// Get the final matcherOut by condensing this intermediate into postFinder contexts
+						temp = [];
+						i = matcherOut.length;
+						while ( i-- ) {
+							if ( (elem = matcherOut[i]) ) {
+								// Restore matcherIn since elem is not yet a final match
+								temp.push( (matcherIn[i] = elem) );
+							}
+						}
+						postFinder( null, (matcherOut = []), temp, xml );
+					}
+
+					// Move matched elements from seed to results to keep them synchronized
+					i = matcherOut.length;
+					while ( i-- ) {
+						if ( (elem = matcherOut[i]) &&
+							(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {
+
+							seed[temp] = !(results[temp] = elem);
+						}
+					}
+				}
+
+			// Add elements to results, through postFinder if defined
+			} else {
+				matcherOut = condense(
+					matcherOut === results ?
+						matcherOut.splice( preexisting, matcherOut.length ) :
+						matcherOut
+				);
+				if ( postFinder ) {
+					postFinder( null, results, matcherOut, xml );
+				} else {
+					push.apply( results, matcherOut );
+				}
+			}
+		});
+	}
+
+	function matcherFromTokens( tokens ) {
+		var checkContext, matcher, j,
+			len = tokens.length,
+			leadingRelative = Expr.relative[ tokens[0].type ],
+			implicitRelative = leadingRelative || Expr.relative[" "],
+			i = leadingRelative ? 1 : 0,
+
+			// The foundational matcher ensures that elements are reachable from top-level context(s)
+			matchContext = addCombinator( function( elem ) {
+				return elem === checkContext;
+			}, implicitRelative, true ),
+			matchAnyContext = addCombinator( function( elem ) {
+				return indexOf.call( checkContext, elem ) > -1;
+			}, implicitRelative, true ),
+			matchers = [ function( elem, context, xml ) {
+				return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
+					(checkContext = context).nodeType ?
+						matchContext( elem, context, xml ) :
+						matchAnyContext( elem, context, xml ) );
+			} ];
+
+		for ( ; i < len; i++ ) {
+			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
+				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
+			} else {
+				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
+
+				// Return special upon seeing a positional matcher
+				if ( matcher[ expando ] ) {
+					// Find the next relative operator (if any) for proper handling
+					j = ++i;
+					for ( ; j < len; j++ ) {
+						if ( Expr.relative[ tokens[j].type ] ) {
+							break;
+						}
+					}
+					return setMatcher(
+						i > 1 && elementMatcher( matchers ),
+						i > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, "$1" ),
+						matcher,
+						i < j && matcherFromTokens( tokens.slice( i, j ) ),
+						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
+						j < len && toSelector( tokens )
+					);
+				}
+				matchers.push( matcher );
+			}
+		}
+
+		return elementMatcher( matchers );
+	}
+
+	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
+		// A counter to specify which element is currently being matched
+		var matcherCachedRuns = 0,
+			bySet = setMatchers.length > 0,
+			byElement = elementMatchers.length > 0,
+			superMatcher = function( seed, context, xml, results, expandContext ) {
+				var elem, j, matcher,
+					setMatched = [],
+					matchedCount = 0,
+					i = "0",
+					unmatched = seed && [],
+					outermost = expandContext != null,
+					contextBackup = outermostContext,
+					// We must always have either seed elements or context
+					elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
+					// Use integer dirruns iff this is the outermost matcher
+					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);
+
+				if ( outermost ) {
+					outermostContext = context !== document && context;
+					cachedruns = matcherCachedRuns;
+				}
+
+				// Add elements passing elementMatchers directly to results
+				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
+				for ( ; (elem = elems[i]) != null; i++ ) {
+					if ( byElement && elem ) {
+						j = 0;
+						while ( (matcher = elementMatchers[j++]) ) {
+							if ( matcher( elem, context, xml ) ) {
+								results.push( elem );
+								break;
+							}
+						}
+						if ( outermost ) {
+							dirruns = dirrunsUnique;
+							cachedruns = ++matcherCachedRuns;
+						}
+					}
+
+					// Track unmatched elements for set filters
+					if ( bySet ) {
+						// They will have gone through all possible matchers
+						if ( (elem = !matcher && elem) ) {
+							matchedCount--;
+						}
+
+						// Lengthen the array for every element, matched or not
+						if ( seed ) {
+							unmatched.push( elem );
+						}
+					}
+				}
+
+				// Apply set filters to unmatched elements
+				matchedCount += i;
+				if ( bySet && i !== matchedCount ) {
+					j = 0;
+					while ( (matcher = setMatchers[j++]) ) {
+						matcher( unmatched, setMatched, context, xml );
+					}
+
+					if ( seed ) {
+						// Reintegrate element matches to eliminate the need for sorting
+						if ( matchedCount > 0 ) {
+							while ( i-- ) {
+								if ( !(unmatched[i] || setMatched[i]) ) {
+									setMatched[i] = pop.call( results );
+								}
+							}
+						}
+
+						// Discard index placeholder values to get only actual matches
+						setMatched = condense( setMatched );
+					}
+
+					// Add matches to results
+					push.apply( results, setMatched );
+
+					// Seedless set matches succeeding multiple successful matchers stipulate sorting
+					if ( outermost && !seed && setMatched.length > 0 &&
+						( matchedCount + setMatchers.length ) > 1 ) {
+
+						Sizzle.uniqueSort( results );
+					}
+				}
+
+				// Override manipulation of globals by nested matchers
+				if ( outermost ) {
+					dirruns = dirrunsUnique;
+					outermostContext = contextBackup;
+				}
+
+				return unmatched;
+			};
+
+		return bySet ?
+			markFunction( superMatcher ) :
+			superMatcher;
+	}
+
+	compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
+		var i,
+			setMatchers = [],
+			elementMatchers = [],
+			cached = compilerCache[ selector + " " ];
+
+		if ( !cached ) {
+			// Generate a function of recursive functions that can be used to check each element
+			if ( !group ) {
+				group = tokenize( selector );
+			}
+			i = group.length;
+			while ( i-- ) {
+				cached = matcherFromTokens( group[i] );
+				if ( cached[ expando ] ) {
+					setMatchers.push( cached );
+				} else {
+					elementMatchers.push( cached );
+				}
+			}
+
+			// Cache the compiled function
+			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
+		}
+		return cached;
+	};
+
+	function multipleContexts( selector, contexts, results ) {
+		var i = 0,
+			len = contexts.length;
+		for ( ; i < len; i++ ) {
+			Sizzle( selector, contexts[i], results );
+		}
+		return results;
+	}
+
+	function select( selector, context, results, seed ) {
+		var i, tokens, token, type, find,
+			match = tokenize( selector );
+
+		if ( !seed ) {
+			// Try to minimize operations if there is only one group
+			if ( match.length === 1 ) {
+
+				// Take a shortcut and set the context if the root selector is an ID
+				tokens = match[0] = match[0].slice( 0 );
+				if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
+						context.nodeType === 9 && !documentIsXML &&
+						Expr.relative[ tokens[1].type ] ) {
+
+					context = Expr.find["ID"]( token.matches[0].replace( runescape, funescape ), context )[0];
+					if ( !context ) {
+						return results;
+					}
+
+					selector = selector.slice( tokens.shift().value.length );
+				}
+
+				// Fetch a seed set for right-to-left matching
+				i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
+				while ( i-- ) {
+					token = tokens[i];
+
+					// Abort if we hit a combinator
+					if ( Expr.relative[ (type = token.type) ] ) {
+						break;
+					}
+					if ( (find = Expr.find[ type ]) ) {
+						// Search, expanding context for leading sibling combinators
+						if ( (seed = find(
+							token.matches[0].replace( runescape, funescape ),
+							rsibling.test( tokens[0].type ) && context.parentNode || context
+						)) ) {
+
+							// If seed is empty or no tokens remain, we can return early
+							tokens.splice( i, 1 );
+							selector = seed.length && toSelector( tokens );
+							if ( !selector ) {
+								push.apply( results, slice.call( seed, 0 ) );
+								return results;
+							}
+
+							break;
+						}
+					}
+				}
+			}
+		}
+
+		// Compile and execute a filtering function
+		// Provide `match` to avoid retokenization if we modified the selector above
+		compile( selector, match )(
+			seed,
+			context,
+			documentIsXML,
+			results,
+			rsibling.test( selector )
+		);
+		return results;
+	}
+
+	// Deprecated
+	Expr.pseudos["nth"] = Expr.pseudos["eq"];
+
+	// Easy API for creating new setFilters
+	function setFilters() {}
+	Expr.filters = setFilters.prototype = Expr.pseudos;
+	Expr.setFilters = new setFilters();
+
+	// Initialize with the default document
+	setDocument();
+
+	// Override sizzle attribute retrieval
+	Sizzle.attr = jQuery.attr;
+	jQuery.find = Sizzle;
+	jQuery.expr = Sizzle.selectors;
+	jQuery.expr[":"] = jQuery.expr.pseudos;
+	jQuery.unique = Sizzle.uniqueSort;
+	jQuery.text = Sizzle.getText;
+	jQuery.isXMLDoc = Sizzle.isXML;
+	jQuery.contains = Sizzle.contains;
+
+
+	})( window );
+	var runtil = /Until$/,
+		rparentsprev = /^(?:parents|prev(?:Until|All))/,
+		isSimple = /^.[^:#\[\.,]*$/,
+		rneedsContext = jQuery.expr.match.needsContext,
+		// methods guaranteed to produce a unique set when starting from a unique set
+		guaranteedUnique = {
+			children: true,
+			contents: true,
+			next: true,
+			prev: true
+		};
+
+	jQuery.fn.extend({
+		find: function( selector ) {
+			var i, ret, self,
+				len = this.length;
+
+			if ( typeof selector !== "string" ) {
+				self = this;
+				return this.pushStack( jQuery( selector ).filter(function() {
+					for ( i = 0; i < len; i++ ) {
+						if ( jQuery.contains( self[ i ], this ) ) {
+							return true;
+						}
+					}
+				}) );
+			}
+
+			ret = [];
+			for ( i = 0; i < len; i++ ) {
+				jQuery.find( selector, this[ i ], ret );
+			}
+
+			// Needed because $( selector, context ) becomes $( context ).find( selector )
+			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
+			ret.selector = ( this.selector ? this.selector + " " : "" ) + selector;
+			return ret;
+		},
+
+		has: function( target ) {
+			var i,
+				targets = jQuery( target, this ),
+				len = targets.length;
+
+			return this.filter(function() {
+				for ( i = 0; i < len; i++ ) {
+					if ( jQuery.contains( this, targets[i] ) ) {
+						return true;
+					}
+				}
+			});
+		},
+
+		not: function( selector ) {
+			return this.pushStack( winnow(this, selector, false) );
+		},
+
+		filter: function( selector ) {
+			return this.pushStack( winnow(this, selector, true) );
+		},
+
+		is: function( selector ) {
+			return !!selector && (
+				typeof selector === "string" ?
+					// If this is a positional/relative selector, check membership in the returned set
+					// so $("p:first").is("p:last") won't return true for a doc with two "p".
+					rneedsContext.test( selector ) ?
+						jQuery( selector, this.context ).index( this[0] ) >= 0 :
+						jQuery.filter( selector, this ).length > 0 :
+					this.filter( selector ).length > 0 );
+		},
+
+		closest: function( selectors, context ) {
+			var cur,
+				i = 0,
+				l = this.length,
+				ret = [],
+				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
+					jQuery( selectors, context || this.context ) :
+					0;
+
+			for ( ; i < l; i++ ) {
+				cur = this[i];
+
+				while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
+					if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
+						ret.push( cur );
+						break;
+					}
+					cur = cur.parentNode;
+				}
+			}
+
+			return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
+		},
+
+		// Determine the position of an element within
+		// the matched set of elements
+		index: function( elem ) {
+
+			// No argument, return index in parent
+			if ( !elem ) {
+				return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
+			}
+
+			// index in selector
+			if ( typeof elem === "string" ) {
+				return jQuery.inArray( this[0], jQuery( elem ) );
+			}
+
+			// Locate the position of the desired element
+			return jQuery.inArray(
+				// If it receives a jQuery object, the first element is used
+				elem.jquery ? elem[0] : elem, this );
+		},
+
+		add: function( selector, context ) {
+			var set = typeof selector === "string" ?
+					jQuery( selector, context ) :
+					jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
+				all = jQuery.merge( this.get(), set );
+
+			return this.pushStack( jQuery.unique(all) );
+		},
+
+		addBack: function( selector ) {
+			return this.add( selector == null ?
+				this.prevObject : this.prevObject.filter(selector)
+			);
+		}
+	});
+
+	jQuery.fn.andSelf = jQuery.fn.addBack;
+
+	function sibling( cur, dir ) {
+		do {
+			cur = cur[ dir ];
+		} while ( cur && cur.nodeType !== 1 );
+
+		return cur;
+	}
+
+	jQuery.each({
+		parent: function( elem ) {
+			var parent = elem.parentNode;
+			return parent && parent.nodeType !== 11 ? parent : null;
+		},
+		parents: function( elem ) {
+			return jQuery.dir( elem, "parentNode" );
+		},
+		parentsUntil: function( elem, i, until ) {
+			return jQuery.dir( elem, "parentNode", until );
+		},
+		next: function( elem ) {
+			return sibling( elem, "nextSibling" );
+		},
+		prev: function( elem ) {
+			return sibling( elem, "previousSibling" );
+		},
+		nextAll: function( elem ) {
+			return jQuery.dir( elem, "nextSibling" );
+		},
+		prevAll: function( elem ) {
+			return jQuery.dir( elem, "previousSibling" );
+		},
+		nextUntil: function( elem, i, until ) {
+			return jQuery.dir( elem, "nextSibling", until );
+		},
+		prevUntil: function( elem, i, until ) {
+			return jQuery.dir( elem, "previousSibling", until );
+		},
+		siblings: function( elem ) {
+			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
+		},
+		children: function( elem ) {
+			return jQuery.sibling( elem.firstChild );
+		},
+		contents: function( elem ) {
+			return jQuery.nodeName( elem, "iframe" ) ?
+				elem.contentDocument || elem.contentWindow.document :
+				jQuery.merge( [], elem.childNodes );
+		}
+	}, function( name, fn ) {
+		jQuery.fn[ name ] = function( until, selector ) {
+			var ret = jQuery.map( this, fn, until );
+
+			if ( !runtil.test( name ) ) {
+				selector = until;
+			}
+
+			if ( selector && typeof selector === "string" ) {
+				ret = jQuery.filter( selector, ret );
+			}
+
+			ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
+
+			if ( this.length > 1 && rparentsprev.test( name ) ) {
+				ret = ret.reverse();
+			}
+
+			return this.pushStack( ret );
+		};
+	});
+
+	jQuery.extend({
+		filter: function( expr, elems, not ) {
+			if ( not ) {
+				expr = ":not(" + expr + ")";
+			}
+
+			return elems.length === 1 ?
+				jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
+				jQuery.find.matches(expr, elems);
+		},
+
+		dir: function( elem, dir, until ) {
+			var matched = [],
+				cur = elem[ dir ];
+
+			while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
+				if ( cur.nodeType === 1 ) {
+					matched.push( cur );
+				}
+				cur = cur[dir];
+			}
+			return matched;
+		},
+
+		sibling: function( n, elem ) {
+			var r = [];
+
+			for ( ; n; n = n.nextSibling ) {
+				if ( n.nodeType === 1 && n !== elem ) {
+					r.push( n );
+				}
+			}
+
+			return r;
+		}
+	});
+
+	// Implement the identical functionality for filter and not
+	function winnow( elements, qualifier, keep ) {
+
+		// Can't pass null or undefined to indexOf in Firefox 4
+		// Set to 0 to skip string check
+		qualifier = qualifier || 0;
+
+		if ( jQuery.isFunction( qualifier ) ) {
+			return jQuery.grep(elements, function( elem, i ) {
+				var retVal = !!qualifier.call( elem, i, elem );
+				return retVal === keep;
+			});
+
+		} else if ( qualifier.nodeType ) {
+			return jQuery.grep(elements, function( elem ) {
+				return ( elem === qualifier ) === keep;
+			});
+
+		} else if ( typeof qualifier === "string" ) {
+			var filtered = jQuery.grep(elements, function( elem ) {
+				return elem.nodeType === 1;
+			});
+
+			if ( isSimple.test( qualifier ) ) {
+				return jQuery.filter(qualifier, filtered, !keep);
+			} else {
+				qualifier = jQuery.filter( qualifier, filtered );
+			}
+		}
+
+		return jQuery.grep(elements, function( elem ) {
+			return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
+		});
+	}
+	function createSafeFragment( document ) {
+		var list = nodeNames.split( "|" ),
+			safeFrag = document.createDocumentFragment();
+
+		if ( safeFrag.createElement ) {
+			while ( list.length ) {
+				safeFrag.createElement(
+					list.pop()
+				);
+			}
+		}
+		return safeFrag;
+	}
+
+	var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
+			"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
+		rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
+		rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
+		rleadingWhitespace = /^\s+/,
+		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
+		rtagName = /<([\w:]+)/,
+		rtbody = /<tbody/i,
+		rhtml = /<|&#?\w+;/,
+		rnoInnerhtml = /<(?:script|style|link)/i,
+		manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
+		// checked="checked" or checked
+		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
+		rscriptType = /^$|\/(?:java|ecma)script/i,
+		rscriptTypeMasked = /^true\/(.*)/,
+		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
+
+		// We have to close these tags to support XHTML (#13200)
+		wrapMap = {
+			option: [ 1, "<select multiple='multiple'>", "</select>" ],
+			legend: [ 1, "<fieldset>", "</fieldset>" ],
+			area: [ 1, "<map>", "</map>" ],
+			param: [ 1, "<object>", "</object>" ],
+			thead: [ 1, "<table>", "</table>" ],
+			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
+			col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
+			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
+
+			// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
+			// unless wrapped in a div with non-breaking characters in front of it.
+			_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
+		},
+		safeFragment = createSafeFragment( document ),
+		fragmentDiv = safeFragment.appendChild( document.createElement("div") );
+
+	wrapMap.optgroup = wrapMap.option;
+	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
+	wrapMap.th = wrapMap.td;
+
+	jQuery.fn.extend({
+		text: function( value ) {
+			return jQuery.access( this, function( value ) {
+				return value === undefined ?
+					jQuery.text( this ) :
+					this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
+			}, null, value, arguments.length );
+		},
+
+		wrapAll: function( html ) {
+			if ( jQuery.isFunction( html ) ) {
+				return this.each(function(i) {
+					jQuery(this).wrapAll( html.call(this, i) );
+				});
+			}
+
+			if ( this[0] ) {
+				// The elements to wrap the target around
+				var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
+
+				if ( this[0].parentNode ) {
+					wrap.insertBefore( this[0] );
+				}
+
+				wrap.map(function() {
+					var elem = this;
+
+					while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
+						elem = elem.firstChild;
+					}
+
+					return elem;
+				}).append( this );
+			}
+
+			return this;
+		},
+
+		wrapInner: function( html ) {
+			if ( jQuery.isFunction( html ) ) {
+				return this.each(function(i) {
+					jQuery(this).wrapInner( html.call(this, i) );
+				});
+			}
+
+			return this.each(function() {
+				var self = jQuery( this ),
+					contents = self.contents();
+
+				if ( contents.length ) {
+					contents.wrapAll( html );
+
+				} else {
+					self.append( html );
+				}
+			});
+		},
+
+		wrap: function( html ) {
+			var isFunction = jQuery.isFunction( html );
+
+			return this.each(function(i) {
+				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
+			});
+		},
+
+		unwrap: function() {
+			return this.parent().each(function() {
+				if ( !jQuery.nodeName( this, "body" ) ) {
+					jQuery( this ).replaceWith( this.childNodes );
+				}
+			}).end();
+		},
+
+		append: function() {
+			return this.domManip(arguments, true, function( elem ) {
+				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
+					this.appendChild( elem );
+				}
+			});
+		},
+
+		prepend: function() {
+			return this.domManip(arguments, true, function( elem ) {
+				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
+					this.insertBefore( elem, this.firstChild );
+				}
+			});
+		},
+
+		before: function() {
+			return this.domManip( arguments, false, function( elem ) {
+				if ( this.parentNode ) {
+					this.parentNode.insertBefore( elem, this );
+				}
+			});
+		},
+
+		after: function() {
+			return this.domManip( arguments, false, function( elem ) {
+				if ( this.parentNode ) {
+					this.parentNode.insertBefore( elem, this.nextSibling );
+				}
+			});
+		},
+
+		// keepData is for internal use only--do not document
+		remove: function( selector, keepData ) {
+			var elem,
+				i = 0;
+
+			for ( ; (elem = this[i]) != null; i++ ) {
+				if ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {
+					if ( !keepData && elem.nodeType === 1 ) {
+						jQuery.cleanData( getAll( elem ) );
+					}
+
+					if ( elem.parentNode ) {
+						if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
+							setGlobalEval( getAll( elem, "script" ) );
+						}
+						elem.parentNode.removeChild( elem );
+					}
+				}
+			}
+
+			return this;
+		},
+
+		empty: function() {
+			var elem,
+				i = 0;
+
+			for ( ; (elem = this[i]) != null; i++ ) {
+				// Remove element nodes and prevent memory leaks
+				if ( elem.nodeType === 1 ) {
+					jQuery.cleanData( getAll( elem, false ) );
+				}
+
+				// Remove any remaining nodes
+				while ( elem.firstChild ) {
+					elem.removeChild( elem.firstChild );
+				}
+
+				// If this is a select, ensure that it displays empty (#12336)
+				// Support: IE<9
+				if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
+					elem.options.length = 0;
+				}
+			}
+
+			return this;
+		},
+
+		clone: function( dataAndEvents, deepDataAndEvents ) {
+			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
+			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
+
+			return this.map( function () {
+				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
+			});
+		},
+
+		html: function( value ) {
+			return jQuery.access( this, function( value ) {
+				var elem = this[0] || {},
+					i = 0,
+					l = this.length;
+
+				if ( value === undefined ) {
+					return elem.nodeType === 1 ?
+						elem.innerHTML.replace( rinlinejQuery, "" ) :
+						undefined;
+				}
+
+				// See if we can take a shortcut and just use innerHTML
+				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
+					( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
+					( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
+					!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {
+
+					value = value.replace( rxhtmlTag, "<$1></$2>" );
+
+					try {
+						for (; i < l; i++ ) {
+							// Remove element nodes and prevent memory leaks
+							elem = this[i] || {};
+							if ( elem.nodeType === 1 ) {
+								jQuery.cleanData( getAll( elem, false ) );
+								elem.innerHTML = value;
+							}
+						}
+
+						elem = 0;
+
+					// If using innerHTML throws an exception, use the fallback method
+					} catch(e) {}
+				}
+
+				if ( elem ) {
+					this.empty().append( value );
+				}
+			}, null, value, arguments.length );
+		},
+
+		replaceWith: function( value ) {
+			var isFunc = jQuery.isFunction( value );
+
+			// Make sure that the elements are removed from the DOM before they are inserted
+			// this can help fix replacing a parent with child elements
+			if ( !isFunc && typeof value !== "string" ) {
+				value = jQuery( value ).not( this ).detach();
+			}
+
+			return this.domManip( [ value ], true, function( elem ) {
+				var next = this.nextSibling,
+					parent = this.parentNode;
+
+				if ( parent ) {
+					jQuery( this ).remove();
+					parent.insertBefore( elem, next );
+				}
+			});
+		},
+
+		detach: function( selector ) {
+			return this.remove( selector, true );
+		},
+
+		domManip: function( args, table, callback ) {
+
+			// Flatten any nested arrays
+			args = core_concat.apply( [], args );
+
+			var first, node, hasScripts,
+				scripts, doc, fragment,
+				i = 0,
+				l = this.length,
+				set = this,
+				iNoClone = l - 1,
+				value = args[0],
+				isFunction = jQuery.isFunction( value );
+
+			// We can't cloneNode fragments that contain checked, in WebKit
+			if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
+				return this.each(function( index ) {
+					var self = set.eq( index );
+					if ( isFunction ) {
+						args[0] = value.call( this, index, table ? self.html() : undefined );
+					}
+					self.domManip( args, table, callback );
+				});
+			}
+
+			if ( l ) {
+				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
+				first = fragment.firstChild;
+
+				if ( fragment.childNodes.length === 1 ) {
+					fragment = first;
+				}
+
+				if ( first ) {
+					table = table && jQuery.nodeName( first, "tr" );
+					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
+					hasScripts = scripts.length;
+
+					// Use the original fragment for the last item instead of the first because it can end up
+					// being emptied incorrectly in certain situations (#8070).
+					for ( ; i < l; i++ ) {
+						node = fragment;
+
+						if ( i !== iNoClone ) {
+							node = jQuery.clone( node, true, true );
+
+							// Keep references to cloned scripts for later restoration
+							if ( hasScripts ) {
+								jQuery.merge( scripts, getAll( node, "script" ) );
+							}
+						}
+
+						callback.call(
+							table && jQuery.nodeName( this[i], "table" ) ?
+								findOrAppend( this[i], "tbody" ) :
+								this[i],
+							node,
+							i
+						);
+					}
+
+					if ( hasScripts ) {
+						doc = scripts[ scripts.length - 1 ].ownerDocument;
+
+						// Reenable scripts
+						jQuery.map( scripts, restoreScript );
+
+						// Evaluate executable scripts on first document insertion
+						for ( i = 0; i < hasScripts; i++ ) {
+							node = scripts[ i ];
+							if ( rscriptType.test( node.type || "" ) &&
+								!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
+
+								if ( node.src ) {
+									// Hope ajax is available...
+									jQuery.ajax({
+										url: node.src,
+										type: "GET",
+										dataType: "script",
+										async: false,
+										global: false,
+										"throws": true
+									});
+								} else {
+									jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
+								}
+							}
+						}
+					}
+
+					// Fix #11809: Avoid leaking memory
+					fragment = first = null;
+				}
+			}
+
+			return this;
+		}
+	});
+
+	function findOrAppend( elem, tag ) {
+		return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
+	}
+
+	// Replace/restore the type attribute of script elements for safe DOM manipulation
+	function disableScript( elem ) {
+		var attr = elem.getAttributeNode("type");
+		elem.type = ( attr && attr.specified ) + "/" + elem.type;
+		return elem;
+	}
+	function restoreScript( elem ) {
+		var match = rscriptTypeMasked.exec( elem.type );
+		if ( match ) {
+			elem.type = match[1];
+		} else {
+			elem.removeAttribute("type");
+		}
+		return elem;
+	}
+
+	// Mark scripts as having already been evaluated
+	function setGlobalEval( elems, refElements ) {
+		var elem,
+			i = 0;
+		for ( ; (elem = elems[i]) != null; i++ ) {
+			jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
+		}
+	}
+
+	function cloneCopyEvent( src, dest ) {
+
+		if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
+			return;
+		}
+
+		var type, i, l,
+			oldData = jQuery._data( src ),
+			curData = jQuery._data( dest, oldData ),
+			events = oldData.events;
+
+		if ( events ) {
+			delete curData.handle;
+			curData.events = {};
+
+			for ( type in events ) {
+				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
+					jQuery.event.add( dest, type, events[ type ][ i ] );
+				}
+			}
+		}
+
+		// make the cloned public data object a copy from the original
+		if ( curData.data ) {
+			curData.data = jQuery.extend( {}, curData.data );
+		}
+	}
+
+	function fixCloneNodeIssues( src, dest ) {
+		var nodeName, e, data;
+
+		// We do not need to do anything for non-Elements
+		if ( dest.nodeType !== 1 ) {
+			return;
+		}
+
+		nodeName = dest.nodeName.toLowerCase();
+
+		// IE6-8 copies events bound via attachEvent when using cloneNode.
+		if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
+			data = jQuery._data( dest );
+
+			for ( e in data.events ) {
+				jQuery.removeEvent( dest, e, data.handle );
+			}
+
+			// Event data gets referenced instead of copied if the expando gets copied too
+			dest.removeAttribute( jQuery.expando );
+		}
+
+		// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
+		if ( nodeName === "script" && dest.text !== src.text ) {
+			disableScript( dest ).text = src.text;
+			restoreScript( dest );
+
+		// IE6-10 improperly clones children of object elements using classid.
+		// IE10 throws NoModificationAllowedError if parent is null, #12132.
+		} else if ( nodeName === "object" ) {
+			if ( dest.parentNode ) {
+				dest.outerHTML = src.outerHTML;
+			}
+
+			// This path appears unavoidable for IE9. When cloning an object
+			// element in IE9, the outerHTML strategy above is not sufficient.
+			// If the src has innerHTML and the destination does not,
+			// copy the src.innerHTML into the dest.innerHTML. #10324
+			if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
+				dest.innerHTML = src.innerHTML;
+			}
+
+		} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
+			// IE6-8 fails to persist the checked state of a cloned checkbox
+			// or radio button. Worse, IE6-7 fail to give the cloned element
+			// a checked appearance if the defaultChecked value isn't also set
+
+			dest.defaultChecked = dest.checked = src.checked;
+
+			// IE6-7 get confused and end up setting the value of a cloned
+			// checkbox/radio button to an empty string instead of "on"
+			if ( dest.value !== src.value ) {
+				dest.value = src.value;
+			}
+
+		// IE6-8 fails to return the selected option to the default selected
+		// state when cloning options
+		} else if ( nodeName === "option" ) {
+			dest.defaultSelected = dest.selected = src.defaultSelected;
+
+		// IE6-8 fails to set the defaultValue to the correct value when
+		// cloning other types of input fields
+		} else if ( nodeName === "input" || nodeName === "textarea" ) {
+			dest.defaultValue = src.defaultValue;
+		}
+	}
+
+	jQuery.each({
+		appendTo: "append",
+		prependTo: "prepend",
+		insertBefore: "before",
+		insertAfter: "after",
+		replaceAll: "replaceWith"
+	}, function( name, original ) {
+		jQuery.fn[ name ] = function( selector ) {
+			var elems,
+				i = 0,
+				ret = [],
+				insert = jQuery( selector ),
+				last = insert.length - 1;
+
+			for ( ; i <= last; i++ ) {
+				elems = i === last ? this : this.clone(true);
+				jQuery( insert[i] )[ original ]( elems );
+
+				// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
+				core_push.apply( ret, elems.get() );
+			}
+
+			return this.pushStack( ret );
+		};
+	});
+
+	function getAll( context, tag ) {
+		var elems, elem,
+			i = 0,
+			found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
+				typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
+				undefined;
+
+		if ( !found ) {
+			for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
+				if ( !tag || jQuery.nodeName( elem, tag ) ) {
+					found.push( elem );
+				} else {
+					jQuery.merge( found, getAll( elem, tag ) );
+				}
+			}
+		}
+
+		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
+			jQuery.merge( [ context ], found ) :
+			found;
+	}
+
+	// Used in buildFragment, fixes the defaultChecked property
+	function fixDefaultChecked( elem ) {
+		if ( manipulation_rcheckableType.test( elem.type ) ) {
+			elem.defaultChecked = elem.checked;
+		}
+	}
+
+	jQuery.extend({
+		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
+			var destElements, node, clone, i, srcElements,
+				inPage = jQuery.contains( elem.ownerDocument, elem );
+
+			if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
+				clone = elem.cloneNode( true );
+
+			// IE<=8 does not properly clone detached, unknown element nodes
+			} else {
+				fragmentDiv.innerHTML = elem.outerHTML;
+				fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
+			}
+
+			if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
+					(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
+
+				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
+				destElements = getAll( clone );
+				srcElements = getAll( elem );
+
+				// Fix all IE cloning issues
+				for ( i = 0; (node = srcElements[i]) != null; ++i ) {
+					// Ensure that the destination node is not null; Fixes #9587
+					if ( destElements[i] ) {
+						fixCloneNodeIssues( node, destElements[i] );
+					}
+				}
+			}
+
+			// Copy the events from the original to the clone
+			if ( dataAndEvents ) {
+				if ( deepDataAndEvents ) {
+					srcElements = srcElements || getAll( elem );
+					destElements = destElements || getAll( clone );
+
+					for ( i = 0; (node = srcElements[i]) != null; i++ ) {
+						cloneCopyEvent( node, destElements[i] );
+					}
+				} else {
+					cloneCopyEvent( elem, clone );
+				}
+			}
+
+			// Preserve script evaluation history
+			destElements = getAll( clone, "script" );
+			if ( destElements.length > 0 ) {
+				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
+			}
+
+			destElements = srcElements = node = null;
+
+			// Return the cloned set
+			return clone;
+		},
+
+		buildFragment: function( elems, context, scripts, selection ) {
+			var j, elem, contains,
+				tmp, tag, tbody, wrap,
+				l = elems.length,
+
+				// Ensure a safe fragment
+				safe = createSafeFragment( context ),
+
+				nodes = [],
+				i = 0;
+
+			for ( ; i < l; i++ ) {
+				elem = elems[ i ];
+
+				if ( elem || elem === 0 ) {
+
+					// Add nodes directly
+					if ( jQuery.type( elem ) === "object" ) {
+						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
+
+					// Convert non-html into a text node
+					} else if ( !rhtml.test( elem ) ) {
+						nodes.push( context.createTextNode( elem ) );
+
+					// Convert html into DOM nodes
+					} else {
+						tmp = tmp || safe.appendChild( context.createElement("div") );
+
+						// Deserialize a standard representation
+						tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
+						wrap = wrapMap[ tag ] || wrapMap._default;
+
+						tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];
+
+						// Descend through wrappers to the right content
+						j = wrap[0];
+						while ( j-- ) {
+							tmp = tmp.lastChild;
+						}
+
+						// Manually add leading whitespace removed by IE
+						if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
+							nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
+						}
+
+						// Remove IE's autoinserted <tbody> from table fragments
+						if ( !jQuery.support.tbody ) {
+
+							// String was a <table>, *may* have spurious <tbody>
+							elem = tag === "table" && !rtbody.test( elem ) ?
+								tmp.firstChild :
+
+								// String was a bare <thead> or <tfoot>
+								wrap[1] === "<table>" && !rtbody.test( elem ) ?
+									tmp :
+									0;
+
+							j = elem && elem.childNodes.length;
+							while ( j-- ) {
+								if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
+									elem.removeChild( tbody );
+								}
+							}
+						}
+
+						jQuery.merge( nodes, tmp.childNodes );
+
+						// Fix #12392 for WebKit and IE > 9
+						tmp.textContent = "";
+
+						// Fix #12392 for oldIE
+						while ( tmp.firstChild ) {
+							tmp.removeChild( tmp.firstChild );
+						}
+
+						// Remember the top-level container for proper cleanup
+						tmp = safe.lastChild;
+					}
+				}
+			}
+
+			// Fix #11356: Clear elements from fragment
+			if ( tmp ) {
+				safe.removeChild( tmp );
+			}
+
+			// Reset defaultChecked for any radios and checkboxes
+			// about to be appended to the DOM in IE 6/7 (#8060)
+			if ( !jQuery.support.appendChecked ) {
+				jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
+			}
+
+			i = 0;
+			while ( (elem = nodes[ i++ ]) ) {
+
+				// #4087 - If origin and destination elements are the same, and this is
+				// that element, do not do anything
+				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
+					continue;
+				}
+
+				contains = jQuery.contains( elem.ownerDocument, elem );
+
+				// Append to fragment
+				tmp = getAll( safe.appendChild( elem ), "script" );
+
+				// Preserve script evaluation history
+				if ( contains ) {
+					setGlobalEval( tmp );
+				}
+
+				// Capture executables
+				if ( scripts ) {
+					j = 0;
+					while ( (elem = tmp[ j++ ]) ) {
+						if ( rscriptType.test( elem.type || "" ) ) {
+							scripts.push( elem );
+						}
+					}
+				}
+			}
+
+			tmp = null;
+
+			return safe;
+		},
+
+		cleanData: function( elems, /* internal */ acceptData ) {
+			var elem, type, id, data,
+				i = 0,
+				internalKey = jQuery.expando,
+				cache = jQuery.cache,
+				deleteExpando = jQuery.support.deleteExpando,
+				special = jQuery.event.special;
+
+			for ( ; (elem = elems[i]) != null; i++ ) {
+
+				if ( acceptData || jQuery.acceptData( elem ) ) {
+
+					id = elem[ internalKey ];
+					data = id && cache[ id ];
+
+					if ( data ) {
+						if ( data.events ) {
+							for ( type in data.events ) {
+								if ( special[ type ] ) {
+									jQuery.event.remove( elem, type );
+
+								// This is a shortcut to avoid jQuery.event.remove's overhead
+								} else {
+									jQuery.removeEvent( elem, type, data.handle );
+								}
+							}
+						}
+
+						// Remove cache only if it was not already removed by jQuery.event.remove
+						if ( cache[ id ] ) {
+
+							delete cache[ id ];
+
+							// IE does not allow us to delete expando properties from nodes,
+							// nor does it have a removeAttribute function on Document nodes;
+							// we must handle all of these cases
+							if ( deleteExpando ) {
+								delete elem[ internalKey ];
+
+							} else if ( typeof elem.removeAttribute !== core_strundefined ) {
+								elem.removeAttribute( internalKey );
+
+							} else {
+								elem[ internalKey ] = null;
+							}
+
+							core_deletedIds.push( id );
+						}
+					}
+				}
+			}
+		}
+	});
+	var iframe, getStyles, curCSS,
+		ralpha = /alpha\([^)]*\)/i,
+		ropacity = /opacity\s*=\s*([^)]*)/,
+		rposition = /^(top|right|bottom|left)$/,
+		// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
+		// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
+		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
+		rmargin = /^margin/,
+		rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
+		rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
+		rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
+		elemdisplay = { BODY: "block" },
+
+		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
+		cssNormalTransform = {
+			letterSpacing: 0,
+			fontWeight: 400
+		},
+
+		cssExpand = [ "Top", "Right", "Bottom", "Left" ],
+		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
+
+	// return a css property mapped to a potentially vendor prefixed property
+	function vendorPropName( style, name ) {
+
+		// shortcut for names that are not vendor prefixed
+		if ( name in style ) {
+			return name;
+		}
+
+		// check for vendor prefixed names
+		var capName = name.charAt(0).toUpperCase() + name.slice(1),
+			origName = name,
+			i = cssPrefixes.length;
+
+		while ( i-- ) {
+			name = cssPrefixes[ i ] + capName;
+			if ( name in style ) {
+				return name;
+			}
+		}
+
+		return origName;
+	}
+
+	function isHidden( elem, el ) {
+		// isHidden might be called from jQuery#filter function;
+		// in that case, element will be second argument
+		elem = el || elem;
+		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
+	}
+
+	function showHide( elements, show ) {
+		var display, elem, hidden,
+			values = [],
+			index = 0,
+			length = elements.length;
+
+		for ( ; index < length; index++ ) {
+			elem = elements[ index ];
+			if ( !elem.style ) {
+				continue;
+			}
+
+			values[ index ] = jQuery._data( elem, "olddisplay" );
+			display = elem.style.display;
+			if ( show ) {
+				// Reset the inline display of this element to learn if it is
+				// being hidden by cascaded rules or not
+				if ( !values[ index ] && display === "none" ) {
+					elem.style.display = "";
+				}
+
+				// Set elements which have been overridden with display: none
+				// in a stylesheet to whatever the default browser style is
+				// for such an element
+				if ( elem.style.display === "" && isHidden( elem ) ) {
+					values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
+				}
+			} else {
+
+				if ( !values[ index ] ) {
+					hidden = isHidden( elem );
+
+					if ( display && display !== "none" || !hidden ) {
+						jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
+					}
+				}
+			}
+		}
+
+		// Set the display of most of the elements in a second loop
+		// to avoid the constant reflow
+		for ( index = 0; index < length; index++ ) {
+			elem = elements[ index ];
+			if ( !elem.style ) {
+				continue;
+			}
+			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
+				elem.style.display = show ? values[ index ] || "" : "none";
+			}
+		}
+
+		return elements;
+	}
+
+	jQuery.fn.extend({
+		css: function( name, value ) {
+			return jQuery.access( this, function( elem, name, value ) {
+				var len, styles,
+					map = {},
+					i = 0;
+
+				if ( jQuery.isArray( name ) ) {
+					styles = getStyles( elem );
+					len = name.length;
+
+					for ( ; i < len; i++ ) {
+						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
+					}
+
+					return map;
+				}
+
+				return value !== undefined ?
+					jQuery.style( elem, name, value ) :
+					jQuery.css( elem, name );
+			}, name, value, arguments.length > 1 );
+		},
+		show: function() {
+			return showHide( this, true );
+		},
+		hide: function() {
+			return showHide( this );
+		},
+		toggle: function( state ) {
+			var bool = typeof state === "boolean";
+
+			return this.each(function() {
+				if ( bool ? state : isHidden( this ) ) {
+					jQuery( this ).show();
+				} else {
+					jQuery( this ).hide();
+				}
+			});
+		}
+	});
+
+	jQuery.extend({
+		// Add in style property hooks for overriding the default
+		// behavior of getting and setting a style property
+		cssHooks: {
+			opacity: {
+				get: function( elem, computed ) {
+					if ( computed ) {
+						// We should always get a number back from opacity
+						var ret = curCSS( elem, "opacity" );
+						return ret === "" ? "1" : ret;
+					}
+				}
+			}
+		},
+
+		// Exclude the following css properties to add px
+		cssNumber: {
+			"columnCount": true,
+			"fillOpacity": true,
+			"fontWeight": true,
+			"lineHeight": true,
+			"opacity": true,
+			"orphans": true,
+			"widows": true,
+			"zIndex": true,
+			"zoom": true
+		},
+
+		// Add in properties whose names you wish to fix before
+		// setting or getting the value
+		cssProps: {
+			// normalize float css property
+			"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
+		},
+
+		// Get and set the style property on a DOM Node
+		style: function( elem, name, value, extra ) {
+			// Don't set styles on text and comment nodes
+			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
+				return;
+			}
+
+			// Make sure that we're working with the right name
+			var ret, type, hooks,
+				origName = jQuery.camelCase( name ),
+				style = elem.style;
+
+			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
+
+			// gets hook for the prefixed version
+			// followed by the unprefixed version
+			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
+
+			// Check if we're setting a value
+			if ( value !== undefined ) {
+				type = typeof value;
+
+				// convert relative number strings (+= or -=) to relative numbers. #7345
+				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
+					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
+					// Fixes bug #9237
+					type = "number";
+				}
+
+				// Make sure that NaN and null values aren't set. See: #7116
+				if ( value == null || type === "number" && isNaN( value ) ) {
+					return;
+				}
+
+				// If a number was passed in, add 'px' to the (except for certain CSS properties)
+				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
+					value += "px";
+				}
+
+				// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
+				// but it would mean to define eight (for every problematic property) identical functions
+				if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
+					style[ name ] = "inherit";
+				}
+
+				// If a hook was provided, use that value, otherwise just set the specified value
+				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
+
+					// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
+					// Fixes bug #5509
+					try {
+						style[ name ] = value;
+					} catch(e) {}
+				}
+
+			} else {
+				// If a hook was provided get the non-computed value from there
+				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
+					return ret;
+				}
+
+				// Otherwise just get the value from the style object
+				return style[ name ];
+			}
+		},
+
+		css: function( elem, name, extra, styles ) {
+			var num, val, hooks,
+				origName = jQuery.camelCase( name );
+
+			// Make sure that we're working with the right name
+			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
+
+			// gets hook for the prefixed version
+			// followed by the unprefixed version
+			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
+
+			// If a hook was provided get the computed value from there
+			if ( hooks && "get" in hooks ) {
+				val = hooks.get( elem, true, extra );
+			}
+
+			// Otherwise, if a way to get the computed value exists, use that
+			if ( val === undefined ) {
+				val = curCSS( elem, name, styles );
+			}
+
+			//convert "normal" to computed value
+			if ( val === "normal" && name in cssNormalTransform ) {
+				val = cssNormalTransform[ name ];
+			}
+
+			// Return, converting to number if forced or a qualifier was provided and val looks numeric
+			if ( extra === "" || extra ) {
+				num = parseFloat( val );
+				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
+			}
+			return val;
+		},
+
+		// A method for quickly swapping in/out CSS properties to get correct calculations
+		swap: function( elem, options, callback, args ) {
+			var ret, name,
+				old = {};
+
+			// Remember the old values, and insert the new ones
+			for ( name in options ) {
+				old[ name ] = elem.style[ name ];
+				elem.style[ name ] = options[ name ];
+			}
+
+			ret = callback.apply( elem, args || [] );
+
+			// Revert the old values
+			for ( name in options ) {
+				elem.style[ name ] = old[ name ];
+			}
+
+			return ret;
+		}
+	});
+
+	// NOTE: we've included the "window" in window.getComputedStyle
+	// because jsdom on node.js will break without it.
+	if ( window.getComputedStyle ) {
+		getStyles = function( elem ) {
+			return window.getComputedStyle( elem, null );
+		};
+
+		curCSS = function( elem, name, _computed ) {
+			var width, minWidth, maxWidth,
+				computed = _computed || getStyles( elem ),
+
+				// getPropertyValue is only needed for .css('filter') in IE9, see #12537
+				ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
+				style = elem.style;
+
+			if ( computed ) {
+
+				if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
+					ret = jQuery.style( elem, name );
+				}
+
+				// A tribute to the "awesome hack by Dean Edwards"
+				// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
+				// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
+				// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
+				if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
+
+					// Remember the original values
+					width = style.width;
+					minWidth = style.minWidth;
+					maxWidth = style.maxWidth;
+
+					// Put in the new values to get a computed value out
+					style.minWidth = style.maxWidth = style.width = ret;
+					ret = computed.width;
+
+					// Revert the changed values
+					style.width = width;
+					style.minWidth = minWidth;
+					style.maxWidth = maxWidth;
+				}
+			}
+
+			return ret;
+		};
+	} else if ( document.documentElement.currentStyle ) {
+		getStyles = function( elem ) {
+			return elem.currentStyle;
+		};
+
+		curCSS = function( elem, name, _computed ) {
+			var left, rs, rsLeft,
+				computed = _computed || getStyles( elem ),
+				ret = computed ? computed[ name ] : undefined,
+				style = elem.style;
+
+			// Avoid setting ret to empty string here
+			// so we don't default to auto
+			if ( ret == null && style && style[ name ] ) {
+				ret = style[ name ];
+			}
+
+			// From the awesome hack by Dean Edwards
+			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
+
+			// If we're not dealing with a regular pixel number
+			// but a number that has a weird ending, we need to convert it to pixels
+			// but not position css attributes, as those are proportional to the parent element instead
+			// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
+			if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {
+
+				// Remember the original values
+				left = style.left;
+				rs = elem.runtimeStyle;
+				rsLeft = rs && rs.left;
+
+				// Put in the new values to get a computed value out
+				if ( rsLeft ) {
+					rs.left = elem.currentStyle.left;
+				}
+				style.left = name === "fontSize" ? "1em" : ret;
+				ret = style.pixelLeft + "px";
+
+				// Revert the changed values
+				style.left = left;
+				if ( rsLeft ) {
+					rs.left = rsLeft;
+				}
+			}
+
+			return ret === "" ? "auto" : ret;
+		};
+	}
+
+	function setPositiveNumber( elem, value, subtract ) {
+		var matches = rnumsplit.exec( value );
+		return matches ?
+			// Guard against undefined "subtract", e.g., when used as in cssHooks
+			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
+			value;
+	}
+
+	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
+		var i = extra === ( isBorderBox ? "border" : "content" ) ?
+			// If we already have the right measurement, avoid augmentation
+			4 :
+			// Otherwise initialize for horizontal or vertical properties
+			name === "width" ? 1 : 0,
+
+			val = 0;
+
+		for ( ; i < 4; i += 2 ) {
+			// both box models exclude margin, so add it if we want it
+			if ( extra === "margin" ) {
+				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
+			}
+
+			if ( isBorderBox ) {
+				// border-box includes padding, so remove it if we want content
+				if ( extra === "content" ) {
+					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
+				}
+
+				// at this point, extra isn't border nor margin, so remove border
+				if ( extra !== "margin" ) {
+					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
+				}
+			} else {
+				// at this point, extra isn't content, so add padding
+				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
+
+				// at this point, extra isn't content nor padding, so add border
+				if ( extra !== "padding" ) {
+					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
+				}
+			}
+		}
+
+		return val;
+	}
+
+	function getWidthOrHeight( elem, name, extra ) {
+
+		// Start with offset property, which is equivalent to the border-box value
+		var valueIsBorderBox = true,
+			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
+			styles = getStyles( elem ),
+			isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
+
+		// some non-html elements return undefined for offsetWidth, so check for null/undefined
+		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
+		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
+		if ( val <= 0 || val == null ) {
+			// Fall back to computed then uncomputed css if necessary
+			val = curCSS( elem, name, styles );
+			if ( val < 0 || val == null ) {
+				val = elem.style[ name ];
+			}
+
+			// Computed unit is not pixels. Stop here and return.
+			if ( rnumnonpx.test(val) ) {
+				return val;
+			}
+
+			// we need the check for style in case a browser which returns unreliable values
+			// for getComputedStyle silently falls back to the reliable elem.style
+			valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );
+
+			// Normalize "", auto, and prepare for extra
+			val = parseFloat( val ) || 0;
+		}
+
+		// use the active box-sizing model to add/subtract irrelevant styles
+		return ( val +
+			augmentWidthOrHeight(
+				elem,
+				name,
+				extra || ( isBorderBox ? "border" : "content" ),
+				valueIsBorderBox,
+				styles
+			)
+		) + "px";
+	}
+
+	// Try to determine the default display value of an element
+	function css_defaultDisplay( nodeName ) {
+		var doc = document,
+			display = elemdisplay[ nodeName ];
+
+		if ( !display ) {
+			display = actualDisplay( nodeName, doc );
+
+			// If the simple way fails, read from inside an iframe
+			if ( display === "none" || !display ) {
+				// Use the already-created iframe if possible
+				iframe = ( iframe ||
+					jQuery("<iframe frameborder='0' width='0' height='0'/>")
+					.css( "cssText", "display:block !important" )
+				).appendTo( doc.documentElement );
+
+				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
+				doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
+				doc.write("<!doctype html><html><body>");
+				doc.close();
+
+				display = actualDisplay( nodeName, doc );
+				iframe.detach();
+			}
+
+			// Store the correct default display
+			elemdisplay[ nodeName ] = display;
+		}
+
+		return display;
+	}
+
+	// Called ONLY from within css_defaultDisplay
+	function actualDisplay( name, doc ) {
+		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
+			display = jQuery.css( elem[0], "display" );
+		elem.remove();
+		return display;
+	}
+
+	jQuery.each([ "height", "width" ], function( i, name ) {
+		jQuery.cssHooks[ name ] = {
+			get: function( elem, computed, extra ) {
+				if ( computed ) {
+					// certain elements can have dimension info if we invisibly show them
+					// however, it must have a current display style that would benefit from this
+					return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
+						jQuery.swap( elem, cssShow, function() {
+							return getWidthOrHeight( elem, name, extra );
+						}) :
+						getWidthOrHeight( elem, name, extra );
+				}
+			},
+
+			set: function( elem, value, extra ) {
+				var styles = extra && getStyles( elem );
+				return setPositiveNumber( elem, value, extra ?
+					augmentWidthOrHeight(
+						elem,
+						name,
+						extra,
+						jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
+						styles
+					) : 0
+				);
+			}
+		};
+	});
+
+	if ( !jQuery.support.opacity ) {
+		jQuery.cssHooks.opacity = {
+			get: function( elem, computed ) {
+				// IE uses filters for opacity
+				return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
+					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
+					computed ? "1" : "";
+			},
+
+			set: function( elem, value ) {
+				var style = elem.style,
+					currentStyle = elem.currentStyle,
+					opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
+					filter = currentStyle && currentStyle.filter || style.filter || "";
+
+				// IE has trouble with opacity if it does not have layout
+				// Force it by setting the zoom level
+				style.zoom = 1;
+
+				// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
+				// if value === "", then remove inline opacity #12685
+				if ( ( value >= 1 || value === "" ) &&
+						jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
+						style.removeAttribute ) {
+
+					// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
+					// if "filter:" is present at all, clearType is disabled, we want to avoid this
+					// style.removeAttribute is IE Only, but so apparently is this code path...
+					style.removeAttribute( "filter" );
+
+					// if there is no filter style applied in a css rule or unset inline opacity, we are done
+					if ( value === "" || currentStyle && !currentStyle.filter ) {
+						return;
+					}
+				}
+
+				// otherwise, set new filter values
+				style.filter = ralpha.test( filter ) ?
+					filter.replace( ralpha, opacity ) :
+					filter + " " + opacity;
+			}
+		};
+	}
+
+	// These hooks cannot be added until DOM ready because the support test
+	// for it is not run until after DOM ready
+	jQuery(function() {
+		if ( !jQuery.support.reliableMarginRight ) {
+			jQuery.cssHooks.marginRight = {
+				get: function( elem, computed ) {
+					if ( computed ) {
+						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
+						// Work around by temporarily setting element display to inline-block
+						return jQuery.swap( elem, { "display": "inline-block" },
+							curCSS, [ elem, "marginRight" ] );
+					}
+				}
+			};
+		}
+
+		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
+		// getComputedStyle returns percent when specified for top/left/bottom/right
+		// rather than make the css module depend on the offset module, we just check for it here
+		if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
+			jQuery.each( [ "top", "left" ], function( i, prop ) {
+				jQuery.cssHooks[ prop ] = {
+					get: function( elem, computed ) {
+						if ( computed ) {
+							computed = curCSS( elem, prop );
+							// if curCSS returns percentage, fallback to offset
+							return rnumnonpx.test( computed ) ?
+								jQuery( elem ).position()[ prop ] + "px" :
+								computed;
+						}
+					}
+				};
+			});
+		}
+
+	});
+
+	if ( jQuery.expr && jQuery.expr.filters ) {
+		jQuery.expr.filters.hidden = function( elem ) {
+			// Support: Opera <= 12.12
+			// Opera reports offsetWidths and offsetHeights less than zero on some elements
+			return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
+				(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
+		};
+
+		jQuery.expr.filters.visible = function( elem ) {
+			return !jQuery.expr.filters.hidden( elem );
+		};
+	}
+
+	// These hooks are used by animate to expand properties
+	jQuery.each({
+		margin: "",
+		padding: "",
+		border: "Width"
+	}, function( prefix, suffix ) {
+		jQuery.cssHooks[ prefix + suffix ] = {
+			expand: function( value ) {
+				var i = 0,
+					expanded = {},
+
+					// assumes a single number if not a string
+					parts = typeof value === "string" ? value.split(" ") : [ value ];
+
+				for ( ; i < 4; i++ ) {
+					expanded[ prefix + cssExpand[ i ] + suffix ] =
+						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
+				}
+
+				return expanded;
+			}
+		};
+
+		if ( !rmargin.test( prefix ) ) {
+			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
+		}
+	});
+	var r20 = /%20/g,
+		rbracket = /\[\]$/,
+		rCRLF = /\r?\n/g,
+		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
+		rsubmittable = /^(?:input|select|textarea|keygen)/i;
+
+	jQuery.fn.extend({
+		serialize: function() {
+			return jQuery.param( this.serializeArray() );
+		},
+		serializeArray: function() {
+			return this.map(function(){
+				// Can add propHook for "elements" to filter or add form elements
+				var elements = jQuery.prop( this, "elements" );
+				return elements ? jQuery.makeArray( elements ) : this;
+			})
+			.filter(function(){
+				var type = this.type;
+				// Use .is(":disabled") so that fieldset[disabled] works
+				return this.name && !jQuery( this ).is( ":disabled" ) &&
+					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
+					( this.checked || !manipulation_rcheckableType.test( type ) );
+			})
+			.map(function( i, elem ){
+				var val = jQuery( this ).val();
+
+				return val == null ?
+					null :
+					jQuery.isArray( val ) ?
+						jQuery.map( val, function( val ){
+							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
+						}) :
+						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
+			}).get();
+		}
+	});
+
+	//Serialize an array of form elements or a set of
+	//key/values into a query string
+	jQuery.param = function( a, traditional ) {
+		var prefix,
+			s = [],
+			add = function( key, value ) {
+				// If value is a function, invoke it and return its value
+				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
+				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
+			};
+
+		// Set traditional to true for jQuery <= 1.3.2 behavior.
+		if ( traditional === undefined ) {
+			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
+		}
+
+		// If an array was passed in, assume that it is an array of form elements.
+		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
+			// Serialize the form elements
+			jQuery.each( a, function() {
+				add( this.name, this.value );
+			});
+
+		} else {
+			// If traditional, encode the "old" way (the way 1.3.2 or older
+			// did it), otherwise encode params recursively.
+			for ( prefix in a ) {
+				buildParams( prefix, a[ prefix ], traditional, add );
+			}
+		}
+
+		// Return the resulting serialization
+		return s.join( "&" ).replace( r20, "+" );
+	};
+
+	function buildParams( prefix, obj, traditional, add ) {
+		var name;
+
+		if ( jQuery.isArray( obj ) ) {
+			// Serialize array item.
+			jQuery.each( obj, function( i, v ) {
+				if ( traditional || rbracket.test( prefix ) ) {
+					// Treat each array item as a scalar.
+					add( prefix, v );
+
+				} else {
+					// Item is non-scalar (array or object), encode its numeric index.
+					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
+				}
+			});
+
+		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
+			// Serialize object item.
+			for ( name in obj ) {
+				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
+			}
+
+		} else {
+			// Serialize scalar item.
+			add( prefix, obj );
+		}
+	}
+	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
+		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
+		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
+
+		// Handle event binding
+		jQuery.fn[ name ] = function( data, fn ) {
+			return arguments.length > 0 ?
+				this.on( name, null, data, fn ) :
+				this.trigger( name );
+		};
+	});
+
+	jQuery.fn.hover = function( fnOver, fnOut ) {
+		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
+	};
+	var
+		// Document location
+		ajaxLocParts,
+		ajaxLocation,
+		ajax_nonce = jQuery.now(),
+
+		ajax_rquery = /\?/,
+		rhash = /#.*$/,
+		rts = /([?&])_=[^&]*/,
+		rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
+		// #7653, #8125, #8152: local protocol detection
+		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
+		rnoContent = /^(?:GET|HEAD)$/,
+		rprotocol = /^\/\//,
+		rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
+
+		// Keep a copy of the old load method
+		_load = jQuery.fn.load,
+
+		/* Prefilters
+		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
+		 * 2) These are called:
+		 *    - BEFORE asking for a transport
+		 *    - AFTER param serialization (s.data is a string if s.processData is true)
+		 * 3) key is the dataType
+		 * 4) the catchall symbol "*" can be used
+		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
+		 */
+		prefilters = {},
+
+		/* Transports bindings
+		 * 1) key is the dataType
+		 * 2) the catchall symbol "*" can be used
+		 * 3) selection will start with transport dataType and THEN go to "*" if needed
+		 */
+		transports = {},
+
+		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
+		allTypes = "*/".concat("*");
+
+	// #8138, IE may throw an exception when accessing
+	// a field from window.location if document.domain has been set
+	try {
+		ajaxLocation = location.href;
+	} catch( e ) {
+		// Use the href attribute of an A element
+		// since IE will modify it given document.location
+		ajaxLocation = document.createElement( "a" );
+		ajaxLocation.href = "";
+		ajaxLocation = ajaxLocation.href;
+	}
+
+	// Segment location into parts
+	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
+
+	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
+	function addToPrefiltersOrTransports( structure ) {
+
+		// dataTypeExpression is optional and defaults to "*"
+		return function( dataTypeExpression, func ) {
+
+			if ( typeof dataTypeExpression !== "string" ) {
+				func = dataTypeExpression;
+				dataTypeExpression = "*";
+			}
+
+			var dataType,
+				i = 0,
+				dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];
+
+			if ( jQuery.isFunction( func ) ) {
+				// For each dataType in the dataTypeExpression
+				while ( (dataType = dataTypes[i++]) ) {
+					// Prepend if requested
+					if ( dataType[0] === "+" ) {
+						dataType = dataType.slice( 1 ) || "*";
+						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );
+
+					// Otherwise append
+					} else {
+						(structure[ dataType ] = structure[ dataType ] || []).push( func );
+					}
+				}
+			}
+		};
+	}
+
+	// Base inspection function for prefilters and transports
+	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
+
+		var inspected = {},
+			seekingTransport = ( structure === transports );
+
+		function inspect( dataType ) {
+			var selected;
+			inspected[ dataType ] = true;
+			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
+				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
+				if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
+					options.dataTypes.unshift( dataTypeOrTransport );
+					inspect( dataTypeOrTransport );
+					return false;
+				} else if ( seekingTransport ) {
+					return !( selected = dataTypeOrTransport );
+				}
+			});
+			return selected;
+		}
+
+		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
+	}
+
+	// A special extend for ajax options
+	// that takes "flat" options (not to be deep extended)
+	// Fixes #9887
+	function ajaxExtend( target, src ) {
+		var deep, key,
+			flatOptions = jQuery.ajaxSettings.flatOptions || {};
+
+		for ( key in src ) {
+			if ( src[ key ] !== undefined ) {
+				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
+			}
+		}
+		if ( deep ) {
+			jQuery.extend( true, target, deep );
+		}
+
+		return target;
+	}
+
+	jQuery.fn.load = function( url, params, callback ) {
+		if ( typeof url !== "string" && _load ) {
+			return _load.apply( this, arguments );
+		}
+
+		var selector, response, type,
+			self = this,
+			off = url.indexOf(" ");
+
+		if ( off >= 0 ) {
+			selector = url.slice( off, url.length );
+			url = url.slice( 0, off );
+		}
+
+		// If it's a function
+		if ( jQuery.isFunction( params ) ) {
+
+			// We assume that it's the callback
+			callback = params;
+			params = undefined;
+
+		// Otherwise, build a param string
+		} else if ( params && typeof params === "object" ) {
+			type = "POST";
+		}
+
+		// If we have elements to modify, make the request
+		if ( self.length > 0 ) {
+			jQuery.ajax({
+				url: url,
+
+				// if "type" variable is undefined, then "GET" method will be used
+				type: type,
+				dataType: "html",
+				data: params
+			}).done(function( responseText ) {
+
+				// Save response for use in complete callback
+				response = arguments;
+
+				self.html( selector ?
+
+					// If a selector was specified, locate the right elements in a dummy div
+					// Exclude scripts to avoid IE 'Permission Denied' errors
+					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
+
+					// Otherwise use the full result
+					responseText );
+
+			}).complete( callback && function( jqXHR, status ) {
+				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
+			});
+		}
+
+		return this;
+	};
+
+	// Attach a bunch of functions for handling common AJAX events
+	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
+		jQuery.fn[ type ] = function( fn ){
+			return this.on( type, fn );
+		};
+	});
+
+	jQuery.each( [ "get", "post" ], function( i, method ) {
+		jQuery[ method ] = function( url, data, callback, type ) {
+			// shift arguments if data argument was omitted
+			if ( jQuery.isFunction( data ) ) {
+				type = type || callback;
+				callback = data;
+				data = undefined;
+			}
+
+			return jQuery.ajax({
+				url: url,
+				type: method,
+				dataType: type,
+				data: data,
+				success: callback
+			});
+		};
+	});
+
+	jQuery.extend({
+
+		// Counter for holding the number of active queries
+		active: 0,
+
+		// Last-Modified header cache for next request
+		lastModified: {},
+		etag: {},
+
+		ajaxSettings: {
+			url: ajaxLocation,
+			type: "GET",
+			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
+			global: true,
+			processData: true,
+			async: true,
+			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
+			/*
+			timeout: 0,
+			data: null,
+			dataType: null,
+			username: null,
+			password: null,
+			cache: null,
+			throws: false,
+			traditional: false,
+			headers: {},
+			*/
+
+			accepts: {
+				"*": allTypes,
+				text: "text/plain",
+				html: "text/html",
+				xml: "application/xml, text/xml",
+				json: "application/json, text/javascript"
+			},
+
+			contents: {
+				xml: /xml/,
+				html: /html/,
+				json: /json/
+			},
+
+			responseFields: {
+				xml: "responseXML",
+				text: "responseText"
+			},
+
+			// Data converters
+			// Keys separate source (or catchall "*") and destination types with a single space
+			converters: {
+
+				// Convert anything to text
+				"* text": window.String,
+
+				// Text to html (true = no transformation)
+				"text html": true,
+
+				// Evaluate text as a json expression
+				"text json": jQuery.parseJSON,
+
+				// Parse text as xml
+				"text xml": jQuery.parseXML
+			},
+
+			// For options that shouldn't be deep extended:
+			// you can add your own custom options here if
+			// and when you create one that shouldn't be
+			// deep extended (see ajaxExtend)
+			flatOptions: {
+				url: true,
+				context: true
+			}
+		},
+
+		// Creates a full fledged settings object into target
+		// with both ajaxSettings and settings fields.
+		// If target is omitted, writes into ajaxSettings.
+		ajaxSetup: function( target, settings ) {
+			return settings ?
+
+				// Building a settings object
+				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
+
+				// Extending ajaxSettings
+				ajaxExtend( jQuery.ajaxSettings, target );
+		},
+
+		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
+		ajaxTransport: addToPrefiltersOrTransports( transports ),
+
+		// Main method
+		ajax: function( url, options ) {
+
+			// If url is an object, simulate pre-1.5 signature
+			if ( typeof url === "object" ) {
+				options = url;
+				url = undefined;
+			}
+
+			// Force options to be an object
+			options = options || {};
+
+			var // Cross-domain detection vars
+				parts,
+				// Loop variable
+				i,
+				// URL without anti-cache param
+				cacheURL,
+				// Response headers as string
+				responseHeadersString,
+				// timeout handle
+				timeoutTimer,
+
+				// To know if global events are to be dispatched
+				fireGlobals,
+
+				transport,
+				// Response headers
+				responseHeaders,
+				// Create the final options object
+				s = jQuery.ajaxSetup( {}, options ),
+				// Callbacks context
+				callbackContext = s.context || s,
+				// Context for global events is callbackContext if it is a DOM node or jQuery collection
+				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
+					jQuery( callbackContext ) :
+					jQuery.event,
+				// Deferreds
+				deferred = jQuery.Deferred(),
+				completeDeferred = jQuery.Callbacks("once memory"),
+				// Status-dependent callbacks
+				statusCode = s.statusCode || {},
+				// Headers (they are sent all at once)
+				requestHeaders = {},
+				requestHeadersNames = {},
+				// The jqXHR state
+				state = 0,
+				// Default abort message
+				strAbort = "canceled",
+				// Fake xhr
+				jqXHR = {
+					readyState: 0,
+
+					// Builds headers hashtable if needed
+					getResponseHeader: function( key ) {
+						var match;
+						if ( state === 2 ) {
+							if ( !responseHeaders ) {
+								responseHeaders = {};
+								while ( (match = rheaders.exec( responseHeadersString )) ) {
+									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
+								}
+							}
+							match = responseHeaders[ key.toLowerCase() ];
+						}
+						return match == null ? null : match;
+					},
+
+					// Raw string
+					getAllResponseHeaders: function() {
+						return state === 2 ? responseHeadersString : null;
+					},
+
+					// Caches the header
+					setRequestHeader: function( name, value ) {
+						var lname = name.toLowerCase();
+						if ( !state ) {
+							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
+							requestHeaders[ name ] = value;
+						}
+						return this;
+					},
+
+					// Overrides response content-type header
+					overrideMimeType: function( type ) {
+						if ( !state ) {
+							s.mimeType = type;
+						}
+						return this;
+					},
+
+					// Status-dependent callbacks
+					statusCode: function( map ) {
+						var code;
+						if ( map ) {
+							if ( state < 2 ) {
+								for ( code in map ) {
+									// Lazy-add the new callback in a way that preserves old ones
+									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
+								}
+							} else {
+								// Execute the appropriate callbacks
+								jqXHR.always( map[ jqXHR.status ] );
+							}
+						}
+						return this;
+					},
+
+					// Cancel the request
+					abort: function( statusText ) {
+						var finalText = statusText || strAbort;
+						if ( transport ) {
+							transport.abort( finalText );
+						}
+						done( 0, finalText );
+						return this;
+					}
+				};
+
+			// Attach deferreds
+			deferred.promise( jqXHR ).complete = completeDeferred.add;
+			jqXHR.success = jqXHR.done;
+			jqXHR.error = jqXHR.fail;
+
+			// Remove hash character (#7531: and string promotion)
+			// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
+			// Handle falsy url in the settings object (#10093: consistency with old signature)
+			// We also use the url parameter if available
+			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
+
+			// Alias method option to type as per ticket #12004
+			s.type = options.method || options.type || s.method || s.type;
+
+			// Extract dataTypes list
+			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];
+
+			// A cross-domain request is in order when we have a protocol:host:port mismatch
+			if ( s.crossDomain == null ) {
+				parts = rurl.exec( s.url.toLowerCase() );
+				s.crossDomain = !!( parts &&
+					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
+						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
+							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
+				);
+			}
+
+			// Convert data if not already a string
+			if ( s.data && s.processData && typeof s.data !== "string" ) {
+				s.data = jQuery.param( s.data, s.traditional );
+			}
+
+			// Apply prefilters
+			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
+
+			// If request was aborted inside a prefilter, stop there
+			if ( state === 2 ) {
+				return jqXHR;
+			}
+
+			// We can fire global events as of now if asked to
+			fireGlobals = s.global;
+
+			// Watch for a new set of requests
+			if ( fireGlobals && jQuery.active++ === 0 ) {
+				jQuery.event.trigger("ajaxStart");
+			}
+
+			// Uppercase the type
+			s.type = s.type.toUpperCase();
+
+			// Determine if request has content
+			s.hasContent = !rnoContent.test( s.type );
+
+			// Save the URL in case we're toying with the If-Modified-Since
+			// and/or If-None-Match header later on
+			cacheURL = s.url;
+
+			// More options handling for requests with no content
+			if ( !s.hasContent ) {
+
+				// If data is available, append data to url
+				if ( s.data ) {
+					cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
+					// #9682: remove data so that it's not used in an eventual retry
+					delete s.data;
+				}
+
+				// Add anti-cache in url if needed
+				if ( s.cache === false ) {
+					s.url = rts.test( cacheURL ) ?
+
+						// If there is already a '_' parameter, set its value
+						cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :
+
+						// Otherwise add one to the end
+						cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
+				}
+			}
+
+			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
+			if ( s.ifModified ) {
+				if ( jQuery.lastModified[ cacheURL ] ) {
+					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
+				}
+				if ( jQuery.etag[ cacheURL ] ) {
+					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
+				}
+			}
+
+			// Set the correct header, if data is being sent
+			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
+				jqXHR.setRequestHeader( "Content-Type", s.contentType );
+			}
+
+			// Set the Accepts header for the server, depending on the dataType
+			jqXHR.setRequestHeader(
+				"Accept",
+				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
+					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
+					s.accepts[ "*" ]
+			);
+
+			// Check for headers option
+			for ( i in s.headers ) {
+				jqXHR.setRequestHeader( i, s.headers[ i ] );
+			}
+
+			// Allow custom headers/mimetypes and early abort
+			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
+				// Abort if not done already and return
+				return jqXHR.abort();
+			}
+
+			// aborting is no longer a cancellation
+			strAbort = "abort";
+
+			// Install callbacks on deferreds
+			for ( i in { success: 1, error: 1, complete: 1 } ) {
+				jqXHR[ i ]( s[ i ] );
+			}
+
+			// Get transport
+			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
+
+			// If no transport, we auto-abort
+			if ( !transport ) {
+				done( -1, "No Transport" );
+			} else {
+				jqXHR.readyState = 1;
+
+				// Send global event
+				if ( fireGlobals ) {
+					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
+				}
+				// Timeout
+				if ( s.async && s.timeout > 0 ) {
+					timeoutTimer = setTimeout(function() {
+						jqXHR.abort("timeout");
+					}, s.timeout );
+				}
+
+				try {
+					state = 1;
+					transport.send( requestHeaders, done );
+				} catch ( e ) {
+					// Propagate exception as error if not done
+					if ( state < 2 ) {
+						done( -1, e );
+					// Simply rethrow otherwise
+					} else {
+						throw e;
+					}
+				}
+			}
+
+			// Callback for when everything is done
+			function done( status, nativeStatusText, responses, headers ) {
+				var isSuccess, success, error, response, modified,
+					statusText = nativeStatusText;
+
+				// Called once
+				if ( state === 2 ) {
+					return;
+				}
+
+				// State is "done" now
+				state = 2;
+
+				// Clear timeout if it exists
+				if ( timeoutTimer ) {
+					clearTimeout( timeoutTimer );
+				}
+
+				// Dereference transport for early garbage collection
+				// (no matter how long the jqXHR object will be used)
+				transport = undefined;
+
+				// Cache response headers
+				responseHeadersString = headers || "";
+
+				// Set readyState
+				jqXHR.readyState = status > 0 ? 4 : 0;
+
+				// Get response data
+				if ( responses ) {
+					response = ajaxHandleResponses( s, jqXHR, responses );
+				}
+
+				// If successful, handle type chaining
+				if ( status >= 200 && status < 300 || status === 304 ) {
+
+					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
+					if ( s.ifModified ) {
+						modified = jqXHR.getResponseHeader("Last-Modified");
+						if ( modified ) {
+							jQuery.lastModified[ cacheURL ] = modified;
+						}
+						modified = jqXHR.getResponseHeader("etag");
+						if ( modified ) {
+							jQuery.etag[ cacheURL ] = modified;
+						}
+					}
+
+					// if no content
+					if ( status === 204 ) {
+						isSuccess = true;
+						statusText = "nocontent";
+
+					// if not modified
+					} else if ( status === 304 ) {
+						isSuccess = true;
+						statusText = "notmodified";
+
+					// If we have data, let's convert it
+					} else {
+						isSuccess = ajaxConvert( s, response );
+						statusText = isSuccess.state;
+						success = isSuccess.data;
+						error = isSuccess.error;
+						isSuccess = !error;
+					}
+				} else {
+					// We extract error from statusText
+					// then normalize statusText and status for non-aborts
+					error = statusText;
+					if ( status || !statusText ) {
+						statusText = "error";
+						if ( status < 0 ) {
+							status = 0;
+						}
+					}
+				}
+
+				// Set data for the fake xhr object
+				jqXHR.status = status;
+				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
+
+				// Success/Error
+				if ( isSuccess ) {
+					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
+				} else {
+					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
+				}
+
+				// Status-dependent callbacks
+				jqXHR.statusCode( statusCode );
+				statusCode = undefined;
+
+				if ( fireGlobals ) {
+					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
+						[ jqXHR, s, isSuccess ? success : error ] );
+				}
+
+				// Complete
+				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
+
+				if ( fireGlobals ) {
+					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
+					// Handle the global AJAX counter
+					if ( !( --jQuery.active ) ) {
+						jQuery.event.trigger("ajaxStop");
+					}
+				}
+			}
+
+			return jqXHR;
+		},
+
+		getScript: function( url, callback ) {
+			return jQuery.get( url, undefined, callback, "script" );
+		},
+
+		getJSON: function( url, data, callback ) {
+			return jQuery.get( url, data, callback, "json" );
+		}
+	});
+
+	/* Handles responses to an ajax request:
+	 * - sets all responseXXX fields accordingly
+	 * - finds the right dataType (mediates between content-type and expected dataType)
+	 * - returns the corresponding response
+	 */
+	function ajaxHandleResponses( s, jqXHR, responses ) {
+		var firstDataType, ct, finalDataType, type,
+			contents = s.contents,
+			dataTypes = s.dataTypes,
+			responseFields = s.responseFields;
+
+		// Fill responseXXX fields
+		for ( type in responseFields ) {
+			if ( type in responses ) {
+				jqXHR[ responseFields[type] ] = responses[ type ];
+			}
+		}
+
+		// Remove auto dataType and get content-type in the process
+		while( dataTypes[ 0 ] === "*" ) {
+			dataTypes.shift();
+			if ( ct === undefined ) {
+				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
+			}
+		}
+
+		// Check if we're dealing with a known content-type
+		if ( ct ) {
+			for ( type in contents ) {
+				if ( contents[ type ] && contents[ type ].test( ct ) ) {
+					dataTypes.unshift( type );
+					break;
+				}
+			}
+		}
+
+		// Check to see if we have a response for the expected dataType
+		if ( dataTypes[ 0 ] in responses ) {
+			finalDataType = dataTypes[ 0 ];
+		} else {
+			// Try convertible dataTypes
+			for ( type in responses ) {
+				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
+					finalDataType = type;
+					break;
+				}
+				if ( !firstDataType ) {
+					firstDataType = type;
+				}
+			}
+			// Or just use first one
+			finalDataType = finalDataType || firstDataType;
+		}
+
+		// If we found a dataType
+		// We add the dataType to the list if needed
+		// and return the corresponding response
+		if ( finalDataType ) {
+			if ( finalDataType !== dataTypes[ 0 ] ) {
+				dataTypes.unshift( finalDataType );
+			}
+			return responses[ finalDataType ];
+		}
+	}
+
+	// Chain conversions given the request and the original response
+	function ajaxConvert( s, response ) {
+		var conv2, current, conv, tmp,
+			converters = {},
+			i = 0,
+			// Work with a copy of dataTypes in case we need to modify it for conversion
+			dataTypes = s.dataTypes.slice(),
+			prev = dataTypes[ 0 ];
+
+		// Apply the dataFilter if provided
+		if ( s.dataFilter ) {
+			response = s.dataFilter( response, s.dataType );
+		}
+
+		// Create converters map with lowercased keys
+		if ( dataTypes[ 1 ] ) {
+			for ( conv in s.converters ) {
+				converters[ conv.toLowerCase() ] = s.converters[ conv ];
+			}
+		}
+
+		// Convert to each sequential dataType, tolerating list modification
+		for ( ; (current = dataTypes[++i]); ) {
+
+			// There's only work to do if current dataType is non-auto
+			if ( current !== "*" ) {
+
+				// Convert response if prev dataType is non-auto and differs from current
+				if ( prev !== "*" && prev !== current ) {
+
+					// Seek a direct converter
+					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
+
+					// If none found, seek a pair
+					if ( !conv ) {
+						for ( conv2 in converters ) {
+
+							// If conv2 outputs current
+							tmp = conv2.split(" ");
+							if ( tmp[ 1 ] === current ) {
+
+								// If prev can be converted to accepted input
+								conv = converters[ prev + " " + tmp[ 0 ] ] ||
+									converters[ "* " + tmp[ 0 ] ];
+								if ( conv ) {
+									// Condense equivalence converters
+									if ( conv === true ) {
+										conv = converters[ conv2 ];
+
+									// Otherwise, insert the intermediate dataType
+									} else if ( converters[ conv2 ] !== true ) {
+										current = tmp[ 0 ];
+										dataTypes.splice( i--, 0, current );
+									}
+
+									break;
+								}
+							}
+						}
+					}
+
+					// Apply converter (if not an equivalence)
+					if ( conv !== true ) {
+
+						// Unless errors are allowed to bubble, catch and return them
+						if ( conv && s["throws"] ) {
+							response = conv( response );
+						} else {
+							try {
+								response = conv( response );
+							} catch ( e ) {
+								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
+							}
+						}
+					}
+				}
+
+				// Update prev for next iteration
+				prev = current;
+			}
+		}
+
+		return { state: "success", data: response };
+	}
+	// Install script dataType
+	jQuery.ajaxSetup({
+		accepts: {
+			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
+		},
+		contents: {
+			script: /(?:java|ecma)script/
+		},
+		converters: {
+			"text script": function( text ) {
+				jQuery.globalEval( text );
+				return text;
+			}
+		}
+	});
+
+	// Handle cache's special case and global
+	jQuery.ajaxPrefilter( "script", function( s ) {
+		if ( s.cache === undefined ) {
+			s.cache = false;
+		}
+		if ( s.crossDomain ) {
+			s.type = "GET";
+			s.global = false;
+		}
+	});
+
+	// Bind script tag hack transport
+	jQuery.ajaxTransport( "script", function(s) {
+
+		// This transport only deals with cross domain requests
+		if ( s.crossDomain ) {
+
+			var script,
+				head = document.head || jQuery("head")[0] || document.documentElement;
+
+			return {
+
+				send: function( _, callback ) {
+
+					script = document.createElement("script");
+
+					script.async = true;
+
+					if ( s.scriptCharset ) {
+						script.charset = s.scriptCharset;
+					}
+
+					script.src = s.url;
+
+					// Attach handlers for all browsers
+					script.onload = script.onreadystatechange = function( _, isAbort ) {
+
+						if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
+
+							// Handle memory leak in IE
+							script.onload = script.onreadystatechange = null;
+
+							// Remove the script
+							if ( script.parentNode ) {
+								script.parentNode.removeChild( script );
+							}
+
+							// Dereference the script
+							script = null;
+
+							// Callback if not abort
+							if ( !isAbort ) {
+								callback( 200, "success" );
+							}
+						}
+					};
+
+					// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
+					// Use native DOM manipulation to avoid our domManip AJAX trickery
+					head.insertBefore( script, head.firstChild );
+				},
+
+				abort: function() {
+					if ( script ) {
+						script.onload( undefined, true );
+					}
+				}
+			};
+		}
+	});
+	var oldCallbacks = [],
+		rjsonp = /(=)\?(?=&|$)|\?\?/;
+
+	// Default jsonp settings
+	jQuery.ajaxSetup({
+		jsonp: "callback",
+		jsonpCallback: function() {
+			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
+			this[ callback ] = true;
+			return callback;
+		}
+	});
+
+	// Detect, normalize options and install callbacks for jsonp requests
+	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
+
+		var callbackName, overwritten, responseContainer,
+			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
+				"url" :
+				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
+			);
+
+		// Handle iff the expected data type is "jsonp" or we have a parameter to set
+		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
+
+			// Get callback name, remembering preexisting value associated with it
+			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
+				s.jsonpCallback() :
+				s.jsonpCallback;
+
+			// Insert callback into url or form data
+			if ( jsonProp ) {
+				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
+			} else if ( s.jsonp !== false ) {
+				s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
+			}
+
+			// Use data converter to retrieve json after script execution
+			s.converters["script json"] = function() {
+				if ( !responseContainer ) {
+					jQuery.error( callbackName + " was not called" );
+				}
+				return responseContainer[ 0 ];
+			};
+
+			// force json dataType
+			s.dataTypes[ 0 ] = "json";
+
+			// Install callback
+			overwritten = window[ callbackName ];
+			window[ callbackName ] = function() {
+				responseContainer = arguments;
+			};
+
+			// Clean-up function (fires after converters)
+			jqXHR.always(function() {
+				// Restore preexisting value
+				window[ callbackName ] = overwritten;
+
+				// Save back as free
+				if ( s[ callbackName ] ) {
+					// make sure that re-using the options doesn't screw things around
+					s.jsonpCallback = originalSettings.jsonpCallback;
+
+					// save the callback name for future use
+					oldCallbacks.push( callbackName );
+				}
+
+				// Call if it was a function and we have a response
+				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
+					overwritten( responseContainer[ 0 ] );
+				}
+
+				responseContainer = overwritten = undefined;
+			});
+
+			// Delegate to script
+			return "script";
+		}
+	});
+	var xhrCallbacks, xhrSupported,
+		xhrId = 0,
+		// #5280: Internet Explorer will keep connections alive if we don't abort on unload
+		xhrOnUnloadAbort = window.ActiveXObject && function() {
+			// Abort all pending requests
+			var key;
+			for ( key in xhrCallbacks ) {
+				xhrCallbacks[ key ]( undefined, true );
+			}
+		};
+
+	// Functions to create xhrs
+	function createStandardXHR() {
+		try {
+			return new window.XMLHttpRequest();
+		} catch( e ) {}
+	}
+
+	function createActiveXHR() {
+		try {
+			return new window.ActiveXObject("Microsoft.XMLHTTP");
+		} catch( e ) {}
+	}
+
+	// Create the request object
+	// (This is still attached to ajaxSettings for backward compatibility)
+	jQuery.ajaxSettings.xhr = window.ActiveXObject ?
+		/* Microsoft failed to properly
+		 * implement the XMLHttpRequest in IE7 (can't request local files),
+		 * so we use the ActiveXObject when it is available
+		 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
+		 * we need a fallback.
+		 */
+		function() {
+			return !this.isLocal && createStandardXHR() || createActiveXHR();
+		} :
+		// For all other browsers, use the standard XMLHttpRequest object
+		createStandardXHR;
+
+	// Determine support properties
+	xhrSupported = jQuery.ajaxSettings.xhr();
+	jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
+	xhrSupported = jQuery.support.ajax = !!xhrSupported;
+
+	// Create transport if the browser can provide an xhr
+	if ( xhrSupported ) {
+
+		jQuery.ajaxTransport(function( s ) {
+			// Cross domain only allowed if supported through XMLHttpRequest
+			if ( !s.crossDomain || jQuery.support.cors ) {
+
+				var callback;
+
+				return {
+					send: function( headers, complete ) {
+
+						// Get a new xhr
+						var handle, i,
+							xhr = s.xhr();
+
+						// Open the socket
+						// Passing null username, generates a login popup on Opera (#2865)
+						if ( s.username ) {
+							xhr.open( s.type, s.url, s.async, s.username, s.password );
+						} else {
+							xhr.open( s.type, s.url, s.async );
+						}
+
+						// Apply custom fields if provided
+						if ( s.xhrFields ) {
+							for ( i in s.xhrFields ) {
+								xhr[ i ] = s.xhrFields[ i ];
+							}
+						}
+
+						// Override mime type if needed
+						if ( s.mimeType && xhr.overrideMimeType ) {
+							xhr.overrideMimeType( s.mimeType );
+						}
+
+						// X-Requested-With header
+						// For cross-domain requests, seeing as conditions for a preflight are
+						// akin to a jigsaw puzzle, we simply never set it to be sure.
+						// (it can always be set on a per-request basis or even using ajaxSetup)
+						// For same-domain requests, won't change header if already provided.
+						if ( !s.crossDomain && !headers["X-Requested-With"] ) {
+							headers["X-Requested-With"] = "XMLHttpRequest";
+						}
+
+						// Need an extra try/catch for cross domain requests in Firefox 3
+						try {
+							for ( i in headers ) {
+								xhr.setRequestHeader( i, headers[ i ] );
+							}
+						} catch( err ) {}
+
+						// Do send the request
+						// This may raise an exception which is actually
+						// handled in jQuery.ajax (so no try/catch here)
+						xhr.send( ( s.hasContent && s.data ) || null );
+
+						// Listener
+						callback = function( _, isAbort ) {
+							var status, responseHeaders, statusText, responses;
+
+							// Firefox throws exceptions when accessing properties
+							// of an xhr when a network error occurred
+							// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
+							try {
+
+								// Was never called and is aborted or complete
+								if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
+
+									// Only called once
+									callback = undefined;
+
+									// Do not keep as active anymore
+									if ( handle ) {
+										xhr.onreadystatechange = jQuery.noop;
+										if ( xhrOnUnloadAbort ) {
+											delete xhrCallbacks[ handle ];
+										}
+									}
+
+									// If it's an abort
+									if ( isAbort ) {
+										// Abort it manually if needed
+										if ( xhr.readyState !== 4 ) {
+											xhr.abort();
+										}
+									} else {
+										responses = {};
+										status = xhr.status;
+										responseHeaders = xhr.getAllResponseHeaders();
+
+										// When requesting binary data, IE6-9 will throw an exception
+										// on any attempt to access responseText (#11426)
+										if ( typeof xhr.responseText === "string" ) {
+											responses.text = xhr.responseText;
+										}
+
+										// Firefox throws an exception when accessing
+										// statusText for faulty cross-domain requests
+										try {
+											statusText = xhr.statusText;
+										} catch( e ) {
+											// We normalize with Webkit giving an empty statusText
+											statusText = "";
+										}
+
+										// Filter status for non standard behaviors
+
+										// If the request is local and we have data: assume a success
+										// (success with no data won't get notified, that's the best we
+										// can do given current implementations)
+										if ( !status && s.isLocal && !s.crossDomain ) {
+											status = responses.text ? 200 : 404;
+										// IE - #1450: sometimes returns 1223 when it should be 204
+										} else if ( status === 1223 ) {
+											status = 204;
+										}
+									}
+								}
+							} catch( firefoxAccessException ) {
+								if ( !isAbort ) {
+									complete( -1, firefoxAccessException );
+								}
+							}
+
+							// Call complete if needed
+							if ( responses ) {
+								complete( status, statusText, responses, responseHeaders );
+							}
+						};
+
+						if ( !s.async ) {
+							// if we're in sync mode we fire the callback
+							callback();
+						} else if ( xhr.readyState === 4 ) {
+							// (IE6 & IE7) if it's in cache and has been
+							// retrieved directly we need to fire the callback
+							setTimeout( callback );
+						} else {
+							handle = ++xhrId;
+							if ( xhrOnUnloadAbort ) {
+								// Create the active xhrs callbacks list if needed
+								// and attach the unload handler
+								if ( !xhrCallbacks ) {
+									xhrCallbacks = {};
+									jQuery( window ).unload( xhrOnUnloadAbort );
+								}
+								// Add to list of active xhrs callbacks
+								xhrCallbacks[ handle ] = callback;
+							}
+							xhr.onreadystatechange = callback;
+						}
+					},
+
+					abort: function() {
+						if ( callback ) {
+							callback( undefined, true );
+						}
+					}
+				};
+			}
+		});
+	}
+	var fxNow, timerId,
+		rfxtypes = /^(?:toggle|show|hide)$/,
+		rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
+		rrun = /queueHooks$/,
+		animationPrefilters = [ defaultPrefilter ],
+		tweeners = {
+			"*": [function( prop, value ) {
+				var end, unit,
+					tween = this.createTween( prop, value ),
+					parts = rfxnum.exec( value ),
+					target = tween.cur(),
+					start = +target || 0,
+					scale = 1,
+					maxIterations = 20;
+
+				if ( parts ) {
+					end = +parts[2];
+					unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );
+
+					// We need to compute starting value
+					if ( unit !== "px" && start ) {
+						// Iteratively approximate from a nonzero starting point
+						// Prefer the current property, because this process will be trivial if it uses the same units
+						// Fallback to end or a simple constant
+						start = jQuery.css( tween.elem, prop, true ) || end || 1;
+
+						do {
+							// If previous iteration zeroed out, double until we get *something*
+							// Use a string for doubling factor so we don't accidentally see scale as unchanged below
+							scale = scale || ".5";
+
+							// Adjust and apply
+							start = start / scale;
+							jQuery.style( tween.elem, prop, start + unit );
+
+						// Update scale, tolerating zero or NaN from tween.cur()
+						// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
+						} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
+					}
+
+					tween.unit = unit;
+					tween.start = start;
+					// If a +=/-= token was provided, we're doing a relative animation
+					tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
+				}
+				return tween;
+			}]
+		};
+
+	// Animations created synchronously will run synchronously
+	function createFxNow() {
+		setTimeout(function() {
+			fxNow = undefined;
+		});
+		return ( fxNow = jQuery.now() );
+	}
+
+	function createTweens( animation, props ) {
+		jQuery.each( props, function( prop, value ) {
+			var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
+				index = 0,
+				length = collection.length;
+			for ( ; index < length; index++ ) {
+				if ( collection[ index ].call( animation, prop, value ) ) {
+
+					// we're done with this property
+					return;
+				}
+			}
+		});
+	}
+
+	function Animation( elem, properties, options ) {
+		var result,
+			stopped,
+			index = 0,
+			length = animationPrefilters.length,
+			deferred = jQuery.Deferred().always( function() {
+				// don't match elem in the :animated selector
+				delete tick.elem;
+			}),
+			tick = function() {
+				if ( stopped ) {
+					return false;
+				}
+				var currentTime = fxNow || createFxNow(),
+					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
+					// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
+					temp = remaining / animation.duration || 0,
+					percent = 1 - temp,
+					index = 0,
+					length = animation.tweens.length;
+
+				for ( ; index < length ; index++ ) {
+					animation.tweens[ index ].run( percent );
+				}
+
+				deferred.notifyWith( elem, [ animation, percent, remaining ]);
+
+				if ( percent < 1 && length ) {
+					return remaining;
+				} else {
+					deferred.resolveWith( elem, [ animation ] );
+					return false;
+				}
+			},
+			animation = deferred.promise({
+				elem: elem,
+				props: jQuery.extend( {}, properties ),
+				opts: jQuery.extend( true, { specialEasing: {} }, options ),
+				originalProperties: properties,
+				originalOptions: options,
+				startTime: fxNow || createFxNow(),
+				duration: options.duration,
+				tweens: [],
+				createTween: function( prop, end ) {
+					var tween = jQuery.Tween( elem, animation.opts, prop, end,
+							animation.opts.specialEasing[ prop ] || animation.opts.easing );
+					animation.tweens.push( tween );
+					return tween;
+				},
+				stop: function( gotoEnd ) {
+					var index = 0,
+						// if we are going to the end, we want to run all the tweens
+						// otherwise we skip this part
+						length = gotoEnd ? animation.tweens.length : 0;
+					if ( stopped ) {
+						return this;
+					}
+					stopped = true;
+					for ( ; index < length ; index++ ) {
+						animation.tweens[ index ].run( 1 );
+					}
+
+					// resolve when we played the last frame
+					// otherwise, reject
+					if ( gotoEnd ) {
+						deferred.resolveWith( elem, [ animation, gotoEnd ] );
+					} else {
+						deferred.rejectWith( elem, [ animation, gotoEnd ] );
+					}
+					return this;
+				}
+			}),
+			props = animation.props;
+
+		propFilter( props, animation.opts.specialEasing );
+
+		for ( ; index < length ; index++ ) {
+			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
+			if ( result ) {
+				return result;
+			}
+		}
+
+		createTweens( animation, props );
+
+		if ( jQuery.isFunction( animation.opts.start ) ) {
+			animation.opts.start.call( elem, animation );
+		}
+
+		jQuery.fx.timer(
+			jQuery.extend( tick, {
+				elem: elem,
+				anim: animation,
+				queue: animation.opts.queue
+			})
+		);
+
+		// attach callbacks from options
+		return animation.progress( animation.opts.progress )
+			.done( animation.opts.done, animation.opts.complete )
+			.fail( animation.opts.fail )
+			.always( animation.opts.always );
+	}
+
+	function propFilter( props, specialEasing ) {
+		var value, name, index, easing, hooks;
+
+		// camelCase, specialEasing and expand cssHook pass
+		for ( index in props ) {
+			name = jQuery.camelCase( index );
+			easing = specialEasing[ name ];
+			value = props[ index ];
+			if ( jQuery.isArray( value ) ) {
+				easing = value[ 1 ];
+				value = props[ index ] = value[ 0 ];
+			}
+
+			if ( index !== name ) {
+				props[ name ] = value;
+				delete props[ index ];
+			}
+
+			hooks = jQuery.cssHooks[ name ];
+			if ( hooks && "expand" in hooks ) {
+				value = hooks.expand( value );
+				delete props[ name ];
+
+				// not quite $.extend, this wont overwrite keys already present.
+				// also - reusing 'index' from above because we have the correct "name"
+				for ( index in value ) {
+					if ( !( index in props ) ) {
+						props[ index ] = value[ index ];
+						specialEasing[ index ] = easing;
+					}
+				}
+			} else {
+				specialEasing[ name ] = easing;
+			}
+		}
+	}
+
+	jQuery.Animation = jQuery.extend( Animation, {
+
+		tweener: function( props, callback ) {
+			if ( jQuery.isFunction( props ) ) {
+				callback = props;
+				props = [ "*" ];
+			} else {
+				props = props.split(" ");
+			}
+
+			var prop,
+				index = 0,
+				length = props.length;
+
+			for ( ; index < length ; index++ ) {
+				prop = props[ index ];
+				tweeners[ prop ] = tweeners[ prop ] || [];
+				tweeners[ prop ].unshift( callback );
+			}
+		},
+
+		prefilter: function( callback, prepend ) {
+			if ( prepend ) {
+				animationPrefilters.unshift( callback );
+			} else {
+				animationPrefilters.push( callback );
+			}
+		}
+	});
+
+	function defaultPrefilter( elem, props, opts ) {
+		/*jshint validthis:true */
+		var prop, index, length,
+			value, dataShow, toggle,
+			tween, hooks, oldfire,
+			anim = this,
+			style = elem.style,
+			orig = {},
+			handled = [],
+			hidden = elem.nodeType && isHidden( elem );
+
+		// handle queue: false promises
+		if ( !opts.queue ) {
+			hooks = jQuery._queueHooks( elem, "fx" );
+			if ( hooks.unqueued == null ) {
+				hooks.unqueued = 0;
+				oldfire = hooks.empty.fire;
+				hooks.empty.fire = function() {
+					if ( !hooks.unqueued ) {
+						oldfire();
+					}
+				};
+			}
+			hooks.unqueued++;
+
+			anim.always(function() {
+				// doing this makes sure that the complete handler will be called
+				// before this completes
+				anim.always(function() {
+					hooks.unqueued--;
+					if ( !jQuery.queue( elem, "fx" ).length ) {
+						hooks.empty.fire();
+					}
+				});
+			});
+		}
+
+		// height/width overflow pass
+		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
+			// Make sure that nothing sneaks out
+			// Record all 3 overflow attributes because IE does not
+			// change the overflow attribute when overflowX and
+			// overflowY are set to the same value
+			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
+
+			// Set display property to inline-block for height/width
+			// animations on inline elements that are having width/height animated
+			if ( jQuery.css( elem, "display" ) === "inline" &&
+					jQuery.css( elem, "float" ) === "none" ) {
+
+				// inline-level elements accept inline-block;
+				// block-level elements need to be inline with layout
+				if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
+					style.display = "inline-block";
+
+				} else {
+					style.zoom = 1;
+				}
+			}
+		}
+
+		if ( opts.overflow ) {
+			style.overflow = "hidden";
+			if ( !jQuery.support.shrinkWrapBlocks ) {
+				anim.always(function() {
+					style.overflow = opts.overflow[ 0 ];
+					style.overflowX = opts.overflow[ 1 ];
+					style.overflowY = opts.overflow[ 2 ];
+				});
+			}
+		}
+
+
+		// show/hide pass
+		for ( index in props ) {
+			value = props[ index ];
+			if ( rfxtypes.exec( value ) ) {
+				delete props[ index ];
+				toggle = toggle || value === "toggle";
+				if ( value === ( hidden ? "hide" : "show" ) ) {
+					continue;
+				}
+				handled.push( index );
+			}
+		}
+
+		length = handled.length;
+		if ( length ) {
+			dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
+			if ( "hidden" in dataShow ) {
+				hidden = dataShow.hidden;
+			}
+
+			// store state if its toggle - enables .stop().toggle() to "reverse"
+			if ( toggle ) {
+				dataShow.hidden = !hidden;
+			}
+			if ( hidden ) {
+				jQuery( elem ).show();
+			} else {
+				anim.done(function() {
+					jQuery( elem ).hide();
+				});
+			}
+			anim.done(function() {
+				var prop;
+				jQuery._removeData( elem, "fxshow" );
+				for ( prop in orig ) {
+					jQuery.style( elem, prop, orig[ prop ] );
+				}
+			});
+			for ( index = 0 ; index < length ; index++ ) {
+				prop = handled[ index ];
+				tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
+				orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );
+
+				if ( !( prop in dataShow ) ) {
+					dataShow[ prop ] = tween.start;
+					if ( hidden ) {
+						tween.end = tween.start;
+						tween.start = prop === "width" || prop === "height" ? 1 : 0;
+					}
+				}
+			}
+		}
+	}
+
+	function Tween( elem, options, prop, end, easing ) {
+		return new Tween.prototype.init( elem, options, prop, end, easing );
+	}
+	jQuery.Tween = Tween;
+
+	Tween.prototype = {
+		constructor: Tween,
+		init: function( elem, options, prop, end, easing, unit ) {
+			this.elem = elem;
+			this.prop = prop;
+			this.easing = easing || "swing";
+			this.options = options;
+			this.start = this.now = this.cur();
+			this.end = end;
+			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
+		},
+		cur: function() {
+			var hooks = Tween.propHooks[ this.prop ];
+
+			return hooks && hooks.get ?
+				hooks.get( this ) :
+				Tween.propHooks._default.get( this );
+		},
+		run: function( percent ) {
+			var eased,
+				hooks = Tween.propHooks[ this.prop ];
+
+			if ( this.options.duration ) {
+				this.pos = eased = jQuery.easing[ this.easing ](
+					percent, this.options.duration * percent, 0, 1, this.options.duration
+				);
+			} else {
+				this.pos = eased = percent;
+			}
+			this.now = ( this.end - this.start ) * eased + this.start;
+
+			if ( this.options.step ) {
+				this.options.step.call( this.elem, this.now, this );
+			}
+
+			if ( hooks && hooks.set ) {
+				hooks.set( this );
+			} else {
+				Tween.propHooks._default.set( this );
+			}
+			return this;
+		}
+	};
+
+	Tween.prototype.init.prototype = Tween.prototype;
+
+	Tween.propHooks = {
+		_default: {
+			get: function( tween ) {
+				var result;
+
+				if ( tween.elem[ tween.prop ] != null &&
+					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
+					return tween.elem[ tween.prop ];
+				}
+
+				// passing an empty string as a 3rd parameter to .css will automatically
+				// attempt a parseFloat and fallback to a string if the parse fails
+				// so, simple values such as "10px" are parsed to Float.
+				// complex values such as "rotate(1rad)" are returned as is.
+				result = jQuery.css( tween.elem, tween.prop, "" );
+				// Empty strings, null, undefined and "auto" are converted to 0.
+				return !result || result === "auto" ? 0 : result;
+			},
+			set: function( tween ) {
+				// use step hook for back compat - use cssHook if its there - use .style if its
+				// available and use plain properties where available
+				if ( jQuery.fx.step[ tween.prop ] ) {
+					jQuery.fx.step[ tween.prop ]( tween );
+				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
+					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
+				} else {
+					tween.elem[ tween.prop ] = tween.now;
+				}
+			}
+		}
+	};
+
+	// Remove in 2.0 - this supports IE8's panic based approach
+	// to setting things on disconnected nodes
+
+	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
+		set: function( tween ) {
+			if ( tween.elem.nodeType && tween.elem.parentNode ) {
+				tween.elem[ tween.prop ] = tween.now;
+			}
+		}
+	};
+
+	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
+		var cssFn = jQuery.fn[ name ];
+		jQuery.fn[ name ] = function( speed, easing, callback ) {
+			return speed == null || typeof speed === "boolean" ?
+				cssFn.apply( this, arguments ) :
+				this.animate( genFx( name, true ), speed, easing, callback );
+		};
+	});
+
+	jQuery.fn.extend({
+		fadeTo: function( speed, to, easing, callback ) {
+
+			// show any hidden elements after setting opacity to 0
+			return this.filter( isHidden ).css( "opacity", 0 ).show()
+
+				// animate to the value specified
+				.end().animate({ opacity: to }, speed, easing, callback );
+		},
+		animate: function( prop, speed, easing, callback ) {
+			var empty = jQuery.isEmptyObject( prop ),
+				optall = jQuery.speed( speed, easing, callback ),
+				doAnimation = function() {
+					// Operate on a copy of prop so per-property easing won't be lost
+					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
+					doAnimation.finish = function() {
+						anim.stop( true );
+					};
+					// Empty animations, or finishing resolves immediately
+					if ( empty || jQuery._data( this, "finish" ) ) {
+						anim.stop( true );
+					}
+				};
+				doAnimation.finish = doAnimation;
+
+			return empty || optall.queue === false ?
+				this.each( doAnimation ) :
+				this.queue( optall.queue, doAnimation );
+		},
+		stop: function( type, clearQueue, gotoEnd ) {
+			var stopQueue = function( hooks ) {
+				var stop = hooks.stop;
+				delete hooks.stop;
+				stop( gotoEnd );
+			};
+
+			if ( typeof type !== "string" ) {
+				gotoEnd = clearQueue;
+				clearQueue = type;
+				type = undefined;
+			}
+			if ( clearQueue && type !== false ) {
+				this.queue( type || "fx", [] );
+			}
+
+			return this.each(function() {
+				var dequeue = true,
+					index = type != null && type + "queueHooks",
+					timers = jQuery.timers,
+					data = jQuery._data( this );
+
+				if ( index ) {
+					if ( data[ index ] && data[ index ].stop ) {
+						stopQueue( data[ index ] );
+					}
+				} else {
+					for ( index in data ) {
+						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
+							stopQueue( data[ index ] );
+						}
+					}
+				}
+
+				for ( index = timers.length; index--; ) {
+					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
+						timers[ index ].anim.stop( gotoEnd );
+						dequeue = false;
+						timers.splice( index, 1 );
+					}
+				}
+
+				// start the next in the queue if the last step wasn't forced
+				// timers currently will call their complete callbacks, which will dequeue
+				// but only if they were gotoEnd
+				if ( dequeue || !gotoEnd ) {
+					jQuery.dequeue( this, type );
+				}
+			});
+		},
+		finish: function( type ) {
+			if ( type !== false ) {
+				type = type || "fx";
+			}
+			return this.each(function() {
+				var index,
+					data = jQuery._data( this ),
+					queue = data[ type + "queue" ],
+					hooks = data[ type + "queueHooks" ],
+					timers = jQuery.timers,
+					length = queue ? queue.length : 0;
+
+				// enable finishing flag on private data
+				data.finish = true;
+
+				// empty the queue first
+				jQuery.queue( this, type, [] );
+
+				if ( hooks && hooks.cur && hooks.cur.finish ) {
+					hooks.cur.finish.call( this );
+				}
+
+				// look for any active animations, and finish them
+				for ( index = timers.length; index--; ) {
+					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
+						timers[ index ].anim.stop( true );
+						timers.splice( index, 1 );
+					}
+				}
+
+				// look for any animations in the old queue and finish them
+				for ( index = 0; index < length; index++ ) {
+					if ( queue[ index ] && queue[ index ].finish ) {
+						queue[ index ].finish.call( this );
+					}
+				}
+
+				// turn off finishing flag
+				delete data.finish;
+			});
+		}
+	});
+
+	// Generate parameters to create a standard animation
+	function genFx( type, includeWidth ) {
+		var which,
+			attrs = { height: type },
+			i = 0;
+
+		// if we include width, step value is 1 to do all cssExpand values,
+		// if we don't include width, step value is 2 to skip over Left and Right
+		includeWidth = includeWidth? 1 : 0;
+		for( ; i < 4 ; i += 2 - includeWidth ) {
+			which = cssExpand[ i ];
+			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
+		}
+
+		if ( includeWidth ) {
+			attrs.opacity = attrs.width = type;
+		}
+
+		return attrs;
+	}
+
+	// Generate shortcuts for custom animations
+	jQuery.each({
+		slideDown: genFx("show"),
+		slideUp: genFx("hide"),
+		slideToggle: genFx("toggle"),
+		fadeIn: { opacity: "show" },
+		fadeOut: { opacity: "hide" },
+		fadeToggle: { opacity: "toggle" }
+	}, function( name, props ) {
+		jQuery.fn[ name ] = function( speed, easing, callback ) {
+			return this.animate( props, speed, easing, callback );
+		};
+	});
+
+	jQuery.speed = function( speed, easing, fn ) {
+		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
+			complete: fn || !fn && easing ||
+				jQuery.isFunction( speed ) && speed,
+			duration: speed,
+			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
+		};
+
+		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
+			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
+
+		// normalize opt.queue - true/undefined/null -> "fx"
+		if ( opt.queue == null || opt.queue === true ) {
+			opt.queue = "fx";
+		}
+
+		// Queueing
+		opt.old = opt.complete;
+
+		opt.complete = function() {
+			if ( jQuery.isFunction( opt.old ) ) {
+				opt.old.call( this );
+			}
+
+			if ( opt.queue ) {
+				jQuery.dequeue( this, opt.queue );
+			}
+		};
+
+		return opt;
+	};
+
+	jQuery.easing = {
+		linear: function( p ) {
+			return p;
+		},
+		swing: function( p ) {
+			return 0.5 - Math.cos( p*Math.PI ) / 2;
+		}
+	};
+
+	jQuery.timers = [];
+	jQuery.fx = Tween.prototype.init;
+	jQuery.fx.tick = function() {
+		var timer,
+			timers = jQuery.timers,
+			i = 0;
+
+		fxNow = jQuery.now();
+
+		for ( ; i < timers.length; i++ ) {
+			timer = timers[ i ];
+			// Checks the timer has not already been removed
+			if ( !timer() && timers[ i ] === timer ) {
+				timers.splice( i--, 1 );
+			}
+		}
+
+		if ( !timers.length ) {
+			jQuery.fx.stop();
+		}
+		fxNow = undefined;
+	};
+
+	jQuery.fx.timer = function( timer ) {
+		if ( timer() && jQuery.timers.push( timer ) ) {
+			jQuery.fx.start();
+		}
+	};
+
+	jQuery.fx.interval = 13;
+
+	jQuery.fx.start = function() {
+		if ( !timerId ) {
+			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
+		}
+	};
+
+	jQuery.fx.stop = function() {
+		clearInterval( timerId );
+		timerId = null;
+	};
+
+	jQuery.fx.speeds = {
+		slow: 600,
+		fast: 200,
+		// Default speed
+		_default: 400
+	};
+
+	// Back Compat <1.8 extension point
+	jQuery.fx.step = {};
+
+	if ( jQuery.expr && jQuery.expr.filters ) {
+		jQuery.expr.filters.animated = function( elem ) {
+			return jQuery.grep(jQuery.timers, function( fn ) {
+				return elem === fn.elem;
+			}).length;
+		};
+	}
+	jQuery.fn.offset = function( options ) {
+		if ( arguments.length ) {
+			return options === undefined ?
+				this :
+				this.each(function( i ) {
+					jQuery.offset.setOffset( this, options, i );
+				});
+		}
+
+		var docElem, win,
+			box = { top: 0, left: 0 },
+			elem = this[ 0 ],
+			doc = elem && elem.ownerDocument;
+
+		if ( !doc ) {
+			return;
+		}
+
+		docElem = doc.documentElement;
+
+		// Make sure it's not a disconnected DOM node
+		if ( !jQuery.contains( docElem, elem ) ) {
+			return box;
+		}
+
+		// If we don't have gBCR, just use 0,0 rather than error
+		// BlackBerry 5, iOS 3 (original iPhone)
+		if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
+			box = elem.getBoundingClientRect();
+		}
+		win = getWindow( doc );
+		return {
+			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
+			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
+		};
+	};
+
+	jQuery.offset = {
+
+		setOffset: function( elem, options, i ) {
+			var position = jQuery.css( elem, "position" );
+
+			// set position first, in-case top/left are set even on static elem
+			if ( position === "static" ) {
+				elem.style.position = "relative";
+			}
+
+			var curElem = jQuery( elem ),
+				curOffset = curElem.offset(),
+				curCSSTop = jQuery.css( elem, "top" ),
+				curCSSLeft = jQuery.css( elem, "left" ),
+				calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
+				props = {}, curPosition = {}, curTop, curLeft;
+
+			// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
+			if ( calculatePosition ) {
+				curPosition = curElem.position();
+				curTop = curPosition.top;
+				curLeft = curPosition.left;
+			} else {
+				curTop = parseFloat( curCSSTop ) || 0;
+				curLeft = parseFloat( curCSSLeft ) || 0;
+			}
+
+			if ( jQuery.isFunction( options ) ) {
+				options = options.call( elem, i, curOffset );
+			}
+
+			if ( options.top != null ) {
+				props.top = ( options.top - curOffset.top ) + curTop;
+			}
+			if ( options.left != null ) {
+				props.left = ( options.left - curOffset.left ) + curLeft;
+			}
+
+			if ( "using" in options ) {
+				options.using.call( elem, props );
+			} else {
+				curElem.css( props );
+			}
+		}
+	};
+
+
+	jQuery.fn.extend({
+
+		position: function() {
+			if ( !this[ 0 ] ) {
+				return;
+			}
+
+			var offsetParent, offset,
+				parentOffset = { top: 0, left: 0 },
+				elem = this[ 0 ];
+
+			// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
+			if ( jQuery.css( elem, "position" ) === "fixed" ) {
+				// we assume that getBoundingClientRect is available when computed position is fixed
+				offset = elem.getBoundingClientRect();
+			} else {
+				// Get *real* offsetParent
+				offsetParent = this.offsetParent();
+
+				// Get correct offsets
+				offset = this.offset();
+				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
+					parentOffset = offsetParent.offset();
+				}
+
+				// Add offsetParent borders
+				parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
+				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
+			}
+
+			// Subtract parent offsets and element margins
+			// note: when an element has margin: auto the offsetLeft and marginLeft
+			// are the same in Safari causing offset.left to incorrectly be 0
+			return {
+				top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
+				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
+			};
+		},
+
+		offsetParent: function() {
+			return this.map(function() {
+				var offsetParent = this.offsetParent || document.documentElement;
+				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
+					offsetParent = offsetParent.offsetParent;
+				}
+				return offsetParent || document.documentElement;
+			});
+		}
+	});
+
+
+	// Create scrollLeft and scrollTop methods
+	jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
+		var top = /Y/.test( prop );
+
+		jQuery.fn[ method ] = function( val ) {
+			return jQuery.access( this, function( elem, method, val ) {
+				var win = getWindow( elem );
+
+				if ( val === undefined ) {
+					return win ? (prop in win) ? win[ prop ] :
+						win.document.documentElement[ method ] :
+						elem[ method ];
+				}
+
+				if ( win ) {
+					win.scrollTo(
+						!top ? val : jQuery( win ).scrollLeft(),
+						top ? val : jQuery( win ).scrollTop()
+					);
+
+				} else {
+					elem[ method ] = val;
+				}
+			}, method, val, arguments.length, null );
+		};
+	});
+
+	function getWindow( elem ) {
+		return jQuery.isWindow( elem ) ?
+			elem :
+			elem.nodeType === 9 ?
+				elem.defaultView || elem.parentWindow :
+				false;
+	}
+	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
+	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
+		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
+			// margin is only for outerHeight, outerWidth
+			jQuery.fn[ funcName ] = function( margin, value ) {
+				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
+					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
+
+				return jQuery.access( this, function( elem, type, value ) {
+					var doc;
+
+					if ( jQuery.isWindow( elem ) ) {
+						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
+						// isn't a whole lot we can do. See pull request at this URL for discussion:
+						// https://github.com/jquery/jquery/pull/764
+						return elem.document.documentElement[ "client" + name ];
+					}
+
+					// Get document width or height
+					if ( elem.nodeType === 9 ) {
+						doc = elem.documentElement;
+
+						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
+						// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
+						return Math.max(
+							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
+							elem.body[ "offset" + name ], doc[ "offset" + name ],
+							doc[ "client" + name ]
+						);
+					}
+
+					return value === undefined ?
+						// Get width or height on the element, requesting but not forcing parseFloat
+						jQuery.css( elem, type, extra ) :
+
+						// Set width or height on the element
+						jQuery.style( elem, type, value, extra );
+				}, type, chainable ? margin : undefined, chainable, null );
+			};
+		});
+	});
+	// Limit scope pollution from any deprecated API
+	// (function() {
+
+	// })();
+	// Expose jQuery to the global object
+	window.jQuery = window.$ = jQuery;
+
+	// DELETE THE PART WHERE JQUERY IS EXPOSED OTHERWISE IT CONFUSES REQUIRE
+
+	})( window );
+	
+	// Raw jQuery does not return anything, so return it explicitly here.
+	return jQuery.noConflict( true );
+} );
diff --git a/public/js_src/jquery_timely20.js b/public/js_src/jquery_timely20.js
new file mode 100644
index 0000000..31da11e
--- /dev/null
+++ b/public/js_src/jquery_timely20.js
@@ -0,0 +1,8744 @@
+define( "jquery_timely", function() {
+	/*global jQuery: true */
+	"use strict"; // jshint ;_;
+	/*!
+	 * jQuery JavaScript Library v2.0.0
+	 * http://jquery.com/
+	 *
+	 * Includes Sizzle.js
+	 * http://sizzlejs.com/
+	 *
+	 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
+	 * Released under the MIT license
+	 * http://jquery.org/license
+	 *
+	 * Date: 2013-04-18
+	 */
+	(function( window, undefined ) {
+
+	// Can't do this because several apps including ASP.NET trace
+	// the stack via arguments.caller.callee and Firefox dies if
+	// you try to trace through "use strict" call chains. (#13335)
+	// Support: Firefox 18+
+	//"use strict";
+	var
+		// A central reference to the root jQuery(document)
+		rootjQuery,
+
+		// The deferred used on DOM ready
+		readyList,
+
+		// Support: IE9
+		// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`
+		core_strundefined = typeof undefined,
+
+		// Use the correct document accordingly with window argument (sandbox)
+		location = window.location,
+		document = window.document,
+		docElem = document.documentElement,
+
+		// Map over jQuery in case of overwrite
+		_jQuery = window.jQuery,
+
+		// Map over the $ in case of overwrite
+		_$ = window.$,
+
+		// [[Class]] -> type pairs
+		class2type = {},
+
+		// List of deleted data cache ids, so we can reuse them
+		core_deletedIds = [],
+
+		core_version = "2.0.0-ai1ec",
+
+		// Save a reference to some core methods
+		core_concat = core_deletedIds.concat,
+		core_push = core_deletedIds.push,
+		core_slice = core_deletedIds.slice,
+		core_indexOf = core_deletedIds.indexOf,
+		core_toString = class2type.toString,
+		core_hasOwn = class2type.hasOwnProperty,
+		core_trim = core_version.trim,
+
+		// Define a local copy of jQuery
+		jQuery = function( selector, context ) {
+			// The jQuery object is actually just the init constructor 'enhanced'
+			return new jQuery.fn.init( selector, context, rootjQuery );
+		},
+
+		// Used for matching numbers
+		core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
+
+		// Used for splitting on whitespace
+		core_rnotwhite = /\S+/g,
+
+		// A simple way to check for HTML strings
+		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
+		// Strict HTML recognition (#11290: must start with <)
+		rquickExpr = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,
+
+		// Match a standalone tag
+		rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
+
+		// Matches dashed string for camelizing
+		rmsPrefix = /^-ms-/,
+		rdashAlpha = /-([\da-z])/gi,
+
+		// Used by jQuery.camelCase as callback to replace()
+		fcamelCase = function( all, letter ) {
+			return letter.toUpperCase();
+		},
+
+		// The ready event handler and self cleanup method
+		completed = function() {
+			document.removeEventListener( "DOMContentLoaded", completed, false );
+			window.removeEventListener( "load", completed, false );
+			jQuery.ready();
+		};
+
+	jQuery.fn = jQuery.prototype = {
+		// The current version of jQuery being used
+		jquery: core_version,
+
+		constructor: jQuery,
+		init: function( selector, context, rootjQuery ) {
+			var match, elem;
+
+			// HANDLE: $(""), $(null), $(undefined), $(false)
+			if ( !selector ) {
+				return this;
+			}
+
+			// Handle HTML strings
+			if ( typeof selector === "string" ) {
+				if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
+					// Assume that strings that start and end with <> are HTML and skip the regex check
+					match = [ null, selector, null ];
+
+				} else {
+					match = rquickExpr.exec( selector );
+				}
+
+				// Match html or make sure no context is specified for #id
+				if ( match && (match[1] || !context) ) {
+
+					// HANDLE: $(html) -> $(array)
+					if ( match[1] ) {
+						context = context instanceof jQuery ? context[0] : context;
+
+						// scripts is true for back-compat
+						jQuery.merge( this, jQuery.parseHTML(
+							match[1],
+							context && context.nodeType ? context.ownerDocument || context : document,
+							true
+						) );
+
+						// HANDLE: $(html, props)
+						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
+							for ( match in context ) {
+								// Properties of context are called as methods if possible
+								if ( jQuery.isFunction( this[ match ] ) ) {
+									this[ match ]( context[ match ] );
+
+								// ...and otherwise set as attributes
+								} else {
+									this.attr( match, context[ match ] );
+								}
+							}
+						}
+
+						return this;
+
+					// HANDLE: $(#id)
+					} else {
+						elem = document.getElementById( match[2] );
+
+						// Check parentNode to catch when Blackberry 4.6 returns
+						// nodes that are no longer in the document #6963
+						if ( elem && elem.parentNode ) {
+							// Inject the element directly into the jQuery object
+							this.length = 1;
+							this[0] = elem;
+						}
+
+						this.context = document;
+						this.selector = selector;
+						return this;
+					}
+
+				// HANDLE: $(expr, $(...))
+				} else if ( !context || context.jquery ) {
+					return ( context || rootjQuery ).find( selector );
+
+				// HANDLE: $(expr, context)
+				// (which is just equivalent to: $(context).find(expr)
+				} else {
+					return this.constructor( context ).find( selector );
+				}
+
+			// HANDLE: $(DOMElement)
+			} else if ( selector.nodeType ) {
+				this.context = this[0] = selector;
+				this.length = 1;
+				return this;
+
+			// HANDLE: $(function)
+			// Shortcut for document ready
+			} else if ( jQuery.isFunction( selector ) ) {
+				return rootjQuery.ready( selector );
+			}
+
+			if ( selector.selector !== undefined ) {
+				this.selector = selector.selector;
+				this.context = selector.context;
+			}
+
+			return jQuery.makeArray( selector, this );
+		},
+
+		// Start with an empty selector
+		selector: "",
+
+		// The default length of a jQuery object is 0
+		length: 0,
+
+		toArray: function() {
+			return core_slice.call( this );
+		},
+
+		// Get the Nth element in the matched element set OR
+		// Get the whole matched element set as a clean array
+		get: function( num ) {
+			return num == null ?
+
+				// Return a 'clean' array
+				this.toArray() :
+
+				// Return just the object
+				( num < 0 ? this[ this.length + num ] : this[ num ] );
+		},
+
+		// Take an array of elements and push it onto the stack
+		// (returning the new matched element set)
+		pushStack: function( elems ) {
+
+			// Build a new jQuery matched element set
+			var ret = jQuery.merge( this.constructor(), elems );
+
+			// Add the old object onto the stack (as a reference)
+			ret.prevObject = this;
+			ret.context = this.context;
+
+			// Return the newly-formed element set
+			return ret;
+		},
+
+		// Execute a callback for every element in the matched set.
+		// (You can seed the arguments with an array of args, but this is
+		// only used internally.)
+		each: function( callback, args ) {
+			return jQuery.each( this, callback, args );
+		},
+
+		ready: function( fn ) {
+			// Add the callback
+			jQuery.ready.promise().done( fn );
+
+			return this;
+		},
+
+		slice: function() {
+			return this.pushStack( core_slice.apply( this, arguments ) );
+		},
+
+		first: function() {
+			return this.eq( 0 );
+		},
+
+		last: function() {
+			return this.eq( -1 );
+		},
+
+		eq: function( i ) {
+			var len = this.length,
+				j = +i + ( i < 0 ? len : 0 );
+			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
+		},
+
+		map: function( callback ) {
+			return this.pushStack( jQuery.map(this, function( elem, i ) {
+				return callback.call( elem, i, elem );
+			}));
+		},
+
+		end: function() {
+			return this.prevObject || this.constructor(null);
+		},
+
+		// For internal use only.
+		// Behaves like an Array's method, not like a jQuery method.
+		push: core_push,
+		sort: [].sort,
+		splice: [].splice
+	};
+
+	// Give the init function the jQuery prototype for later instantiation
+	jQuery.fn.init.prototype = jQuery.fn;
+
+	jQuery.extend = jQuery.fn.extend = function() {
+		var options, name, src, copy, copyIsArray, clone,
+			target = arguments[0] || {},
+			i = 1,
+			length = arguments.length,
+			deep = false;
+
+		// Handle a deep copy situation
+		if ( typeof target === "boolean" ) {
+			deep = target;
+			target = arguments[1] || {};
+			// skip the boolean and the target
+			i = 2;
+		}
+
+		// Handle case when target is a string or something (possible in deep copy)
+		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
+			target = {};
+		}
+
+		// extend jQuery itself if only one argument is passed
+		if ( length === i ) {
+			target = this;
+			--i;
+		}
+
+		for ( ; i < length; i++ ) {
+			// Only deal with non-null/undefined values
+			if ( (options = arguments[ i ]) != null ) {
+				// Extend the base object
+				for ( name in options ) {
+					src = target[ name ];
+					copy = options[ name ];
+
+					// Prevent never-ending loop
+					if ( target === copy ) {
+						continue;
+					}
+
+					// Recurse if we're merging plain objects or arrays
+					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
+						if ( copyIsArray ) {
+							copyIsArray = false;
+							clone = src && jQuery.isArray(src) ? src : [];
+
+						} else {
+							clone = src && jQuery.isPlainObject(src) ? src : {};
+						}
+
+						// Never move original objects, clone them
+						target[ name ] = jQuery.extend( deep, clone, copy );
+
+					// Don't bring in undefined values
+					} else if ( copy !== undefined ) {
+						target[ name ] = copy;
+					}
+				}
+			}
+		}
+
+		// Return the modified object
+		return target;
+	};
+
+	jQuery.extend({
+		// Unique for each copy of jQuery on the page
+		expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),
+
+		noConflict: function( deep ) {
+			if ( window.$ === jQuery ) {
+				window.$ = _$;
+			}
+
+			if ( deep && window.jQuery === jQuery ) {
+				window.jQuery = _jQuery;
+			}
+
+			return jQuery;
+		},
+
+		// Is the DOM ready to be used? Set to true once it occurs.
+		isReady: false,
+
+		// A counter to track how many items to wait for before
+		// the ready event fires. See #6781
+		readyWait: 1,
+
+		// Hold (or release) the ready event
+		holdReady: function( hold ) {
+			if ( hold ) {
+				jQuery.readyWait++;
+			} else {
+				jQuery.ready( true );
+			}
+		},
+
+		// Handle when the DOM is ready
+		ready: function( wait ) {
+
+			// Abort if there are pending holds or we're already ready
+			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
+				return;
+			}
+
+			// Remember that the DOM is ready
+			jQuery.isReady = true;
+
+			// If a normal DOM Ready event fired, decrement, and wait if need be
+			if ( wait !== true && --jQuery.readyWait > 0 ) {
+				return;
+			}
+
+			// If there are functions bound, to execute
+			readyList.resolveWith( document, [ jQuery ] );
+
+			// Trigger any bound ready events
+			if ( jQuery.fn.trigger ) {
+				jQuery( document ).trigger("ready").off("ready");
+			}
+		},
+
+		// See test/unit/core.js for details concerning isFunction.
+		// Since version 1.3, DOM methods and functions like alert
+		// aren't supported. They return false on IE (#2968).
+		isFunction: function( obj ) {
+			return jQuery.type(obj) === "function";
+		},
+
+		isArray: Array.isArray,
+
+		isWindow: function( obj ) {
+			return obj != null && obj === obj.window;
+		},
+
+		isNumeric: function( obj ) {
+			return !isNaN( parseFloat(obj) ) && isFinite( obj );
+		},
+
+		type: function( obj ) {
+			if ( obj == null ) {
+				return String( obj );
+			}
+			// Support: Safari <= 5.1 (functionish RegExp)
+			return typeof obj === "object" || typeof obj === "function" ?
+				class2type[ core_toString.call(obj) ] || "object" :
+				typeof obj;
+		},
+
+		isPlainObject: function( obj ) {
+			// Not plain objects:
+			// - Any object or value whose internal [[Class]] property is not "[object Object]"
+			// - DOM nodes
+			// - window
+			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
+				return false;
+			}
+
+			// Support: Firefox <20
+			// The try/catch suppresses exceptions thrown when attempting to access
+			// the "constructor" property of certain host objects, ie. |window.location|
+			// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
+			try {
+				if ( obj.constructor &&
+						!core_hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
+					return false;
+				}
+			} catch ( e ) {
+				return false;
+			}
+
+			// If the function hasn't returned already, we're confident that
+			// |obj| is a plain object, created by {} or constructed with new Object
+			return true;
+		},
+
+		isEmptyObject: function( obj ) {
+			var name;
+			for ( name in obj ) {
+				return false;
+			}
+			return true;
+		},
+
+		error: function( msg ) {
+			throw new Error( msg );
+		},
+
+		// data: string of html
+		// context (optional): If specified, the fragment will be created in this context, defaults to document
+		// keepScripts (optional): If true, will include scripts passed in the html string
+		parseHTML: function( data, context, keepScripts ) {
+			if ( !data || typeof data !== "string" ) {
+				return null;
+			}
+			if ( typeof context === "boolean" ) {
+				keepScripts = context;
+				context = false;
+			}
+			context = context || document;
+
+			var parsed = rsingleTag.exec( data ),
+				scripts = !keepScripts && [];
+
+			// Single tag
+			if ( parsed ) {
+				return [ context.createElement( parsed[1] ) ];
+			}
+
+			parsed = jQuery.buildFragment( [ data ], context, scripts );
+
+			if ( scripts ) {
+				jQuery( scripts ).remove();
+			}
+
+			return jQuery.merge( [], parsed.childNodes );
+		},
+
+		parseJSON: JSON.parse,
+
+		// Cross-browser xml parsing
+		parseXML: function( data ) {
+			var xml, tmp;
+			if ( !data || typeof data !== "string" ) {
+				return null;
+			}
+
+			// Support: IE9
+			try {
+				tmp = new DOMParser();
+				xml = tmp.parseFromString( data , "text/xml" );
+			} catch ( e ) {
+				xml = undefined;
+			}
+
+			if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
+				jQuery.error( "Invalid XML: " + data );
+			}
+			return xml;
+		},
+
+		noop: function() {},
+
+		// Evaluates a script in a global context
+		globalEval: function( code ) {
+			var script,
+					indirect = eval;
+
+			code = jQuery.trim( code );
+
+			if ( code ) {
+				// If the code includes a valid, prologue position
+				// strict mode pragma, execute code by injecting a
+				// script tag into the document.
+				if ( code.indexOf("use strict") === 1 ) {
+					script = document.createElement("script");
+					script.text = code;
+					document.head.appendChild( script ).parentNode.removeChild( script );
+				} else {
+				// Otherwise, avoid the DOM node creation, insertion
+				// and removal by using an indirect global eval
+					indirect( code );
+				}
+			}
+		},
+
+		// Convert dashed to camelCase; used by the css and data modules
+		// Microsoft forgot to hump their vendor prefix (#9572)
+		camelCase: function( string ) {
+			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
+		},
+
+		nodeName: function( elem, name ) {
+			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
+		},
+
+		// args is for internal usage only
+		each: function( obj, callback, args ) {
+			var value,
+				i = 0,
+				length = obj.length,
+				isArray = isArraylike( obj );
+
+			if ( args ) {
+				if ( isArray ) {
+					for ( ; i < length; i++ ) {
+						value = callback.apply( obj[ i ], args );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				} else {
+					for ( i in obj ) {
+						value = callback.apply( obj[ i ], args );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				}
+
+			// A special, fast, case for the most common use of each
+			} else {
+				if ( isArray ) {
+					for ( ; i < length; i++ ) {
+						value = callback.call( obj[ i ], i, obj[ i ] );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				} else {
+					for ( i in obj ) {
+						value = callback.call( obj[ i ], i, obj[ i ] );
+
+						if ( value === false ) {
+							break;
+						}
+					}
+				}
+			}
+
+			return obj;
+		},
+
+		trim: function( text ) {
+			return text == null ? "" : core_trim.call( text );
+		},
+
+		// results is for internal usage only
+		makeArray: function( arr, results ) {
+			var ret = results || [];
+
+			if ( arr != null ) {
+				if ( isArraylike( Object(arr) ) ) {
+					jQuery.merge( ret,
+						typeof arr === "string" ?
+						[ arr ] : arr
+					);
+				} else {
+					core_push.call( ret, arr );
+				}
+			}
+
+			return ret;
+		},
+
+		inArray: function( elem, arr, i ) {
+			return arr == null ? -1 : core_indexOf.call( arr, elem, i );
+		},
+
+		merge: function( first, second ) {
+			var l = second.length,
+				i = first.length,
+				j = 0;
+
+			if ( typeof l === "number" ) {
+				for ( ; j < l; j++ ) {
+					first[ i++ ] = second[ j ];
+				}
+			} else {
+				while ( second[j] !== undefined ) {
+					first[ i++ ] = second[ j++ ];
+				}
+			}
+
+			first.length = i;
+
+			return first;
+		},
+
+		grep: function( elems, callback, inv ) {
+			var retVal,
+				ret = [],
+				i = 0,
+				length = elems.length;
+			inv = !!inv;
+
+			// Go through the array, only saving the items
+			// that pass the validator function
+			for ( ; i < length; i++ ) {
+				retVal = !!callback( elems[ i ], i );
+				if ( inv !== retVal ) {
+					ret.push( elems[ i ] );
+				}
+			}
+
+			return ret;
+		},
+
+		// arg is for internal usage only
+		map: function( elems, callback, arg ) {
+			var value,
+				i = 0,
+				length = elems.length,
+				isArray = isArraylike( elems ),
+				ret = [];
+
+			// Go through the array, translating each of the items to their
+			if ( isArray ) {
+				for ( ; i < length; i++ ) {
+					value = callback( elems[ i ], i, arg );
+
+					if ( value != null ) {
+						ret[ ret.length ] = value;
+					}
+				}
+
+			// Go through every key on the object,
+			} else {
+				for ( i in elems ) {
+					value = callback( elems[ i ], i, arg );
+
+					if ( value != null ) {
+						ret[ ret.length ] = value;
+					}
+				}
+			}
+
+			// Flatten any nested arrays
+			return core_concat.apply( [], ret );
+		},
+
+		// A global GUID counter for objects
+		guid: 1,
+
+		// Bind a function to a context, optionally partially applying any
+		// arguments.
+		proxy: function( fn, context ) {
+			var tmp, args, proxy;
+
+			if ( typeof context === "string" ) {
+				tmp = fn[ context ];
+				context = fn;
+				fn = tmp;
+			}
+
+			// Quick check to determine if target is callable, in the spec
+			// this throws a TypeError, but we will just return undefined.
+			if ( !jQuery.isFunction( fn ) ) {
+				return undefined;
+			}
+
+			// Simulated bind
+			args = core_slice.call( arguments, 2 );
+			proxy = function() {
+				return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
+			};
+
+			// Set the guid of unique handler to the same of original handler, so it can be removed
+			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
+
+			return proxy;
+		},
+
+		// Multifunctional method to get and set values of a collection
+		// The value/s can optionally be executed if it's a function
+		access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
+			var i = 0,
+				length = elems.length,
+				bulk = key == null;
+
+			// Sets many values
+			if ( jQuery.type( key ) === "object" ) {
+				chainable = true;
+				for ( i in key ) {
+					jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
+				}
+
+			// Sets one value
+			} else if ( value !== undefined ) {
+				chainable = true;
+
+				if ( !jQuery.isFunction( value ) ) {
+					raw = true;
+				}
+
+				if ( bulk ) {
+					// Bulk operations run against the entire set
+					if ( raw ) {
+						fn.call( elems, value );
+						fn = null;
+
+					// ...except when executing function values
+					} else {
+						bulk = fn;
+						fn = function( elem, key, value ) {
+							return bulk.call( jQuery( elem ), value );
+						};
+					}
+				}
+
+				if ( fn ) {
+					for ( ; i < length; i++ ) {
+						fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
+					}
+				}
+			}
+
+			return chainable ?
+				elems :
+
+				// Gets
+				bulk ?
+					fn.call( elems ) :
+					length ? fn( elems[0], key ) : emptyGet;
+		},
+
+		now: Date.now,
+
+		// A method for quickly swapping in/out CSS properties to get correct calculations.
+		// Note: this method belongs to the css module but it's needed here for the support module.
+		// If support gets modularized, this method should be moved back to the css module.
+		swap: function( elem, options, callback, args ) {
+			var ret, name,
+				old = {};
+
+			// Remember the old values, and insert the new ones
+			for ( name in options ) {
+				old[ name ] = elem.style[ name ];
+				elem.style[ name ] = options[ name ];
+			}
+
+			ret = callback.apply( elem, args || [] );
+
+			// Revert the old values
+			for ( name in options ) {
+				elem.style[ name ] = old[ name ];
+			}
+
+			return ret;
+		}
+	});
+
+	jQuery.ready.promise = function( obj ) {
+		if ( !readyList ) {
+
+			readyList = jQuery.Deferred();
+
+			// Catch cases where $(document).ready() is called after the browser event has already occurred.
+			// we once tried to use readyState "interactive" here, but it caused issues like the one
+			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
+			if ( document.readyState === "complete" ) {
+				// Handle it asynchronously to allow scripts the opportunity to delay ready
+				setTimeout( jQuery.ready );
+
+			} else {
+
+				// Use the handy event callback
+				document.addEventListener( "DOMContentLoaded", completed, false );
+
+				// A fallback to window.onload, that will always work
+				window.addEventListener( "load", completed, false );
+			}
+		}
+		return readyList.promise( obj );
+	};
+
+	// Populate the class2type map
+	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
+		class2type[ "[object " + name + "]" ] = name.toLowerCase();
+	});
+
+	function isArraylike( obj ) {
+		var length = obj.length,
+			type = jQuery.type( obj );
+
+		if ( jQuery.isWindow( obj ) ) {
+			return false;
+		}
+
+		if ( obj.nodeType === 1 && length ) {
+			return true;
+		}
+
+		return type === "array" || type !== "function" &&
+			( length === 0 ||
+			typeof length === "number" && length > 0 && ( length - 1 ) in obj );
+	}
+
+	// All jQuery objects should point back to these
+	rootjQuery = jQuery(document);
+	/*!
+	 * Sizzle CSS Selector Engine v1.9.2-pre
+	 * http://sizzlejs.com/
+	 *
+	 * Copyright 2013 jQuery Foundation, Inc. and other contributors
+	 * Released under the MIT license
+	 * http://jquery.org/license
+	 *
+	 * Date: 2013-04-16
+	 */
+	(function( window, undefined ) {
+
+	var i,
+		cachedruns,
+		Expr,
+		getText,
+		isXML,
+		compile,
+		outermostContext,
+		sortInput,
+
+		// Local document vars
+		setDocument,
+		document,
+		docElem,
+		documentIsHTML,
+		rbuggyQSA,
+		rbuggyMatches,
+		matches,
+		contains,
+
+		// Instance-specific data
+		expando = "sizzle" + -(new Date()),
+		preferredDoc = window.document,
+		support = {},
+		dirruns = 0,
+		done = 0,
+		classCache = createCache(),
+		tokenCache = createCache(),
+		compilerCache = createCache(),
+		hasDuplicate = false,
+		sortOrder = function() { return 0; },
+
+		// General-purpose constants
+		strundefined = typeof undefined,
+		MAX_NEGATIVE = 1 << 31,
+
+		// Array methods
+		arr = [],
+		pop = arr.pop,
+		push_native = arr.push,
+		push = arr.push,
+		slice = arr.slice,
+		// Use a stripped-down indexOf if we can't use a native one
+		indexOf = arr.indexOf || function( elem ) {
+			var i = 0,
+				len = this.length;
+			for ( ; i < len; i++ ) {
+				if ( this[i] === elem ) {
+					return i;
+				}
+			}
+			return -1;
+		},
+
+		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
+
+		// Regular expressions
+
+		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
+		whitespace = "[\\x20\\t\\r\\n\\f]",
+		// http://www.w3.org/TR/css3-syntax/#characters
+		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
+
+		// Loosely modeled on CSS identifier characters
+		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
+		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
+		identifier = characterEncoding.replace( "w", "w#" ),
+
+		// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
+		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
+			"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
+
+		// Prefer arguments quoted,
+		//   then not containing pseudos/brackets,
+		//   then attribute selectors/non-parenthetical expressions,
+		//   then anything else
+		// These preferences are here to reduce the number of selectors
+		//   needing tokenize in the PSEUDO preFilter
+		pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",
+
+		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
+		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
+
+		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
+		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
+
+		rsibling = new RegExp( whitespace + "*[+~]" ),
+		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g" ),
+
+		rpseudo = new RegExp( pseudos ),
+		ridentifier = new RegExp( "^" + identifier + "$" ),
+
+		matchExpr = {
+			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
+			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
+			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
+			"ATTR": new RegExp( "^" + attributes ),
+			"PSEUDO": new RegExp( "^" + pseudos ),
+			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
+				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
+				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
+			"boolean": new RegExp( "^(?:" + booleans + ")$", "i" ),
+			// For use in libraries implementing .is()
+			// We use this for POS matching in `select`
+			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
+				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
+		},
+
+		rnative = /^[^{]+\{\s*\[native \w/,
+
+		// Easily-parseable/retrievable ID or TAG or CLASS selectors
+		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
+
+		rinputs = /^(?:input|select|textarea|button)$/i,
+		rheader = /^h\d$/i,
+
+		rescape = /'|\\/g,
+
+		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
+		runescape = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,
+		funescape = function( _, escaped ) {
+			var high = "0x" + escaped - 0x10000;
+			// NaN means non-codepoint
+			return high !== high ?
+				escaped :
+				// BMP codepoint
+				high < 0 ?
+					String.fromCharCode( high + 0x10000 ) :
+					// Supplemental Plane codepoint (surrogate pair)
+					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
+		};
+
+	// Optimize for push.apply( _, NodeList )
+	try {
+		push.apply(
+			(arr = slice.call( preferredDoc.childNodes )),
+			preferredDoc.childNodes
+		);
+		// Support: Android<4.0
+		// Detect silently failing push.apply
+		arr[ preferredDoc.childNodes.length ].nodeType;
+	} catch ( e ) {
+		push = { apply: arr.length ?
+
+			// Leverage slice if possible
+			function( target, els ) {
+				push_native.apply( target, slice.call(els) );
+			} :
+
+			// Support: IE<9
+			// Otherwise append directly
+			function( target, els ) {
+				var j = target.length,
+					i = 0;
+				// Can't trust NodeList.length
+				while ( (target[j++] = els[i++]) ) {}
+				target.length = j - 1;
+			}
+		};
+	}
+
+	/**
+	 * For feature detection
+	 * @param {Function} fn The function to test for native support
+	 */
+	function isNative( fn ) {
+		return rnative.test( fn + "" );
+	}
+
+	/**
+	 * Create key-value caches of limited size
+	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
+	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
+	 *	deleting the oldest entry
+	 */
+	function createCache() {
+		var cache,
+			keys = [];
+
+		return (cache = function( key, value ) {
+			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
+			if ( keys.push( key += " " ) > Expr.cacheLength ) {
+				// Only keep the most recent entries
+				delete cache[ keys.shift() ];
+			}
+			return (cache[ key ] = value);
+		});
+	}
+
+	/**
+	 * Mark a function for special use by Sizzle
+	 * @param {Function} fn The function to mark
+	 */
+	function markFunction( fn ) {
+		fn[ expando ] = true;
+		return fn;
+	}
+
+	/**
+	 * Support testing using an element
+	 * @param {Function} fn Passed the created div and expects a boolean result
+	 */
+	function assert( fn ) {
+		var div = document.createElement("div");
+
+		try {
+			return !!fn( div );
+		} catch (e) {
+			return false;
+		} finally {
+			if ( div.parentNode ) {
+				div.parentNode.removeChild( div );
+			}
+			// release memory in IE
+			div = null;
+		}
+	}
+
+	function Sizzle( selector, context, results, seed ) {
+		var match, elem, m, nodeType,
+			// QSA vars
+			i, groups, old, nid, newContext, newSelector;
+
+		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
+			setDocument( context );
+		}
+
+		context = context || document;
+		results = results || [];
+
+		if ( !selector || typeof selector !== "string" ) {
+			return results;
+		}
+
+		if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
+			return [];
+		}
+
+		if ( documentIsHTML && !seed ) {
+
+			// Shortcuts
+			if ( (match = rquickExpr.exec( selector )) ) {
+				// Speed-up: Sizzle("#ID")
+				if ( (m = match[1]) ) {
+					if ( nodeType === 9 ) {
+						elem = context.getElementById( m );
+						// Check parentNode to catch when Blackberry 4.6 returns
+						// nodes that are no longer in the document #6963
+						if ( elem && elem.parentNode ) {
+							// Handle the case where IE, Opera, and Webkit return items
+							// by name instead of ID
+							if ( elem.id === m ) {
+								results.push( elem );
+								return results;
+							}
+						} else {
+							return results;
+						}
+					} else {
+						// Context is not a document
+						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
+							contains( context, elem ) && elem.id === m ) {
+							results.push( elem );
+							return results;
+						}
+					}
+
+				// Speed-up: Sizzle("TAG")
+				} else if ( match[2] ) {
+					push.apply( results, context.getElementsByTagName( selector ) );
+					return results;
+
+				// Speed-up: Sizzle(".CLASS")
+				} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
+					push.apply( results, context.getElementsByClassName( m ) );
+					return results;
+				}
+			}
+
+			// QSA path
+			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
+				nid = old = expando;
+				newContext = context;
+				newSelector = nodeType === 9 && selector;
+
+				// qSA works strangely on Element-rooted queries
+				// We can work around this by specifying an extra ID on the root
+				// and working up from there (Thanks to Andrew Dupont for the technique)
+				// IE 8 doesn't work on object elements
+				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
+					groups = tokenize( selector );
+
+					if ( (old = context.getAttribute("id")) ) {
+						nid = old.replace( rescape, "\\$&" );
+					} else {
+						context.setAttribute( "id", nid );
+					}
+					nid = "[id='" + nid + "'] ";
+
+					i = groups.length;
+					while ( i-- ) {
+						groups[i] = nid + toSelector( groups[i] );
+					}
+					newContext = rsibling.test( selector ) && context.parentNode || context;
+					newSelector = groups.join(",");
+				}
+
+				if ( newSelector ) {
+					try {
+						push.apply( results,
+							newContext.querySelectorAll( newSelector )
+						);
+						return results;
+					} catch(qsaError) {
+					} finally {
+						if ( !old ) {
+							context.removeAttribute("id");
+						}
+					}
+				}
+			}
+		}
+
+		// All others
+		return select( selector.replace( rtrim, "$1" ), context, results, seed );
+	}
+
+	/**
+	 * Detect xml
+	 * @param {Element|Object} elem An element or a document
+	 */
+	isXML = Sizzle.isXML = function( elem ) {
+		// documentElement is verified for cases where it doesn't yet exist
+		// (such as loading iframes in IE - #4833)
+		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
+		return documentElement ? documentElement.nodeName !== "HTML" : false;
+	};
+
+	/**
+	 * Sets document-related variables once based on the current document
+	 * @param {Element|Object} [doc] An element or document object to use to set the document
+	 * @returns {Object} Returns the current document
+	 */
+	setDocument = Sizzle.setDocument = function( node ) {
+		var doc = node ? node.ownerDocument || node : preferredDoc;
+
+		// If no document and documentElement is available, return
+		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
+			return document;
+		}
+
+		// Set our document
+		document = doc;
+		docElem = doc.documentElement;
+
+		// Support tests
+		documentIsHTML = !isXML( doc );
+
+		// Check if getElementsByTagName("*") returns only elements
+		support.getElementsByTagName = assert(function( div ) {
+			div.appendChild( doc.createComment("") );
+			return !div.getElementsByTagName("*").length;
+		});
+
+		// Support: IE<8
+		// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
+		support.attributes = assert(function( div ) {
+			div.className = "i";
+			return !div.getAttribute("className");
+		});
+
+		// Check if getElementsByClassName can be trusted
+		support.getElementsByClassName = assert(function( div ) {
+			div.innerHTML = "<div class='a'></div><div class='a i'></div>";
+
+			// Support: Safari<4
+			// Catch class over-caching
+			div.firstChild.className = "i";
+			// Support: Opera<10
+			// Catch gEBCN failure to find non-leading classes
+			return div.getElementsByClassName("i").length === 2;
+		});
+
+		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
+		// Detached nodes confoundingly follow *each other*
+		support.sortDetached = assert(function( div1 ) {
+			// Should return 1, but returns 4 (following)
+			return div1.compareDocumentPosition( document.createElement("div") ) & 1;
+		});
+
+		// Support: IE<10
+		// Check if getElementById returns elements by name
+		// Support: Windows 8 Native Apps
+		// Assigning innerHTML with "name" attributes throws uncatchable exceptions
+		// (http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx)
+		// and the broken getElementById methods don't pick up programatically-set names,
+		// so use a roundabout getElementsByName test
+		support.getById = assert(function( div ) {
+			docElem.appendChild( div ).id = expando;
+			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
+		});
+
+		// ID find and filter
+		if ( support.getById ) {
+			Expr.find["ID"] = function( id, context ) {
+				if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
+					var m = context.getElementById( id );
+					// Check parentNode to catch when Blackberry 4.6 returns
+					// nodes that are no longer in the document #6963
+					return m && m.parentNode ? [m] : [];
+				}
+			};
+			Expr.filter["ID"] = function( id ) {
+				var attrId = id.replace( runescape, funescape );
+				return function( elem ) {
+					return elem.getAttribute("id") === attrId;
+				};
+			};
+		} else {
+			Expr.find["ID"] = function( id, context ) {
+				if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
+					var m = context.getElementById( id );
+
+					return m ?
+						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
+							[m] :
+							undefined :
+						[];
+				}
+			};
+			Expr.filter["ID"] =  function( id ) {
+				var attrId = id.replace( runescape, funescape );
+				return function( elem ) {
+					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
+					return node && node.value === attrId;
+				};
+			};
+		}
+
+		// Tag
+		Expr.find["TAG"] = support.getElementsByTagName ?
+			function( tag, context ) {
+				if ( typeof context.getElementsByTagName !== strundefined ) {
+					return context.getElementsByTagName( tag );
+				}
+			} :
+			function( tag, context ) {
+				var elem,
+					tmp = [],
+					i = 0,
+					results = context.getElementsByTagName( tag );
+
+				// Filter out possible comments
+				if ( tag === "*" ) {
+					while ( (elem = results[i++]) ) {
+						if ( elem.nodeType === 1 ) {
+							tmp.push( elem );
+						}
+					}
+
+					return tmp;
+				}
+				return results;
+			};
+
+		// Class
+		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
+			if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
+				return context.getElementsByClassName( className );
+			}
+		};
+
+		// QSA and matchesSelector support
+
+		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
+		rbuggyMatches = [];
+
+		// qSa(:focus) reports false when true (Chrome 21)
+		// We allow this because of a bug in IE8/9 that throws an error
+		// whenever `document.activeElement` is accessed on an iframe
+		// So, we allow :focus to pass through QSA all the time to avoid the IE error
+		// See http://bugs.jquery.com/ticket/13378
+		rbuggyQSA = [];
+
+		if ( (support.qsa = isNative(doc.querySelectorAll)) ) {
+			// Build QSA regex
+			// Regex strategy adopted from Diego Perini
+			assert(function( div ) {
+				// Select is set to empty string on purpose
+				// This is to test IE's treatment of not explicitly
+				// setting a boolean content attribute,
+				// since its presence should be enough
+				// http://bugs.jquery.com/ticket/12359
+				div.innerHTML = "<select><option selected=''></option></select>";
+
+				// Support: IE8
+				// Boolean attributes and "value" are not treated correctly
+				if ( !div.querySelectorAll("[selected]").length ) {
+					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
+				}
+
+				// Webkit/Opera - :checked should return selected option elements
+				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
+				// IE8 throws error here and will not see later tests
+				if ( !div.querySelectorAll(":checked").length ) {
+					rbuggyQSA.push(":checked");
+				}
+			});
+
+			assert(function( div ) {
+
+				// Support: Opera 10-12/IE8
+				// ^= $= *= and empty values
+				// Should not select anything
+				// Support: Windows 8 Native Apps
+				// The type attribute is restricted during .innerHTML assignment
+				var input = document.createElement("input");
+				input.setAttribute( "type", "hidden" );
+				div.appendChild( input ).setAttribute( "t", "" );
+
+				if ( div.querySelectorAll("[t^='']").length ) {
+					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
+				}
+
+				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
+				// IE8 throws error here and will not see later tests
+				if ( !div.querySelectorAll(":enabled").length ) {
+					rbuggyQSA.push( ":enabled", ":disabled" );
+				}
+
+				// Opera 10-11 does not throw on post-comma invalid pseudos
+				div.querySelectorAll("*,:x");
+				rbuggyQSA.push(",.*:");
+			});
+		}
+
+		if ( (support.matchesSelector = isNative( (matches = docElem.webkitMatchesSelector ||
+			docElem.mozMatchesSelector ||
+			docElem.oMatchesSelector ||
+			docElem.msMatchesSelector) )) ) {
+
+			assert(function( div ) {
+				// Check to see if it's possible to do matchesSelector
+				// on a disconnected node (IE 9)
+				support.disconnectedMatch = matches.call( div, "div" );
+
+				// This should fail with an exception
+				// Gecko does not error, returns false instead
+				matches.call( div, "[s!='']:x" );
+				rbuggyMatches.push( "!=", pseudos );
+			});
+		}
+
+		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
+		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
+
+		// Element contains another
+		// Purposefully does not implement inclusive descendent
+		// As in, an element does not contain itself
+		contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
+			function( a, b ) {
+				var adown = a.nodeType === 9 ? a.documentElement : a,
+					bup = b && b.parentNode;
+				return a === bup || !!( bup && bup.nodeType === 1 && (
+					adown.contains ?
+						adown.contains( bup ) :
+						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
+				));
+			} :
+			function( a, b ) {
+				if ( b ) {
+					while ( (b = b.parentNode) ) {
+						if ( b === a ) {
+							return true;
+						}
+					}
+				}
+				return false;
+			};
+
+		// Document order sorting
+		sortOrder = docElem.compareDocumentPosition ?
+		function( a, b ) {
+
+			// Flag for duplicate removal
+			if ( a === b ) {
+				hasDuplicate = true;
+				return 0;
+			}
+
+			var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );
+
+			if ( compare ) {
+				// Disconnected nodes
+				if ( compare & 1 ||
+					(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
+
+					// Choose the first element that is related to our preferred document
+					if ( a === doc || contains(preferredDoc, a) ) {
+						return -1;
+					}
+					if ( b === doc || contains(preferredDoc, b) ) {
+						return 1;
+					}
+
+					// Maintain original order
+					return sortInput ?
+						( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
+						0;
+				}
+
+				return compare & 4 ? -1 : 1;
+			}
+
+			// Not directly comparable, sort on existence of method
+			return a.compareDocumentPosition ? -1 : 1;
+		} :
+		function( a, b ) {
+			var cur,
+				i = 0,
+				aup = a.parentNode,
+				bup = b.parentNode,
+				ap = [ a ],
+				bp = [ b ];
+
+			// Exit early if the nodes are identical
+			if ( a === b ) {
+				hasDuplicate = true;
+				return 0;
+
+			// Parentless nodes are either documents or disconnected
+			} else if ( !aup || !bup ) {
+				return a === doc ? -1 :
+					b === doc ? 1 :
+					aup ? -1 :
+					bup ? 1 :
+					sortInput ?
+					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
+					0;
+
+			// If the nodes are siblings, we can do a quick check
+			} else if ( aup === bup ) {
+				return siblingCheck( a, b );
+			}
+
+			// Otherwise we need full lists of their ancestors for comparison
+			cur = a;
+			while ( (cur = cur.parentNode) ) {
+				ap.unshift( cur );
+			}
+			cur = b;
+			while ( (cur = cur.parentNode) ) {
+				bp.unshift( cur );
+			}
+
+			// Walk down the tree looking for a discrepancy
+			while ( ap[i] === bp[i] ) {
+				i++;
+			}
+
+			return i ?
+				// Do a sibling check if the nodes have a common ancestor
+				siblingCheck( ap[i], bp[i] ) :
+
+				// Otherwise nodes in our document sort first
+				ap[i] === preferredDoc ? -1 :
+				bp[i] === preferredDoc ? 1 :
+				0;
+		};
+
+		return document;
+	};
+
+	Sizzle.matches = function( expr, elements ) {
+		return Sizzle( expr, null, null, elements );
+	};
+
+	Sizzle.matchesSelector = function( elem, expr ) {
+		// Set document vars if needed
+		if ( ( elem.ownerDocument || elem ) !== document ) {
+			setDocument( elem );
+		}
+
+		// Make sure that attribute selectors are quoted
+		expr = expr.replace( rattributeQuotes, "='$1']" );
+
+		// rbuggyQSA always contains :focus, so no need for an existence check
+		if ( support.matchesSelector && documentIsHTML &&
+			(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
+			(!rbuggyQSA     || !rbuggyQSA.test(expr)) ) {
+
+			try {
+				var ret = matches.call( elem, expr );
+
+				// IE 9's matchesSelector returns false on disconnected nodes
+				if ( ret || support.disconnectedMatch ||
+						// As well, disconnected nodes are said to be in a document
+						// fragment in IE 9
+						elem.document && elem.document.nodeType !== 11 ) {
+					return ret;
+				}
+			} catch(e) {}
+		}
+
+		return Sizzle( expr, document, null, [elem] ).length > 0;
+	};
+
+	Sizzle.contains = function( context, elem ) {
+		// Set document vars if needed
+		if ( ( context.ownerDocument || context ) !== document ) {
+			setDocument( context );
+		}
+		return contains( context, elem );
+	};
+
+	Sizzle.attr = function( elem, name ) {
+		// Set document vars if needed
+		if ( ( elem.ownerDocument || elem ) !== document ) {
+			setDocument( elem );
+		}
+
+		var fn = Expr.attrHandle[ name.toLowerCase() ],
+			val = fn && fn( elem, name, !documentIsHTML );
+
+		return val === undefined ?
+			support.attributes || !documentIsHTML ?
+				elem.getAttribute( name ) :
+				(val = elem.getAttributeNode(name)) && val.specified ?
+					val.value :
+					null :
+			val;
+	};
+
+	Sizzle.error = function( msg ) {
+		throw new Error( "Syntax error, unrecognized expression: " + msg );
+	};
+
+	// Document sorting and removing duplicates
+	Sizzle.uniqueSort = function( results ) {
+		var elem,
+			duplicates = [],
+			j = 0,
+			i = 0;
+
+		// Unless we *know* we can detect duplicates, assume their presence
+		hasDuplicate = !support.detectDuplicates;
+		sortInput = !support.sortStable && results.slice( 0 );
+		results.sort( sortOrder );
+
+		if ( hasDuplicate ) {
+			while ( (elem = results[i++]) ) {
+				if ( elem === results[ i ] ) {
+					j = duplicates.push( i );
+				}
+			}
+			while ( j-- ) {
+				results.splice( duplicates[ j ], 1 );
+			}
+		}
+
+		return results;
+	};
+
+	/**
+	 * Checks document order of two siblings
+	 * @param {Element} a
+	 * @param {Element} b
+	 * @returns Returns -1 if a precedes b, 1 if a follows b
+	 */
+	function siblingCheck( a, b ) {
+		var cur = b && a,
+			diff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );
+
+		// Use IE sourceIndex if available on both nodes
+		if ( diff ) {
+			return diff;
+		}
+
+		// Check if b follows a
+		if ( cur ) {
+			while ( (cur = cur.nextSibling) ) {
+				if ( cur === b ) {
+					return -1;
+				}
+			}
+		}
+
+		return a ? 1 : -1;
+	}
+
+	// Fetches boolean attributes by node
+	function boolHandler( elem, name, isXML ) {
+		var val;
+		return isXML ?
+			undefined :
+			(val = elem.getAttributeNode( name )) && val.specified ?
+				val.value :
+				elem[ name ] === true ? name.toLowerCase() : null;
+	}
+
+	// Fetches attributes without interpolation
+	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
+	function interpolationHandler( elem, name, isXML ) {
+		var val;
+		return isXML ?
+			undefined :
+			(val = elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 ));
+	}
+
+	// Returns a function to use in pseudos for input types
+	function createInputPseudo( type ) {
+		return function( elem ) {
+			var name = elem.nodeName.toLowerCase();
+			return name === "input" && elem.type === type;
+		};
+	}
+
+	// Returns a function to use in pseudos for buttons
+	function createButtonPseudo( type ) {
+		return function( elem ) {
+			var name = elem.nodeName.toLowerCase();
+			return (name === "input" || name === "button") && elem.type === type;
+		};
+	}
+
+	// Returns a function to use in pseudos for positionals
+	function createPositionalPseudo( fn ) {
+		return markFunction(function( argument ) {
+			argument = +argument;
+			return markFunction(function( seed, matches ) {
+				var j,
+					matchIndexes = fn( [], seed.length, argument ),
+					i = matchIndexes.length;
+
+				// Match elements found at the specified indexes
+				while ( i-- ) {
+					if ( seed[ (j = matchIndexes[i]) ] ) {
+						seed[j] = !(matches[j] = seed[j]);
+					}
+				}
+			});
+		});
+	}
+
+	/**
+	 * Utility function for retrieving the text value of an array of DOM nodes
+	 * @param {Array|Element} elem
+	 */
+	getText = Sizzle.getText = function( elem ) {
+		var node,
+			ret = "",
+			i = 0,
+			nodeType = elem.nodeType;
+
+		if ( !nodeType ) {
+			// If no nodeType, this is expected to be an array
+			for ( ; (node = elem[i]); i++ ) {
+				// Do not traverse comment nodes
+				ret += getText( node );
+			}
+		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
+			// Use textContent for elements
+			// innerText usage removed for consistency of new lines (see #11153)
+			if ( typeof elem.textContent === "string" ) {
+				return elem.textContent;
+			} else {
+				// Traverse its children
+				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
+					ret += getText( elem );
+				}
+			}
+		} else if ( nodeType === 3 || nodeType === 4 ) {
+			return elem.nodeValue;
+		}
+		// Do not include comment or processing instruction nodes
+
+		return ret;
+	};
+
+	Expr = Sizzle.selectors = {
+
+		// Can be adjusted by the user
+		cacheLength: 50,
+
+		createPseudo: markFunction,
+
+		match: matchExpr,
+
+		attrHandle: {},
+
+		find: {},
+
+		relative: {
+			">": { dir: "parentNode", first: true },
+			" ": { dir: "parentNode" },
+			"+": { dir: "previousSibling", first: true },
+			"~": { dir: "previousSibling" }
+		},
+
+		preFilter: {
+			"ATTR": function( match ) {
+				match[1] = match[1].replace( runescape, funescape );
+
+				// Move the given value to match[3] whether quoted or unquoted
+				match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );
+
+				if ( match[2] === "~=" ) {
+					match[3] = " " + match[3] + " ";
+				}
+
+				return match.slice( 0, 4 );
+			},
+
+			"CHILD": function( match ) {
+				/* matches from matchExpr["CHILD"]
+					1 type (only|nth|...)
+					2 what (child|of-type)
+					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
+					4 xn-component of xn+y argument ([+-]?\d*n|)
+					5 sign of xn-component
+					6 x of xn-component
+					7 sign of y-component
+					8 y of y-component
+				*/
+				match[1] = match[1].toLowerCase();
+
+				if ( match[1].slice( 0, 3 ) === "nth" ) {
+					// nth-* requires argument
+					if ( !match[3] ) {
+						Sizzle.error( match[0] );
+					}
+
+					// numeric x and y parameters for Expr.filter.CHILD
+					// remember that false/true cast respectively to 0/1
+					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
+					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
+
+				// other types prohibit arguments
+				} else if ( match[3] ) {
+					Sizzle.error( match[0] );
+				}
+
+				return match;
+			},
+
+			"PSEUDO": function( match ) {
+				var excess,
+					unquoted = !match[5] && match[2];
+
+				if ( matchExpr["CHILD"].test( match[0] ) ) {
+					return null;
+				}
+
+				// Accept quoted arguments as-is
+				if ( match[4] ) {
+					match[2] = match[4];
+
+				// Strip excess characters from unquoted arguments
+				} else if ( unquoted && rpseudo.test( unquoted ) &&
+					// Get excess from tokenize (recursively)
+					(excess = tokenize( unquoted, true )) &&
+					// advance to the next closing parenthesis
+					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
+
+					// excess is a negative index
+					match[0] = match[0].slice( 0, excess );
+					match[2] = unquoted.slice( 0, excess );
+				}
+
+				// Return only captures needed by the pseudo filter method (type and argument)
+				return match.slice( 0, 3 );
+			}
+		},
+
+		filter: {
+
+			"TAG": function( nodeNameSelector ) {
+				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
+				return nodeNameSelector === "*" ?
+					function() { return true; } :
+					function( elem ) {
+						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
+					};
+			},
+
+			"CLASS": function( className ) {
+				var pattern = classCache[ className + " " ];
+
+				return pattern ||
+					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
+					classCache( className, function( elem ) {
+						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
+					});
+			},
+
+			"ATTR": function( name, operator, check ) {
+				return function( elem ) {
+					var result = Sizzle.attr( elem, name );
+
+					if ( result == null ) {
+						return operator === "!=";
+					}
+					if ( !operator ) {
+						return true;
+					}
+
+					result += "";
+
+					return operator === "=" ? result === check :
+						operator === "!=" ? result !== check :
+						operator === "^=" ? check && result.indexOf( check ) === 0 :
+						operator === "*=" ? check && result.indexOf( check ) > -1 :
+						operator === "$=" ? check && result.slice( -check.length ) === check :
+						operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
+						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
+						false;
+				};
+			},
+
+			"CHILD": function( type, what, argument, first, last ) {
+				var simple = type.slice( 0, 3 ) !== "nth",
+					forward = type.slice( -4 ) !== "last",
+					ofType = what === "of-type";
+
+				return first === 1 && last === 0 ?
+
+					// Shortcut for :nth-*(n)
+					function( elem ) {
+						return !!elem.parentNode;
+					} :
+
+					function( elem, context, xml ) {
+						var cache, outerCache, node, diff, nodeIndex, start,
+							dir = simple !== forward ? "nextSibling" : "previousSibling",
+							parent = elem.parentNode,
+							name = ofType && elem.nodeName.toLowerCase(),
+							useCache = !xml && !ofType;
+
+						if ( parent ) {
+
+							// :(first|last|only)-(child|of-type)
+							if ( simple ) {
+								while ( dir ) {
+									node = elem;
+									while ( (node = node[ dir ]) ) {
+										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
+											return false;
+										}
+									}
+									// Reverse direction for :only-* (if we haven't yet done so)
+									start = dir = type === "only" && !start && "nextSibling";
+								}
+								return true;
+							}
+
+							start = [ forward ? parent.firstChild : parent.lastChild ];
+
+							// non-xml :nth-child(...) stores cache data on `parent`
+							if ( forward && useCache ) {
+								// Seek `elem` from a previously-cached index
+								outerCache = parent[ expando ] || (parent[ expando ] = {});
+								cache = outerCache[ type ] || [];
+								nodeIndex = cache[0] === dirruns && cache[1];
+								diff = cache[0] === dirruns && cache[2];
+								node = nodeIndex && parent.childNodes[ nodeIndex ];
+
+								while ( (node = ++nodeIndex && node && node[ dir ] ||
+
+									// Fallback to seeking `elem` from the start
+									(diff = nodeIndex = 0) || start.pop()) ) {
+
+									// When found, cache indexes on `parent` and break
+									if ( node.nodeType === 1 && ++diff && node === elem ) {
+										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
+										break;
+									}
+								}
+
+							// Use previously-cached element index if available
+							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
+								diff = cache[1];
+
+							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
+							} else {
+								// Use the same loop as above to seek `elem` from the start
+								while ( (node = ++nodeIndex && node && node[ dir ] ||
+									(diff = nodeIndex = 0) || start.pop()) ) {
+
+									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
+										// Cache the index of each encountered element
+										if ( useCache ) {
+											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
+										}
+
+										if ( node === elem ) {
+											break;
+										}
+									}
+								}
+							}
+
+							// Incorporate the offset, then check against cycle size
+							diff -= last;
+							return diff === first || ( diff % first === 0 && diff / first >= 0 );
+						}
+					};
+			},
+
+			"PSEUDO": function( pseudo, argument ) {
+				// pseudo-class names are case-insensitive
+				// http://www.w3.org/TR/selectors/#pseudo-classes
+				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
+				// Remember that setFilters inherits from pseudos
+				var args,
+					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
+						Sizzle.error( "unsupported pseudo: " + pseudo );
+
+				// The user may use createPseudo to indicate that
+				// arguments are needed to create the filter function
+				// just as Sizzle does
+				if ( fn[ expando ] ) {
+					return fn( argument );
+				}
+
+				// But maintain support for old signatures
+				if ( fn.length > 1 ) {
+					args = [ pseudo, pseudo, "", argument ];
+					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
+						markFunction(function( seed, matches ) {
+							var idx,
+								matched = fn( seed, argument ),
+								i = matched.length;
+							while ( i-- ) {
+								idx = indexOf.call( seed, matched[i] );
+								seed[ idx ] = !( matches[ idx ] = matched[i] );
+							}
+						}) :
+						function( elem ) {
+							return fn( elem, 0, args );
+						};
+				}
+
+				return fn;
+			}
+		},
+
+		pseudos: {
+			// Potentially complex pseudos
+			"not": markFunction(function( selector ) {
+				// Trim the selector passed to compile
+				// to avoid treating leading and trailing
+				// spaces as combinators
+				var input = [],
+					results = [],
+					matcher = compile( selector.replace( rtrim, "$1" ) );
+
+				return matcher[ expando ] ?
+					markFunction(function( seed, matches, context, xml ) {
+						var elem,
+							unmatched = matcher( seed, null, xml, [] ),
+							i = seed.length;
+
+						// Match elements unmatched by `matcher`
+						while ( i-- ) {
+							if ( (elem = unmatched[i]) ) {
+								seed[i] = !(matches[i] = elem);
+							}
+						}
+					}) :
+					function( elem, context, xml ) {
+						input[0] = elem;
+						matcher( input, null, xml, results );
+						return !results.pop();
+					};
+			}),
+
+			"has": markFunction(function( selector ) {
+				return function( elem ) {
+					return Sizzle( selector, elem ).length > 0;
+				};
+			}),
+
+			"contains": markFunction(function( text ) {
+				return function( elem ) {
+					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
+				};
+			}),
+
+			// "Whether an element is represented by a :lang() selector
+			// is based solely on the element's language value
+			// being equal to the identifier C,
+			// or beginning with the identifier C immediately followed by "-".
+			// The matching of C against the element's language value is performed case-insensitively.
+			// The identifier C does not have to be a valid language name."
+			// http://www.w3.org/TR/selectors/#lang-pseudo
+			"lang": markFunction( function( lang ) {
+				// lang value must be a valid identifier
+				if ( !ridentifier.test(lang || "") ) {
+					Sizzle.error( "unsupported lang: " + lang );
+				}
+				lang = lang.replace( runescape, funescape ).toLowerCase();
+				return function( elem ) {
+					var elemLang;
+					do {
+						if ( (elemLang = documentIsHTML ?
+							elem.lang :
+							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
+
+							elemLang = elemLang.toLowerCase();
+							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
+						}
+					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
+					return false;
+				};
+			}),
+
+			// Miscellaneous
+			"target": function( elem ) {
+				var hash = window.location && window.location.hash;
+				return hash && hash.slice( 1 ) === elem.id;
+			},
+
+			"root": function( elem ) {
+				return elem === docElem;
+			},
+
+			"focus": function( elem ) {
+				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
+			},
+
+			// Boolean properties
+			"enabled": function( elem ) {
+				return elem.disabled === false;
+			},
+
+			"disabled": function( elem ) {
+				return elem.disabled === true;
+			},
+
+			"checked": function( elem ) {
+				// In CSS3, :checked should return both checked and selected elements
+				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
+				var nodeName = elem.nodeName.toLowerCase();
+				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
+			},
+
+			"selected": function( elem ) {
+				// Accessing this property makes selected-by-default
+				// options in Safari work properly
+				if ( elem.parentNode ) {
+					elem.parentNode.selectedIndex;
+				}
+
+				return elem.selected === true;
+			},
+
+			// Contents
+			"empty": function( elem ) {
+				// http://www.w3.org/TR/selectors/#empty-pseudo
+				// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
+				//   not comment, processing instructions, or others
+				// Thanks to Diego Perini for the nodeName shortcut
+				//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
+				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
+					if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
+						return false;
+					}
+				}
+				return true;
+			},
+
+			"parent": function( elem ) {
+				return !Expr.pseudos["empty"]( elem );
+			},
+
+			// Element/input types
+			"header": function( elem ) {
+				return rheader.test( elem.nodeName );
+			},
+
+			"input": function( elem ) {
+				return rinputs.test( elem.nodeName );
+			},
+
+			"button": function( elem ) {
+				var name = elem.nodeName.toLowerCase();
+				return name === "input" && elem.type === "button" || name === "button";
+			},
+
+			"text": function( elem ) {
+				var attr;
+				// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
+				// use getAttribute instead to test this case
+				return elem.nodeName.toLowerCase() === "input" &&
+					elem.type === "text" &&
+					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
+			},
+
+			// Position-in-collection
+			"first": createPositionalPseudo(function() {
+				return [ 0 ];
+			}),
+
+			"last": createPositionalPseudo(function( matchIndexes, length ) {
+				return [ length - 1 ];
+			}),
+
+			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
+				return [ argument < 0 ? argument + length : argument ];
+			}),
+
+			"even": createPositionalPseudo(function( matchIndexes, length ) {
+				var i = 0;
+				for ( ; i < length; i += 2 ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			}),
+
+			"odd": createPositionalPseudo(function( matchIndexes, length ) {
+				var i = 1;
+				for ( ; i < length; i += 2 ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			}),
+
+			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
+				var i = argument < 0 ? argument + length : argument;
+				for ( ; --i >= 0; ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			}),
+
+			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
+				var i = argument < 0 ? argument + length : argument;
+				for ( ; ++i < length; ) {
+					matchIndexes.push( i );
+				}
+				return matchIndexes;
+			})
+		}
+	};
+
+	// Add button/input type pseudos
+	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
+		Expr.pseudos[ i ] = createInputPseudo( i );
+	}
+	for ( i in { submit: true, reset: true } ) {
+		Expr.pseudos[ i ] = createButtonPseudo( i );
+	}
+
+	function tokenize( selector, parseOnly ) {
+		var matched, match, tokens, type,
+			soFar, groups, preFilters,
+			cached = tokenCache[ selector + " " ];
+
+		if ( cached ) {
+			return parseOnly ? 0 : cached.slice( 0 );
+		}
+
+		soFar = selector;
+		groups = [];
+		preFilters = Expr.preFilter;
+
+		while ( soFar ) {
+
+			// Comma and first run
+			if ( !matched || (match = rcomma.exec( soFar )) ) {
+				if ( match ) {
+					// Don't consume trailing commas as valid
+					soFar = soFar.slice( match[0].length ) || soFar;
+				}
+				groups.push( tokens = [] );
+			}
+
+			matched = false;
+
+			// Combinators
+			if ( (match = rcombinators.exec( soFar )) ) {
+				matched = match.shift();
+				tokens.push( {
+					value: matched,
+					// Cast descendant combinators to space
+					type: match[0].replace( rtrim, " " )
+				} );
+				soFar = soFar.slice( matched.length );
+			}
+
+			// Filters
+			for ( type in Expr.filter ) {
+				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
+					(match = preFilters[ type ]( match ))) ) {
+					matched = match.shift();
+					tokens.push( {
+						value: matched,
+						type: type,
+						matches: match
+					} );
+					soFar = soFar.slice( matched.length );
+				}
+			}
+
+			if ( !matched ) {
+				break;
+			}
+		}
+
+		// Return the length of the invalid excess
+		// if we're just parsing
+		// Otherwise, throw an error or return tokens
+		return parseOnly ?
+			soFar.length :
+			soFar ?
+				Sizzle.error( selector ) :
+				// Cache the tokens
+				tokenCache( selector, groups ).slice( 0 );
+	}
+
+	function toSelector( tokens ) {
+		var i = 0,
+			len = tokens.length,
+			selector = "";
+		for ( ; i < len; i++ ) {
+			selector += tokens[i].value;
+		}
+		return selector;
+	}
+
+	function addCombinator( matcher, combinator, base ) {
+		var dir = combinator.dir,
+			checkNonElements = base && dir === "parentNode",
+			doneName = done++;
+
+		return combinator.first ?
+			// Check against closest ancestor/preceding element
+			function( elem, context, xml ) {
+				while ( (elem = elem[ dir ]) ) {
+					if ( elem.nodeType === 1 || checkNonElements ) {
+						return matcher( elem, context, xml );
+					}
+				}
+			} :
+
+			// Check against all ancestor/preceding elements
+			function( elem, context, xml ) {
+				var data, cache, outerCache,
+					dirkey = dirruns + " " + doneName;
+
+				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
+				if ( xml ) {
+					while ( (elem = elem[ dir ]) ) {
+						if ( elem.nodeType === 1 || checkNonElements ) {
+							if ( matcher( elem, context, xml ) ) {
+								return true;
+							}
+						}
+					}
+				} else {
+					while ( (elem = elem[ dir ]) ) {
+						if ( elem.nodeType === 1 || checkNonElements ) {
+							outerCache = elem[ expando ] || (elem[ expando ] = {});
+							if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
+								if ( (data = cache[1]) === true || data === cachedruns ) {
+									return data === true;
+								}
+							} else {
+								cache = outerCache[ dir ] = [ dirkey ];
+								cache[1] = matcher( elem, context, xml ) || cachedruns;
+								if ( cache[1] === true ) {
+									return true;
+								}
+							}
+						}
+					}
+				}
+			};
+	}
+
+	function elementMatcher( matchers ) {
+		return matchers.length > 1 ?
+			function( elem, context, xml ) {
+				var i = matchers.length;
+				while ( i-- ) {
+					if ( !matchers[i]( elem, context, xml ) ) {
+						return false;
+					}
+				}
+				return true;
+			} :
+			matchers[0];
+	}
+
+	function condense( unmatched, map, filter, context, xml ) {
+		var elem,
+			newUnmatched = [],
+			i = 0,
+			len = unmatched.length,
+			mapped = map != null;
+
+		for ( ; i < len; i++ ) {
+			if ( (elem = unmatched[i]) ) {
+				if ( !filter || filter( elem, context, xml ) ) {
+					newUnmatched.push( elem );
+					if ( mapped ) {
+						map.push( i );
+					}
+				}
+			}
+		}
+
+		return newUnmatched;
+	}
+
+	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
+		if ( postFilter && !postFilter[ expando ] ) {
+			postFilter = setMatcher( postFilter );
+		}
+		if ( postFinder && !postFinder[ expando ] ) {
+			postFinder = setMatcher( postFinder, postSelector );
+		}
+		return markFunction(function( seed, results, context, xml ) {
+			var temp, i, elem,
+				preMap = [],
+				postMap = [],
+				preexisting = results.length,
+
+				// Get initial elements from seed or context
+				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
+
+				// Prefilter to get matcher input, preserving a map for seed-results synchronization
+				matcherIn = preFilter && ( seed || !selector ) ?
+					condense( elems, preMap, preFilter, context, xml ) :
+					elems,
+
+				matcherOut = matcher ?
+					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
+					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
+
+						// ...intermediate processing is necessary
+						[] :
+
+						// ...otherwise use results directly
+						results :
+					matcherIn;
+
+			// Find primary matches
+			if ( matcher ) {
+				matcher( matcherIn, matcherOut, context, xml );
+			}
+
+			// Apply postFilter
+			if ( postFilter ) {
+				temp = condense( matcherOut, postMap );
+				postFilter( temp, [], context, xml );
+
+				// Un-match failing elements by moving them back to matcherIn
+				i = temp.length;
+				while ( i-- ) {
+					if ( (elem = temp[i]) ) {
+						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
+					}
+				}
+			}
+
+			if ( seed ) {
+				if ( postFinder || preFilter ) {
+					if ( postFinder ) {
+						// Get the final matcherOut by condensing this intermediate into postFinder contexts
+						temp = [];
+						i = matcherOut.length;
+						while ( i-- ) {
+							if ( (elem = matcherOut[i]) ) {
+								// Restore matcherIn since elem is not yet a final match
+								temp.push( (matcherIn[i] = elem) );
+							}
+						}
+						postFinder( null, (matcherOut = []), temp, xml );
+					}
+
+					// Move matched elements from seed to results to keep them synchronized
+					i = matcherOut.length;
+					while ( i-- ) {
+						if ( (elem = matcherOut[i]) &&
+							(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {
+
+							seed[temp] = !(results[temp] = elem);
+						}
+					}
+				}
+
+			// Add elements to results, through postFinder if defined
+			} else {
+				matcherOut = condense(
+					matcherOut === results ?
+						matcherOut.splice( preexisting, matcherOut.length ) :
+						matcherOut
+				);
+				if ( postFinder ) {
+					postFinder( null, results, matcherOut, xml );
+				} else {
+					push.apply( results, matcherOut );
+				}
+			}
+		});
+	}
+
+	function matcherFromTokens( tokens ) {
+		var checkContext, matcher, j,
+			len = tokens.length,
+			leadingRelative = Expr.relative[ tokens[0].type ],
+			implicitRelative = leadingRelative || Expr.relative[" "],
+			i = leadingRelative ? 1 : 0,
+
+			// The foundational matcher ensures that elements are reachable from top-level context(s)
+			matchContext = addCombinator( function( elem ) {
+				return elem === checkContext;
+			}, implicitRelative, true ),
+			matchAnyContext = addCombinator( function( elem ) {
+				return indexOf.call( checkContext, elem ) > -1;
+			}, implicitRelative, true ),
+			matchers = [ function( elem, context, xml ) {
+				return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
+					(checkContext = context).nodeType ?
+						matchContext( elem, context, xml ) :
+						matchAnyContext( elem, context, xml ) );
+			} ];
+
+		for ( ; i < len; i++ ) {
+			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
+				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
+			} else {
+				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
+
+				// Return special upon seeing a positional matcher
+				if ( matcher[ expando ] ) {
+					// Find the next relative operator (if any) for proper handling
+					j = ++i;
+					for ( ; j < len; j++ ) {
+						if ( Expr.relative[ tokens[j].type ] ) {
+							break;
+						}
+					}
+					return setMatcher(
+						i > 1 && elementMatcher( matchers ),
+						i > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, "$1" ),
+						matcher,
+						i < j && matcherFromTokens( tokens.slice( i, j ) ),
+						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
+						j < len && toSelector( tokens )
+					);
+				}
+				matchers.push( matcher );
+			}
+		}
+
+		return elementMatcher( matchers );
+	}
+
+	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
+		// A counter to specify which element is currently being matched
+		var matcherCachedRuns = 0,
+			bySet = setMatchers.length > 0,
+			byElement = elementMatchers.length > 0,
+			superMatcher = function( seed, context, xml, results, expandContext ) {
+				var elem, j, matcher,
+					setMatched = [],
+					matchedCount = 0,
+					i = "0",
+					unmatched = seed && [],
+					outermost = expandContext != null,
+					contextBackup = outermostContext,
+					// We must always have either seed elements or context
+					elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
+					// Use integer dirruns iff this is the outermost matcher
+					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);
+
+				if ( outermost ) {
+					outermostContext = context !== document && context;
+					cachedruns = matcherCachedRuns;
+				}
+
+				// Add elements passing elementMatchers directly to results
+				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
+				for ( ; (elem = elems[i]) != null; i++ ) {
+					if ( byElement && elem ) {
+						j = 0;
+						while ( (matcher = elementMatchers[j++]) ) {
+							if ( matcher( elem, context, xml ) ) {
+								results.push( elem );
+								break;
+							}
+						}
+						if ( outermost ) {
+							dirruns = dirrunsUnique;
+							cachedruns = ++matcherCachedRuns;
+						}
+					}
+
+					// Track unmatched elements for set filters
+					if ( bySet ) {
+						// They will have gone through all possible matchers
+						if ( (elem = !matcher && elem) ) {
+							matchedCount--;
+						}
+
+						// Lengthen the array for every element, matched or not
+						if ( seed ) {
+							unmatched.push( elem );
+						}
+					}
+				}
+
+				// Apply set filters to unmatched elements
+				matchedCount += i;
+				if ( bySet && i !== matchedCount ) {
+					j = 0;
+					while ( (matcher = setMatchers[j++]) ) {
+						matcher( unmatched, setMatched, context, xml );
+					}
+
+					if ( seed ) {
+						// Reintegrate element matches to eliminate the need for sorting
+						if ( matchedCount > 0 ) {
+							while ( i-- ) {
+								if ( !(unmatched[i] || setMatched[i]) ) {
+									setMatched[i] = pop.call( results );
+								}
+							}
+						}
+
+						// Discard index placeholder values to get only actual matches
+						setMatched = condense( setMatched );
+					}
+
+					// Add matches to results
+					push.apply( results, setMatched );
+
+					// Seedless set matches succeeding multiple successful matchers stipulate sorting
+					if ( outermost && !seed && setMatched.length > 0 &&
+						( matchedCount + setMatchers.length ) > 1 ) {
+
+						Sizzle.uniqueSort( results );
+					}
+				}
+
+				// Override manipulation of globals by nested matchers
+				if ( outermost ) {
+					dirruns = dirrunsUnique;
+					outermostContext = contextBackup;
+				}
+
+				return unmatched;
+			};
+
+		return bySet ?
+			markFunction( superMatcher ) :
+			superMatcher;
+	}
+
+	compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
+		var i,
+			setMatchers = [],
+			elementMatchers = [],
+			cached = compilerCache[ selector + " " ];
+
+		if ( !cached ) {
+			// Generate a function of recursive functions that can be used to check each element
+			if ( !group ) {
+				group = tokenize( selector );
+			}
+			i = group.length;
+			while ( i-- ) {
+				cached = matcherFromTokens( group[i] );
+				if ( cached[ expando ] ) {
+					setMatchers.push( cached );
+				} else {
+					elementMatchers.push( cached );
+				}
+			}
+
+			// Cache the compiled function
+			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
+		}
+		return cached;
+	};
+
+	function multipleContexts( selector, contexts, results ) {
+		var i = 0,
+			len = contexts.length;
+		for ( ; i < len; i++ ) {
+			Sizzle( selector, contexts[i], results );
+		}
+		return results;
+	}
+
+	function select( selector, context, results, seed ) {
+		var i, tokens, token, type, find,
+			match = tokenize( selector );
+
+		if ( !seed ) {
+			// Try to minimize operations if there is only one group
+			if ( match.length === 1 ) {
+
+				// Take a shortcut and set the context if the root selector is an ID
+				tokens = match[0] = match[0].slice( 0 );
+				if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
+						context.nodeType === 9 && documentIsHTML &&
+						Expr.relative[ tokens[1].type ] ) {
+
+					context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
+					if ( !context ) {
+						return results;
+					}
+
+					selector = selector.slice( tokens.shift().value.length );
+				}
+
+				// Fetch a seed set for right-to-left matching
+				i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
+				while ( i-- ) {
+					token = tokens[i];
+
+					// Abort if we hit a combinator
+					if ( Expr.relative[ (type = token.type) ] ) {
+						break;
+					}
+					if ( (find = Expr.find[ type ]) ) {
+						// Search, expanding context for leading sibling combinators
+						if ( (seed = find(
+							token.matches[0].replace( runescape, funescape ),
+							rsibling.test( tokens[0].type ) && context.parentNode || context
+						)) ) {
+
+							// If seed is empty or no tokens remain, we can return early
+							tokens.splice( i, 1 );
+							selector = seed.length && toSelector( tokens );
+							if ( !selector ) {
+								push.apply( results, seed );
+								return results;
+							}
+
+							break;
+						}
+					}
+				}
+			}
+		}
+
+		// Compile and execute a filtering function
+		// Provide `match` to avoid retokenization if we modified the selector above
+		compile( selector, match )(
+			seed,
+			context,
+			!documentIsHTML,
+			results,
+			rsibling.test( selector )
+		);
+		return results;
+	}
+
+	// Deprecated
+	Expr.pseudos["nth"] = Expr.pseudos["eq"];
+
+	// Easy API for creating new setFilters
+	function setFilters() {}
+	setFilters.prototype = Expr.filters = Expr.pseudos;
+	Expr.setFilters = new setFilters();
+
+	// One-time assignments
+
+	// Sort stability
+	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
+
+	// Initialize against the default document
+	setDocument();
+
+	// Support: Chrome<<14
+	// Always assume duplicates if they aren't passed to the comparison function
+	[0, 0].sort( sortOrder );
+	support.detectDuplicates = hasDuplicate;
+
+	// Support: IE<8
+	// Prevent attribute/property "interpolation"
+	assert(function( div ) {
+		div.innerHTML = "<a href='#'></a>";
+		if ( div.firstChild.getAttribute("href") !== "#" ) {
+			var attrs = "type|href|height|width".split("|"),
+				i = attrs.length;
+			while ( i-- ) {
+				Expr.attrHandle[ attrs[i] ] = interpolationHandler;
+			}
+		}
+	});
+
+	// Support: IE<9
+	// Use getAttributeNode to fetch booleans when getAttribute lies
+	assert(function( div ) {
+		if ( div.getAttribute("disabled") != null ) {
+			var attrs = booleans.split("|"),
+				i = attrs.length;
+			while ( i-- ) {
+				Expr.attrHandle[ attrs[i] ] = boolHandler;
+			}
+		}
+	});
+
+	jQuery.find = Sizzle;
+	jQuery.expr = Sizzle.selectors;
+	jQuery.expr[":"] = jQuery.expr.pseudos;
+	jQuery.unique = Sizzle.uniqueSort;
+	jQuery.text = Sizzle.getText;
+	jQuery.isXMLDoc = Sizzle.isXML;
+	jQuery.contains = Sizzle.contains;
+
+
+	})( window );
+	// String to Object options format cache
+	var optionsCache = {};
+
+	// Convert String-formatted options into Object-formatted ones and store in cache
+	function createOptions( options ) {
+		var object = optionsCache[ options ] = {};
+		jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
+			object[ flag ] = true;
+		});
+		return object;
+	}
+
+	/*
+	 * Create a callback list using the following parameters:
+	 *
+	 *	options: an optional list of space-separated options that will change how
+	 *			the callback list behaves or a more traditional option object
+	 *
+	 * By default a callback list will act like an event callback list and can be
+	 * "fired" multiple times.
+	 *
+	 * Possible options:
+	 *
+	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
+	 *
+	 *	memory:			will keep track of previous values and will call any callback added
+	 *					after the list has been fired right away with the latest "memorized"
+	 *					values (like a Deferred)
+	 *
+	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
+	 *
+	 *	stopOnFalse:	interrupt callings when a callback returns false
+	 *
+	 */
+	jQuery.Callbacks = function( options ) {
+
+		// Convert options from String-formatted to Object-formatted if needed
+		// (we check in cache first)
+		options = typeof options === "string" ?
+			( optionsCache[ options ] || createOptions( options ) ) :
+			jQuery.extend( {}, options );
+
+		var // Last fire value (for non-forgettable lists)
+			memory,
+			// Flag to know if list was already fired
+			fired,
+			// Flag to know if list is currently firing
+			firing,
+			// First callback to fire (used internally by add and fireWith)
+			firingStart,
+			// End of the loop when firing
+			firingLength,
+			// Index of currently firing callback (modified by remove if needed)
+			firingIndex,
+			// Actual callback list
+			list = [],
+			// Stack of fire calls for repeatable lists
+			stack = !options.once && [],
+			// Fire callbacks
+			fire = function( data ) {
+				memory = options.memory && data;
+				fired = true;
+				firingIndex = firingStart || 0;
+				firingStart = 0;
+				firingLength = list.length;
+				firing = true;
+				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
+					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
+						memory = false; // To prevent further calls using add
+						break;
+					}
+				}
+				firing = false;
+				if ( list ) {
+					if ( stack ) {
+						if ( stack.length ) {
+							fire( stack.shift() );
+						}
+					} else if ( memory ) {
+						list = [];
+					} else {
+						self.disable();
+					}
+				}
+			},
+			// Actual Callbacks object
+			self = {
+				// Add a callback or a collection of callbacks to the list
+				add: function() {
+					if ( list ) {
+						// First, we save the current length
+						var start = list.length;
+						(function add( args ) {
+							jQuery.each( args, function( _, arg ) {
+								var type = jQuery.type( arg );
+								if ( type === "function" ) {
+									if ( !options.unique || !self.has( arg ) ) {
+										list.push( arg );
+									}
+								} else if ( arg && arg.length && type !== "string" ) {
+									// Inspect recursively
+									add( arg );
+								}
+							});
+						})( arguments );
+						// Do we need to add the callbacks to the
+						// current firing batch?
+						if ( firing ) {
+							firingLength = list.length;
+						// With memory, if we're not firing then
+						// we should call right away
+						} else if ( memory ) {
+							firingStart = start;
+							fire( memory );
+						}
+					}
+					return this;
+				},
+				// Remove a callback from the list
+				remove: function() {
+					if ( list ) {
+						jQuery.each( arguments, function( _, arg ) {
+							var index;
+							while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
+								list.splice( index, 1 );
+								// Handle firing indexes
+								if ( firing ) {
+									if ( index <= firingLength ) {
+										firingLength--;
+									}
+									if ( index <= firingIndex ) {
+										firingIndex--;
+									}
+								}
+							}
+						});
+					}
+					return this;
+				},
+				// Check if a given callback is in the list.
+				// If no argument is given, return whether or not list has callbacks attached.
+				has: function( fn ) {
+					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
+				},
+				// Remove all callbacks from the list
+				empty: function() {
+					list = [];
+					firingLength = 0;
+					return this;
+				},
+				// Have the list do nothing anymore
+				disable: function() {
+					list = stack = memory = undefined;
+					return this;
+				},
+				// Is it disabled?
+				disabled: function() {
+					return !list;
+				},
+				// Lock the list in its current state
+				lock: function() {
+					stack = undefined;
+					if ( !memory ) {
+						self.disable();
+					}
+					return this;
+				},
+				// Is it locked?
+				locked: function() {
+					return !stack;
+				},
+				// Call all callbacks with the given context and arguments
+				fireWith: function( context, args ) {
+					args = args || [];
+					args = [ context, args.slice ? args.slice() : args ];
+					if ( list && ( !fired || stack ) ) {
+						if ( firing ) {
+							stack.push( args );
+						} else {
+							fire( args );
+						}
+					}
+					return this;
+				},
+				// Call all the callbacks with the given arguments
+				fire: function() {
+					self.fireWith( this, arguments );
+					return this;
+				},
+				// To know if the callbacks have already been called at least once
+				fired: function() {
+					return !!fired;
+				}
+			};
+
+		return self;
+	};
+	jQuery.extend({
+
+		Deferred: function( func ) {
+			var tuples = [
+					// action, add listener, listener list, final state
+					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
+					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
+					[ "notify", "progress", jQuery.Callbacks("memory") ]
+				],
+				state = "pending",
+				promise = {
+					state: function() {
+						return state;
+					},
+					always: function() {
+						deferred.done( arguments ).fail( arguments );
+						return this;
+					},
+					then: function( /* fnDone, fnFail, fnProgress */ ) {
+						var fns = arguments;
+						return jQuery.Deferred(function( newDefer ) {
+							jQuery.each( tuples, function( i, tuple ) {
+								var action = tuple[ 0 ],
+									fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
+								// deferred[ done | fail | progress ] for forwarding actions to newDefer
+								deferred[ tuple[1] ](function() {
+									var returned = fn && fn.apply( this, arguments );
+									if ( returned && jQuery.isFunction( returned.promise ) ) {
+										returned.promise()
+											.done( newDefer.resolve )
+											.fail( newDefer.reject )
+											.progress( newDefer.notify );
+									} else {
+										newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
+									}
+								});
+							});
+							fns = null;
+						}).promise();
+					},
+					// Get a promise for this deferred
+					// If obj is provided, the promise aspect is added to the object
+					promise: function( obj ) {
+						return obj != null ? jQuery.extend( obj, promise ) : promise;
+					}
+				},
+				deferred = {};
+
+			// Keep pipe for back-compat
+			promise.pipe = promise.then;
+
+			// Add list-specific methods
+			jQuery.each( tuples, function( i, tuple ) {
+				var list = tuple[ 2 ],
+					stateString = tuple[ 3 ];
+
+				// promise[ done | fail | progress ] = list.add
+				promise[ tuple[1] ] = list.add;
+
+				// Handle state
+				if ( stateString ) {
+					list.add(function() {
+						// state = [ resolved | rejected ]
+						state = stateString;
+
+					// [ reject_list | resolve_list ].disable; progress_list.lock
+					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
+				}
+
+				// deferred[ resolve | reject | notify ]
+				deferred[ tuple[0] ] = function() {
+					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
+					return this;
+				};
+				deferred[ tuple[0] + "With" ] = list.fireWith;
+			});
+
+			// Make the deferred a promise
+			promise.promise( deferred );
+
+			// Call given func if any
+			if ( func ) {
+				func.call( deferred, deferred );
+			}
+
+			// All done!
+			return deferred;
+		},
+
+		// Deferred helper
+		when: function( subordinate /* , ..., subordinateN */ ) {
+			var i = 0,
+				resolveValues = core_slice.call( arguments ),
+				length = resolveValues.length,
+
+				// the count of uncompleted subordinates
+				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
+
+				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
+				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
+
+				// Update function for both resolve and progress values
+				updateFunc = function( i, contexts, values ) {
+					return function( value ) {
+						contexts[ i ] = this;
+						values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
+						if( values === progressValues ) {
+							deferred.notifyWith( contexts, values );
+						} else if ( !( --remaining ) ) {
+							deferred.resolveWith( contexts, values );
+						}
+					};
+				},
+
+				progressValues, progressContexts, resolveContexts;
+
+			// add listeners to Deferred subordinates; treat others as resolved
+			if ( length > 1 ) {
+				progressValues = new Array( length );
+				progressContexts = new Array( length );
+				resolveContexts = new Array( length );
+				for ( ; i < length; i++ ) {
+					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
+						resolveValues[ i ].promise()
+							.done( updateFunc( i, resolveContexts, resolveValues ) )
+							.fail( deferred.reject )
+							.progress( updateFunc( i, progressContexts, progressValues ) );
+					} else {
+						--remaining;
+					}
+				}
+			}
+
+			// if we're not waiting on anything, resolve the master
+			if ( !remaining ) {
+				deferred.resolveWith( resolveContexts, resolveValues );
+			}
+
+			return deferred.promise();
+		}
+	});
+	jQuery.support = (function( support ) {
+		var input = document.createElement("input"),
+			fragment = document.createDocumentFragment(),
+			div = document.createElement("div"),
+			select = document.createElement("select"),
+			opt = select.appendChild( document.createElement("option") );
+
+		// Finish early in limited environments
+		if ( !input.type ) {
+			return support;
+		}
+
+		input.type = "checkbox";
+
+		// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
+		// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
+		support.checkOn = input.value !== "";
+
+		// Must access the parent to make an option select properly
+		// Support: IE9, IE10
+		support.optSelected = opt.selected;
+
+		// Will be defined later
+		support.reliableMarginRight = true;
+		support.boxSizingReliable = true;
+		support.pixelPosition = false;
+
+		// Make sure checked status is properly cloned
+		// Support: IE9, IE10
+		input.checked = true;
+		support.noCloneChecked = input.cloneNode( true ).checked;
+
+		// Make sure that the options inside disabled selects aren't marked as disabled
+		// (WebKit marks them as disabled)
+		select.disabled = true;
+		support.optDisabled = !opt.disabled;
+
+		// Check if an input maintains its value after becoming a radio
+		// Support: IE9, IE10
+		input = document.createElement("input");
+		input.value = "t";
+		input.type = "radio";
+		support.radioValue = input.value === "t";
+
+		// #11217 - WebKit loses check when the name is after the checked attribute
+		input.setAttribute( "checked", "t" );
+		input.setAttribute( "name", "t" );
+
+		fragment.appendChild( input );
+
+		// Support: Safari 5.1, Android 4.x, Android 2.3
+		// old WebKit doesn't clone checked state correctly in fragments
+		support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
+
+		// Support: Firefox, Chrome, Safari
+		// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
+		support.focusinBubbles = "onfocusin" in window;
+
+		div.style.backgroundClip = "content-box";
+		div.cloneNode( true ).style.backgroundClip = "";
+		support.clearCloneStyle = div.style.backgroundClip === "content-box";
+
+		// Run tests that need a body at doc ready
+		jQuery(function() {
+			var container, marginDiv,
+				// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
+				divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",
+				body = document.getElementsByTagName("body")[ 0 ];
+
+			if ( !body ) {
+				// Return for frameset docs that don't have a body
+				return;
+			}
+
+			container = document.createElement("div");
+			container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";
+
+			// Check box-sizing and margin behavior.
+			body.appendChild( container ).appendChild( div );
+			div.innerHTML = "";
+			// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
+			div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%";
+
+			// Workaround failing boxSizing test due to offsetWidth returning wrong value
+			// with some non-1 values of body zoom, ticket #13543
+			jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
+				support.boxSizing = div.offsetWidth === 4;
+			});
+
+			// Use window.getComputedStyle because jsdom on node.js will break without it.
+			if ( window.getComputedStyle ) {
+				support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
+				support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
+
+				// Support: Android 2.3
+				// Check if div with explicit width and no margin-right incorrectly
+				// gets computed margin-right based on width of container. (#3333)
+				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
+				marginDiv = div.appendChild( document.createElement("div") );
+				marginDiv.style.cssText = div.style.cssText = divReset;
+				marginDiv.style.marginRight = marginDiv.style.width = "0";
+				div.style.width = "1px";
+
+				support.reliableMarginRight =
+					!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
+			}
+
+			body.removeChild( container );
+		});
+
+		return support;
+	})( {} );
+
+	/*
+		Implementation Summary
+
+		1. Enforce API surface and semantic compatibility with 1.9.x branch
+		2. Improve the module's maintainability by reducing the storage
+			paths to a single mechanism.
+		3. Use the same single mechanism to support "private" and "user" data.
+		4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
+		5. Avoid exposing implementation details on user objects (eg. expando properties)
+		6. Provide a clear path for implementation upgrade to WeakMap in 2014
+	*/
+	var data_user, data_priv,
+		rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
+		rmultiDash = /([A-Z])/g;
+
+	function Data() {
+		// Support: Android < 4,
+		// Old WebKit does not have Object.preventExtensions/freeze method,
+		// return new empty object instead with no [[set]] accessor
+		Object.defineProperty( this.cache = {}, 0, {
+			get: function() {
+				return {};
+			}
+		});
+
+		this.expando = jQuery.expando + Math.random();
+	}
+
+	Data.uid = 1;
+
+	Data.accepts = function( owner ) {
+		// Accepts only:
+		//  - Node
+		//    - Node.ELEMENT_NODE
+		//    - Node.DOCUMENT_NODE
+		//  - Object
+		//    - Any
+		return owner.nodeType ?
+			owner.nodeType === 1 || owner.nodeType === 9 : true;
+	};
+
+	Data.prototype = {
+		key: function( owner ) {
+			// We can accept data for non-element nodes in modern browsers,
+			// but we should not, see #8335.
+			// Always return the key for a frozen object.
+			if ( !Data.accepts( owner ) ) {
+				return 0;
+			}
+
+			var descriptor = {},
+				// Check if the owner object already has a cache key
+				unlock = owner[ this.expando ];
+
+			// If not, create one
+			if ( !unlock ) {
+				unlock = Data.uid++;
+
+				// Secure it in a non-enumerable, non-writable property
+				try {
+					descriptor[ this.expando ] = { value: unlock };
+					Object.defineProperties( owner, descriptor );
+
+				// Support: Android < 4
+				// Fallback to a less secure definition
+				} catch ( e ) {
+					descriptor[ this.expando ] = unlock;
+					jQuery.extend( owner, descriptor );
+				}
+			}
+
+			// Ensure the cache object
+			if ( !this.cache[ unlock ] ) {
+				this.cache[ unlock ] = {};
+			}
+
+			return unlock;
+		},
+		set: function( owner, data, value ) {
+			var prop,
+				// There may be an unlock assigned to this node,
+				// if there is no entry for this "owner", create one inline
+				// and set the unlock as though an owner entry had always existed
+				unlock = this.key( owner ),
+				cache = this.cache[ unlock ];
+
+			// Handle: [ owner, key, value ] args
+			if ( typeof data === "string" ) {
+				cache[ data ] = value;
+
+			// Handle: [ owner, { properties } ] args
+			} else {
+				// Support an expectation from the old data system where plain
+				// objects used to initialize would be set to the cache by
+				// reference, instead of having properties and values copied.
+				// Note, this will kill the connection between
+				// "this.cache[ unlock ]" and "cache"
+				if ( jQuery.isEmptyObject( cache ) ) {
+					this.cache[ unlock ] = data;
+				// Otherwise, copy the properties one-by-one to the cache object
+				} else {
+					for ( prop in data ) {
+						cache[ prop ] = data[ prop ];
+					}
+				}
+			}
+		},
+		get: function( owner, key ) {
+			// Either a valid cache is found, or will be created.
+			// New caches will be created and the unlock returned,
+			// allowing direct access to the newly created
+			// empty data object. A valid owner object must be provided.
+			var cache = this.cache[ this.key( owner ) ];
+
+			return key === undefined ?
+				cache : cache[ key ];
+		},
+		access: function( owner, key, value ) {
+			// In cases where either:
+			//
+			//   1. No key was specified
+			//   2. A string key was specified, but no value provided
+			//
+			// Take the "read" path and allow the get method to determine
+			// which value to return, respectively either:
+			//
+			//   1. The entire cache object
+			//   2. The data stored at the key
+			//
+			if ( key === undefined ||
+					((key && typeof key === "string") && value === undefined) ) {
+				return this.get( owner, key );
+			}
+
+			// [*]When the key is not a string, or both a key and value
+			// are specified, set or extend (existing objects) with either:
+			//
+			//   1. An object of properties
+			//   2. A key and value
+			//
+			this.set( owner, key, value );
+
+			// Since the "set" path can have two possible entry points
+			// return the expected data based on which path was taken[*]
+			return value !== undefined ? value : key;
+		},
+		remove: function( owner, key ) {
+			var i, name,
+				unlock = this.key( owner ),
+				cache = this.cache[ unlock ];
+
+			if ( key === undefined ) {
+				this.cache[ unlock ] = {};
+
+			} else {
+				// Support array or space separated string of keys
+				if ( jQuery.isArray( key ) ) {
+					// If "name" is an array of keys...
+					// When data is initially created, via ("key", "val") signature,
+					// keys will be converted to camelCase.
+					// Since there is no way to tell _how_ a key was added, remove
+					// both plain key and camelCase key. #12786
+					// This will only penalize the array argument path.
+					name = key.concat( key.map( jQuery.camelCase ) );
+				} else {
+					// Try the string as a key before any manipulation
+					if ( key in cache ) {
+						name = [ key ];
+					} else {
+						// If a key with the spaces exists, use it.
+						// Otherwise, create an array by matching non-whitespace
+						name = jQuery.camelCase( key );
+						name = name in cache ?
+							[ name ] : ( name.match( core_rnotwhite ) || [] );
+					}
+				}
+
+				i = name.length;
+				while ( i-- ) {
+					delete cache[ name[ i ] ];
+				}
+			}
+		},
+		hasData: function( owner ) {
+			return !jQuery.isEmptyObject(
+				this.cache[ owner[ this.expando ] ] || {}
+			);
+		},
+		discard: function( owner ) {
+			delete this.cache[ this.key( owner ) ];
+		}
+	};
+
+	// These may be used throughout the jQuery core codebase
+	data_user = new Data();
+	data_priv = new Data();
+
+
+	jQuery.extend({
+		acceptData: Data.accepts,
+
+		hasData: function( elem ) {
+			return data_user.hasData( elem ) || data_priv.hasData( elem );
+		},
+
+		data: function( elem, name, data ) {
+			return data_user.access( elem, name, data );
+		},
+
+		removeData: function( elem, name ) {
+			data_user.remove( elem, name );
+		},
+
+		// TODO: Now that all calls to _data and _removeData have been replaced
+		// with direct calls to data_priv methods, these can be deprecated.
+		_data: function( elem, name, data ) {
+			return data_priv.access( elem, name, data );
+		},
+
+		_removeData: function( elem, name ) {
+			data_priv.remove( elem, name );
+		}
+	});
+
+	jQuery.fn.extend({
+		data: function( key, value ) {
+			var attrs, name,
+				elem = this[ 0 ],
+				i = 0,
+				data = null;
+
+			// Gets all values
+			if ( key === undefined ) {
+				if ( this.length ) {
+					data = data_user.get( elem );
+
+					if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
+						attrs = elem.attributes;
+						for ( ; i < attrs.length; i++ ) {
+							name = attrs[ i ].name;
+
+							if ( name.indexOf( "data-" ) === 0 ) {
+								name = jQuery.camelCase( name.substring(5) );
+								dataAttr( elem, name, data[ name ] );
+							}
+						}
+						data_priv.set( elem, "hasDataAttrs", true );
+					}
+				}
+
+				return data;
+			}
+
+			// Sets multiple values
+			if ( typeof key === "object" ) {
+				return this.each(function() {
+					data_user.set( this, key );
+				});
+			}
+
+			return jQuery.access( this, function( value ) {
+				var data,
+					camelKey = jQuery.camelCase( key );
+
+				// The calling jQuery object (element matches) is not empty
+				// (and therefore has an element appears at this[ 0 ]) and the
+				// `value` parameter was not undefined. An empty jQuery object
+				// will result in `undefined` for elem = this[ 0 ] which will
+				// throw an exception if an attempt to read a data cache is made.
+				if ( elem && value === undefined ) {
+					// Attempt to get data from the cache
+					// with the key as-is
+					data = data_user.get( elem, key );
+					if ( data !== undefined ) {
+						return data;
+					}
+
+					// Attempt to get data from the cache
+					// with the key camelized
+					data = data_user.get( elem, camelKey );
+					if ( data !== undefined ) {
+						return data;
+					}
+
+					// Attempt to "discover" the data in
+					// HTML5 custom data-* attrs
+					data = dataAttr( elem, camelKey, undefined );
+					if ( data !== undefined ) {
+						return data;
+					}
+
+					// We tried really hard, but the data doesn't exist.
+					return;
+				}
+
+				// Set the data...
+				this.each(function() {
+					// First, attempt to store a copy or reference of any
+					// data that might've been store with a camelCased key.
+					var data = data_user.get( this, camelKey );
+
+					// For HTML5 data-* attribute interop, we have to
+					// store property names with dashes in a camelCase form.
+					// This might not apply to all properties...*
+					data_user.set( this, camelKey, value );
+
+					// *... In the case of properties that might _actually_
+					// have dashes, we need to also store a copy of that
+					// unchanged property.
+					if ( key.indexOf("-") !== -1 && data !== undefined ) {
+						data_user.set( this, key, value );
+					}
+				});
+			}, null, value, arguments.length > 1, null, true );
+		},
+
+		removeData: function( key ) {
+			return this.each(function() {
+				data_user.remove( this, key );
+			});
+		}
+	});
+
+	function dataAttr( elem, key, data ) {
+		var name;
+
+		// If nothing was found internally, try to fetch any
+		// data from the HTML5 data-* attribute
+		if ( data === undefined && elem.nodeType === 1 ) {
+			name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
+			data = elem.getAttribute( name );
+
+			if ( typeof data === "string" ) {
+				try {
+					data = data === "true" ? true :
+						data === "false" ? false :
+						data === "null" ? null :
+						// Only convert to a number if it doesn't change the string
+						+data + "" === data ? +data :
+						rbrace.test( data ) ? JSON.parse( data ) :
+						data;
+				} catch( e ) {}
+
+				// Make sure we set the data so it isn't changed later
+				data_user.set( elem, key, data );
+			} else {
+				data = undefined;
+			}
+		}
+		return data;
+	}
+	jQuery.extend({
+		queue: function( elem, type, data ) {
+			var queue;
+
+			if ( elem ) {
+				type = ( type || "fx" ) + "queue";
+				queue = data_priv.get( elem, type );
+
+				// Speed up dequeue by getting out quickly if this is just a lookup
+				if ( data ) {
+					if ( !queue || jQuery.isArray( data ) ) {
+						queue = data_priv.access( elem, type, jQuery.makeArray(data) );
+					} else {
+						queue.push( data );
+					}
+				}
+				return queue || [];
+			}
+		},
+
+		dequeue: function( elem, type ) {
+			type = type || "fx";
+
+			var queue = jQuery.queue( elem, type ),
+				startLength = queue.length,
+				fn = queue.shift(),
+				hooks = jQuery._queueHooks( elem, type ),
+				next = function() {
+					jQuery.dequeue( elem, type );
+				};
+
+			// If the fx queue is dequeued, always remove the progress sentinel
+			if ( fn === "inprogress" ) {
+				fn = queue.shift();
+				startLength--;
+			}
+
+			hooks.cur = fn;
+			if ( fn ) {
+
+				// Add a progress sentinel to prevent the fx queue from being
+				// automatically dequeued
+				if ( type === "fx" ) {
+					queue.unshift( "inprogress" );
+				}
+
+				// clear up the last queue stop function
+				delete hooks.stop;
+				fn.call( elem, next, hooks );
+			}
+
+			if ( !startLength && hooks ) {
+				hooks.empty.fire();
+			}
+		},
+
+		// not intended for public consumption - generates a queueHooks object, or returns the current one
+		_queueHooks: function( elem, type ) {
+			var key = type + "queueHooks";
+			return data_priv.get( elem, key ) || data_priv.access( elem, key, {
+				empty: jQuery.Callbacks("once memory").add(function() {
+					data_priv.remove( elem, [ type + "queue", key ] );
+				})
+			});
+		}
+	});
+
+	jQuery.fn.extend({
+		queue: function( type, data ) {
+			var setter = 2;
+
+			if ( typeof type !== "string" ) {
+				data = type;
+				type = "fx";
+				setter--;
+			}
+
+			if ( arguments.length < setter ) {
+				return jQuery.queue( this[0], type );
+			}
+
+			return data === undefined ?
+				this :
+				this.each(function() {
+					var queue = jQuery.queue( this, type, data );
+
+					// ensure a hooks for this queue
+					jQuery._queueHooks( this, type );
+
+					if ( type === "fx" && queue[0] !== "inprogress" ) {
+						jQuery.dequeue( this, type );
+					}
+				});
+		},
+		dequeue: function( type ) {
+			return this.each(function() {
+				jQuery.dequeue( this, type );
+			});
+		},
+		// Based off of the plugin by Clint Helfers, with permission.
+		// http://blindsignals.com/index.php/2009/07/jquery-delay/
+		delay: function( time, type ) {
+			time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
+			type = type || "fx";
+
+			return this.queue( type, function( next, hooks ) {
+				var timeout = setTimeout( next, time );
+				hooks.stop = function() {
+					clearTimeout( timeout );
+				};
+			});
+		},
+		clearQueue: function( type ) {
+			return this.queue( type || "fx", [] );
+		},
+		// Get a promise resolved when queues of a certain type
+		// are emptied (fx is the type by default)
+		promise: function( type, obj ) {
+			var tmp,
+				count = 1,
+				defer = jQuery.Deferred(),
+				elements = this,
+				i = this.length,
+				resolve = function() {
+					if ( !( --count ) ) {
+						defer.resolveWith( elements, [ elements ] );
+					}
+				};
+
+			if ( typeof type !== "string" ) {
+				obj = type;
+				type = undefined;
+			}
+			type = type || "fx";
+
+			while( i-- ) {
+				tmp = data_priv.get( elements[ i ], type + "queueHooks" );
+				if ( tmp && tmp.empty ) {
+					count++;
+					tmp.empty.add( resolve );
+				}
+			}
+			resolve();
+			return defer.promise( obj );
+		}
+	});
+	var nodeHook, boolHook,
+		rclass = /[\t\r\n]/g,
+		rreturn = /\r/g,
+		rfocusable = /^(?:input|select|textarea|button)$/i;
+
+	jQuery.fn.extend({
+		attr: function( name, value ) {
+			return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
+		},
+
+		removeAttr: function( name ) {
+			return this.each(function() {
+				jQuery.removeAttr( this, name );
+			});
+		},
+
+		prop: function( name, value ) {
+			return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
+		},
+
+		removeProp: function( name ) {
+			return this.each(function() {
+				delete this[ jQuery.propFix[ name ] || name ];
+			});
+		},
+
+		addClass: function( value ) {
+			var classes, elem, cur, clazz, j,
+				i = 0,
+				len = this.length,
+				proceed = typeof value === "string" && value;
+
+			if ( jQuery.isFunction( value ) ) {
+				return this.each(function( j ) {
+					jQuery( this ).addClass( value.call( this, j, this.className ) );
+				});
+			}
+
+			if ( proceed ) {
+				// The disjunction here is for better compressibility (see removeClass)
+				classes = ( value || "" ).match( core_rnotwhite ) || [];
+
+				for ( ; i < len; i++ ) {
+					elem = this[ i ];
+					cur = elem.nodeType === 1 && ( elem.className ?
+						( " " + elem.className + " " ).replace( rclass, " " ) :
+						" "
+					);
+
+					if ( cur ) {
+						j = 0;
+						while ( (clazz = classes[j++]) ) {
+							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
+								cur += clazz + " ";
+							}
+						}
+						elem.className = jQuery.trim( cur );
+
+					}
+				}
+			}
+
+			return this;
+		},
+
+		removeClass: function( value ) {
+			var classes, elem, cur, clazz, j,
+				i = 0,
+				len = this.length,
+				proceed = arguments.length === 0 || typeof value === "string" && value;
+
+			if ( jQuery.isFunction( value ) ) {
+				return this.each(function( j ) {
+					jQuery( this ).removeClass( value.call( this, j, this.className ) );
+				});
+			}
+			if ( proceed ) {
+				classes = ( value || "" ).match( core_rnotwhite ) || [];
+
+				for ( ; i < len; i++ ) {
+					elem = this[ i ];
+					// This expression is here for better compressibility (see addClass)
+					cur = elem.nodeType === 1 && ( elem.className ?
+						( " " + elem.className + " " ).replace( rclass, " " ) :
+						""
+					);
+
+					if ( cur ) {
+						j = 0;
+						while ( (clazz = classes[j++]) ) {
+							// Remove *all* instances
+							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
+								cur = cur.replace( " " + clazz + " ", " " );
+							}
+						}
+						elem.className = value ? jQuery.trim( cur ) : "";
+					}
+				}
+			}
+
+			return this;
+		},
+
+		toggleClass: function( value, stateVal ) {
+			var type = typeof value,
+				isBool = typeof stateVal === "boolean";
+
+			if ( jQuery.isFunction( value ) ) {
+				return this.each(function( i ) {
+					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
+				});
+			}
+
+			return this.each(function() {
+				if ( type === "string" ) {
+					// toggle individual class names
+					var className,
+						i = 0,
+						self = jQuery( this ),
+						state = stateVal,
+						classNames = value.match( core_rnotwhite ) || [];
+
+					while ( (className = classNames[ i++ ]) ) {
+						// check each className given, space separated list
+						state = isBool ? state : !self.hasClass( className );
+						self[ state ? "addClass" : "removeClass" ]( className );
+					}
+
+				// Toggle whole class name
+				} else if ( type === core_strundefined || type === "boolean" ) {
+					if ( this.className ) {
+						// store className if set
+						data_priv.set( this, "__className__", this.className );
+					}
+
+					// If the element has a class name or if we're passed "false",
+					// then remove the whole classname (if there was one, the above saved it).
+					// Otherwise bring back whatever was previously saved (if anything),
+					// falling back to the empty string if nothing was stored.
+					this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
+				}
+			});
+		},
+
+		hasClass: function( selector ) {
+			var className = " " + selector + " ",
+				i = 0,
+				l = this.length;
+			for ( ; i < l; i++ ) {
+				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
+					return true;
+				}
+			}
+
+			return false;
+		},
+
+		val: function( value ) {
+			var hooks, ret, isFunction,
+				elem = this[0];
+
+			if ( !arguments.length ) {
+				if ( elem ) {
+					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
+
+					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
+						return ret;
+					}
+
+					ret = elem.value;
+
+					return typeof ret === "string" ?
+						// handle most common string cases
+						ret.replace(rreturn, "") :
+						// handle cases where value is null/undef or number
+						ret == null ? "" : ret;
+				}
+
+				return;
+			}
+
+			isFunction = jQuery.isFunction( value );
+
+			return this.each(function( i ) {
+				var val,
+					self = jQuery(this);
+
+				if ( this.nodeType !== 1 ) {
+					return;
+				}
+
+				if ( isFunction ) {
+					val = value.call( this, i, self.val() );
+				} else {
+					val = value;
+				}
+
+				// Treat null/undefined as ""; convert numbers to string
+				if ( val == null ) {
+					val = "";
+				} else if ( typeof val === "number" ) {
+					val += "";
+				} else if ( jQuery.isArray( val ) ) {
+					val = jQuery.map(val, function ( value ) {
+						return value == null ? "" : value + "";
+					});
+				}
+
+				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
+
+				// If set returns undefined, fall back to normal setting
+				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
+					this.value = val;
+				}
+			});
+		}
+	});
+
+	jQuery.extend({
+		valHooks: {
+			option: {
+				get: function( elem ) {
+					// attributes.value is undefined in Blackberry 4.7 but
+					// uses .value. See #6932
+					var val = elem.attributes.value;
+					return !val || val.specified ? elem.value : elem.text;
+				}
+			},
+			select: {
+				get: function( elem ) {
+					var value, option,
+						options = elem.options,
+						index = elem.selectedIndex,
+						one = elem.type === "select-one" || index < 0,
+						values = one ? null : [],
+						max = one ? index + 1 : options.length,
+						i = index < 0 ?
+							max :
+							one ? index : 0;
+
+					// Loop through all the selected options
+					for ( ; i < max; i++ ) {
+						option = options[ i ];
+
+						// IE6-9 doesn't update selected after form reset (#2551)
+						if ( ( option.selected || i === index ) &&
+								// Don't return options that are disabled or in a disabled optgroup
+								( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
+								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
+
+							// Get the specific value for the option
+							value = jQuery( option ).val();
+
+							// We don't need an array for one selects
+							if ( one ) {
+								return value;
+							}
+
+							// Multi-Selects return an array
+							values.push( value );
+						}
+					}
+
+					return values;
+				},
+
+				set: function( elem, value ) {
+					var optionSet, option,
+						options = elem.options,
+						values = jQuery.makeArray( value ),
+						i = options.length;
+
+					while ( i-- ) {
+						option = options[ i ];
+						if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
+							optionSet = true;
+						}
+					}
+
+					// force browsers to behave consistently when non-matching value is set
+					if ( !optionSet ) {
+						elem.selectedIndex = -1;
+					}
+					return values;
+				}
+			}
+		},
+
+		attr: function( elem, name, value ) {
+			var hooks, ret,
+				nType = elem.nodeType;
+
+			// don't get/set attributes on text, comment and attribute nodes
+			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
+				return;
+			}
+
+			// Fallback to prop when attributes are not supported
+			if ( typeof elem.getAttribute === core_strundefined ) {
+				return jQuery.prop( elem, name, value );
+			}
+
+			// All attributes are lowercase
+			// Grab necessary hook if one is defined
+			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
+				name = name.toLowerCase();
+				hooks = jQuery.attrHooks[ name ] ||
+					( jQuery.expr.match.boolean.test( name ) ? boolHook : nodeHook );
+			}
+
+			if ( value !== undefined ) {
+
+				if ( value === null ) {
+					jQuery.removeAttr( elem, name );
+
+				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
+					return ret;
+
+				} else {
+					elem.setAttribute( name, value + "" );
+					return value;
+				}
+
+			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
+				return ret;
+
+			} else {
+				ret = jQuery.find.attr( elem, name );
+
+				// Non-existent attributes return null, we normalize to undefined
+				return ret == null ?
+					undefined :
+					ret;
+			}
+		},
+
+		removeAttr: function( elem, value ) {
+			var name, propName,
+				i = 0,
+				attrNames = value && value.match( core_rnotwhite );
+
+			if ( attrNames && elem.nodeType === 1 ) {
+				while ( (name = attrNames[i++]) ) {
+					propName = jQuery.propFix[ name ] || name;
+
+					// Boolean attributes get special treatment (#10870)
+					if ( jQuery.expr.match.boolean.test( name ) ) {
+						// Set corresponding property to false
+						elem[ propName ] = false;
+					}
+
+					elem.removeAttribute( name );
+				}
+			}
+		},
+
+		attrHooks: {
+			type: {
+				set: function( elem, value ) {
+					if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
+						// Setting the type on a radio button after the value resets the value in IE6-9
+						// Reset value to default in case type is set after value during creation
+						var val = elem.value;
+						elem.setAttribute( "type", value );
+						if ( val ) {
+							elem.value = val;
+						}
+						return value;
+					}
+				}
+			}
+		},
+
+		propFix: {
+			"for": "htmlFor",
+			"class": "className"
+		},
+
+		prop: function( elem, name, value ) {
+			var ret, hooks, notxml,
+				nType = elem.nodeType;
+
+			// don't get/set properties on text, comment and attribute nodes
+			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
+				return;
+			}
+
+			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
+
+			if ( notxml ) {
+				// Fix name and attach hooks
+				name = jQuery.propFix[ name ] || name;
+				hooks = jQuery.propHooks[ name ];
+			}
+
+			if ( value !== undefined ) {
+				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
+					ret :
+					( elem[ name ] = value );
+
+			} else {
+				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
+					ret :
+					elem[ name ];
+			}
+		},
+
+		propHooks: {
+			tabIndex: {
+				get: function( elem ) {
+					return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
+						elem.tabIndex :
+						-1;
+				}
+			}
+		}
+	});
+
+	// Hooks for boolean attributes
+	boolHook = {
+		set: function( elem, value, name ) {
+			if ( value === false ) {
+				// Remove boolean attributes when set to false
+				jQuery.removeAttr( elem, name );
+			} else {
+				elem.setAttribute( name, name );
+			}
+			return name;
+		}
+	};
+	jQuery.each( jQuery.expr.match.boolean.source.match( /\w+/g ), function( i, name ) {
+		var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;
+
+		jQuery.expr.attrHandle[ name ] = function( elem, name, isXML ) {
+			var fn = jQuery.expr.attrHandle[ name ],
+				ret = isXML ?
+					undefined :
+					/* jshint eqeqeq: false */
+					// Temporarily disable this handler to check existence
+					(jQuery.expr.attrHandle[ name ] = undefined) !=
+						getter( elem, name, isXML ) ?
+
+						name.toLowerCase() :
+						null;
+
+			// Restore handler
+			jQuery.expr.attrHandle[ name ] = fn;
+
+			return ret;
+		};
+	});
+
+	// Support: IE9+
+	// Selectedness for an option in an optgroup can be inaccurate
+	if ( !jQuery.support.optSelected ) {
+		jQuery.propHooks.selected = {
+			get: function( elem ) {
+				var parent = elem.parentNode;
+				if ( parent && parent.parentNode ) {
+					parent.parentNode.selectedIndex;
+				}
+				return null;
+			}
+		};
+	}
+
+	jQuery.each([
+		"tabIndex",
+		"readOnly",
+		"maxLength",
+		"cellSpacing",
+		"cellPadding",
+		"rowSpan",
+		"colSpan",
+		"useMap",
+		"frameBorder",
+		"contentEditable"
+	], function() {
+		jQuery.propFix[ this.toLowerCase() ] = this;
+	});
+
+	// Radios and checkboxes getter/setter
+	jQuery.each([ "radio", "checkbox" ], function() {
+		jQuery.valHooks[ this ] = {
+			set: function( elem, value ) {
+				if ( jQuery.isArray( value ) ) {
+					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
+				}
+			}
+		};
+		if ( !jQuery.support.checkOn ) {
+			jQuery.valHooks[ this ].get = function( elem ) {
+				// Support: Webkit
+				// "" is returned instead of "on" if a value isn't specified
+				return elem.getAttribute("value") === null ? "on" : elem.value;
+			};
+		}
+	});
+	var rkeyEvent = /^key/,
+		rmouseEvent = /^(?:mouse|contextmenu)|click/,
+		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
+		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
+
+	function returnTrue() {
+		return true;
+	}
+
+	function returnFalse() {
+		return false;
+	}
+
+	function safeActiveElement() {
+		try {
+			return document.activeElement;
+		} catch ( err ) { }
+	}
+
+	/*
+	 * Helper functions for managing events -- not part of the public interface.
+	 * Props to Dean Edwards' addEvent library for many of the ideas.
+	 */
+	jQuery.event = {
+
+		global: {},
+
+		add: function( elem, types, handler, data, selector ) {
+
+			var handleObjIn, eventHandle, tmp,
+				events, t, handleObj,
+				special, handlers, type, namespaces, origType,
+				elemData = data_priv.get( elem );
+
+			// Don't attach events to noData or text/comment nodes (but allow plain objects)
+			if ( !elemData ) {
+				return;
+			}
+
+			// Caller can pass in an object of custom data in lieu of the handler
+			if ( handler.handler ) {
+				handleObjIn = handler;
+				handler = handleObjIn.handler;
+				selector = handleObjIn.selector;
+			}
+
+			// Make sure that the handler has a unique ID, used to find/remove it later
+			if ( !handler.guid ) {
+				handler.guid = jQuery.guid++;
+			}
+
+			// Init the element's event structure and main handler, if this is the first
+			if ( !(events = elemData.events) ) {
+				events = elemData.events = {};
+			}
+			if ( !(eventHandle = elemData.handle) ) {
+				eventHandle = elemData.handle = function( e ) {
+					// Discard the second event of a jQuery.event.trigger() and
+					// when an event is called after a page has unloaded
+					return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
+						jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
+						undefined;
+				};
+				// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
+				eventHandle.elem = elem;
+			}
+
+			// Handle multiple events separated by a space
+			types = ( types || "" ).match( core_rnotwhite ) || [""];
+			t = types.length;
+			while ( t-- ) {
+				tmp = rtypenamespace.exec( types[t] ) || [];
+				type = origType = tmp[1];
+				namespaces = ( tmp[2] || "" ).split( "." ).sort();
+
+				// There *must* be a type, no attaching namespace-only handlers
+				if ( !type ) {
+					continue;
+				}
+
+				// If event changes its type, use the special event handlers for the changed type
+				special = jQuery.event.special[ type ] || {};
+
+				// If selector defined, determine special event api type, otherwise given type
+				type = ( selector ? special.delegateType : special.bindType ) || type;
+
+				// Update special based on newly reset type
+				special = jQuery.event.special[ type ] || {};
+
+				// handleObj is passed to all event handlers
+				handleObj = jQuery.extend({
+					type: type,
+					origType: origType,
+					data: data,
+					handler: handler,
+					guid: handler.guid,
+					selector: selector,
+					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
+					namespace: namespaces.join(".")
+				}, handleObjIn );
+
+				// Init the event handler queue if we're the first
+				if ( !(handlers = events[ type ]) ) {
+					handlers = events[ type ] = [];
+					handlers.delegateCount = 0;
+
+					// Only use addEventListener if the special events handler returns false
+					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
+						if ( elem.addEventListener ) {
+							elem.addEventListener( type, eventHandle, false );
+						}
+					}
+				}
+
+				if ( special.add ) {
+					special.add.call( elem, handleObj );
+
+					if ( !handleObj.handler.guid ) {
+						handleObj.handler.guid = handler.guid;
+					}
+				}
+
+				// Add to the element's handler list, delegates in front
+				if ( selector ) {
+					handlers.splice( handlers.delegateCount++, 0, handleObj );
+				} else {
+					handlers.push( handleObj );
+				}
+
+				// Keep track of which events have ever been used, for event optimization
+				jQuery.event.global[ type ] = true;
+			}
+
+			// Nullify elem to prevent memory leaks in IE
+			elem = null;
+		},
+
+		// Detach an event or set of events from an element
+		remove: function( elem, types, handler, selector, mappedTypes ) {
+
+			var j, origCount, tmp,
+				events, t, handleObj,
+				special, handlers, type, namespaces, origType,
+				elemData = data_priv.hasData( elem ) && data_priv.get( elem );
+
+			if ( !elemData || !(events = elemData.events) ) {
+				return;
+			}
+
+			// Once for each type.namespace in types; type may be omitted
+			types = ( types || "" ).match( core_rnotwhite ) || [""];
+			t = types.length;
+			while ( t-- ) {
+				tmp = rtypenamespace.exec( types[t] ) || [];
+				type = origType = tmp[1];
+				namespaces = ( tmp[2] || "" ).split( "." ).sort();
+
+				// Unbind all events (on this namespace, if provided) for the element
+				if ( !type ) {
+					for ( type in events ) {
+						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
+					}
+					continue;
+				}
+
+				special = jQuery.event.special[ type ] || {};
+				type = ( selector ? special.delegateType : special.bindType ) || type;
+				handlers = events[ type ] || [];
+				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
+
+				// Remove matching events
+				origCount = j = handlers.length;
+				while ( j-- ) {
+					handleObj = handlers[ j ];
+
+					if ( ( mappedTypes || origType === handleObj.origType ) &&
+						( !handler || handler.guid === handleObj.guid ) &&
+						( !tmp || tmp.test( handleObj.namespace ) ) &&
+						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
+						handlers.splice( j, 1 );
+
+						if ( handleObj.selector ) {
+							handlers.delegateCount--;
+						}
+						if ( special.remove ) {
+							special.remove.call( elem, handleObj );
+						}
+					}
+				}
+
+				// Remove generic event handler if we removed something and no more handlers exist
+				// (avoids potential for endless recursion during removal of special event handlers)
+				if ( origCount && !handlers.length ) {
+					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
+						jQuery.removeEvent( elem, type, elemData.handle );
+					}
+
+					delete events[ type ];
+				}
+			}
+
+			// Remove the expando if it's no longer used
+			if ( jQuery.isEmptyObject( events ) ) {
+				delete elemData.handle;
+				data_priv.remove( elem, "events" );
+			}
+		},
+
+		trigger: function( event, data, elem, onlyHandlers ) {
+
+			var i, cur, tmp, bubbleType, ontype, handle, special,
+				eventPath = [ elem || document ],
+				type = core_hasOwn.call( event, "type" ) ? event.type : event,
+				namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
+
+			cur = tmp = elem = elem || document;
+
+			// Don't do events on text and comment nodes
+			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
+				return;
+			}
+
+			// focus/blur morphs to focusin/out; ensure we're not firing them right now
+			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
+				return;
+			}
+
+			if ( type.indexOf(".") >= 0 ) {
+				// Namespaced trigger; create a regexp to match event type in handle()
+				namespaces = type.split(".");
+				type = namespaces.shift();
+				namespaces.sort();
+			}
+			ontype = type.indexOf(":") < 0 && "on" + type;
+
+			// Caller can pass in a jQuery.Event object, Object, or just an event type string
+			event = event[ jQuery.expando ] ?
+				event :
+				new jQuery.Event( type, typeof event === "object" && event );
+
+			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
+			event.isTrigger = onlyHandlers ? 2 : 3;
+			event.namespace = namespaces.join(".");
+			event.namespace_re = event.namespace ?
+				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
+				null;
+
+			// Clean up the event in case it is being reused
+			event.result = undefined;
+			if ( !event.target ) {
+				event.target = elem;
+			}
+
+			// Clone any incoming data and prepend the event, creating the handler arg list
+			data = data == null ?
+				[ event ] :
+				jQuery.makeArray( data, [ event ] );
+
+			// Allow special events to draw outside the lines
+			special = jQuery.event.special[ type ] || {};
+			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
+				return;
+			}
+
+			// Determine event propagation path in advance, per W3C events spec (#9951)
+			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
+			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
+
+				bubbleType = special.delegateType || type;
+				if ( !rfocusMorph.test( bubbleType + type ) ) {
+					cur = cur.parentNode;
+				}
+				for ( ; cur; cur = cur.parentNode ) {
+					eventPath.push( cur );
+					tmp = cur;
+				}
+
+				// Only add window if we got to document (e.g., not plain obj or detached DOM)
+				if ( tmp === (elem.ownerDocument || document) ) {
+					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
+				}
+			}
+
+			// Fire handlers on the event path
+			i = 0;
+			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
+
+				event.type = i > 1 ?
+					bubbleType :
+					special.bindType || type;
+
+				// jQuery handler
+				handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
+				if ( handle ) {
+					handle.apply( cur, data );
+				}
+
+				// Native handler
+				handle = ontype && cur[ ontype ];
+				if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
+					event.preventDefault();
+				}
+			}
+			event.type = type;
+
+			// If nobody prevented the default action, do it now
+			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
+
+				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
+					jQuery.acceptData( elem ) ) {
+
+					// Call a native DOM method on the target with the same name name as the event.
+					// Don't do default actions on window, that's where global variables be (#6170)
+					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
+
+						// Don't re-trigger an onFOO event when we call its FOO() method
+						tmp = elem[ ontype ];
+
+						if ( tmp ) {
+							elem[ ontype ] = null;
+						}
+
+						// Prevent re-triggering of the same event, since we already bubbled it above
+						jQuery.event.triggered = type;
+						elem[ type ]();
+						jQuery.event.triggered = undefined;
+
+						if ( tmp ) {
+							elem[ ontype ] = tmp;
+						}
+					}
+				}
+			}
+
+			return event.result;
+		},
+
+		dispatch: function( event ) {
+
+			// Make a writable jQuery.Event from the native event object
+			event = jQuery.event.fix( event );
+
+			var i, j, ret, matched, handleObj,
+				handlerQueue = [],
+				args = core_slice.call( arguments ),
+				handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
+				special = jQuery.event.special[ event.type ] || {};
+
+			// Use the fix-ed jQuery.Event rather than the (read-only) native event
+			args[0] = event;
+			event.delegateTarget = this;
+
+			// Call the preDispatch hook for the mapped type, and let it bail if desired
+			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
+				return;
+			}
+
+			// Determine handlers
+			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
+
+			// Run delegates first; they may want to stop propagation beneath us
+			i = 0;
+			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
+				event.currentTarget = matched.elem;
+
+				j = 0;
+				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
+
+					// Triggered event must either 1) have no namespace, or
+					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
+					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
+
+						event.handleObj = handleObj;
+						event.data = handleObj.data;
+
+						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
+								.apply( matched.elem, args );
+
+						if ( ret !== undefined ) {
+							if ( (event.result = ret) === false ) {
+								event.preventDefault();
+								event.stopPropagation();
+							}
+						}
+					}
+				}
+			}
+
+			// Call the postDispatch hook for the mapped type
+			if ( special.postDispatch ) {
+				special.postDispatch.call( this, event );
+			}
+
+			return event.result;
+		},
+
+		handlers: function( event, handlers ) {
+			var i, matches, sel, handleObj,
+				handlerQueue = [],
+				delegateCount = handlers.delegateCount,
+				cur = event.target;
+
+			// Find delegate handlers
+			// Black-hole SVG <use> instance trees (#13180)
+			// Avoid non-left-click bubbling in Firefox (#3861)
+			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
+
+				for ( ; cur !== this; cur = cur.parentNode || this ) {
+
+					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
+					if ( cur.disabled !== true || event.type !== "click" ) {
+						matches = [];
+						for ( i = 0; i < delegateCount; i++ ) {
+							handleObj = handlers[ i ];
+
+							// Don't conflict with Object.prototype properties (#13203)
+							sel = handleObj.selector + " ";
+
+							if ( matches[ sel ] === undefined ) {
+								matches[ sel ] = handleObj.needsContext ?
+									jQuery( sel, this ).index( cur ) >= 0 :
+									jQuery.find( sel, this, null, [ cur ] ).length;
+							}
+							if ( matches[ sel ] ) {
+								matches.push( handleObj );
+							}
+						}
+						if ( matches.length ) {
+							handlerQueue.push({ elem: cur, handlers: matches });
+						}
+					}
+				}
+			}
+
+			// Add the remaining (directly-bound) handlers
+			if ( delegateCount < handlers.length ) {
+				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
+			}
+
+			return handlerQueue;
+		},
+
+		// Includes some event props shared by KeyEvent and MouseEvent
+		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
+
+		fixHooks: {},
+
+		keyHooks: {
+			props: "char charCode key keyCode".split(" "),
+			filter: function( event, original ) {
+
+				// Add which for key events
+				if ( event.which == null ) {
+					event.which = original.charCode != null ? original.charCode : original.keyCode;
+				}
+
+				return event;
+			}
+		},
+
+		mouseHooks: {
+			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
+			filter: function( event, original ) {
+				var eventDoc, doc, body,
+					button = original.button;
+
+				// Calculate pageX/Y if missing and clientX/Y available
+				if ( event.pageX == null && original.clientX != null ) {
+					eventDoc = event.target.ownerDocument || document;
+					doc = eventDoc.documentElement;
+					body = eventDoc.body;
+
+					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
+					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
+				}
+
+				// Add which for click: 1 === left; 2 === middle; 3 === right
+				// Note: button is not normalized, so don't use it
+				if ( !event.which && button !== undefined ) {
+					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
+				}
+
+				return event;
+			}
+		},
+
+		fix: function( event ) {
+			if ( event[ jQuery.expando ] ) {
+				return event;
+			}
+
+			// Create a writable copy of the event object and normalize some properties
+			var i, prop, copy,
+				type = event.type,
+				originalEvent = event,
+				fixHook = this.fixHooks[ type ];
+
+			if ( !fixHook ) {
+				this.fixHooks[ type ] = fixHook =
+					rmouseEvent.test( type ) ? this.mouseHooks :
+					rkeyEvent.test( type ) ? this.keyHooks :
+					{};
+			}
+			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
+
+			event = new jQuery.Event( originalEvent );
+
+			i = copy.length;
+			while ( i-- ) {
+				prop = copy[ i ];
+				event[ prop ] = originalEvent[ prop ];
+			}
+
+			// Support: Safari 6.0+, Chrome < 28
+			// Target should not be a text node (#504, #13143)
+			if ( event.target.nodeType === 3 ) {
+				event.target = event.target.parentNode;
+			}
+
+			return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
+		},
+
+		special: {
+			load: {
+				// Prevent triggered image.load events from bubbling to window.load
+				noBubble: true
+			},
+			focus: {
+				// Fire native event if possible so blur/focus sequence is correct
+				trigger: function() {
+					if ( this !== safeActiveElement() && this.focus ) {
+						this.focus();
+						return false;
+					}
+				},
+				delegateType: "focusin"
+			},
+			blur: {
+				trigger: function() {
+					if ( this === safeActiveElement() && this.blur ) {
+						this.blur();
+						return false;
+					}
+				},
+				delegateType: "focusout"
+			},
+			click: {
+				// For checkbox, fire native event so checked state will be right
+				trigger: function() {
+					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
+						this.click();
+						return false;
+					}
+				},
+
+				// For cross-browser consistency, don't fire native .click() on links
+				_default: function( event ) {
+					return jQuery.nodeName( event.target, "a" );
+				}
+			},
+
+			beforeunload: {
+				postDispatch: function( event ) {
+
+					// Support: Firefox 20+
+					// Firefox doesn't alert if the returnValue field is not set.
+					if ( event.result !== undefined ) {
+						event.originalEvent.returnValue = event.result;
+					}
+				}
+			}
+		},
+
+		simulate: function( type, elem, event, bubble ) {
+			// Piggyback on a donor event to simulate a different one.
+			// Fake originalEvent to avoid donor's stopPropagation, but if the
+			// simulated event prevents default then we do the same on the donor.
+			var e = jQuery.extend(
+				new jQuery.Event(),
+				event,
+				{
+					type: type,
+					isSimulated: true,
+					originalEvent: {}
+				}
+			);
+			if ( bubble ) {
+				jQuery.event.trigger( e, null, elem );
+			} else {
+				jQuery.event.dispatch.call( elem, e );
+			}
+			if ( e.isDefaultPrevented() ) {
+				event.preventDefault();
+			}
+		}
+	};
+
+	jQuery.removeEvent = function( elem, type, handle ) {
+		if ( elem.removeEventListener ) {
+			elem.removeEventListener( type, handle, false );
+		}
+	};
+
+	jQuery.Event = function( src, props ) {
+		// Allow instantiation without the 'new' keyword
+		if ( !(this instanceof jQuery.Event) ) {
+			return new jQuery.Event( src, props );
+		}
+
+		// Event object
+		if ( src && src.type ) {
+			this.originalEvent = src;
+			this.type = src.type;
+
+			// Events bubbling up the document may have been marked as prevented
+			// by a handler lower down the tree; reflect the correct value.
+			this.isDefaultPrevented = ( src.defaultPrevented ||
+				src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
+
+		// Event type
+		} else {
+			this.type = src;
+		}
+
+		// Put explicitly provided properties onto the event object
+		if ( props ) {
+			jQuery.extend( this, props );
+		}
+
+		// Create a timestamp if incoming event doesn't have one
+		this.timeStamp = src && src.timeStamp || jQuery.now();
+
+		// Mark it as fixed
+		this[ jQuery.expando ] = true;
+	};
+
+	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
+	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
+	jQuery.Event.prototype = {
+		isDefaultPrevented: returnFalse,
+		isPropagationStopped: returnFalse,
+		isImmediatePropagationStopped: returnFalse,
+
+		preventDefault: function() {
+			var e = this.originalEvent;
+
+			this.isDefaultPrevented = returnTrue;
+
+			if ( e && e.preventDefault ) {
+				e.preventDefault();
+			}
+		},
+		stopPropagation: function() {
+			var e = this.originalEvent;
+
+			this.isPropagationStopped = returnTrue;
+
+			if ( e && e.stopPropagation ) {
+				e.stopPropagation();
+			}
+		},
+		stopImmediatePropagation: function() {
+			this.isImmediatePropagationStopped = returnTrue;
+			this.stopPropagation();
+		}
+	};
+
+	// Create mouseenter/leave events using mouseover/out and event-time checks
+	// Support: Chrome 15+
+	jQuery.each({
+		mouseenter: "mouseover",
+		mouseleave: "mouseout"
+	}, function( orig, fix ) {
+		jQuery.event.special[ orig ] = {
+			delegateType: fix,
+			bindType: fix,
+
+			handle: function( event ) {
+				var ret,
+					target = this,
+					related = event.relatedTarget,
+					handleObj = event.handleObj;
+
+				// For mousenter/leave call the handler if related is outside the target.
+				// NB: No relatedTarget if the mouse left/entered the browser window
+				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
+					event.type = handleObj.origType;
+					ret = handleObj.handler.apply( this, arguments );
+					event.type = fix;
+				}
+				return ret;
+			}
+		};
+	});
+
+	// Create "bubbling" focus and blur events
+	// Support: Firefox, Chrome, Safari
+	if ( !jQuery.support.focusinBubbles ) {
+		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
+
+			// Attach a single capturing handler while someone wants focusin/focusout
+			var attaches = 0,
+				handler = function( event ) {
+					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
+				};
+
+			jQuery.event.special[ fix ] = {
+				setup: function() {
+					if ( attaches++ === 0 ) {
+						document.addEventListener( orig, handler, true );
+					}
+				},
+				teardown: function() {
+					if ( --attaches === 0 ) {
+						document.removeEventListener( orig, handler, true );
+					}
+				}
+			};
+		});
+	}
+
+	jQuery.fn.extend({
+
+		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
+			var origFn, type;
+
+			// Types can be a map of types/handlers
+			if ( typeof types === "object" ) {
+				// ( types-Object, selector, data )
+				if ( typeof selector !== "string" ) {
+					// ( types-Object, data )
+					data = data || selector;
+					selector = undefined;
+				}
+				for ( type in types ) {
+					this.on( type, selector, data, types[ type ], one );
+				}
+				return this;
+			}
+
+			if ( data == null && fn == null ) {
+				// ( types, fn )
+				fn = selector;
+				data = selector = undefined;
+			} else if ( fn == null ) {
+				if ( typeof selector === "string" ) {
+					// ( types, selector, fn )
+					fn = data;
+					data = undefined;
+				} else {
+					// ( types, data, fn )
+					fn = data;
+					data = selector;
+					selector = undefined;
+				}
+			}
+			if ( fn === false ) {
+				fn = returnFalse;
+			} else if ( !fn ) {
+				return this;
+			}
+
+			if ( one === 1 ) {
+				origFn = fn;
+				fn = function( event ) {
+					// Can use an empty set, since event contains the info
+					jQuery().off( event );
+					return origFn.apply( this, arguments );
+				};
+				// Use same guid so caller can remove using origFn
+				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
+			}
+			return this.each( function() {
+				jQuery.event.add( this, types, fn, data, selector );
+			});
+		},
+		one: function( types, selector, data, fn ) {
+			return this.on( types, selector, data, fn, 1 );
+		},
+		off: function( types, selector, fn ) {
+			var handleObj, type;
+			if ( types && types.preventDefault && types.handleObj ) {
+				// ( event )  dispatched jQuery.Event
+				handleObj = types.handleObj;
+				jQuery( types.delegateTarget ).off(
+					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
+					handleObj.selector,
+					handleObj.handler
+				);
+				return this;
+			}
+			if ( typeof types === "object" ) {
+				// ( types-object [, selector] )
+				for ( type in types ) {
+					this.off( type, selector, types[ type ] );
+				}
+				return this;
+			}
+			if ( selector === false || typeof selector === "function" ) {
+				// ( types [, fn] )
+				fn = selector;
+				selector = undefined;
+			}
+			if ( fn === false ) {
+				fn = returnFalse;
+			}
+			return this.each(function() {
+				jQuery.event.remove( this, types, fn, selector );
+			});
+		},
+
+		trigger: function( type, data ) {
+			return this.each(function() {
+				jQuery.event.trigger( type, data, this );
+			});
+		},
+		triggerHandler: function( type, data ) {
+			var elem = this[0];
+			if ( elem ) {
+				return jQuery.event.trigger( type, data, elem, true );
+			}
+		}
+	});
+	var isSimple = /^.[^:#\[\.,]*$/,
+		rneedsContext = jQuery.expr.match.needsContext,
+		// methods guaranteed to produce a unique set when starting from a unique set
+		guaranteedUnique = {
+			children: true,
+			contents: true,
+			next: true,
+			prev: true
+		};
+
+	jQuery.fn.extend({
+		find: function( selector ) {
+			var self, matched, i,
+				l = this.length;
+
+			if ( typeof selector !== "string" ) {
+				self = this;
+				return this.pushStack( jQuery( selector ).filter(function() {
+					for ( i = 0; i < l; i++ ) {
+						if ( jQuery.contains( self[ i ], this ) ) {
+							return true;
+						}
+					}
+				}) );
+			}
+
+			matched = [];
+			for ( i = 0; i < l; i++ ) {
+				jQuery.find( selector, this[ i ], matched );
+			}
+
+			// Needed because $( selector, context ) becomes $( context ).find( selector )
+			matched = this.pushStack( l > 1 ? jQuery.unique( matched ) : matched );
+			matched.selector = ( this.selector ? this.selector + " " : "" ) + selector;
+			return matched;
+		},
+
+		has: function( target ) {
+			var targets = jQuery( target, this ),
+				l = targets.length;
+
+			return this.filter(function() {
+				var i = 0;
+				for ( ; i < l; i++ ) {
+					if ( jQuery.contains( this, targets[i] ) ) {
+						return true;
+					}
+				}
+			});
+		},
+
+		not: function( selector ) {
+			return this.pushStack( winnow(this, selector || [], true) );
+		},
+
+		filter: function( selector ) {
+			return this.pushStack( winnow(this, selector || [], false) );
+		},
+
+		is: function( selector ) {
+			return !!selector && (
+				typeof selector === "string" ?
+					// If this is a positional/relative selector, check membership in the returned set
+					// so $("p:first").is("p:last") won't return true for a doc with two "p".
+					rneedsContext.test( selector ) ?
+						jQuery( selector, this.context ).index( this[ 0 ] ) >= 0 :
+						jQuery.filter( selector, this ).length > 0 :
+					this.filter( selector ).length > 0 );
+		},
+
+		closest: function( selectors, context ) {
+			var cur,
+				i = 0,
+				l = this.length,
+				matched = [],
+				pos = ( rneedsContext.test( selectors ) || typeof selectors !== "string" ) ?
+					jQuery( selectors, context || this.context ) :
+					0;
+
+			for ( ; i < l; i++ ) {
+				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
+					// Always skip document fragments
+					if ( cur.nodeType < 11 && (pos ?
+						pos.index(cur) > -1 :
+
+						// Don't pass non-elements to Sizzle
+						cur.nodeType === 1 &&
+							jQuery.find.matchesSelector(cur, selectors)) ) {
+
+						cur = matched.push( cur );
+						break;
+					}
+				}
+			}
+
+			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
+		},
+
+		// Determine the position of an element within
+		// the matched set of elements
+		index: function( elem ) {
+
+			// No argument, return index in parent
+			if ( !elem ) {
+				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
+			}
+
+			// index in selector
+			if ( typeof elem === "string" ) {
+				return core_indexOf.call( jQuery( elem ), this[ 0 ] );
+			}
+
+			// Locate the position of the desired element
+			return core_indexOf.call( this,
+
+				// If it receives a jQuery object, the first element is used
+				elem.jquery ? elem[ 0 ] : elem
+			);
+		},
+
+		add: function( selector, context ) {
+			var set = typeof selector === "string" ?
+					jQuery( selector, context ) :
+					jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
+				all = jQuery.merge( this.get(), set );
+
+			return this.pushStack( jQuery.unique(all) );
+		},
+
+		addBack: function( selector ) {
+			return this.add( selector == null ?
+				this.prevObject : this.prevObject.filter(selector)
+			);
+		}
+	});
+
+	function sibling( cur, dir ) {
+		while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
+
+		return cur;
+	}
+
+	jQuery.each({
+		parent: function( elem ) {
+			var parent = elem.parentNode;
+			return parent && parent.nodeType !== 11 ? parent : null;
+		},
+		parents: function( elem ) {
+			return jQuery.dir( elem, "parentNode" );
+		},
+		parentsUntil: function( elem, i, until ) {
+			return jQuery.dir( elem, "parentNode", until );
+		},
+		next: function( elem ) {
+			return sibling( elem, "nextSibling" );
+		},
+		prev: function( elem ) {
+			return sibling( elem, "previousSibling" );
+		},
+		nextAll: function( elem ) {
+			return jQuery.dir( elem, "nextSibling" );
+		},
+		prevAll: function( elem ) {
+			return jQuery.dir( elem, "previousSibling" );
+		},
+		nextUntil: function( elem, i, until ) {
+			return jQuery.dir( elem, "nextSibling", until );
+		},
+		prevUntil: function( elem, i, until ) {
+			return jQuery.dir( elem, "previousSibling", until );
+		},
+		siblings: function( elem ) {
+			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
+		},
+		children: function( elem ) {
+			return jQuery.sibling( elem.firstChild );
+		},
+		contents: function( elem ) {
+			return jQuery.nodeName( elem, "iframe" ) ?
+				elem.contentDocument || elem.contentWindow.document :
+				jQuery.merge( [], elem.childNodes );
+		}
+	}, function( name, fn ) {
+		jQuery.fn[ name ] = function( until, selector ) {
+			var matched = jQuery.map( this, fn, until );
+
+			if ( name.slice( -5 ) !== "Until" ) {
+				selector = until;
+			}
+
+			if ( selector && typeof selector === "string" ) {
+				matched = jQuery.filter( selector, matched );
+			}
+
+			if ( this.length > 1 ) {
+				// Remove duplicates
+				if ( !guaranteedUnique[ name ] ) {
+					jQuery.unique( matched );
+				}
+
+				// Reverse order for parents* and prev*
+				if ( name[ 0 ] === "p" ) {
+					matched.reverse();
+				}
+			}
+
+			return this.pushStack( matched );
+		};
+	});
+
+	jQuery.extend({
+		filter: function( expr, elems, not ) {
+			var elem = elems[ 0 ];
+
+			if ( not ) {
+				expr = ":not(" + expr + ")";
+			}
+
+			return elems.length === 1 && elem.nodeType === 1 ?
+				jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
+				jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
+					return elem.nodeType === 1;
+				}));
+		},
+
+		dir: function( elem, dir, until ) {
+			var matched = [],
+				truncate = until !== undefined;
+
+			while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
+				if ( elem.nodeType === 1 ) {
+					if ( truncate && jQuery( elem ).is( until ) ) {
+						break;
+					}
+					matched.push( elem );
+				}
+			}
+			return matched;
+		},
+
+		sibling: function( n, elem ) {
+			var matched = [];
+
+			for ( ; n; n = n.nextSibling ) {
+				if ( n.nodeType === 1 && n !== elem ) {
+					matched.push( n );
+				}
+			}
+
+			return matched;
+		}
+	});
+
+	// Implement the identical functionality for filter and not
+	function winnow( elements, qualifier, not ) {
+		if ( jQuery.isFunction( qualifier ) ) {
+			return jQuery.grep( elements, function( elem, i ) {
+				/* jshint -W018 */
+				return !!qualifier.call( elem, i, elem ) !== not;
+			});
+
+		}
+
+		if ( qualifier.nodeType ) {
+			return jQuery.grep( elements, function( elem ) {
+				return ( elem === qualifier ) !== not;
+			});
+
+		}
+
+		if ( typeof qualifier === "string" ) {
+			if ( isSimple.test( qualifier ) ) {
+				return jQuery.filter( qualifier, elements, not );
+			}
+
+			qualifier = jQuery.filter( qualifier, elements );
+		}
+
+		return jQuery.grep( elements, function( elem ) {
+			return ( core_indexOf.call( qualifier, elem ) >= 0 ) !== not;
+		});
+	}
+	var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
+		rtagName = /<([\w:]+)/,
+		rhtml = /<|&#?\w+;/,
+		rnoInnerhtml = /<(?:script|style|link)/i,
+		manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
+		// checked="checked" or checked
+		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
+		rscriptType = /^$|\/(?:java|ecma)script/i,
+		rscriptTypeMasked = /^true\/(.*)/,
+		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
+
+		// We have to close these tags to support XHTML (#13200)
+		wrapMap = {
+
+			// Support: IE 9
+			option: [ 1, "<select multiple='multiple'>", "</select>" ],
+
+			thead: [ 1, "<table>", "</table>" ],
+			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
+			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
+
+			_default: [ 0, "", "" ]
+		};
+
+	// Support: IE 9
+	wrapMap.optgroup = wrapMap.option;
+
+	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.col = wrapMap.thead;
+	wrapMap.th = wrapMap.td;
+
+	jQuery.fn.extend({
+		text: function( value ) {
+			return jQuery.access( this, function( value ) {
+				return value === undefined ?
+					jQuery.text( this ) :
+					this.empty().append( ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value ) );
+			}, null, value, arguments.length );
+		},
+
+		append: function() {
+			return this.domManip( arguments, function( elem ) {
+				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
+					var target = manipulationTarget( this, elem );
+					target.appendChild( elem );
+				}
+			});
+		},
+
+		prepend: function() {
+			return this.domManip( arguments, function( elem ) {
+				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
+					var target = manipulationTarget( this, elem );
+					target.insertBefore( elem, target.firstChild );
+				}
+			});
+		},
+
+		before: function() {
+			return this.domManip( arguments, function( elem ) {
+				if ( this.parentNode ) {
+					this.parentNode.insertBefore( elem, this );
+				}
+			});
+		},
+
+		after: function() {
+			return this.domManip( arguments, function( elem ) {
+				if ( this.parentNode ) {
+					this.parentNode.insertBefore( elem, this.nextSibling );
+				}
+			});
+		},
+
+		// keepData is for internal use only--do not document
+		remove: function( selector, keepData ) {
+			var elem,
+				elems = selector ? jQuery.filter( selector, this ) : this,
+				i = 0;
+
+			for ( ; (elem = elems[i]) != null; i++ ) {
+				if ( !keepData && elem.nodeType === 1 ) {
+					jQuery.cleanData( getAll( elem ) );
+				}
+
+				if ( elem.parentNode ) {
+					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
+						setGlobalEval( getAll( elem, "script" ) );
+					}
+					elem.parentNode.removeChild( elem );
+				}
+			}
+
+			return this;
+		},
+
+		empty: function() {
+			var elem,
+				i = 0;
+
+			for ( ; (elem = this[i]) != null; i++ ) {
+				if ( elem.nodeType === 1 ) {
+
+					// Prevent memory leaks
+					jQuery.cleanData( getAll( elem, false ) );
+
+					// Remove any remaining nodes
+					elem.textContent = "";
+				}
+			}
+
+			return this;
+		},
+
+		clone: function( dataAndEvents, deepDataAndEvents ) {
+			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
+			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
+
+			return this.map( function () {
+				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
+			});
+		},
+
+		html: function( value ) {
+			return jQuery.access( this, function( value ) {
+				var elem = this[ 0 ] || {},
+					i = 0,
+					l = this.length;
+
+				if ( value === undefined && elem.nodeType === 1 ) {
+					return elem.innerHTML;
+				}
+
+				// See if we can take a shortcut and just use innerHTML
+				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
+					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
+
+					value = value.replace( rxhtmlTag, "<$1></$2>" );
+
+					try {
+						for ( ; i < l; i++ ) {
+							elem = this[ i ] || {};
+
+							// Remove element nodes and prevent memory leaks
+							if ( elem.nodeType === 1 ) {
+								jQuery.cleanData( getAll( elem, false ) );
+								elem.innerHTML = value;
+							}
+						}
+
+						elem = 0;
+
+					// If using innerHTML throws an exception, use the fallback method
+					} catch( e ) {}
+				}
+
+				if ( elem ) {
+					this.empty().append( value );
+				}
+			}, null, value, arguments.length );
+		},
+
+		replaceWith: function() {
+			var
+				// Snapshot the DOM in case .domManip sweeps something relevant into its fragment
+				args = jQuery.map( this, function( elem ) {
+					return [ elem.nextSibling, elem.parentNode ];
+				}),
+				i = 0;
+
+			// Make the changes, replacing each context element with the new content
+			this.domManip( arguments, function( elem ) {
+				var next = args[ i++ ],
+					parent = args[ i++ ];
+
+				if ( parent ) {
+					jQuery( this ).remove();
+					parent.insertBefore( elem, next );
+				}
+			// Allow new content to include elements from the context set
+			}, true );
+
+			// Force removal if there was no new content (e.g., from empty arguments)
+			return i ? this : this.remove();
+		},
+
+		detach: function( selector ) {
+			return this.remove( selector, true );
+		},
+
+		domManip: function( args, callback, allowIntersection ) {
+
+			// Flatten any nested arrays
+			args = core_concat.apply( [], args );
+
+			var fragment, first, scripts, hasScripts, node, doc,
+				i = 0,
+				l = this.length,
+				set = this,
+				iNoClone = l - 1,
+				value = args[ 0 ],
+				isFunction = jQuery.isFunction( value );
+
+			// We can't cloneNode fragments that contain checked, in WebKit
+			if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
+				return this.each(function( index ) {
+					var self = set.eq( index );
+					if ( isFunction ) {
+						args[ 0 ] = value.call( this, index, self.html() );
+					}
+					self.domManip( args, callback, allowIntersection );
+				});
+			}
+
+			if ( l ) {
+				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );
+				first = fragment.firstChild;
+
+				if ( fragment.childNodes.length === 1 ) {
+					fragment = first;
+				}
+
+				if ( first ) {
+					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
+					hasScripts = scripts.length;
+
+					// Use the original fragment for the last item instead of the first because it can end up
+					// being emptied incorrectly in certain situations (#8070).
+					for ( ; i < l; i++ ) {
+						node = fragment;
+
+						if ( i !== iNoClone ) {
+							node = jQuery.clone( node, true, true );
+
+							// Keep references to cloned scripts for later restoration
+							if ( hasScripts ) {
+								// Support: QtWebKit
+								// jQuery.merge because core_push.apply(_, arraylike) throws
+								jQuery.merge( scripts, getAll( node, "script" ) );
+							}
+						}
+
+						callback.call( this[ i ], node, i );
+					}
+
+					if ( hasScripts ) {
+						doc = scripts[ scripts.length - 1 ].ownerDocument;
+
+						// Reenable scripts
+						jQuery.map( scripts, restoreScript );
+
+						// Evaluate executable scripts on first document insertion
+						for ( i = 0; i < hasScripts; i++ ) {
+							node = scripts[ i ];
+							if ( rscriptType.test( node.type || "" ) &&
+								!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
+
+								if ( node.src ) {
+									// Hope ajax is available...
+									jQuery._evalUrl( node.src );
+								} else {
+									jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
+								}
+							}
+						}
+					}
+				}
+			}
+
+			return this;
+		}
+	});
+
+	jQuery.each({
+		appendTo: "append",
+		prependTo: "prepend",
+		insertBefore: "before",
+		insertAfter: "after",
+		replaceAll: "replaceWith"
+	}, function( name, original ) {
+		jQuery.fn[ name ] = function( selector ) {
+			var elems,
+				ret = [],
+				insert = jQuery( selector ),
+				last = insert.length - 1,
+				i = 0;
+
+			for ( ; i <= last; i++ ) {
+				elems = i === last ? this : this.clone( true );
+				jQuery( insert[ i ] )[ original ]( elems );
+
+				// Support: QtWebKit
+				// .get() because core_push.apply(_, arraylike) throws
+				core_push.apply( ret, elems.get() );
+			}
+
+			return this.pushStack( ret );
+		};
+	});
+
+	jQuery.extend({
+		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
+			var i, l, srcElements, destElements,
+				clone = elem.cloneNode( true ),
+				inPage = jQuery.contains( elem.ownerDocument, elem );
+
+			// Support: IE >= 9
+			// Fix Cloning issues
+			if ( !jQuery.support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {
+
+				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
+				destElements = getAll( clone );
+				srcElements = getAll( elem );
+
+				for ( i = 0, l = srcElements.length; i < l; i++ ) {
+					fixInput( srcElements[ i ], destElements[ i ] );
+				}
+			}
+
+			// Copy the events from the original to the clone
+			if ( dataAndEvents ) {
+				if ( deepDataAndEvents ) {
+					srcElements = srcElements || getAll( elem );
+					destElements = destElements || getAll( clone );
+
+					for ( i = 0, l = srcElements.length; i < l; i++ ) {
+						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
+					}
+				} else {
+					cloneCopyEvent( elem, clone );
+				}
+			}
+
+			// Preserve script evaluation history
+			destElements = getAll( clone, "script" );
+			if ( destElements.length > 0 ) {
+				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
+			}
+
+			// Return the cloned set
+			return clone;
+		},
+
+		buildFragment: function( elems, context, scripts, selection ) {
+			var elem, tmp, tag, wrap, contains, j,
+				i = 0,
+				l = elems.length,
+				fragment = context.createDocumentFragment(),
+				nodes = [];
+
+			for ( ; i < l; i++ ) {
+				elem = elems[ i ];
+
+				if ( elem || elem === 0 ) {
+
+					// Add nodes directly
+					if ( jQuery.type( elem ) === "object" ) {
+						// Support: QtWebKit
+						// jQuery.merge because core_push.apply(_, arraylike) throws
+						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
+
+					// Convert non-html into a text node
+					} else if ( !rhtml.test( elem ) ) {
+						nodes.push( context.createTextNode( elem ) );
+
+					// Convert html into DOM nodes
+					} else {
+						tmp = tmp || fragment.appendChild( context.createElement("div") );
+
+						// Deserialize a standard representation
+						tag = ( rtagName.exec( elem ) || ["", ""] )[ 1 ].toLowerCase();
+						wrap = wrapMap[ tag ] || wrapMap._default;
+						tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];
+
+						// Descend through wrappers to the right content
+						j = wrap[ 0 ];
+						while ( j-- ) {
+							tmp = tmp.firstChild;
+						}
+
+						// Support: QtWebKit
+						// jQuery.merge because core_push.apply(_, arraylike) throws
+						jQuery.merge( nodes, tmp.childNodes );
+
+						// Remember the top-level container
+						tmp = fragment.firstChild;
+
+						// Fixes #12346
+						// Support: Webkit, IE
+						tmp.textContent = "";
+					}
+				}
+			}
+
+			// Remove wrapper from fragment
+			fragment.textContent = "";
+
+			i = 0;
+			while ( (elem = nodes[ i++ ]) ) {
+
+				// #4087 - If origin and destination elements are the same, and this is
+				// that element, do not do anything
+				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
+					continue;
+				}
+
+				contains = jQuery.contains( elem.ownerDocument, elem );
+
+				// Append to fragment
+				tmp = getAll( fragment.appendChild( elem ), "script" );
+
+				// Preserve script evaluation history
+				if ( contains ) {
+					setGlobalEval( tmp );
+				}
+
+				// Capture executables
+				if ( scripts ) {
+					j = 0;
+					while ( (elem = tmp[ j++ ]) ) {
+						if ( rscriptType.test( elem.type || "" ) ) {
+							scripts.push( elem );
+						}
+					}
+				}
+			}
+
+			return fragment;
+		},
+
+		cleanData: function( elems ) {
+			var data, elem, type,
+				l = elems.length,
+				i = 0,
+				special = jQuery.event.special;
+
+			for ( ; i < l; i++ ) {
+				elem = elems[ i ];
+
+				if ( jQuery.acceptData( elem ) ) {
+
+					data = data_priv.access( elem );
+
+					if ( data ) {
+						for ( type in data.events ) {
+							if ( special[ type ] ) {
+								jQuery.event.remove( elem, type );
+
+							// This is a shortcut to avoid jQuery.event.remove's overhead
+							} else {
+								jQuery.removeEvent( elem, type, data.handle );
+							}
+						}
+					}
+				}
+				// Discard any remaining `private` and `user` data
+				// One day we'll replace the dual arrays with a WeakMap and this won't be an issue.
+				// (Splices the data objects out of the internal cache arrays)
+				data_user.discard( elem );
+				data_priv.discard( elem );
+			}
+		},
+
+		_evalUrl: function( url ) {
+			return jQuery.ajax({
+				url: url,
+				type: "GET",
+				dataType: "text",
+				async: false,
+				global: false,
+				success: jQuery.globalEval
+			});
+		}
+	});
+
+	// Support: 1.x compatibility
+	// Manipulating tables requires a tbody
+	function manipulationTarget( elem, content ) {
+		return jQuery.nodeName( elem, "table" ) &&
+			jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?
+
+			elem.getElementsByTagName("tbody")[0] ||
+				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
+			elem;
+	}
+
+	// Replace/restore the type attribute of script elements for safe DOM manipulation
+	function disableScript( elem ) {
+		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
+		return elem;
+	}
+	function restoreScript( elem ) {
+		var match = rscriptTypeMasked.exec( elem.type );
+
+		if ( match ) {
+			elem.type = match[ 1 ];
+		} else {
+			elem.removeAttribute("type");
+		}
+
+		return elem;
+	}
+
+	// Mark scripts as having already been evaluated
+	function setGlobalEval( elems, refElements ) {
+		var l = elems.length,
+			i = 0;
+
+		for ( ; i < l; i++ ) {
+			data_priv.set(
+				elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
+			);
+		}
+	}
+
+	function cloneCopyEvent( src, dest ) {
+		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
+
+		if ( dest.nodeType !== 1 ) {
+			return;
+		}
+
+		// 1. Copy private data: events, handlers, etc.
+		if ( data_priv.hasData( src ) ) {
+			pdataOld = data_priv.access( src );
+			pdataCur = jQuery.extend( {}, pdataOld );
+			events = pdataOld.events;
+
+			data_priv.set( dest, pdataCur );
+
+			if ( events ) {
+				delete pdataCur.handle;
+				pdataCur.events = {};
+
+				for ( type in events ) {
+					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
+						jQuery.event.add( dest, type, events[ type ][ i ] );
+					}
+				}
+			}
+		}
+
+		// 2. Copy user data
+		if ( data_user.hasData( src ) ) {
+			udataOld = data_user.access( src );
+			udataCur = jQuery.extend( {}, udataOld );
+
+			data_user.set( dest, udataCur );
+		}
+	}
+
+
+	function getAll( context, tag ) {
+		var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
+				context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
+				[];
+
+		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
+			jQuery.merge( [ context ], ret ) :
+			ret;
+	}
+
+	// Support: IE >= 9
+	function fixInput( src, dest ) {
+		var nodeName = dest.nodeName.toLowerCase();
+
+		// Fails to persist the checked state of a cloned checkbox or radio button.
+		if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
+			dest.checked = src.checked;
+
+		// Fails to return the selected option to the default selected state when cloning options
+		} else if ( nodeName === "input" || nodeName === "textarea" ) {
+			dest.defaultValue = src.defaultValue;
+		}
+	}
+	jQuery.fn.extend({
+		wrapAll: function( html ) {
+			var wrap;
+
+			if ( jQuery.isFunction( html ) ) {
+				return this.each(function( i ) {
+					jQuery( this ).wrapAll( html.call(this, i) );
+				});
+			}
+
+			if ( this[ 0 ] ) {
+
+				// The elements to wrap the target around
+				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
+
+				if ( this[ 0 ].parentNode ) {
+					wrap.insertBefore( this[ 0 ] );
+				}
+
+				wrap.map(function() {
+					var elem = this;
+
+					while ( elem.firstElementChild ) {
+						elem = elem.firstElementChild;
+					}
+
+					return elem;
+				}).append( this );
+			}
+
+			return this;
+		},
+
+		wrapInner: function( html ) {
+			if ( jQuery.isFunction( html ) ) {
+				return this.each(function( i ) {
+					jQuery( this ).wrapInner( html.call(this, i) );
+				});
+			}
+
+			return this.each(function() {
+				var self = jQuery( this ),
+					contents = self.contents();
+
+				if ( contents.length ) {
+					contents.wrapAll( html );
+
+				} else {
+					self.append( html );
+				}
+			});
+		},
+
+		wrap: function( html ) {
+			var isFunction = jQuery.isFunction( html );
+
+			return this.each(function( i ) {
+				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
+			});
+		},
+
+		unwrap: function() {
+			return this.parent().each(function() {
+				if ( !jQuery.nodeName( this, "body" ) ) {
+					jQuery( this ).replaceWith( this.childNodes );
+				}
+			}).end();
+		}
+	});
+	var curCSS, iframe,
+		// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
+		// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
+		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
+		rmargin = /^margin/,
+		rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
+		rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
+		rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
+		elemdisplay = { BODY: "block" },
+
+		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
+		cssNormalTransform = {
+			letterSpacing: 0,
+			fontWeight: 400
+		},
+
+		cssExpand = [ "Top", "Right", "Bottom", "Left" ],
+		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
+
+	// return a css property mapped to a potentially vendor prefixed property
+	function vendorPropName( style, name ) {
+
+		// shortcut for names that are not vendor prefixed
+		if ( name in style ) {
+			return name;
+		}
+
+		// check for vendor prefixed names
+		var capName = name.charAt(0).toUpperCase() + name.slice(1),
+			origName = name,
+			i = cssPrefixes.length;
+
+		while ( i-- ) {
+			name = cssPrefixes[ i ] + capName;
+			if ( name in style ) {
+				return name;
+			}
+		}
+
+		return origName;
+	}
+
+	function isHidden( elem, el ) {
+		// isHidden might be called from jQuery#filter function;
+		// in that case, element will be second argument
+		elem = el || elem;
+		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
+	}
+
+	// NOTE: we've included the "window" in window.getComputedStyle
+	// because jsdom on node.js will break without it.
+	function getStyles( elem ) {
+		return window.getComputedStyle( elem, null );
+	}
+
+	function showHide( elements, show ) {
+		var display, elem, hidden,
+			values = [],
+			index = 0,
+			length = elements.length;
+
+		for ( ; index < length; index++ ) {
+			elem = elements[ index ];
+			if ( !elem.style ) {
+				continue;
+			}
+
+			values[ index ] = data_priv.get( elem, "olddisplay" );
+			display = elem.style.display;
+			if ( show ) {
+				// Reset the inline display of this element to learn if it is
+				// being hidden by cascaded rules or not
+				if ( !values[ index ] && display === "none" ) {
+					elem.style.display = "";
+				}
+
+				// Set elements which have been overridden with display: none
+				// in a stylesheet to whatever the default browser style is
+				// for such an element
+				if ( elem.style.display === "" && isHidden( elem ) ) {
+					values[ index ] = data_priv.access( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
+				}
+			} else {
+
+				if ( !values[ index ] ) {
+					hidden = isHidden( elem );
+
+					if ( display && display !== "none" || !hidden ) {
+						data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css(elem, "display") );
+					}
+				}
+			}
+		}
+
+		// Set the display of most of the elements in a second loop
+		// to avoid the constant reflow
+		for ( index = 0; index < length; index++ ) {
+			elem = elements[ index ];
+			if ( !elem.style ) {
+				continue;
+			}
+			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
+				elem.style.display = show ? values[ index ] || "" : "none";
+			}
+		}
+
+		return elements;
+	}
+
+	jQuery.fn.extend({
+		css: function( name, value ) {
+			return jQuery.access( this, function( elem, name, value ) {
+				var styles, len,
+					map = {},
+					i = 0;
+
+				if ( jQuery.isArray( name ) ) {
+					styles = getStyles( elem );
+					len = name.length;
+
+					for ( ; i < len; i++ ) {
+						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
+					}
+
+					return map;
+				}
+
+				return value !== undefined ?
+					jQuery.style( elem, name, value ) :
+					jQuery.css( elem, name );
+			}, name, value, arguments.length > 1 );
+		},
+		show: function() {
+			return showHide( this, true );
+		},
+		hide: function() {
+			return showHide( this );
+		},
+		toggle: function( state ) {
+			var bool = typeof state === "boolean";
+
+			return this.each(function() {
+				if ( bool ? state : isHidden( this ) ) {
+					jQuery( this ).show();
+				} else {
+					jQuery( this ).hide();
+				}
+			});
+		}
+	});
+
+	jQuery.extend({
+		// Add in style property hooks for overriding the default
+		// behavior of getting and setting a style property
+		cssHooks: {
+			opacity: {
+				get: function( elem, computed ) {
+					if ( computed ) {
+						// We should always get a number back from opacity
+						var ret = curCSS( elem, "opacity" );
+						return ret === "" ? "1" : ret;
+					}
+				}
+			}
+		},
+
+		// Exclude the following css properties to add px
+		cssNumber: {
+			"columnCount": true,
+			"fillOpacity": true,
+			"fontWeight": true,
+			"lineHeight": true,
+			"opacity": true,
+			"orphans": true,
+			"widows": true,
+			"zIndex": true,
+			"zoom": true
+		},
+
+		// Add in properties whose names you wish to fix before
+		// setting or getting the value
+		cssProps: {
+			// normalize float css property
+			"float": "cssFloat"
+		},
+
+		// Get and set the style property on a DOM Node
+		style: function( elem, name, value, extra ) {
+			// Don't set styles on text and comment nodes
+			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
+				return;
+			}
+
+			// Make sure that we're working with the right name
+			var ret, type, hooks,
+				origName = jQuery.camelCase( name ),
+				style = elem.style;
+
+			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
+
+			// gets hook for the prefixed version
+			// followed by the unprefixed version
+			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
+
+			// Check if we're setting a value
+			if ( value !== undefined ) {
+				type = typeof value;
+
+				// convert relative number strings (+= or -=) to relative numbers. #7345
+				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
+					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
+					// Fixes bug #9237
+					type = "number";
+				}
+
+				// Make sure that NaN and null values aren't set. See: #7116
+				if ( value == null || type === "number" && isNaN( value ) ) {
+					return;
+				}
+
+				// If a number was passed in, add 'px' to the (except for certain CSS properties)
+				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
+					value += "px";
+				}
+
+				// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
+				// but it would mean to define eight (for every problematic property) identical functions
+				if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
+					style[ name ] = "inherit";
+				}
+
+				// If a hook was provided, use that value, otherwise just set the specified value
+				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
+					style[ name ] = value;
+				}
+
+			} else {
+				// If a hook was provided get the non-computed value from there
+				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
+					return ret;
+				}
+
+				// Otherwise just get the value from the style object
+				return style[ name ];
+			}
+		},
+
+		css: function( elem, name, extra, styles ) {
+			var val, num, hooks,
+				origName = jQuery.camelCase( name );
+
+			// Make sure that we're working with the right name
+			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
+
+			// gets hook for the prefixed version
+			// followed by the unprefixed version
+			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
+
+			// If a hook was provided get the computed value from there
+			if ( hooks && "get" in hooks ) {
+				val = hooks.get( elem, true, extra );
+			}
+
+			// Otherwise, if a way to get the computed value exists, use that
+			if ( val === undefined ) {
+				val = curCSS( elem, name, styles );
+			}
+
+			//convert "normal" to computed value
+			if ( val === "normal" && name in cssNormalTransform ) {
+				val = cssNormalTransform[ name ];
+			}
+
+			// Return, converting to number if forced or a qualifier was provided and val looks numeric
+			if ( extra === "" || extra ) {
+				num = parseFloat( val );
+				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
+			}
+			return val;
+		}
+	});
+
+	curCSS = function( elem, name, _computed ) {
+		var width, minWidth, maxWidth,
+			computed = _computed || getStyles( elem ),
+
+			// Support: IE9
+			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
+			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
+			style = elem.style;
+
+		if ( computed ) {
+
+			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
+				ret = jQuery.style( elem, name );
+			}
+
+			// Support: Safari 5.1
+			// A tribute to the "awesome hack by Dean Edwards"
+			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
+			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
+			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
+
+				// Remember the original values
+				width = style.width;
+				minWidth = style.minWidth;
+				maxWidth = style.maxWidth;
+
+				// Put in the new values to get a computed value out
+				style.minWidth = style.maxWidth = style.width = ret;
+				ret = computed.width;
+
+				// Revert the changed values
+				style.width = width;
+				style.minWidth = minWidth;
+				style.maxWidth = maxWidth;
+			}
+		}
+
+		return ret;
+	};
+
+
+	function setPositiveNumber( elem, value, subtract ) {
+		var matches = rnumsplit.exec( value );
+		return matches ?
+			// Guard against undefined "subtract", e.g., when used as in cssHooks
+			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
+			value;
+	}
+
+	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
+		var i = extra === ( isBorderBox ? "border" : "content" ) ?
+			// If we already have the right measurement, avoid augmentation
+			4 :
+			// Otherwise initialize for horizontal or vertical properties
+			name === "width" ? 1 : 0,
+
+			val = 0;
+
+		for ( ; i < 4; i += 2 ) {
+			// both box models exclude margin, so add it if we want it
+			if ( extra === "margin" ) {
+				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
+			}
+
+			if ( isBorderBox ) {
+				// border-box includes padding, so remove it if we want content
+				if ( extra === "content" ) {
+					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
+				}
+
+				// at this point, extra isn't border nor margin, so remove border
+				if ( extra !== "margin" ) {
+					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
+				}
+			} else {
+				// at this point, extra isn't content, so add padding
+				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
+
+				// at this point, extra isn't content nor padding, so add border
+				if ( extra !== "padding" ) {
+					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
+				}
+			}
+		}
+
+		return val;
+	}
+
+	function getWidthOrHeight( elem, name, extra ) {
+
+		// Start with offset property, which is equivalent to the border-box value
+		var valueIsBorderBox = true,
+			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
+			styles = getStyles( elem ),
+			isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
+
+		// some non-html elements return undefined for offsetWidth, so check for null/undefined
+		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
+		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
+		if ( val <= 0 || val == null ) {
+			// Fall back to computed then uncomputed css if necessary
+			val = curCSS( elem, name, styles );
+			if ( val < 0 || val == null ) {
+				val = elem.style[ name ];
+			}
+
+			// Computed unit is not pixels. Stop here and return.
+			if ( rnumnonpx.test(val) ) {
+				return val;
+			}
+
+			// we need the check for style in case a browser which returns unreliable values
+			// for getComputedStyle silently falls back to the reliable elem.style
+			valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );
+
+			// Normalize "", auto, and prepare for extra
+			val = parseFloat( val ) || 0;
+		}
+
+		// use the active box-sizing model to add/subtract irrelevant styles
+		return ( val +
+			augmentWidthOrHeight(
+				elem,
+				name,
+				extra || ( isBorderBox ? "border" : "content" ),
+				valueIsBorderBox,
+				styles
+			)
+		) + "px";
+	}
+
+	// Try to determine the default display value of an element
+	function css_defaultDisplay( nodeName ) {
+		var doc = document,
+			display = elemdisplay[ nodeName ];
+
+		if ( !display ) {
+			display = actualDisplay( nodeName, doc );
+
+			// If the simple way fails, read from inside an iframe
+			if ( display === "none" || !display ) {
+				// Use the already-created iframe if possible
+				iframe = ( iframe ||
+					jQuery("<iframe frameborder='0' width='0' height='0'/>")
+					.css( "cssText", "display:block !important" )
+				).appendTo( doc.documentElement );
+
+				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
+				doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
+				doc.write("<!doctype html><html><body>");
+				doc.close();
+
+				display = actualDisplay( nodeName, doc );
+				iframe.detach();
+			}
+
+			// Store the correct default display
+			elemdisplay[ nodeName ] = display;
+		}
+
+		return display;
+	}
+
+	// Called ONLY from within css_defaultDisplay
+	function actualDisplay( name, doc ) {
+		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
+			display = jQuery.css( elem[0], "display" );
+		elem.remove();
+		return display;
+	}
+
+	jQuery.each([ "height", "width" ], function( i, name ) {
+		jQuery.cssHooks[ name ] = {
+			get: function( elem, computed, extra ) {
+				if ( computed ) {
+					// certain elements can have dimension info if we invisibly show them
+					// however, it must have a current display style that would benefit from this
+					return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
+						jQuery.swap( elem, cssShow, function() {
+							return getWidthOrHeight( elem, name, extra );
+						}) :
+						getWidthOrHeight( elem, name, extra );
+				}
+			},
+
+			set: function( elem, value, extra ) {
+				var styles = extra && getStyles( elem );
+				return setPositiveNumber( elem, value, extra ?
+					augmentWidthOrHeight(
+						elem,
+						name,
+						extra,
+						jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
+						styles
+					) : 0
+				);
+			}
+		};
+	});
+
+	// These hooks cannot be added until DOM ready because the support test
+	// for it is not run until after DOM ready
+	jQuery(function() {
+		// Support: Android 2.3
+		if ( !jQuery.support.reliableMarginRight ) {
+			jQuery.cssHooks.marginRight = {
+				get: function( elem, computed ) {
+					if ( computed ) {
+						// Support: Android 2.3
+						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
+						// Work around by temporarily setting element display to inline-block
+						return jQuery.swap( elem, { "display": "inline-block" },
+							curCSS, [ elem, "marginRight" ] );
+					}
+				}
+			};
+		}
+
+		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
+		// getComputedStyle returns percent when specified for top/left/bottom/right
+		// rather than make the css module depend on the offset module, we just check for it here
+		if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
+			jQuery.each( [ "top", "left" ], function( i, prop ) {
+				jQuery.cssHooks[ prop ] = {
+					get: function( elem, computed ) {
+						if ( computed ) {
+							computed = curCSS( elem, prop );
+							// if curCSS returns percentage, fallback to offset
+							return rnumnonpx.test( computed ) ?
+								jQuery( elem ).position()[ prop ] + "px" :
+								computed;
+						}
+					}
+				};
+			});
+		}
+
+	});
+
+	if ( jQuery.expr && jQuery.expr.filters ) {
+		jQuery.expr.filters.hidden = function( elem ) {
+			// Support: Opera <= 12.12
+			// Opera reports offsetWidths and offsetHeights less than zero on some elements
+			return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
+		};
+
+		jQuery.expr.filters.visible = function( elem ) {
+			return !jQuery.expr.filters.hidden( elem );
+		};
+	}
+
+	// These hooks are used by animate to expand properties
+	jQuery.each({
+		margin: "",
+		padding: "",
+		border: "Width"
+	}, function( prefix, suffix ) {
+		jQuery.cssHooks[ prefix + suffix ] = {
+			expand: function( value ) {
+				var i = 0,
+					expanded = {},
+
+					// assumes a single number if not a string
+					parts = typeof value === "string" ? value.split(" ") : [ value ];
+
+				for ( ; i < 4; i++ ) {
+					expanded[ prefix + cssExpand[ i ] + suffix ] =
+						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
+				}
+
+				return expanded;
+			}
+		};
+
+		if ( !rmargin.test( prefix ) ) {
+			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
+		}
+	});
+	var r20 = /%20/g,
+		rbracket = /\[\]$/,
+		rCRLF = /\r?\n/g,
+		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
+		rsubmittable = /^(?:input|select|textarea|keygen)/i;
+
+	jQuery.fn.extend({
+		serialize: function() {
+			return jQuery.param( this.serializeArray() );
+		},
+		serializeArray: function() {
+			return this.map(function(){
+				// Can add propHook for "elements" to filter or add form elements
+				var elements = jQuery.prop( this, "elements" );
+				return elements ? jQuery.makeArray( elements ) : this;
+			})
+			.filter(function(){
+				var type = this.type;
+				// Use .is(":disabled") so that fieldset[disabled] works
+				return this.name && !jQuery( this ).is( ":disabled" ) &&
+					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
+					( this.checked || !manipulation_rcheckableType.test( type ) );
+			})
+			.map(function( i, elem ){
+				var val = jQuery( this ).val();
+
+				return val == null ?
+					null :
+					jQuery.isArray( val ) ?
+						jQuery.map( val, function( val ){
+							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
+						}) :
+						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
+			}).get();
+		}
+	});
+
+	//Serialize an array of form elements or a set of
+	//key/values into a query string
+	jQuery.param = function( a, traditional ) {
+		var prefix,
+			s = [],
+			add = function( key, value ) {
+				// If value is a function, invoke it and return its value
+				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
+				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
+			};
+
+		// Set traditional to true for jQuery <= 1.3.2 behavior.
+		if ( traditional === undefined ) {
+			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
+		}
+
+		// If an array was passed in, assume that it is an array of form elements.
+		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
+			// Serialize the form elements
+			jQuery.each( a, function() {
+				add( this.name, this.value );
+			});
+
+		} else {
+			// If traditional, encode the "old" way (the way 1.3.2 or older
+			// did it), otherwise encode params recursively.
+			for ( prefix in a ) {
+				buildParams( prefix, a[ prefix ], traditional, add );
+			}
+		}
+
+		// Return the resulting serialization
+		return s.join( "&" ).replace( r20, "+" );
+	};
+
+	function buildParams( prefix, obj, traditional, add ) {
+		var name;
+
+		if ( jQuery.isArray( obj ) ) {
+			// Serialize array item.
+			jQuery.each( obj, function( i, v ) {
+				if ( traditional || rbracket.test( prefix ) ) {
+					// Treat each array item as a scalar.
+					add( prefix, v );
+
+				} else {
+					// Item is non-scalar (array or object), encode its numeric index.
+					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
+				}
+			});
+
+		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
+			// Serialize object item.
+			for ( name in obj ) {
+				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
+			}
+
+		} else {
+			// Serialize scalar item.
+			add( prefix, obj );
+		}
+	}
+	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
+		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
+		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
+
+		// Handle event binding
+		jQuery.fn[ name ] = function( data, fn ) {
+			return arguments.length > 0 ?
+				this.on( name, null, data, fn ) :
+				this.trigger( name );
+		};
+	});
+
+	jQuery.fn.extend({
+		hover: function( fnOver, fnOut ) {
+			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
+		},
+
+		bind: function( types, data, fn ) {
+			return this.on( types, null, data, fn );
+		},
+		unbind: function( types, fn ) {
+			return this.off( types, null, fn );
+		},
+
+		delegate: function( selector, types, data, fn ) {
+			return this.on( types, selector, data, fn );
+		},
+		undelegate: function( selector, types, fn ) {
+			// ( namespace ) or ( selector, types [, fn] )
+			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
+		}
+	});
+	var
+		// Document location
+		ajaxLocParts,
+		ajaxLocation,
+
+		ajax_nonce = jQuery.now(),
+
+		ajax_rquery = /\?/,
+		rhash = /#.*$/,
+		rts = /([?&])_=[^&]*/,
+		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
+		// #7653, #8125, #8152: local protocol detection
+		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
+		rnoContent = /^(?:GET|HEAD)$/,
+		rprotocol = /^\/\//,
+		rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
+
+		// Keep a copy of the old load method
+		_load = jQuery.fn.load,
+
+		/* Prefilters
+		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
+		 * 2) These are called:
+		 *    - BEFORE asking for a transport
+		 *    - AFTER param serialization (s.data is a string if s.processData is true)
+		 * 3) key is the dataType
+		 * 4) the catchall symbol "*" can be used
+		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
+		 */
+		prefilters = {},
+
+		/* Transports bindings
+		 * 1) key is the dataType
+		 * 2) the catchall symbol "*" can be used
+		 * 3) selection will start with transport dataType and THEN go to "*" if needed
+		 */
+		transports = {},
+
+		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
+		allTypes = "*/".concat("*");
+
+	// #8138, IE may throw an exception when accessing
+	// a field from window.location if document.domain has been set
+	try {
+		ajaxLocation = location.href;
+	} catch( e ) {
+		// Use the href attribute of an A element
+		// since IE will modify it given document.location
+		ajaxLocation = document.createElement( "a" );
+		ajaxLocation.href = "";
+		ajaxLocation = ajaxLocation.href;
+	}
+
+	// Segment location into parts
+	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
+
+	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
+	function addToPrefiltersOrTransports( structure ) {
+
+		// dataTypeExpression is optional and defaults to "*"
+		return function( dataTypeExpression, func ) {
+
+			if ( typeof dataTypeExpression !== "string" ) {
+				func = dataTypeExpression;
+				dataTypeExpression = "*";
+			}
+
+			var dataType,
+				i = 0,
+				dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];
+
+			if ( jQuery.isFunction( func ) ) {
+				// For each dataType in the dataTypeExpression
+				while ( (dataType = dataTypes[i++]) ) {
+					// Prepend if requested
+					if ( dataType[0] === "+" ) {
+						dataType = dataType.slice( 1 ) || "*";
+						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );
+
+					// Otherwise append
+					} else {
+						(structure[ dataType ] = structure[ dataType ] || []).push( func );
+					}
+				}
+			}
+		};
+	}
+
+	// Base inspection function for prefilters and transports
+	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
+
+		var inspected = {},
+			seekingTransport = ( structure === transports );
+
+		function inspect( dataType ) {
+			var selected;
+			inspected[ dataType ] = true;
+			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
+				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
+				if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
+					options.dataTypes.unshift( dataTypeOrTransport );
+					inspect( dataTypeOrTransport );
+					return false;
+				} else if ( seekingTransport ) {
+					return !( selected = dataTypeOrTransport );
+				}
+			});
+			return selected;
+		}
+
+		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
+	}
+
+	// A special extend for ajax options
+	// that takes "flat" options (not to be deep extended)
+	// Fixes #9887
+	function ajaxExtend( target, src ) {
+		var key, deep,
+			flatOptions = jQuery.ajaxSettings.flatOptions || {};
+
+		for ( key in src ) {
+			if ( src[ key ] !== undefined ) {
+				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
+			}
+		}
+		if ( deep ) {
+			jQuery.extend( true, target, deep );
+		}
+
+		return target;
+	}
+
+	jQuery.fn.load = function( url, params, callback ) {
+		if ( typeof url !== "string" && _load ) {
+			return _load.apply( this, arguments );
+		}
+
+		var selector, type, response,
+			self = this,
+			off = url.indexOf(" ");
+
+		if ( off >= 0 ) {
+			selector = url.slice( off );
+			url = url.slice( 0, off );
+		}
+
+		// If it's a function
+		if ( jQuery.isFunction( params ) ) {
+
+			// We assume that it's the callback
+			callback = params;
+			params = undefined;
+
+		// Otherwise, build a param string
+		} else if ( params && typeof params === "object" ) {
+			type = "POST";
+		}
+
+		// If we have elements to modify, make the request
+		if ( self.length > 0 ) {
+			jQuery.ajax({
+				url: url,
+
+				// if "type" variable is undefined, then "GET" method will be used
+				type: type,
+				dataType: "html",
+				data: params
+			}).done(function( responseText ) {
+
+				// Save response for use in complete callback
+				response = arguments;
+
+				self.html( selector ?
+
+					// If a selector was specified, locate the right elements in a dummy div
+					// Exclude scripts to avoid IE 'Permission Denied' errors
+					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
+
+					// Otherwise use the full result
+					responseText );
+
+			}).complete( callback && function( jqXHR, status ) {
+				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
+			});
+		}
+
+		return this;
+	};
+
+	// Attach a bunch of functions for handling common AJAX events
+	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
+		jQuery.fn[ type ] = function( fn ){
+			return this.on( type, fn );
+		};
+	});
+
+	jQuery.extend({
+
+		// Counter for holding the number of active queries
+		active: 0,
+
+		// Last-Modified header cache for next request
+		lastModified: {},
+		etag: {},
+
+		ajaxSettings: {
+			url: ajaxLocation,
+			type: "GET",
+			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
+			global: true,
+			processData: true,
+			async: true,
+			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
+			/*
+			timeout: 0,
+			data: null,
+			dataType: null,
+			username: null,
+			password: null,
+			cache: null,
+			throws: false,
+			traditional: false,
+			headers: {},
+			*/
+
+			accepts: {
+				"*": allTypes,
+				text: "text/plain",
+				html: "text/html",
+				xml: "application/xml, text/xml",
+				json: "application/json, text/javascript"
+			},
+
+			contents: {
+				xml: /xml/,
+				html: /html/,
+				json: /json/
+			},
+
+			responseFields: {
+				xml: "responseXML",
+				text: "responseText",
+				json: "responseJSON"
+			},
+
+			// Data converters
+			// Keys separate source (or catchall "*") and destination types with a single space
+			converters: {
+
+				// Convert anything to text
+				"* text": String,
+
+				// Text to html (true = no transformation)
+				"text html": true,
+
+				// Evaluate text as a json expression
+				"text json": jQuery.parseJSON,
+
+				// Parse text as xml
+				"text xml": jQuery.parseXML
+			},
+
+			// For options that shouldn't be deep extended:
+			// you can add your own custom options here if
+			// and when you create one that shouldn't be
+			// deep extended (see ajaxExtend)
+			flatOptions: {
+				url: true,
+				context: true
+			}
+		},
+
+		// Creates a full fledged settings object into target
+		// with both ajaxSettings and settings fields.
+		// If target is omitted, writes into ajaxSettings.
+		ajaxSetup: function( target, settings ) {
+			return settings ?
+
+				// Building a settings object
+				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
+
+				// Extending ajaxSettings
+				ajaxExtend( jQuery.ajaxSettings, target );
+		},
+
+		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
+		ajaxTransport: addToPrefiltersOrTransports( transports ),
+
+		// Main method
+		ajax: function( url, options ) {
+
+			// If url is an object, simulate pre-1.5 signature
+			if ( typeof url === "object" ) {
+				options = url;
+				url = undefined;
+			}
+
+			// Force options to be an object
+			options = options || {};
+
+			var transport,
+				// URL without anti-cache param
+				cacheURL,
+				// Response headers
+				responseHeadersString,
+				responseHeaders,
+				// timeout handle
+				timeoutTimer,
+				// Cross-domain detection vars
+				parts,
+				// To know if global events are to be dispatched
+				fireGlobals,
+				// Loop variable
+				i,
+				// Create the final options object
+				s = jQuery.ajaxSetup( {}, options ),
+				// Callbacks context
+				callbackContext = s.context || s,
+				// Context for global events is callbackContext if it is a DOM node or jQuery collection
+				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
+					jQuery( callbackContext ) :
+					jQuery.event,
+				// Deferreds
+				deferred = jQuery.Deferred(),
+				completeDeferred = jQuery.Callbacks("once memory"),
+				// Status-dependent callbacks
+				statusCode = s.statusCode || {},
+				// Headers (they are sent all at once)
+				requestHeaders = {},
+				requestHeadersNames = {},
+				// The jqXHR state
+				state = 0,
+				// Default abort message
+				strAbort = "canceled",
+				// Fake xhr
+				jqXHR = {
+					readyState: 0,
+
+					// Builds headers hashtable if needed
+					getResponseHeader: function( key ) {
+						var match;
+						if ( state === 2 ) {
+							if ( !responseHeaders ) {
+								responseHeaders = {};
+								while ( (match = rheaders.exec( responseHeadersString )) ) {
+									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
+								}
+							}
+							match = responseHeaders[ key.toLowerCase() ];
+						}
+						return match == null ? null : match;
+					},
+
+					// Raw string
+					getAllResponseHeaders: function() {
+						return state === 2 ? responseHeadersString : null;
+					},
+
+					// Caches the header
+					setRequestHeader: function( name, value ) {
+						var lname = name.toLowerCase();
+						if ( !state ) {
+							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
+							requestHeaders[ name ] = value;
+						}
+						return this;
+					},
+
+					// Overrides response content-type header
+					overrideMimeType: function( type ) {
+						if ( !state ) {
+							s.mimeType = type;
+						}
+						return this;
+					},
+
+					// Status-dependent callbacks
+					statusCode: function( map ) {
+						var code;
+						if ( map ) {
+							if ( state < 2 ) {
+								for ( code in map ) {
+									// Lazy-add the new callback in a way that preserves old ones
+									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
+								}
+							} else {
+								// Execute the appropriate callbacks
+								jqXHR.always( map[ jqXHR.status ] );
+							}
+						}
+						return this;
+					},
+
+					// Cancel the request
+					abort: function( statusText ) {
+						var finalText = statusText || strAbort;
+						if ( transport ) {
+							transport.abort( finalText );
+						}
+						done( 0, finalText );
+						return this;
+					}
+				};
+
+			// Attach deferreds
+			deferred.promise( jqXHR ).complete = completeDeferred.add;
+			jqXHR.success = jqXHR.done;
+			jqXHR.error = jqXHR.fail;
+
+			// Remove hash character (#7531: and string promotion)
+			// Add protocol if not provided (prefilters might expect it)
+			// Handle falsy url in the settings object (#10093: consistency with old signature)
+			// We also use the url parameter if available
+			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
+				.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
+
+			// Alias method option to type as per ticket #12004
+			s.type = options.method || options.type || s.method || s.type;
+
+			// Extract dataTypes list
+			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];
+
+			// A cross-domain request is in order when we have a protocol:host:port mismatch
+			if ( s.crossDomain == null ) {
+				parts = rurl.exec( s.url.toLowerCase() );
+				s.crossDomain = !!( parts &&
+					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
+						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
+							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
+				);
+			}
+
+			// Convert data if not already a string
+			if ( s.data && s.processData && typeof s.data !== "string" ) {
+				s.data = jQuery.param( s.data, s.traditional );
+			}
+
+			// Apply prefilters
+			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
+
+			// If request was aborted inside a prefilter, stop there
+			if ( state === 2 ) {
+				return jqXHR;
+			}
+
+			// We can fire global events as of now if asked to
+			fireGlobals = s.global;
+
+			// Watch for a new set of requests
+			if ( fireGlobals && jQuery.active++ === 0 ) {
+				jQuery.event.trigger("ajaxStart");
+			}
+
+			// Uppercase the type
+			s.type = s.type.toUpperCase();
+
+			// Determine if request has content
+			s.hasContent = !rnoContent.test( s.type );
+
+			// Save the URL in case we're toying with the If-Modified-Since
+			// and/or If-None-Match header later on
+			cacheURL = s.url;
+
+			// More options handling for requests with no content
+			if ( !s.hasContent ) {
+
+				// If data is available, append data to url
+				if ( s.data ) {
+					cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
+					// #9682: remove data so that it's not used in an eventual retry
+					delete s.data;
+				}
+
+				// Add anti-cache in url if needed
+				if ( s.cache === false ) {
+					s.url = rts.test( cacheURL ) ?
+
+						// If there is already a '_' parameter, set its value
+						cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :
+
+						// Otherwise add one to the end
+						cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
+				}
+			}
+
+			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
+			if ( s.ifModified ) {
+				if ( jQuery.lastModified[ cacheURL ] ) {
+					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
+				}
+				if ( jQuery.etag[ cacheURL ] ) {
+					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
+				}
+			}
+
+			// Set the correct header, if data is being sent
+			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
+				jqXHR.setRequestHeader( "Content-Type", s.contentType );
+			}
+
+			// Set the Accepts header for the server, depending on the dataType
+			jqXHR.setRequestHeader(
+				"Accept",
+				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
+					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
+					s.accepts[ "*" ]
+			);
+
+			// Check for headers option
+			for ( i in s.headers ) {
+				jqXHR.setRequestHeader( i, s.headers[ i ] );
+			}
+
+			// Allow custom headers/mimetypes and early abort
+			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
+				// Abort if not done already and return
+				return jqXHR.abort();
+			}
+
+			// aborting is no longer a cancellation
+			strAbort = "abort";
+
+			// Install callbacks on deferreds
+			for ( i in { success: 1, error: 1, complete: 1 } ) {
+				jqXHR[ i ]( s[ i ] );
+			}
+
+			// Get transport
+			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
+
+			// If no transport, we auto-abort
+			if ( !transport ) {
+				done( -1, "No Transport" );
+			} else {
+				jqXHR.readyState = 1;
+
+				// Send global event
+				if ( fireGlobals ) {
+					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
+				}
+				// Timeout
+				if ( s.async && s.timeout > 0 ) {
+					timeoutTimer = setTimeout(function() {
+						jqXHR.abort("timeout");
+					}, s.timeout );
+				}
+
+				try {
+					state = 1;
+					transport.send( requestHeaders, done );
+				} catch ( e ) {
+					// Propagate exception as error if not done
+					if ( state < 2 ) {
+						done( -1, e );
+					// Simply rethrow otherwise
+					} else {
+						throw e;
+					}
+				}
+			}
+
+			// Callback for when everything is done
+			function done( status, nativeStatusText, responses, headers ) {
+				var isSuccess, success, error, response, modified,
+					statusText = nativeStatusText;
+
+				// Called once
+				if ( state === 2 ) {
+					return;
+				}
+
+				// State is "done" now
+				state = 2;
+
+				// Clear timeout if it exists
+				if ( timeoutTimer ) {
+					clearTimeout( timeoutTimer );
+				}
+
+				// Dereference transport for early garbage collection
+				// (no matter how long the jqXHR object will be used)
+				transport = undefined;
+
+				// Cache response headers
+				responseHeadersString = headers || "";
+
+				// Set readyState
+				jqXHR.readyState = status > 0 ? 4 : 0;
+
+				// Determine if successful
+				isSuccess = status >= 200 && status < 300 || status === 304;
+
+				// Get response data
+				if ( responses ) {
+					response = ajaxHandleResponses( s, jqXHR, responses );
+				}
+
+				// Convert no matter what (that way responseXXX fields are always set)
+				response = ajaxConvert( s, response, jqXHR, isSuccess );
+
+				// If successful, handle type chaining
+				if ( isSuccess ) {
+
+					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
+					if ( s.ifModified ) {
+						modified = jqXHR.getResponseHeader("Last-Modified");
+						if ( modified ) {
+							jQuery.lastModified[ cacheURL ] = modified;
+						}
+						modified = jqXHR.getResponseHeader("etag");
+						if ( modified ) {
+							jQuery.etag[ cacheURL ] = modified;
+						}
+					}
+
+					// if no content
+					if ( status === 204 ) {
+						statusText = "nocontent";
+
+					// if not modified
+					} else if ( status === 304 ) {
+						statusText = "notmodified";
+
+					// If we have data, let's convert it
+					} else {
+						statusText = response.state;
+						success = response.data;
+						error = response.error;
+						isSuccess = !error;
+					}
+				} else {
+					// We extract error from statusText
+					// then normalize statusText and status for non-aborts
+					error = statusText;
+					if ( status || !statusText ) {
+						statusText = "error";
+						if ( status < 0 ) {
+							status = 0;
+						}
+					}
+				}
+
+				// Set data for the fake xhr object
+				jqXHR.status = status;
+				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
+
+				// Success/Error
+				if ( isSuccess ) {
+					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
+				} else {
+					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
+				}
+
+				// Status-dependent callbacks
+				jqXHR.statusCode( statusCode );
+				statusCode = undefined;
+
+				if ( fireGlobals ) {
+					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
+						[ jqXHR, s, isSuccess ? success : error ] );
+				}
+
+				// Complete
+				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
+
+				if ( fireGlobals ) {
+					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
+					// Handle the global AJAX counter
+					if ( !( --jQuery.active ) ) {
+						jQuery.event.trigger("ajaxStop");
+					}
+				}
+			}
+
+			return jqXHR;
+		},
+
+		getJSON: function( url, data, callback ) {
+			return jQuery.get( url, data, callback, "json" );
+		},
+
+		getScript: function( url, callback ) {
+			return jQuery.get( url, undefined, callback, "script" );
+		}
+	});
+
+	jQuery.each( [ "get", "post" ], function( i, method ) {
+		jQuery[ method ] = function( url, data, callback, type ) {
+			// shift arguments if data argument was omitted
+			if ( jQuery.isFunction( data ) ) {
+				type = type || callback;
+				callback = data;
+				data = undefined;
+			}
+
+			return jQuery.ajax({
+				url: url,
+				type: method,
+				dataType: type,
+				data: data,
+				success: callback
+			});
+		};
+	});
+
+	/* Handles responses to an ajax request:
+	 * - finds the right dataType (mediates between content-type and expected dataType)
+	 * - returns the corresponding response
+	 */
+	function ajaxHandleResponses( s, jqXHR, responses ) {
+
+		var ct, type, finalDataType, firstDataType,
+			contents = s.contents,
+			dataTypes = s.dataTypes;
+
+		// Remove auto dataType and get content-type in the process
+		while( dataTypes[ 0 ] === "*" ) {
+			dataTypes.shift();
+			if ( ct === undefined ) {
+				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
+			}
+		}
+
+		// Check if we're dealing with a known content-type
+		if ( ct ) {
+			for ( type in contents ) {
+				if ( contents[ type ] && contents[ type ].test( ct ) ) {
+					dataTypes.unshift( type );
+					break;
+				}
+			}
+		}
+
+		// Check to see if we have a response for the expected dataType
+		if ( dataTypes[ 0 ] in responses ) {
+			finalDataType = dataTypes[ 0 ];
+		} else {
+			// Try convertible dataTypes
+			for ( type in responses ) {
+				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
+					finalDataType = type;
+					break;
+				}
+				if ( !firstDataType ) {
+					firstDataType = type;
+				}
+			}
+			// Or just use first one
+			finalDataType = finalDataType || firstDataType;
+		}
+
+		// If we found a dataType
+		// We add the dataType to the list if needed
+		// and return the corresponding response
+		if ( finalDataType ) {
+			if ( finalDataType !== dataTypes[ 0 ] ) {
+				dataTypes.unshift( finalDataType );
+			}
+			return responses[ finalDataType ];
+		}
+	}
+
+	/* Chain conversions given the request and the original response
+	 * Also sets the responseXXX fields on the jqXHR instance
+	 */
+	function ajaxConvert( s, response, jqXHR, isSuccess ) {
+		var conv2, current, conv, tmp, prev,
+			converters = {},
+			// Work with a copy of dataTypes in case we need to modify it for conversion
+			dataTypes = s.dataTypes.slice();
+
+		// Create converters map with lowercased keys
+		if ( dataTypes[ 1 ] ) {
+			for ( conv in s.converters ) {
+				converters[ conv.toLowerCase() ] = s.converters[ conv ];
+			}
+		}
+
+		current = dataTypes.shift();
+
+		// Convert to each sequential dataType
+		while ( current ) {
+
+			if ( s.responseFields[ current ] ) {
+				jqXHR[ s.responseFields[ current ] ] = response;
+			}
+
+			// Apply the dataFilter if provided
+			if ( !prev && isSuccess && s.dataFilter ) {
+				response = s.dataFilter( response, s.dataType );
+			}
+
+			prev = current;
+			current = dataTypes.shift();
+
+			if ( current ) {
+
+			// There's only work to do if current dataType is non-auto
+				if ( current === "*" ) {
+
+					current = prev;
+
+				// Convert response if prev dataType is non-auto and differs from current
+				} else if ( prev !== "*" && prev !== current ) {
+
+					// Seek a direct converter
+					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
+
+					// If none found, seek a pair
+					if ( !conv ) {
+						for ( conv2 in converters ) {
+
+							// If conv2 outputs current
+							tmp = conv2.split( " " );
+							if ( tmp[ 1 ] === current ) {
+
+								// If prev can be converted to accepted input
+								conv = converters[ prev + " " + tmp[ 0 ] ] ||
+									converters[ "* " + tmp[ 0 ] ];
+								if ( conv ) {
+									// Condense equivalence converters
+									if ( conv === true ) {
+										conv = converters[ conv2 ];
+
+									// Otherwise, insert the intermediate dataType
+									} else if ( converters[ conv2 ] !== true ) {
+										current = tmp[ 0 ];
+										dataTypes.unshift( tmp[ 1 ] );
+									}
+									break;
+								}
+							}
+						}
+					}
+
+					// Apply converter (if not an equivalence)
+					if ( conv !== true ) {
+
+						// Unless errors are allowed to bubble, catch and return them
+						if ( conv && s[ "throws" ] ) {
+							response = conv( response );
+						} else {
+							try {
+								response = conv( response );
+							} catch ( e ) {
+								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
+							}
+						}
+					}
+				}
+			}
+		}
+
+		return { state: "success", data: response };
+	}
+	// Install script dataType
+	jQuery.ajaxSetup({
+		accepts: {
+			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
+		},
+		contents: {
+			script: /(?:java|ecma)script/
+		},
+		converters: {
+			"text script": function( text ) {
+				jQuery.globalEval( text );
+				return text;
+			}
+		}
+	});
+
+	// Handle cache's special case and crossDomain
+	jQuery.ajaxPrefilter( "script", function( s ) {
+		if ( s.cache === undefined ) {
+			s.cache = false;
+		}
+		if ( s.crossDomain ) {
+			s.type = "GET";
+		}
+	});
+
+	// Bind script tag hack transport
+	jQuery.ajaxTransport( "script", function( s ) {
+		// This transport only deals with cross domain requests
+		if ( s.crossDomain ) {
+			var script, callback;
+			return {
+				send: function( _, complete ) {
+					script = jQuery("<script>").prop({
+						async: true,
+						charset: s.scriptCharset,
+						src: s.url
+					}).on(
+						"load error",
+						callback = function( evt ) {
+							script.remove();
+							callback = null;
+							if ( evt ) {
+								complete( evt.type === "error" ? 404 : 200, evt.type );
+							}
+						}
+					);
+					document.head.appendChild( script[ 0 ] );
+				},
+				abort: function() {
+					if ( callback ) {
+						callback();
+					}
+				}
+			};
+		}
+	});
+	var oldCallbacks = [],
+		rjsonp = /(=)\?(?=&|$)|\?\?/;
+
+	// Default jsonp settings
+	jQuery.ajaxSetup({
+		jsonp: "callback",
+		jsonpCallback: function() {
+			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
+			this[ callback ] = true;
+			return callback;
+		}
+	});
+
+	// Detect, normalize options and install callbacks for jsonp requests
+	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
+
+		var callbackName, overwritten, responseContainer,
+			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
+				"url" :
+				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
+			);
+
+		// Handle iff the expected data type is "jsonp" or we have a parameter to set
+		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
+
+			// Get callback name, remembering preexisting value associated with it
+			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
+				s.jsonpCallback() :
+				s.jsonpCallback;
+
+			// Insert callback into url or form data
+			if ( jsonProp ) {
+				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
+			} else if ( s.jsonp !== false ) {
+				s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
+			}
+
+			// Use data converter to retrieve json after script execution
+			s.converters["script json"] = function() {
+				if ( !responseContainer ) {
+					jQuery.error( callbackName + " was not called" );
+				}
+				return responseContainer[ 0 ];
+			};
+
+			// force json dataType
+			s.dataTypes[ 0 ] = "json";
+
+			// Install callback
+			overwritten = window[ callbackName ];
+			window[ callbackName ] = function() {
+				responseContainer = arguments;
+			};
+
+			// Clean-up function (fires after converters)
+			jqXHR.always(function() {
+				// Restore preexisting value
+				window[ callbackName ] = overwritten;
+
+				// Save back as free
+				if ( s[ callbackName ] ) {
+					// make sure that re-using the options doesn't screw things around
+					s.jsonpCallback = originalSettings.jsonpCallback;
+
+					// save the callback name for future use
+					oldCallbacks.push( callbackName );
+				}
+
+				// Call if it was a function and we have a response
+				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
+					overwritten( responseContainer[ 0 ] );
+				}
+
+				responseContainer = overwritten = undefined;
+			});
+
+			// Delegate to script
+			return "script";
+		}
+	});
+	jQuery.ajaxSettings.xhr = function() {
+		try {
+			return new XMLHttpRequest();
+		} catch( e ) {}
+	};
+
+	var xhrSupported = jQuery.ajaxSettings.xhr(),
+		xhrSuccessStatus = {
+			// file protocol always yields status code 0, assume 200
+			0: 200,
+			// Support: IE9
+			// #1450: sometimes IE returns 1223 when it should be 204
+			1223: 204
+		},
+		// Support: IE9
+		// We need to keep track of outbound xhr and abort them manually
+		// because IE is not smart enough to do it all by itself
+		xhrId = 0,
+		xhrCallbacks = {};
+
+	if ( window.ActiveXObject ) {
+		jQuery( window ).on( "unload", function() {
+			for( var key in xhrCallbacks ) {
+				xhrCallbacks[ key ]();
+			}
+			xhrCallbacks = undefined;
+		});
+	}
+
+	jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
+	jQuery.support.ajax = xhrSupported = !!xhrSupported;
+
+	jQuery.ajaxTransport(function( options ) {
+		var callback;
+		// Cross domain only allowed if supported through XMLHttpRequest
+		if ( jQuery.support.cors || xhrSupported && !options.crossDomain ) {
+			return {
+				send: function( headers, complete ) {
+					var i, id,
+						xhr = options.xhr();
+					xhr.open( options.type, options.url, options.async, options.username, options.password );
+					// Apply custom fields if provided
+					if ( options.xhrFields ) {
+						for ( i in options.xhrFields ) {
+							xhr[ i ] = options.xhrFields[ i ];
+						}
+					}
+					// Override mime type if needed
+					if ( options.mimeType && xhr.overrideMimeType ) {
+						xhr.overrideMimeType( options.mimeType );
+					}
+					// X-Requested-With header
+					// For cross-domain requests, seeing as conditions for a preflight are
+					// akin to a jigsaw puzzle, we simply never set it to be sure.
+					// (it can always be set on a per-request basis or even using ajaxSetup)
+					// For same-domain requests, won't change header if already provided.
+					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
+						headers["X-Requested-With"] = "XMLHttpRequest";
+					}
+					// Set headers
+					for ( i in headers ) {
+						xhr.setRequestHeader( i, headers[ i ] );
+					}
+					// Callback
+					callback = function( type ) {
+						return function() {
+							if ( callback ) {
+								delete xhrCallbacks[ id ];
+								callback = xhr.onload = xhr.onerror = null;
+								if ( type === "abort" ) {
+									xhr.abort();
+								} else if ( type === "error" ) {
+									complete(
+										// file protocol always yields status 0, assume 404
+										xhr.status || 404,
+										xhr.statusText
+									);
+								} else {
+									complete(
+										xhrSuccessStatus[ xhr.status ] || xhr.status,
+										xhr.statusText,
+										// Support: IE9
+										// #11426: When requesting binary data, IE9 will throw an exception
+										// on any attempt to access responseText
+										typeof xhr.responseText === "string" ? {
+											text: xhr.responseText
+										} : undefined,
+										xhr.getAllResponseHeaders()
+									);
+								}
+							}
+						};
+					};
+					// Listen to events
+					xhr.onload = callback();
+					xhr.onerror = callback("error");
+					// Create the abort callback
+					callback = xhrCallbacks[( id = xhrId++ )] = callback("abort");
+					// Do send the request
+					// This may raise an exception which is actually
+					// handled in jQuery.ajax (so no try/catch here)
+					xhr.send( options.hasContent && options.data || null );
+				},
+				abort: function() {
+					if ( callback ) {
+						callback();
+					}
+				}
+			};
+		}
+	});
+	var fxNow, timerId,
+		rfxtypes = /^(?:toggle|show|hide)$/,
+		rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
+		rrun = /queueHooks$/,
+		animationPrefilters = [ defaultPrefilter ],
+		tweeners = {
+			"*": [function( prop, value ) {
+				var end, unit,
+					tween = this.createTween( prop, value ),
+					parts = rfxnum.exec( value ),
+					target = tween.cur(),
+					start = +target || 0,
+					scale = 1,
+					maxIterations = 20;
+
+				if ( parts ) {
+					end = +parts[2];
+					unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );
+
+					// We need to compute starting value
+					if ( unit !== "px" && start ) {
+						// Iteratively approximate from a nonzero starting point
+						// Prefer the current property, because this process will be trivial if it uses the same units
+						// Fallback to end or a simple constant
+						start = jQuery.css( tween.elem, prop, true ) || end || 1;
+
+						do {
+							// If previous iteration zeroed out, double until we get *something*
+							// Use a string for doubling factor so we don't accidentally see scale as unchanged below
+							scale = scale || ".5";
+
+							// Adjust and apply
+							start = start / scale;
+							jQuery.style( tween.elem, prop, start + unit );
+
+						// Update scale, tolerating zero or NaN from tween.cur()
+						// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
+						} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
+					}
+
+					tween.unit = unit;
+					tween.start = start;
+					// If a +=/-= token was provided, we're doing a relative animation
+					tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
+				}
+				return tween;
+			}]
+		};
+
+	// Animations created synchronously will run synchronously
+	function createFxNow() {
+		setTimeout(function() {
+			fxNow = undefined;
+		});
+		return ( fxNow = jQuery.now() );
+	}
+
+	function createTweens( animation, props ) {
+		jQuery.each( props, function( prop, value ) {
+			var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
+				index = 0,
+				length = collection.length;
+			for ( ; index < length; index++ ) {
+				if ( collection[ index ].call( animation, prop, value ) ) {
+
+					// we're done with this property
+					return;
+				}
+			}
+		});
+	}
+
+	function Animation( elem, properties, options ) {
+		var result,
+			stopped,
+			index = 0,
+			length = animationPrefilters.length,
+			deferred = jQuery.Deferred().always( function() {
+				// don't match elem in the :animated selector
+				delete tick.elem;
+			}),
+			tick = function() {
+				if ( stopped ) {
+					return false;
+				}
+				var currentTime = fxNow || createFxNow(),
+					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
+					// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
+					temp = remaining / animation.duration || 0,
+					percent = 1 - temp,
+					index = 0,
+					length = animation.tweens.length;
+
+				for ( ; index < length ; index++ ) {
+					animation.tweens[ index ].run( percent );
+				}
+
+				deferred.notifyWith( elem, [ animation, percent, remaining ]);
+
+				if ( percent < 1 && length ) {
+					return remaining;
+				} else {
+					deferred.resolveWith( elem, [ animation ] );
+					return false;
+				}
+			},
+			animation = deferred.promise({
+				elem: elem,
+				props: jQuery.extend( {}, properties ),
+				opts: jQuery.extend( true, { specialEasing: {} }, options ),
+				originalProperties: properties,
+				originalOptions: options,
+				startTime: fxNow || createFxNow(),
+				duration: options.duration,
+				tweens: [],
+				createTween: function( prop, end ) {
+					var tween = jQuery.Tween( elem, animation.opts, prop, end,
+							animation.opts.specialEasing[ prop ] || animation.opts.easing );
+					animation.tweens.push( tween );
+					return tween;
+				},
+				stop: function( gotoEnd ) {
+					var index = 0,
+						// if we are going to the end, we want to run all the tweens
+						// otherwise we skip this part
+						length = gotoEnd ? animation.tweens.length : 0;
+					if ( stopped ) {
+						return this;
+					}
+					stopped = true;
+					for ( ; index < length ; index++ ) {
+						animation.tweens[ index ].run( 1 );
+					}
+
+					// resolve when we played the last frame
+					// otherwise, reject
+					if ( gotoEnd ) {
+						deferred.resolveWith( elem, [ animation, gotoEnd ] );
+					} else {
+						deferred.rejectWith( elem, [ animation, gotoEnd ] );
+					}
+					return this;
+				}
+			}),
+			props = animation.props;
+
+		propFilter( props, animation.opts.specialEasing );
+
+		for ( ; index < length ; index++ ) {
+			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
+			if ( result ) {
+				return result;
+			}
+		}
+
+		createTweens( animation, props );
+
+		if ( jQuery.isFunction( animation.opts.start ) ) {
+			animation.opts.start.call( elem, animation );
+		}
+
+		jQuery.fx.timer(
+			jQuery.extend( tick, {
+				elem: elem,
+				anim: animation,
+				queue: animation.opts.queue
+			})
+		);
+
+		// attach callbacks from options
+		return animation.progress( animation.opts.progress )
+			.done( animation.opts.done, animation.opts.complete )
+			.fail( animation.opts.fail )
+			.always( animation.opts.always );
+	}
+
+	function propFilter( props, specialEasing ) {
+		var index, name, easing, value, hooks;
+
+		// camelCase, specialEasing and expand cssHook pass
+		for ( index in props ) {
+			name = jQuery.camelCase( index );
+			easing = specialEasing[ name ];
+			value = props[ index ];
+			if ( jQuery.isArray( value ) ) {
+				easing = value[ 1 ];
+				value = props[ index ] = value[ 0 ];
+			}
+
+			if ( index !== name ) {
+				props[ name ] = value;
+				delete props[ index ];
+			}
+
+			hooks = jQuery.cssHooks[ name ];
+			if ( hooks && "expand" in hooks ) {
+				value = hooks.expand( value );
+				delete props[ name ];
+
+				// not quite $.extend, this wont overwrite keys already present.
+				// also - reusing 'index' from above because we have the correct "name"
+				for ( index in value ) {
+					if ( !( index in props ) ) {
+						props[ index ] = value[ index ];
+						specialEasing[ index ] = easing;
+					}
+				}
+			} else {
+				specialEasing[ name ] = easing;
+			}
+		}
+	}
+
+	jQuery.Animation = jQuery.extend( Animation, {
+
+		tweener: function( props, callback ) {
+			if ( jQuery.isFunction( props ) ) {
+				callback = props;
+				props = [ "*" ];
+			} else {
+				props = props.split(" ");
+			}
+
+			var prop,
+				index = 0,
+				length = props.length;
+
+			for ( ; index < length ; index++ ) {
+				prop = props[ index ];
+				tweeners[ prop ] = tweeners[ prop ] || [];
+				tweeners[ prop ].unshift( callback );
+			}
+		},
+
+		prefilter: function( callback, prepend ) {
+			if ( prepend ) {
+				animationPrefilters.unshift( callback );
+			} else {
+				animationPrefilters.push( callback );
+			}
+		}
+	});
+
+	function defaultPrefilter( elem, props, opts ) {
+		/* jshint validthis: true */
+		var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
+			anim = this,
+			style = elem.style,
+			orig = {},
+			handled = [],
+			hidden = elem.nodeType && isHidden( elem );
+
+		// handle queue: false promises
+		if ( !opts.queue ) {
+			hooks = jQuery._queueHooks( elem, "fx" );
+			if ( hooks.unqueued == null ) {
+				hooks.unqueued = 0;
+				oldfire = hooks.empty.fire;
+				hooks.empty.fire = function() {
+					if ( !hooks.unqueued ) {
+						oldfire();
+					}
+				};
+			}
+			hooks.unqueued++;
+
+			anim.always(function() {
+				// doing this makes sure that the complete handler will be called
+				// before this completes
+				anim.always(function() {
+					hooks.unqueued--;
+					if ( !jQuery.queue( elem, "fx" ).length ) {
+						hooks.empty.fire();
+					}
+				});
+			});
+		}
+
+		// height/width overflow pass
+		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
+			// Make sure that nothing sneaks out
+			// Record all 3 overflow attributes because IE9-10 do not
+			// change the overflow attribute when overflowX and
+			// overflowY are set to the same value
+			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
+
+			// Set display property to inline-block for height/width
+			// animations on inline elements that are having width/height animated
+			if ( jQuery.css( elem, "display" ) === "inline" &&
+					jQuery.css( elem, "float" ) === "none" ) {
+
+				style.display = "inline-block";
+			}
+		}
+
+		if ( opts.overflow ) {
+			style.overflow = "hidden";
+			anim.always(function() {
+				style.overflow = opts.overflow[ 0 ];
+				style.overflowX = opts.overflow[ 1 ];
+				style.overflowY = opts.overflow[ 2 ];
+			});
+		}
+
+
+		// show/hide pass
+		dataShow = data_priv.get( elem, "fxshow" );
+		for ( index in props ) {
+			value = props[ index ];
+			if ( rfxtypes.exec( value ) ) {
+				delete props[ index ];
+				toggle = toggle || value === "toggle";
+				if ( value === ( hidden ? "hide" : "show" ) ) {
+
+					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
+					if( value === "show" && dataShow !== undefined && dataShow[ index ] !== undefined ) {
+						hidden = true;
+					} else {
+						continue;
+					}
+				}
+				handled.push( index );
+			}
+		}
+
+		length = handled.length;
+		if ( length ) {
+			dataShow = data_priv.get( elem, "fxshow" ) || data_priv.access( elem, "fxshow", {} );
+			if ( "hidden" in dataShow ) {
+				hidden = dataShow.hidden;
+			}
+
+			// store state if its toggle - enables .stop().toggle() to "reverse"
+			if ( toggle ) {
+				dataShow.hidden = !hidden;
+			}
+			if ( hidden ) {
+				jQuery( elem ).show();
+			} else {
+				anim.done(function() {
+					jQuery( elem ).hide();
+				});
+			}
+			anim.done(function() {
+				var prop;
+
+				data_priv.remove( elem, "fxshow" );
+				for ( prop in orig ) {
+					jQuery.style( elem, prop, orig[ prop ] );
+				}
+			});
+			for ( index = 0 ; index < length ; index++ ) {
+				prop = handled[ index ];
+				tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
+				orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );
+
+				if ( !( prop in dataShow ) ) {
+					dataShow[ prop ] = tween.start;
+					if ( hidden ) {
+						tween.end = tween.start;
+						tween.start = prop === "width" || prop === "height" ? 1 : 0;
+					}
+				}
+			}
+		}
+	}
+
+	function Tween( elem, options, prop, end, easing ) {
+		return new Tween.prototype.init( elem, options, prop, end, easing );
+	}
+	jQuery.Tween = Tween;
+
+	Tween.prototype = {
+		constructor: Tween,
+		init: function( elem, options, prop, end, easing, unit ) {
+			this.elem = elem;
+			this.prop = prop;
+			this.easing = easing || "swing";
+			this.options = options;
+			this.start = this.now = this.cur();
+			this.end = end;
+			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
+		},
+		cur: function() {
+			var hooks = Tween.propHooks[ this.prop ];
+
+			return hooks && hooks.get ?
+				hooks.get( this ) :
+				Tween.propHooks._default.get( this );
+		},
+		run: function( percent ) {
+			var eased,
+				hooks = Tween.propHooks[ this.prop ];
+
+			if ( this.options.duration ) {
+				this.pos = eased = jQuery.easing[ this.easing ](
+					percent, this.options.duration * percent, 0, 1, this.options.duration
+				);
+			} else {
+				this.pos = eased = percent;
+			}
+			this.now = ( this.end - this.start ) * eased + this.start;
+
+			if ( this.options.step ) {
+				this.options.step.call( this.elem, this.now, this );
+			}
+
+			if ( hooks && hooks.set ) {
+				hooks.set( this );
+			} else {
+				Tween.propHooks._default.set( this );
+			}
+			return this;
+		}
+	};
+
+	Tween.prototype.init.prototype = Tween.prototype;
+
+	Tween.propHooks = {
+		_default: {
+			get: function( tween ) {
+				var result;
+
+				if ( tween.elem[ tween.prop ] != null &&
+					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
+					return tween.elem[ tween.prop ];
+				}
+
+				// passing an empty string as a 3rd parameter to .css will automatically
+				// attempt a parseFloat and fallback to a string if the parse fails
+				// so, simple values such as "10px" are parsed to Float.
+				// complex values such as "rotate(1rad)" are returned as is.
+				result = jQuery.css( tween.elem, tween.prop, "" );
+				// Empty strings, null, undefined and "auto" are converted to 0.
+				return !result || result === "auto" ? 0 : result;
+			},
+			set: function( tween ) {
+				// use step hook for back compat - use cssHook if its there - use .style if its
+				// available and use plain properties where available
+				if ( jQuery.fx.step[ tween.prop ] ) {
+					jQuery.fx.step[ tween.prop ]( tween );
+				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
+					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
+				} else {
+					tween.elem[ tween.prop ] = tween.now;
+				}
+			}
+		}
+	};
+
+	// Support: IE9
+	// Panic based approach to setting things on disconnected nodes
+
+	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
+		set: function( tween ) {
+			if ( tween.elem.nodeType && tween.elem.parentNode ) {
+				tween.elem[ tween.prop ] = tween.now;
+			}
+		}
+	};
+
+	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
+		var cssFn = jQuery.fn[ name ];
+		jQuery.fn[ name ] = function( speed, easing, callback ) {
+			return speed == null || typeof speed === "boolean" ?
+				cssFn.apply( this, arguments ) :
+				this.animate( genFx( name, true ), speed, easing, callback );
+		};
+	});
+
+	jQuery.fn.extend({
+		fadeTo: function( speed, to, easing, callback ) {
+
+			// show any hidden elements after setting opacity to 0
+			return this.filter( isHidden ).css( "opacity", 0 ).show()
+
+				// animate to the value specified
+				.end().animate({ opacity: to }, speed, easing, callback );
+		},
+		animate: function( prop, speed, easing, callback ) {
+			var empty = jQuery.isEmptyObject( prop ),
+				optall = jQuery.speed( speed, easing, callback ),
+				doAnimation = function() {
+					// Operate on a copy of prop so per-property easing won't be lost
+					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
+					doAnimation.finish = function() {
+						anim.stop( true );
+					};
+					// Empty animations, or finishing resolves immediately
+					if ( empty || data_priv.get( this, "finish" ) ) {
+						anim.stop( true );
+					}
+				};
+				doAnimation.finish = doAnimation;
+
+			return empty || optall.queue === false ?
+				this.each( doAnimation ) :
+				this.queue( optall.queue, doAnimation );
+		},
+		stop: function( type, clearQueue, gotoEnd ) {
+			var stopQueue = function( hooks ) {
+				var stop = hooks.stop;
+				delete hooks.stop;
+				stop( gotoEnd );
+			};
+
+			if ( typeof type !== "string" ) {
+				gotoEnd = clearQueue;
+				clearQueue = type;
+				type = undefined;
+			}
+			if ( clearQueue && type !== false ) {
+				this.queue( type || "fx", [] );
+			}
+
+			return this.each(function() {
+				var dequeue = true,
+					index = type != null && type + "queueHooks",
+					timers = jQuery.timers,
+					data = data_priv.get( this );
+
+				if ( index ) {
+					if ( data[ index ] && data[ index ].stop ) {
+						stopQueue( data[ index ] );
+					}
+				} else {
+					for ( index in data ) {
+						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
+							stopQueue( data[ index ] );
+						}
+					}
+				}
+
+				for ( index = timers.length; index--; ) {
+					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
+						timers[ index ].anim.stop( gotoEnd );
+						dequeue = false;
+						timers.splice( index, 1 );
+					}
+				}
+
+				// start the next in the queue if the last step wasn't forced
+				// timers currently will call their complete callbacks, which will dequeue
+				// but only if they were gotoEnd
+				if ( dequeue || !gotoEnd ) {
+					jQuery.dequeue( this, type );
+				}
+			});
+		},
+		finish: function( type ) {
+			if ( type !== false ) {
+				type = type || "fx";
+			}
+			return this.each(function() {
+				var index,
+					data = data_priv.get( this ),
+					queue = data[ type + "queue" ],
+					hooks = data[ type + "queueHooks" ],
+					timers = jQuery.timers,
+					length = queue ? queue.length : 0;
+
+				// enable finishing flag on private data
+				data.finish = true;
+
+				// empty the queue first
+				jQuery.queue( this, type, [] );
+
+				if ( hooks && hooks.cur && hooks.cur.finish ) {
+					hooks.cur.finish.call( this );
+				}
+
+				// look for any active animations, and finish them
+				for ( index = timers.length; index--; ) {
+					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
+						timers[ index ].anim.stop( true );
+						timers.splice( index, 1 );
+					}
+				}
+
+				// look for any animations in the old queue and finish them
+				for ( index = 0; index < length; index++ ) {
+					if ( queue[ index ] && queue[ index ].finish ) {
+						queue[ index ].finish.call( this );
+					}
+				}
+
+				// turn off finishing flag
+				delete data.finish;
+			});
+		}
+	});
+
+	// Generate parameters to create a standard animation
+	function genFx( type, includeWidth ) {
+		var which,
+			attrs = { height: type },
+			i = 0;
+
+		// if we include width, step value is 1 to do all cssExpand values,
+		// if we don't include width, step value is 2 to skip over Left and Right
+		includeWidth = includeWidth? 1 : 0;
+		for( ; i < 4 ; i += 2 - includeWidth ) {
+			which = cssExpand[ i ];
+			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
+		}
+
+		if ( includeWidth ) {
+			attrs.opacity = attrs.width = type;
+		}
+
+		return attrs;
+	}
+
+	// Generate shortcuts for custom animations
+	jQuery.each({
+		slideDown: genFx("show"),
+		slideUp: genFx("hide"),
+		slideToggle: genFx("toggle"),
+		fadeIn: { opacity: "show" },
+		fadeOut: { opacity: "hide" },
+		fadeToggle: { opacity: "toggle" }
+	}, function( name, props ) {
+		jQuery.fn[ name ] = function( speed, easing, callback ) {
+			return this.animate( props, speed, easing, callback );
+		};
+	});
+
+	jQuery.speed = function( speed, easing, fn ) {
+		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
+			complete: fn || !fn && easing ||
+				jQuery.isFunction( speed ) && speed,
+			duration: speed,
+			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
+		};
+
+		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
+			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
+
+		// normalize opt.queue - true/undefined/null -> "fx"
+		if ( opt.queue == null || opt.queue === true ) {
+			opt.queue = "fx";
+		}
+
+		// Queueing
+		opt.old = opt.complete;
+
+		opt.complete = function() {
+			if ( jQuery.isFunction( opt.old ) ) {
+				opt.old.call( this );
+			}
+
+			if ( opt.queue ) {
+				jQuery.dequeue( this, opt.queue );
+			}
+		};
+
+		return opt;
+	};
+
+	jQuery.easing = {
+		linear: function( p ) {
+			return p;
+		},
+		swing: function( p ) {
+			return 0.5 - Math.cos( p*Math.PI ) / 2;
+		}
+	};
+
+	jQuery.timers = [];
+	jQuery.fx = Tween.prototype.init;
+	jQuery.fx.tick = function() {
+		var timer,
+			timers = jQuery.timers,
+			i = 0;
+
+		fxNow = jQuery.now();
+
+		for ( ; i < timers.length; i++ ) {
+			timer = timers[ i ];
+			// Checks the timer has not already been removed
+			if ( !timer() && timers[ i ] === timer ) {
+				timers.splice( i--, 1 );
+			}
+		}
+
+		if ( !timers.length ) {
+			jQuery.fx.stop();
+		}
+		fxNow = undefined;
+	};
+
+	jQuery.fx.timer = function( timer ) {
+		if ( timer() && jQuery.timers.push( timer ) ) {
+			jQuery.fx.start();
+		}
+	};
+
+	jQuery.fx.interval = 13;
+
+	jQuery.fx.start = function() {
+		if ( !timerId ) {
+			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
+		}
+	};
+
+	jQuery.fx.stop = function() {
+		clearInterval( timerId );
+		timerId = null;
+	};
+
+	jQuery.fx.speeds = {
+		slow: 600,
+		fast: 200,
+		// Default speed
+		_default: 400
+	};
+
+	// Back Compat <1.8 extension point
+	jQuery.fx.step = {};
+
+	if ( jQuery.expr && jQuery.expr.filters ) {
+		jQuery.expr.filters.animated = function( elem ) {
+			return jQuery.grep(jQuery.timers, function( fn ) {
+				return elem === fn.elem;
+			}).length;
+		};
+	}
+	jQuery.fn.offset = function( options ) {
+		if ( arguments.length ) {
+			return options === undefined ?
+				this :
+				this.each(function( i ) {
+					jQuery.offset.setOffset( this, options, i );
+				});
+		}
+
+		var docElem, win,
+			elem = this[ 0 ],
+			box = { top: 0, left: 0 },
+			doc = elem && elem.ownerDocument;
+
+		if ( !doc ) {
+			return;
+		}
+
+		docElem = doc.documentElement;
+
+		// Make sure it's not a disconnected DOM node
+		if ( !jQuery.contains( docElem, elem ) ) {
+			return box;
+		}
+
+		// If we don't have gBCR, just use 0,0 rather than error
+		// BlackBerry 5, iOS 3 (original iPhone)
+		if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
+			box = elem.getBoundingClientRect();
+		}
+		win = getWindow( doc );
+		return {
+			top: box.top + win.pageYOffset - docElem.clientTop,
+			left: box.left + win.pageXOffset - docElem.clientLeft
+		};
+	};
+
+	jQuery.offset = {
+
+		setOffset: function( elem, options, i ) {
+			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
+				position = jQuery.css( elem, "position" ),
+				curElem = jQuery( elem ),
+				props = {};
+
+			// Set position first, in-case top/left are set even on static elem
+			if ( position === "static" ) {
+				elem.style.position = "relative";
+			}
+
+			curOffset = curElem.offset();
+			curCSSTop = jQuery.css( elem, "top" );
+			curCSSLeft = jQuery.css( elem, "left" );
+			calculatePosition = ( position === "absolute" || position === "fixed" ) && ( curCSSTop + curCSSLeft ).indexOf("auto") > -1;
+
+			// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
+			if ( calculatePosition ) {
+				curPosition = curElem.position();
+				curTop = curPosition.top;
+				curLeft = curPosition.left;
+
+			} else {
+				curTop = parseFloat( curCSSTop ) || 0;
+				curLeft = parseFloat( curCSSLeft ) || 0;
+			}
+
+			if ( jQuery.isFunction( options ) ) {
+				options = options.call( elem, i, curOffset );
+			}
+
+			if ( options.top != null ) {
+				props.top = ( options.top - curOffset.top ) + curTop;
+			}
+			if ( options.left != null ) {
+				props.left = ( options.left - curOffset.left ) + curLeft;
+			}
+
+			if ( "using" in options ) {
+				options.using.call( elem, props );
+
+			} else {
+				curElem.css( props );
+			}
+		}
+	};
+
+
+	jQuery.fn.extend({
+
+		position: function() {
+			if ( !this[ 0 ] ) {
+				return;
+			}
+
+			var offsetParent, offset,
+				elem = this[ 0 ],
+				parentOffset = { top: 0, left: 0 };
+
+			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
+			if ( jQuery.css( elem, "position" ) === "fixed" ) {
+				// We assume that getBoundingClientRect is available when computed position is fixed
+				offset = elem.getBoundingClientRect();
+
+			} else {
+				// Get *real* offsetParent
+				offsetParent = this.offsetParent();
+
+				// Get correct offsets
+				offset = this.offset();
+				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
+					parentOffset = offsetParent.offset();
+				}
+
+				// Add offsetParent borders
+				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
+				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
+			}
+
+			// Subtract parent offsets and element margins
+			return {
+				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
+				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
+			};
+		},
+
+		offsetParent: function() {
+			return this.map(function() {
+				var offsetParent = this.offsetParent || docElem;
+
+				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
+					offsetParent = offsetParent.offsetParent;
+				}
+
+				return offsetParent || docElem;
+			});
+		}
+	});
+
+
+	// Create scrollLeft and scrollTop methods
+	jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
+		var top = "pageYOffset" === prop;
+
+		jQuery.fn[ method ] = function( val ) {
+			return jQuery.access( this, function( elem, method, val ) {
+				var win = getWindow( elem );
+
+				if ( val === undefined ) {
+					return win ? win[ prop ] : elem[ method ];
+				}
+
+				if ( win ) {
+					win.scrollTo(
+						!top ? val : window.pageXOffset,
+						top ? val : window.pageYOffset
+					);
+
+				} else {
+					elem[ method ] = val;
+				}
+			}, method, val, arguments.length, null );
+		};
+	});
+
+	function getWindow( elem ) {
+		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
+	}
+	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
+	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
+		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
+			// margin is only for outerHeight, outerWidth
+			jQuery.fn[ funcName ] = function( margin, value ) {
+				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
+					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
+
+				return jQuery.access( this, function( elem, type, value ) {
+					var doc;
+
+					if ( jQuery.isWindow( elem ) ) {
+						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
+						// isn't a whole lot we can do. See pull request at this URL for discussion:
+						// https://github.com/jquery/jquery/pull/764
+						return elem.document.documentElement[ "client" + name ];
+					}
+
+					// Get document width or height
+					if ( elem.nodeType === 9 ) {
+						doc = elem.documentElement;
+
+						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
+						// whichever is greatest
+						return Math.max(
+							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
+							elem.body[ "offset" + name ], doc[ "offset" + name ],
+							doc[ "client" + name ]
+						);
+					}
+
+					return value === undefined ?
+						// Get width or height on the element, requesting but not forcing parseFloat
+						jQuery.css( elem, type, extra ) :
+
+						// Set width or height on the element
+						jQuery.style( elem, type, value, extra );
+				}, type, chainable ? margin : undefined, chainable, null );
+			};
+		});
+	});
+	// Limit scope pollution from any deprecated API
+	// (function() {
+
+	// The number of elements contained in the matched element set
+	jQuery.fn.size = function() {
+		return this.length;
+	};
+
+	jQuery.fn.andSelf = jQuery.fn.addBack;
+
+	// })();
+
+	// If there is a window object, that at least has a document property,
+	// define jQuery and $ identifiers
+	if ( typeof window === "object" && typeof window.document === "object" ) {
+		window.jQuery = window.$ = jQuery;
+	}
+
+	})( window );
+	
+	// Raw jQuery does not return anything, so return it explicitly here.
+	return jQuery.noConflict( true );
+} );
diff --git a/public/js_src/libs/ajax_fileupload.js b/public/js_src/libs/ajax_fileupload.js
new file mode 100644
index 0000000..8ce4a05
--- /dev/null
+++ b/public/js_src/libs/ajax_fileupload.js
@@ -0,0 +1,82 @@
+define(
+	[
+		"jquery_timely",
+	],
+	function( $ ) {
+	"use strict"; // jshint ;_;
+
+	/**
+	 * Submits the given $form into a hidden iframe so that file uploads can be
+	 * received by the server.
+	 *
+	 * @param  {object}   $form   jQuery object representing form to POST
+	 * @param  {string}   type    Either 'json', 'xml-json', 'xml', or 'html' -
+	 *                            the expected format of the HTTP response; if
+	 *                            'json' or 'xml-json', data argument in success
+	 *                            callback is the parsed JSON object; if 'xml' or
+	 *                            'html', data argument is XML/HTML content parsed
+	 *                            into a jQuery object.
+	 * @param  {function} success Callback that receives 1 argument, data,
+	 *                            containing the HTTP response of the submission.
+	 */
+	var post = function( $form, type, success ) {
+		// Attempt to generate unique ID.
+		var id = "ajax_fileupload" + ( new Date().getTime() );
+
+		// Create hidden iframe and append to page.
+		var $iframe = $( '<iframe name="' + id + '"/>' )
+			.css( { border: 'none', width: 0, height: 0 } );
+		$iframe.appendTo( 'body' );
+
+		// Handle load event once.
+		$iframe.one( 'load', function() {
+			var data;
+			// Return JS object if JSON format expected.
+			// NOTE: Not typically used as it causes issues in Internet Explorer
+			// (which prompts to download any file that has JSON content type), and
+			// issues a warning in other browsers.
+			if ( type === 'json' ) {
+				data = $.parseJSON( $iframe.contents().text() );
+			}
+			// XML wrapper around JSON object.
+			else if ( type === 'xml-json' ) {
+				// Handle IE's wonderfully special and uniquely different way of
+				// providing access to XML document data. So nice that MS give us the
+				// chance to spend hours studying their curious departure from the norm.
+				var doc;
+				if ( typeof ( doc = $iframe[0].contentWindow.document.XMLDocument ) !==
+				     'undefined' ) {
+					data = $( doc ).text();
+				}
+				else {
+					data = $iframe.contents().text();
+				}
+				data = $.parseJSON( data );
+			}
+			// Else return jQuery object containing returned XML/HTML structure.
+			else {
+				data = $iframe.contents().children();
+			}
+
+			// Pass to callback.
+			success( data );
+
+			// Clean up.
+			$iframe.remove();
+		} );
+
+		// Prepare form.
+		$form.attr( {
+			target: id,
+			method: 'post',
+			enctype: 'multipart/form-data',
+			encoding: 'multipart/form-data'
+		} );
+
+		$form.submit();
+	};
+
+	return {
+		post: post
+	};
+} );
diff --git a/public/js_src/libs/collapse_helper.js b/public/js_src/libs/collapse_helper.js
new file mode 100644
index 0000000..c7a6cc1
--- /dev/null
+++ b/public/js_src/libs/collapse_helper.js
@@ -0,0 +1,19 @@
+define(
+	[
+		"jquery_timely",
+		"domReady",
+		"external_libs/bootstrap_collapse"
+	],
+	function( $, domReady ) {
+	"use strict";
+
+	domReady( function() {
+		// Toggle visibility of .icon-caret-down/.icon-caret-up in collapse triggers
+		// when they are clicked.
+		$( document ).on( 'click', '[data-toggle="ai1ec_collapse"]', function() {
+			$( this ).toggleClass( 'active' );
+			$( '.icon-caret-down, .icon-caret-up, .icon-chevron-down, .icon-chevron-up, .icon-arrow-down, .icon-arrow-up', this )
+				.toggleClass( 'hide' );
+		} );
+	} );
+} );
diff --git a/public/js_src/libs/frontend_utils.js b/public/js_src/libs/frontend_utils.js
new file mode 100644
index 0000000..938c5af
--- /dev/null
+++ b/public/js_src/libs/frontend_utils.js
@@ -0,0 +1,118 @@
+/**
+* This modules defines some common functions that are used by some other frontend modules
+*/
+define( function() {
+	"use strict"; // jshint ;_;
+	/**
+	 * Used to ensure that entities used in L10N strings are correct.
+	 */
+	var ai1ec_convert_entities = function( o ) {
+		var c, v;
+
+		c = function( s ) {
+			if( /&[^;]+;/.test( s ) ) {
+				var e = document.createElement( 'div' );
+				e.innerHTML = s;
+				return ! e.firstChild ? s : e.firstChild.nodeValue;
+			}
+			return s;
+		};
+
+		if( typeof o === 'string' ) {
+			return c( o );
+		} else if( typeof o === 'object' ) {
+			for( v in o ) {
+				if( typeof o[v] === 'string' ) {
+					o[v] = c( o[v] );
+				}
+			}
+		}
+		return o;
+	};
+
+	/**
+	 * Convert URI to map object
+	 *
+	 * @param {string} uri       URI to parse
+	 * @param {char}   separator Character that separates arguments
+	 * @param {char}   assigner  Character that denotes key from value
+	 *
+	 * @return {Object} Map of URI properties (non recursive!)
+	 */
+	var ai1ec_tokenize_uri = function( uri, separator, assigner ) {
+		var argv, argc, key, value, spos;
+		if ( '#' === uri.charAt( 0 ) || '?' === uri.charAt( 0 ) ) {
+			uri = uri.substring( 1 );
+		}
+		argv = {};
+		uri  = uri.split( separator );
+		for ( argc = 0; argc < uri.length; argc++ ) {
+			value = uri[argc].trim();
+			if ( -1 !== ( spos = value.indexOf( assigner ) ) ) {
+				key   = value.substring( 0, spos ).trim();
+				value = value.substring( spos + 1 ).trim();
+			} else {
+				key   = value;
+				value = true;
+			}
+			argv[key] = value;
+		}
+		return argv;
+	};
+
+	/**
+	 * Parse internal query to more appropriate format.
+	 *
+	 * @param {string} hash Query hash to process
+	 *
+	 * @return {string} Converted query to use in admin-ajax request
+	 */
+	var ai1ec_map_internal_query = function( hash ) {
+		var query, argc, keys, use_key, result;
+		hash  = ai1ec_tokenize_uri( hash, '&', '=' );
+		keys  = Object.keys( hash );
+		query = {
+			ai1ec  : {},
+			action : 'posterboard'
+		};
+		for ( argc = 0; argc < keys.length; argc++ ) {
+			if ( 'ai1ec' === keys[argc] ) {
+				var new_map = ai1ec_tokenize_uri( hash[keys[argc]], '|', ':' );
+				for ( use_key in new_map ) {
+					if ( '' !== new_map[use_key] ) {
+						if ( 'action' === use_key || 'view' === use_key ) {
+							query.action = new_map[use_key];
+						}
+						query.ai1ec[use_key] = new_map[use_key];
+					}
+				}
+			} else if ( 'ai1ec_' === keys[argc].substring( 0, 6 ) ) {
+				query.ai1ec[keys[argc].substring( 6 )] = hash[keys[argc]];
+			} else {
+				query[keys[argc]] = hash[keys[argc]];
+			}
+		}
+		if ( 'ai1ec_' !== query.action.substring( 0, 6 ) ) {
+			query.action = 'ai1ec_' + query.action;
+		}
+		result = 'action=' + query.action + '&ai1ec=';
+		for ( use_key in query.ai1ec ) {
+			if( query.ai1ec.hasOwnProperty( use_key ) ) {
+				result += escape( use_key ) + ':' + escape( query.ai1ec[use_key] ) + '|';
+			}
+		}
+		result = result.substring( 0, result.length - 1 );
+		for ( use_key in query ) {
+			if ( 'ai1ec' !== use_key && 'action' !== use_key ) {
+				result += '&' + use_key + '=' + escape( query[use_key] );
+			}
+		}
+		return result;
+	};
+
+	return {
+		ai1ec_convert_entities   : ai1ec_convert_entities,
+		ai1ec_map_internal_query : ai1ec_map_internal_query,
+		ai1ec_tokenize_uri       : ai1ec_tokenize_uri
+	};
+} );
diff --git a/public/js_src/libs/gmaps.js b/public/js_src/libs/gmaps.js
new file mode 100644
index 0000000..f6582e2
--- /dev/null
+++ b/public/js_src/libs/gmaps.js
@@ -0,0 +1,23 @@
+define(
+		[
+		 "ai1ec_config"
+		 ],
+		 function( ai1ec_config ) {
+	"use strict"; // jshint ;_;
+
+	// Get the language
+	var lang = ai1ec_config.language;
+	
+	// Create the url
+	var url = 'async!https://maps.google.com/maps/api/js?sensor=false&language=' + lang;
+	// Return a wrapper function so that we have a callback.
+	// This is important because we load gMaps async and we don't want to wait for it to load and block other functions
+	return function( callback ) {
+		// if the map object is already loaded use it, otherwise require it
+		if( typeof google === 'object' && typeof google.maps === 'object' ) {
+			callback();
+		} else {
+			timely.require( [ url ], callback );
+		}
+	};
+} );
diff --git a/public/js_src/libs/modal_helper.js b/public/js_src/libs/modal_helper.js
new file mode 100644
index 0000000..e1ee152
--- /dev/null
+++ b/public/js_src/libs/modal_helper.js
@@ -0,0 +1,22 @@
+define(
+	[
+		"jquery_timely",
+		"domReady",
+		"external_libs/bootstrap_modal"
+	],
+	function( $, domReady ) {
+	"use strict";
+
+	domReady( function() {
+		// Reproduce old Bootstrap behaviour of adding "modal-open" class to body
+		// element while modal is open.
+		var $body = $( 'body' );
+		$body
+			.on( 'shown', '.ai1ec-modal', function () {
+				$body.addClass( 'ai1ec-modal-open' )
+			} )
+			.on( 'hidden', '.ai1ec-modal', function () {
+				$body.removeClass( 'ai1ec-modal-open' )
+			} );
+	} );
+} );
diff --git a/public/js_src/libs/recaptcha.js b/public/js_src/libs/recaptcha.js
new file mode 100644
index 0000000..d0fd2a8
--- /dev/null
+++ b/public/js_src/libs/recaptcha.js
@@ -0,0 +1,43 @@
+define(
+		[
+		 "jquery_timely",
+		 "//www.google.com/recaptcha/api/js/recaptcha_ajax.js"
+		 ],
+		 function( $ ) {
+	"use strict"; // jshint ;_;
+
+	/**
+	 * Initialize reCAPTCHA field if it hasn't been already.
+	 */
+	var init_recaptcha = function( $form ) {
+		var $recaptcha = $( '.ai1ec-recaptcha', $form );
+
+		if ( $recaptcha.length === 0 ) {
+			return;
+		}
+		if ( $recaptcha.is( '.ai1ec-initializing, .ai1ec-initialized' ) ) {
+			return;
+		}
+		if ( typeof Recaptcha === 'undefined' ) {
+			return;
+		}
+		Recaptcha.create(
+			$recaptcha.data( 'recaptchaKey' ),
+			$recaptcha[0],
+			{
+				theme: 'white',
+				callback: function() {
+					$( '#recaptcha_response_field', $recaptcha )
+						.attr( 'placeholder', $recaptcha.data( 'placeholder' ) );
+					$recaptcha
+						.removeClass( 'ai1ec-initializing' )
+						.addClass( 'ai1ec-initialized' );
+				},
+			}
+		);
+		$recaptcha.addClass( 'ai1ec-initializing' );
+	};
+	return {
+		init_recaptcha : init_recaptcha
+	};
+} );
diff --git a/public/js_src/libs/select2_multiselect_helper.js b/public/js_src/libs/select2_multiselect_helper.js
new file mode 100644
index 0000000..1a59a41
--- /dev/null
+++ b/public/js_src/libs/select2_multiselect_helper.js
@@ -0,0 +1,92 @@
+define(
+	[
+		"jquery_timely",
+		"external_libs/select2"
+	],
+	function( $ ) {
+	"use strict"; // jshint ;_;
+
+	/**
+	 * Formatter for selected event categories shown in the Select2 widget.
+	 *
+	 * @param  {object} category Passed by Select2 representing selected item
+	 * @return {string}          Markup for formatted item
+	 */
+	var format_selection = function( option ) {
+		var $option = $( option.element ),
+				color = $option.data( 'color' ),
+				description = $option.data( 'description' ),
+				markup = '';
+
+		if ( typeof color !== 'undefined' && color !== '' ) {
+			markup += '<span class="ai1ec-color-swatch" style="background: ' +
+				$option.data( 'color' ) + '"></span> ';
+		}
+		markup += option.text;
+		markup = '<span title="' + description + '">' + markup + '</span>';
+
+		return markup;
+	};
+
+	/**
+	 * Formatter for event categories shown in the Select2 widget dropdown.
+	 *
+	 * @param  {object} category Passed by Select2 representing selected item
+	 * @return {string}          Markup for formatted item
+	 */
+	var format_result = function( option ) {
+		var $option = $( option.element ),
+				color = $option.data( 'color' ),
+				description = $option.data( 'description' ),
+				markup = '';
+
+		if ( typeof color !== 'undefined' && color !== '' ) {
+			markup += '<span class="ai1ec-color-swatch" style="background: ' +
+				$option.data( 'color' ) + '"></span> ';
+		}
+		else {
+			markup += '<span class="ai1ec-color-swatch-empty"></span> ';
+		}
+		markup += option.text;
+		markup = '<span title="' + description + '">' + markup + '</span>';
+
+		return markup;
+	};
+
+	/**
+	 * Initialize any category selectors on the page. Limit search to $container
+	 * parent element if provided.
+	 *
+	 * @param  {object} $container jQuery object representing parent container
+	 */
+	var init = function( $container ) {
+		if ( typeof $container === 'undefined' ) {
+			$container = $( document );
+		}
+		$( '.ai1ec-select2-multiselect-selector', $container )
+			.select2( {
+				allowClear: true,
+				formatResult: format_result,
+				formatSelection: format_selection,
+				escapeMarkup: function( m ) { return m; }
+			} );
+	};
+
+	/**
+	 * Refresh any category selectors on the page, usually to allow absolutely
+	 * positioned components to be properly aligned when the selector is shown.
+	 * Limit search to $container parent element if provided.
+	 *
+	 * @param  {object} $container jQuery object representing parent container
+	 */
+	var refresh = function( $container ) {
+		$( '.ai1ec-select2-multiselect-selector.select2-container', $container ).each( function() {
+			$( this ).data( 'select2' ).resizeSearch();
+		} );
+	};
+
+	return {
+		init: init,
+		refresh: refresh
+	};
+} );
diff --git a/public/js_src/libs/tags_select.js b/public/js_src/libs/tags_select.js
new file mode 100644
index 0000000..a83e932
--- /dev/null
+++ b/public/js_src/libs/tags_select.js
@@ -0,0 +1,46 @@
+define(
+	[
+		"jquery_timely",
+		"external_libs/select2"
+	],
+	function( $ ) {
+	"use strict"; // jshint ;_;
+
+	/**
+	 * Initialize any tag selectors on the page. Limit search to $container
+	 * parent element if provided.
+	 *
+	 * @param  {object} $container jQuery object representing parent container
+	 */
+	var init = function( $container ) {
+		if ( typeof $container === 'undefined' ) {
+			$container = $( document );
+		}
+		$( '.ai1ec-tags-selector', $container ).each( function() {
+			var $this = $( this );
+			$this
+				.select2( {
+					tags: $this.data( 'ai1ecTags' ),
+					tokenSeparators: [ ',' ]
+				} );
+		} );
+	};
+
+	/**
+	 * Refresh any tag selectors on the page, usually to allow absolutely
+	 * positioned components to be properly aligned when the selector is shown.
+	 * Limit search to $container parent element if provided.
+	 *
+	 * @param  {object} $container jQuery object representing parent container
+	 */
+	var refresh = function( $container ) {
+		$( '.ai1ec-tags-selector.select2-container', $container ).each( function() {
+			$( this ).data( 'select2' ).resizeSearch();
+		} );
+	};
+
+	return {
+		init: init,
+		refresh: refresh
+	};
+} );
diff --git a/public/js_src/libs/timepicker_helper.js b/public/js_src/libs/timepicker_helper.js
new file mode 100644
index 0000000..7d234ba
--- /dev/null
+++ b/public/js_src/libs/timepicker_helper.js
@@ -0,0 +1,70 @@
+define(
+	[
+		"jquery_timely",
+		"external_libs/moment",
+		"external_libs/bootstrap_timepicker"
+	],
+	function( $, moment, domReady ) {
+	"use strict";
+
+	/**
+	 * Event handler for timepicker's first focus. Initialize widget.
+	 */
+	var init_timepicker = function() {
+		var $this = $( this );
+		if ( typeof $this.data( 'timepicker' ) === 'undefined' ) {
+
+			// If the input field lacks a value, provide current time (in UTC).
+			if ( $this.val() === '' ) {
+				var def_time = moment().utc();
+				var time_format = $this.data( 'showMeridian' ) ? 'hh:mm A' : 'HH:mm';
+				$this.val( def_time.format( time_format ) );
+			}
+
+			// Activate timepicker.
+			$this
+				.timepicker( {
+					showMeridian: $this.data( 'showMeridian' ),
+					showInputs: false,
+					defaultTime: $this.val()
+				} )
+				// Toggle class on root element to disable "overflow: none" on Bootstrap
+				// Collapse elements while timepicker is visible.
+				.on( 'show.timepicker', function() {
+					$this.parents( '.collapse' ).addClass( 'ai1ec-timepicker-visible' );
+				} )
+				.on( 'hide.timepicker', function() {
+					$this.parents( '.collapse' ).removeClass( 'ai1ec-timepicker-visible' );
+				} );
+
+			// Wrap timepicker in div.timely to avoid polluting global namespace.
+			var $widget = $this.data( 'timepicker' ).$widget;
+			$widget.wrapAll( '<div class="timely">' );
+
+			// Apply alignment class.
+			var alignment = $this.data( 'alignment' );
+			if ( typeof alignment === 'undefined' ) alignment = 'left';
+			$widget.addClass( 'ai1ec-alignment-' + alignment );
+		}
+	};
+
+	/**
+	 * Initialize any tag selectors on the page. Limit search to $container
+	 * parent element if provided.
+	 *
+	 * @param  {object} $container jQuery object representing parent container
+	 */
+	var init = function( $container ) {
+		if ( typeof $container === 'undefined' ) {
+			$container = $( document );
+		}
+
+		// Initialize timepickers only on first focus to provide default time value
+		// if empty.
+		$container.on( 'focus', '.ai1ec-timepicker', init_timepicker );
+	};
+
+	return {
+		init: init
+	};
+} );
diff --git a/public/js_src/libs/utils.js b/public/js_src/libs/utils.js
new file mode 100644
index 0000000..7008698
--- /dev/null
+++ b/public/js_src/libs/utils.js
@@ -0,0 +1,146 @@
+define(
+		[
+		 "jquery_timely",
+		 "external_libs/bootstrap_tab"
+		 ],
+		 function( $ ) {
+	"use strict"; // jshint ;_;
+	var AI1EC_UTILS = function() {
+			// We just return an object. This is useful if we ever need to define some private variables.
+			return {
+				/**
+				 * check if a number is float
+				 *
+				 * @param the value to check
+				 *
+				 * @return boolean true if the value is float, false if it's not
+				 */
+				"is_float": function( n ) {
+					return ! isNaN( parseFloat( n ) );
+				},
+				/**
+				 * check if the value is a valid coordinate
+				 *
+				 * @param mixed the value to check
+				 *
+				 * @param boolean true if we are validating latitude
+				 *
+				 * @return boolean true if the value is a valid coordinate
+				 */
+				"is_valid_coordinate": function( n, is_latitude ) {
+					// Longitude is valid between +180 and -180 while Latitude is valid between +90 an -90
+					var max_value = is_latitude ? 90 : 180;
+					return this.is_float( n ) && Math.abs( n ) < max_value;
+				},
+				/**
+				 * Converts all the commas to dots so that the value can be used as a float
+				 */
+				"convert_comma_to_dot": function( value ) {
+					return value.replace( ',', '.' );
+				},
+				/**
+				 * Check if a field has a value.
+				 *
+				 * @param string id, the id of the element to check
+				 *
+				 * @return boolean Whether the fields has a value or not
+				 */
+				"field_has_value": function( id ) {
+					var selector = '#' + id;
+					var $field = $( selector );
+					var has_value = false;
+					// Check if the field was found. If it's not found we treat it as having no value.
+					if( $field.length === 1 ) {
+						has_value = $.trim( $field.val() ) !== '';
+					}
+					return has_value;
+				},
+				/**
+				 * Create a twitter bootstrap aler
+				 *
+				 * @param text the text of the message
+				 *
+				 * @param type the type of the message
+				 *
+				 * @return the alert, ready to be inserted in the DOM
+				 *
+				 */
+				"make_alert": function( text, type, hide_close_button ) {
+					var alert_class = '';
+					switch (type) {
+						case 'error'  : alert_class = 'alert alert-error';
+							break;
+						case 'success': alert_class = 'alert alert-success';
+							break;
+						default: alert_class = 'alert';
+							break;
+					}
+					// Create the alert
+					var $alert = $( '<div />', {
+						"class" : alert_class,
+						"html"  : text
+					} );
+					if ( ! hide_close_button ) {
+						// Create the close button
+						var $close = $( '<a />', {
+							"class"        : "close",
+							"data-dismiss" : "alert",
+							"href"         : "#",
+							"text"         : "x"
+						} );
+						// Prepend the close button to the alert.
+						$alert.prepend( $close );
+					}
+					return $alert;
+				},
+				/**
+				 * Define the ajax url. If undefined we hardcode a value. This is needed for testing purpose only because in the testing environment the variable ajaxurl is undefined.
+				 */
+				"get_ajax_url": function() {
+					if( typeof window.ajaxurl === "undefined" ) {
+						return "http://localhost/wordpress/wp-admin/admin-ajax.php";
+					} else {
+						return window.ajaxurl;
+					}
+				},
+				/**
+				 * isUrl checks to see if the passed parameter is a valid url
+				 * and returns true on access and false on failure
+				 *
+				 * @param String s String to validate
+				 *
+				 * @return boolean True if the string is a valid url, false otherwise
+				 */
+				 "isUrl" : function( s ) {
+					var regexp = /(http|https|webcal):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
+					return regexp.test(s);
+				},
+				/**
+				 * isValidEmail checks if the mail passed is valid.
+				 *
+				 * @param email string
+				 * @returns boolean
+				 */
+				"isValidEmail" : function( email ) {
+					var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
+					return re.test( email );
+				},
+				/**
+				 * activates the passed tab or the first one if no tab is passed.
+				 * 
+				 * @param active_tab
+				 * @returns
+				 */
+				activate_saved_tab_on_page_load : function( active_tab ) {
+					if ( null === active_tab || undefined === active_tab ){
+						// Activate the first tab
+						$( 'ul.nav-tabs a:first' ).tab( 'show' );
+					} else {
+						// Activate the correct tab
+						$( 'ul.nav-tabs a[href=' + active_tab + ']' ).tab( 'show' );
+					}
+				}
+			};
+	}();
+	return AI1EC_UTILS;
+} );
diff --git a/public/js_src/main.js b/public/js_src/main.js
new file mode 100644
index 0000000..2845e5b
--- /dev/null
+++ b/public/js_src/main.js
@@ -0,0 +1,3 @@
+// this file is empty because it's just used to set requirejs baseUrl
+
+
diff --git a/public/js_src/main_widget.js b/public/js_src/main_widget.js
new file mode 100644
index 0000000..8a89731
--- /dev/null
+++ b/public/js_src/main_widget.js
@@ -0,0 +1,54 @@
+require(
+		[
+		 "scripts/calendar",
+		 "scripts/common_scripts/frontend/common_frontend",
+		 "scripts/calendar/event",
+		 "domReady",
+		 "jquery_timely",
+		 "ai1ec_calendar"
+		 ],
+		function( page, common, event, domReady, $, config ) {
+	"use strict"; // jshint ;_;
+
+	var url = config.calendar_url;
+
+	$( 'div.timely-calendar:first' ).on( 'click', '.ai1ec-load-event[data-type=jsonp]', event.load_event_through_jsonp );
+	// If there are multiple divs load multiple calendars
+	$( 'div.timely-calendar:first' ).each( function( i, el ) {
+		var ai1ec = event.create_ai1ec_to_send( el );
+		var data = {
+			ai1ec_doing_ajax : true,
+			request_type: 'jsonp',
+			ai1ec : ai1ec
+		};
+		$.ajax( {
+			url: url,
+			dataType: 'jsonp',
+			data: data,
+			success: function( data ) {
+				var $view_container = $( '<div/>', { id : 'ai1ec-calendar-view-container' } );
+				var $timely = $( '<div/>', { 'class' : 'timely' } );
+				var spinner = $( '<div/>', {
+					id : 'ai1ec-calendar-view-loading',
+					"class" : 'ai1ec-loading'
+				} );
+				var $view_div = $( '<div/>', { id : 'ai1ec-calendar-view' } );
+				$view_div.append( data.html );
+				$view_container.append( spinner ).append( $view_div );
+				$timely.append( $view_container ).append( data.subscribe_buttons );
+				$( el ).append( $timely );
+				// the common library might be already loaded if we are embedding the calendar
+				// In a wordpress page with our plugin installed.
+				if( ! common.are_event_listeners_attached() ) {
+					common.start();
+				}
+				page.start();
+			},
+			error: function( jqXHR, textStatus, errorThrown ) {
+				window.alert( "An error occurred while retrieving the calendar data." );
+			}
+		} );
+	} );
+
+
+} );
diff --git a/public/js_src/pages/add_new_event.js b/public/js_src/pages/add_new_event.js
new file mode 100644
index 0000000..91906a8
--- /dev/null
+++ b/public/js_src/pages/add_new_event.js
@@ -0,0 +1,7 @@
+require(
+	[ "scripts/add_new_event" ],
+	function( page ) {
+		"use strict"; // jshint ;_;
+		page.start();
+	}
+);
diff --git a/public/js_src/pages/admin_settings.js b/public/js_src/pages/admin_settings.js
new file mode 100644
index 0000000..6bcd75f
--- /dev/null
+++ b/public/js_src/pages/admin_settings.js
@@ -0,0 +1,6 @@
+require(
+		[ "scripts/admin_settings" ],
+		function( page ) {
+	"use strict"; // jshint ;_;
+	page.start();
+} );
\ No newline at end of file
diff --git a/public/js_src/pages/calendar.js b/public/js_src/pages/calendar.js
new file mode 100644
index 0000000..ab471fc
--- /dev/null
+++ b/public/js_src/pages/calendar.js
@@ -0,0 +1,7 @@
+require(
+		[ "scripts/calendar" ],
+		function( page ) {
+		"use strict"; // jshint ;_;
+			page.start();
+		}
+);
\ No newline at end of file
diff --git a/public/js_src/pages/common_backend.js b/public/js_src/pages/common_backend.js
new file mode 100644
index 0000000..669c1fa
--- /dev/null
+++ b/public/js_src/pages/common_backend.js
@@ -0,0 +1,7 @@
+require(
+		[ "scripts/common_scripts/backend/common_backend" ],
+		function( page ) {
+		"use strict"; // jshint ;_;
+			page.start();
+		}
+);
diff --git a/public/js_src/pages/common_frontend.js b/public/js_src/pages/common_frontend.js
new file mode 100644
index 0000000..f4c50d8
--- /dev/null
+++ b/public/js_src/pages/common_frontend.js
@@ -0,0 +1,7 @@
+require(
+		[ "scripts/common_scripts/frontend/common_frontend" ],
+		function( page ) {
+			"use strict"; // jshint ;_;
+			page.start();
+		}
+);
diff --git a/public/js_src/pages/event.js b/public/js_src/pages/event.js
new file mode 100644
index 0000000..d9a1bef
--- /dev/null
+++ b/public/js_src/pages/event.js
@@ -0,0 +1,7 @@
+require(
+		[ "scripts/event" ],
+		function( page ) {
+		"use strict"; // jshint ;_;
+			page.start();
+		}
+);
\ No newline at end of file
diff --git a/public/js_src/pages/event_category.js b/public/js_src/pages/event_category.js
new file mode 100644
index 0000000..93a7ab6
--- /dev/null
+++ b/public/js_src/pages/event_category.js
@@ -0,0 +1,3 @@
+require(
+		[ "scripts/event_category" ]
+);
\ No newline at end of file
diff --git a/public/js_src/require.js b/public/js_src/require.js
new file mode 100644
index 0000000..062516a
--- /dev/null
+++ b/public/js_src/require.js
@@ -0,0 +1,2019 @@
+/** vim: et:ts=4:sw=4:sts=4
+ * @license RequireJS 2.1.5 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+//Not using strict: uneven strict support in browsers, #392, and causes
+//problems with requirejs.exec()/transpiler plugins that may not be strict.
+/*jslint regexp: true, nomen: true, sloppy: true */
+/*global window, navigator, document, importScripts, setTimeout, opera */
+
+var requirejs, require, define;
+(function (global) {
+    var req, s, head, baseElement, dataMain, src,
+        interactiveScript, currentlyAddingScript, mainScript, subPath,
+        version = '2.1.5',
+        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
+        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
+        jsSuffixRegExp = /\.js$/,
+        currDirRegExp = /^\.\//,
+        op = Object.prototype,
+        ostring = op.toString,
+        hasOwn = op.hasOwnProperty,
+        ap = Array.prototype,
+        apsp = ap.splice,
+        isBrowser = !!(typeof window !== 'undefined' && navigator && document),
+        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
+        //PS3 indicates loaded and complete, but need to wait for complete
+        //specifically. Sequence is 'loading', 'loaded', execution,
+        // then 'complete'. The UA check is unfortunate, but not sure how
+        //to feature test w/o causing perf issues.
+        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
+                      /^complete$/ : /^(complete|loaded)$/,
+        defContextName = '_',
+        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
+        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
+        contexts = {},
+        cfg = {},
+        globalDefQueue = [],
+        useInteractive = false;
+
+    function isFunction(it) {
+        return ostring.call(it) === '[object Function]';
+    }
+
+    function isArray(it) {
+        return ostring.call(it) === '[object Array]';
+    }
+
+    /**
+     * Helper function for iterating over an array. If the func returns
+     * a true value, it will break out of the loop.
+     */
+    function each(ary, func) {
+        if (ary) {
+            var i;
+            for (i = 0; i < ary.length; i += 1) {
+                if (ary[i] && func(ary[i], i, ary)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Helper function for iterating over an array backwards. If the func
+     * returns a true value, it will break out of the loop.
+     */
+    function eachReverse(ary, func) {
+        if (ary) {
+            var i;
+            for (i = ary.length - 1; i > -1; i -= 1) {
+                if (ary[i] && func(ary[i], i, ary)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    function hasProp(obj, prop) {
+        return hasOwn.call(obj, prop);
+    }
+
+    function getOwn(obj, prop) {
+        return hasProp(obj, prop) && obj[prop];
+    }
+
+    /**
+     * Cycles over properties in an object and calls a function for each
+     * property value. If the function returns a truthy value, then the
+     * iteration is stopped.
+     */
+    function eachProp(obj, func) {
+        var prop;
+        for (prop in obj) {
+            if (hasProp(obj, prop)) {
+                if (func(obj[prop], prop)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Simple function to mix in properties from source into target,
+     * but only if target does not already have a property of the same name.
+     */
+    function mixin(target, source, force, deepStringMixin) {
+        if (source) {
+            eachProp(source, function (value, prop) {
+                if (force || !hasProp(target, prop)) {
+                    if (deepStringMixin && typeof value !== 'string') {
+                        if (!target[prop]) {
+                            target[prop] = {};
+                        }
+                        mixin(target[prop], value, force, deepStringMixin);
+                    } else {
+                        target[prop] = value;
+                    }
+                }
+            });
+        }
+        return target;
+    }
+
+    //Similar to Function.prototype.bind, but the 'this' object is specified
+    //first, since it is easier to read/figure out what 'this' will be.
+    function bind(obj, fn) {
+        return function () {
+            return fn.apply(obj, arguments);
+        };
+    }
+
+    function scripts() {
+        return document.getElementsByTagName('script');
+    }
+
+    //Allow getting a global that expressed in
+    //dot notation, like 'a.b.c'.
+    function getGlobal(value) {
+        if (!value) {
+            return value;
+        }
+        var g = global;
+        each(value.split('.'), function (part) {
+            g = g[part];
+        });
+        return g;
+    }
+
+    /**
+     * Constructs an error with a pointer to an URL with more information.
+     * @param {String} id the error ID that maps to an ID on a web page.
+     * @param {String} message human readable error.
+     * @param {Error} [err] the original error, if there is one.
+     *
+     * @returns {Error}
+     */
+    function makeError(id, msg, err, requireModules) {
+        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
+        e.requireType = id;
+        e.requireModules = requireModules;
+        if (err) {
+            e.originalError = err;
+        }
+        return e;
+    }
+
+    if (typeof define !== 'undefined') {
+        //If a define is already in play via another AMD loader,
+        //do not overwrite.
+        return;
+    }
+
+    if (typeof requirejs !== 'undefined') {
+        if (isFunction(requirejs)) {
+            //Do not overwrite and existing requirejs instance.
+            return;
+        }
+        cfg = requirejs;
+        requirejs = undefined;
+    }
+
+    //Allow for a require config object
+    if (typeof require !== 'undefined' && !isFunction(require)) {
+        //assume it is a config object.
+        cfg = require;
+        require = undefined;
+    }
+
+    function newContext(contextName) {
+        var inCheckLoaded, Module, context, handlers,
+            checkLoadedTimeoutId,
+            config = {
+                //Defaults. Do not set a default for map
+                //config to speed up normalize(), which
+                //will run faster if there is no default.
+                waitSeconds: 7,
+                baseUrl: './',
+                paths: {},
+                pkgs: {},
+                shim: {},
+                config: {}
+            },
+            registry = {},
+            //registry of just enabled modules, to speed
+            //cycle breaking code when lots of modules
+            //are registered, but not activated.
+            enabledRegistry = {},
+            undefEvents = {},
+            defQueue = [],
+            defined = {},
+            urlFetched = {},
+            requireCounter = 1,
+            unnormalizedCounter = 1;
+
+        /**
+         * Trims the . and .. from an array of path segments.
+         * It will keep a leading path segment if a .. will become
+         * the first path segment, to help with module name lookups,
+         * which act like paths, but can be remapped. But the end result,
+         * all paths that use this function should look normalized.
+         * NOTE: this method MODIFIES the input array.
+         * @param {Array} ary the array of path segments.
+         */
+        function trimDots(ary) {
+            var i, part;
+            for (i = 0; ary[i]; i += 1) {
+                part = ary[i];
+                if (part === '.') {
+                    ary.splice(i, 1);
+                    i -= 1;
+                } else if (part === '..') {
+                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
+                        //End of the line. Keep at least one non-dot
+                        //path segment at the front so it can be mapped
+                        //correctly to disk. Otherwise, there is likely
+                        //no path mapping for a path starting with '..'.
+                        //This can still fail, but catches the most reasonable
+                        //uses of ..
+                        break;
+                    } else if (i > 0) {
+                        ary.splice(i - 1, 2);
+                        i -= 2;
+                    }
+                }
+            }
+        }
+
+        /**
+         * Given a relative module name, like ./something, normalize it to
+         * a real name that can be mapped to a path.
+         * @param {String} name the relative name
+         * @param {String} baseName a real name that the name arg is relative
+         * to.
+         * @param {Boolean} applyMap apply the map config to the value. Should
+         * only be done if this normalization is for a dependency ID.
+         * @returns {String} normalized name
+         */
+        function normalize(name, baseName, applyMap) {
+            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
+                foundMap, foundI, foundStarMap, starI,
+                baseParts = baseName && baseName.split('/'),
+                normalizedBaseParts = baseParts,
+                map = config.map,
+                starMap = map && map['*'];
+
+            //Adjust any relative paths.
+            if (name && name.charAt(0) === '.') {
+                //If have a base name, try to normalize against it,
+                //otherwise, assume it is a top-level require that will
+                //be relative to baseUrl in the end.
+                if (baseName) {
+                    if (getOwn(config.pkgs, baseName)) {
+                        //If the baseName is a package name, then just treat it as one
+                        //name to concat the name with.
+                        normalizedBaseParts = baseParts = [baseName];
+                    } else {
+                        //Convert baseName to array, and lop off the last part,
+                        //so that . matches that 'directory' and not name of the baseName's
+                        //module. For instance, baseName of 'one/two/three', maps to
+                        //'one/two/three.js', but we want the directory, 'one/two' for
+                        //this normalization.
+                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
+                    }
+
+                    name = normalizedBaseParts.concat(name.split('/'));
+                    trimDots(name);
+
+                    //Some use of packages may use a . path to reference the
+                    //'main' module name, so normalize for that.
+                    pkgConfig = getOwn(config.pkgs, (pkgName = name[0]));
+                    name = name.join('/');
+                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
+                        name = pkgName;
+                    }
+                } else if (name.indexOf('./') === 0) {
+                    // No baseName, so this is ID is resolved relative
+                    // to baseUrl, pull off the leading dot.
+                    name = name.substring(2);
+                }
+            }
+
+            //Apply map config if available.
+            if (applyMap && map && (baseParts || starMap)) {
+                nameParts = name.split('/');
+
+                for (i = nameParts.length; i > 0; i -= 1) {
+                    nameSegment = nameParts.slice(0, i).join('/');
+
+                    if (baseParts) {
+                        //Find the longest baseName segment match in the config.
+                        //So, do joins on the biggest to smallest lengths of baseParts.
+                        for (j = baseParts.length; j > 0; j -= 1) {
+                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));
+
+                            //baseName segment has config, find if it has one for
+                            //this name.
+                            if (mapValue) {
+                                mapValue = getOwn(mapValue, nameSegment);
+                                if (mapValue) {
+                                    //Match, update name to the new value.
+                                    foundMap = mapValue;
+                                    foundI = i;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+
+                    if (foundMap) {
+                        break;
+                    }
+
+                    //Check for a star map match, but just hold on to it,
+                    //if there is a shorter segment match later in a matching
+                    //config, then favor over this star map.
+                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
+                        foundStarMap = getOwn(starMap, nameSegment);
+                        starI = i;
+                    }
+                }
+
+                if (!foundMap && foundStarMap) {
+                    foundMap = foundStarMap;
+                    foundI = starI;
+                }
+
+                if (foundMap) {
+                    nameParts.splice(0, foundI, foundMap);
+                    name = nameParts.join('/');
+                }
+            }
+
+            return name;
+        }
+
+        function removeScript(name) {
+            if (isBrowser) {
+                each(scripts(), function (scriptNode) {
+                    if (scriptNode.getAttribute('data-requiremodule') === name &&
+                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
+                        scriptNode.parentNode.removeChild(scriptNode);
+                        return true;
+                    }
+                });
+            }
+        }
+
+        function hasPathFallback(id) {
+            var pathConfig = getOwn(config.paths, id);
+            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
+                removeScript(id);
+                //Pop off the first array value, since it failed, and
+                //retry
+                pathConfig.shift();
+                context.require.undef(id);
+                context.require([id]);
+                return true;
+            }
+        }
+
+        //Turns a plugin!resource to [plugin, resource]
+        //with the plugin being undefined if the name
+        //did not have a plugin prefix.
+        function splitPrefix(name) {
+            var prefix,
+                index = name ? name.indexOf('!') : -1;
+            if (index > -1) {
+                prefix = name.substring(0, index);
+                name = name.substring(index + 1, name.length);
+            }
+            return [prefix, name];
+        }
+
+        /**
+         * Creates a module mapping that includes plugin prefix, module
+         * name, and path. If parentModuleMap is provided it will
+         * also normalize the name via require.normalize()
+         *
+         * @param {String} name the module name
+         * @param {String} [parentModuleMap] parent module map
+         * for the module name, used to resolve relative names.
+         * @param {Boolean} isNormalized: is the ID already normalized.
+         * This is true if this call is done for a define() module ID.
+         * @param {Boolean} applyMap: apply the map config to the ID.
+         * Should only be true if this map is for a dependency.
+         *
+         * @returns {Object}
+         */
+        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
+            var url, pluginModule, suffix, nameParts,
+                prefix = null,
+                parentName = parentModuleMap ? parentModuleMap.name : null,
+                originalName = name,
+                isDefine = true,
+                normalizedName = '';
+
+            //If no name, then it means it is a require call, generate an
+            //internal name.
+            if (!name) {
+                isDefine = false;
+                name = '_@r' + (requireCounter += 1);
+            }
+
+            nameParts = splitPrefix(name);
+            prefix = nameParts[0];
+            name = nameParts[1];
+
+            if (prefix) {
+                prefix = normalize(prefix, parentName, applyMap);
+                pluginModule = getOwn(defined, prefix);
+            }
+
+            //Account for relative paths if there is a base name.
+            if (name) {
+                if (prefix) {
+                    if (pluginModule && pluginModule.normalize) {
+                        //Plugin is loaded, use its normalize method.
+                        normalizedName = pluginModule.normalize(name, function (name) {
+                            return normalize(name, parentName, applyMap);
+                        });
+                    } else {
+                        normalizedName = normalize(name, parentName, applyMap);
+                    }
+                } else {
+                    //A regular module.
+                    normalizedName = normalize(name, parentName, applyMap);
+
+                    //Normalized name may be a plugin ID due to map config
+                    //application in normalize. The map config values must
+                    //already be normalized, so do not need to redo that part.
+                    nameParts = splitPrefix(normalizedName);
+                    prefix = nameParts[0];
+                    normalizedName = nameParts[1];
+                    isNormalized = true;
+
+                    url = context.nameToUrl(normalizedName);
+                }
+            }
+
+            //If the id is a plugin id that cannot be determined if it needs
+            //normalization, stamp it with a unique ID so two matching relative
+            //ids that may conflict can be separate.
+            suffix = prefix && !pluginModule && !isNormalized ?
+                     '_unnormalized' + (unnormalizedCounter += 1) :
+                     '';
+
+            return {
+                prefix: prefix,
+                name: normalizedName,
+                parentMap: parentModuleMap,
+                unnormalized: !!suffix,
+                url: url,
+                originalName: originalName,
+                isDefine: isDefine,
+                id: (prefix ?
+                        prefix + '!' + normalizedName :
+                        normalizedName) + suffix
+            };
+        }
+
+        function getModule(depMap) {
+            var id = depMap.id,
+                mod = getOwn(registry, id);
+
+            if (!mod) {
+                mod = registry[id] = new context.Module(depMap);
+            }
+
+            return mod;
+        }
+
+        function on(depMap, name, fn) {
+            var id = depMap.id,
+                mod = getOwn(registry, id);
+
+            if (hasProp(defined, id) &&
+                    (!mod || mod.defineEmitComplete)) {
+                if (name === 'defined') {
+                    fn(defined[id]);
+                }
+            } else {
+                getModule(depMap).on(name, fn);
+            }
+        }
+
+        function onError(err, errback) {
+            var ids = err.requireModules,
+                notified = false;
+
+            if (errback) {
+                errback(err);
+            } else {
+                each(ids, function (id) {
+                    var mod = getOwn(registry, id);
+                    if (mod) {
+                        //Set error on module, so it skips timeout checks.
+                        mod.error = err;
+                        if (mod.events.error) {
+                            notified = true;
+                            mod.emit('error', err);
+                        }
+                    }
+                });
+
+                if (!notified) {
+                    req.onError(err);
+                }
+            }
+        }
+
+        /**
+         * Internal method to transfer globalQueue items to this context's
+         * defQueue.
+         */
+        function takeGlobalQueue() {
+            //Push all the globalDefQueue items into the context's defQueue
+            if (globalDefQueue.length) {
+                //Array splice in the values since the context code has a
+                //local var ref to defQueue, so cannot just reassign the one
+                //on context.
+                apsp.apply(defQueue,
+                           [defQueue.length - 1, 0].concat(globalDefQueue));
+                globalDefQueue = [];
+            }
+        }
+
+        handlers = {
+            'require': function (mod) {
+                if (mod.require) {
+                    return mod.require;
+                } else {
+                    return (mod.require = context.makeRequire(mod.map));
+                }
+            },
+            'exports': function (mod) {
+                mod.usingExports = true;
+                if (mod.map.isDefine) {
+                    if (mod.exports) {
+                        return mod.exports;
+                    } else {
+                        return (mod.exports = defined[mod.map.id] = {});
+                    }
+                }
+            },
+            'module': function (mod) {
+                if (mod.module) {
+                    return mod.module;
+                } else {
+                    return (mod.module = {
+                        id: mod.map.id,
+                        uri: mod.map.url,
+                        config: function () {
+                            return (config.config && getOwn(config.config, mod.map.id)) || {};
+                        },
+                        exports: defined[mod.map.id]
+                    });
+                }
+            }
+        };
+
+        function cleanRegistry(id) {
+            //Clean up machinery used for waiting modules.
+            delete registry[id];
+            delete enabledRegistry[id];
+        }
+
+        function breakCycle(mod, traced, processed) {
+            var id = mod.map.id;
+
+            if (mod.error) {
+                mod.emit('error', mod.error);
+            } else {
+                traced[id] = true;
+                each(mod.depMaps, function (depMap, i) {
+                    var depId = depMap.id,
+                        dep = getOwn(registry, depId);
+
+                    //Only force things that have not completed
+                    //being defined, so still in the registry,
+                    //and only if it has not been matched up
+                    //in the module already.
+                    if (dep && !mod.depMatched[i] && !processed[depId]) {
+                        if (getOwn(traced, depId)) {
+                            mod.defineDep(i, defined[depId]);
+                            mod.check(); //pass false?
+                        } else {
+                            breakCycle(dep, traced, processed);
+                        }
+                    }
+                });
+                processed[id] = true;
+            }
+        }
+
+        function checkLoaded() {
+            var map, modId, err, usingPathFallback,
+                waitInterval = config.waitSeconds * 1000,
+                //It is possible to disable the wait interval by using waitSeconds of 0.
+                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
+                noLoads = [],
+                reqCalls = [],
+                stillLoading = false,
+                needCycleCheck = true;
+
+            //Do not bother if this call was a result of a cycle break.
+            if (inCheckLoaded) {
+                return;
+            }
+
+            inCheckLoaded = true;
+
+            //Figure out the state of all the modules.
+            eachProp(enabledRegistry, function (mod) {
+                map = mod.map;
+                modId = map.id;
+
+                //Skip things that are not enabled or in error state.
+                if (!mod.enabled) {
+                    return;
+                }
+
+                if (!map.isDefine) {
+                    reqCalls.push(mod);
+                }
+
+                if (!mod.error) {
+                    //If the module should be executed, and it has not
+                    //been inited and time is up, remember it.
+                    if (!mod.inited && expired) {
+                        if (hasPathFallback(modId)) {
+                            usingPathFallback = true;
+                            stillLoading = true;
+                        } else {
+                            noLoads.push(modId);
+                            removeScript(modId);
+                        }
+                    } else if (!mod.inited && mod.fetched && map.isDefine) {
+                        stillLoading = true;
+                        if (!map.prefix) {
+                            //No reason to keep looking for unfinished
+                            //loading. If the only stillLoading is a
+                            //plugin resource though, keep going,
+                            //because it may be that a plugin resource
+                            //is waiting on a non-plugin cycle.
+                            return (needCycleCheck = false);
+                        }
+                    }
+                }
+            });
+
+            if (expired && noLoads.length) {
+                //If wait time expired, throw error of unloaded modules.
+                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
+                err.contextName = context.contextName;
+                return onError(err);
+            }
+
+            //Not expired, check for a cycle.
+            if (needCycleCheck) {
+                each(reqCalls, function (mod) {
+                    breakCycle(mod, {}, {});
+                });
+            }
+
+            //If still waiting on loads, and the waiting load is something
+            //other than a plugin resource, or there are still outstanding
+            //scripts, then just try back later.
+            if ((!expired || usingPathFallback) && stillLoading) {
+                //Something is still waiting to load. Wait for it, but only
+                //if a timeout is not already in effect.
+                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
+                    checkLoadedTimeoutId = setTimeout(function () {
+                        checkLoadedTimeoutId = 0;
+                        checkLoaded();
+                    }, 50);
+                }
+            }
+
+            inCheckLoaded = false;
+        }
+
+        Module = function (map) {
+            this.events = getOwn(undefEvents, map.id) || {};
+            this.map = map;
+            this.shim = getOwn(config.shim, map.id);
+            this.depExports = [];
+            this.depMaps = [];
+            this.depMatched = [];
+            this.pluginMaps = {};
+            this.depCount = 0;
+
+            /* this.exports this.factory
+               this.depMaps = [],
+               this.enabled, this.fetched
+            */
+        };
+
+        Module.prototype = {
+            init: function (depMaps, factory, errback, options) {
+                options = options || {};
+
+                //Do not do more inits if already done. Can happen if there
+                //are multiple define calls for the same module. That is not
+                //a normal, common case, but it is also not unexpected.
+                if (this.inited) {
+                    return;
+                }
+
+                this.factory = factory;
+
+                if (errback) {
+                    //Register for errors on this module.
+                    this.on('error', errback);
+                } else if (this.events.error) {
+                    //If no errback already, but there are error listeners
+                    //on this module, set up an errback to pass to the deps.
+                    errback = bind(this, function (err) {
+                        this.emit('error', err);
+                    });
+                }
+
+                //Do a copy of the dependency array, so that
+                //source inputs are not modified. For example
+                //"shim" deps are passed in here directly, and
+                //doing a direct modification of the depMaps array
+                //would affect that config.
+                this.depMaps = depMaps && depMaps.slice(0);
+
+                this.errback = errback;
+
+                //Indicate this module has be initialized
+                this.inited = true;
+
+                this.ignore = options.ignore;
+
+                //Could have option to init this module in enabled mode,
+                //or could have been previously marked as enabled. However,
+                //the dependencies are not known until init is called. So
+                //if enabled previously, now trigger dependencies as enabled.
+                if (options.enabled || this.enabled) {
+                    //Enable this module and dependencies.
+                    //Will call this.check()
+                    this.enable();
+                } else {
+                    this.check();
+                }
+            },
+
+            defineDep: function (i, depExports) {
+                //Because of cycles, defined callback for a given
+                //export can be called more than once.
+                if (!this.depMatched[i]) {
+                    this.depMatched[i] = true;
+                    this.depCount -= 1;
+                    this.depExports[i] = depExports;
+                }
+            },
+
+            fetch: function () {
+                if (this.fetched) {
+                    return;
+                }
+                this.fetched = true;
+
+                context.startTime = (new Date()).getTime();
+
+                var map = this.map;
+
+                //If the manager is for a plugin managed resource,
+                //ask the plugin to load it now.
+                if (this.shim) {
+                    context.makeRequire(this.map, {
+                        enableBuildCallback: true
+                    })(this.shim.deps || [], bind(this, function () {
+                        return map.prefix ? this.callPlugin() : this.load();
+                    }));
+                } else {
+                    //Regular dependency.
+                    return map.prefix ? this.callPlugin() : this.load();
+                }
+            },
+
+            load: function () {
+                var url = this.map.url;
+
+                //Regular dependency.
+                if (!urlFetched[url]) {
+                    urlFetched[url] = true;
+                    context.load(this.map.id, url);
+                }
+            },
+
+            /**
+             * Checks if the module is ready to define itself, and if so,
+             * define it.
+             */
+            check: function () {
+                if (!this.enabled || this.enabling) {
+                    return;
+                }
+
+                var err, cjsModule,
+                    id = this.map.id,
+                    depExports = this.depExports,
+                    exports = this.exports,
+                    factory = this.factory;
+
+                if (!this.inited) {
+                    this.fetch();
+                } else if (this.error) {
+                    this.emit('error', this.error);
+                } else if (!this.defining) {
+                    //The factory could trigger another require call
+                    //that would result in checking this module to
+                    //define itself again. If already in the process
+                    //of doing that, skip this work.
+                    this.defining = true;
+
+                    if (this.depCount < 1 && !this.defined) {
+                        if (isFunction(factory)) {
+                            //If there is an error listener, favor passing
+                            //to that instead of throwing an error.
+                            if (this.events.error) {
+                                try {
+                                    exports = context.execCb(id, factory, depExports, exports);
+                                } catch (e) {
+                                    err = e;
+                                }
+                            } else {
+                                exports = context.execCb(id, factory, depExports, exports);
+                            }
+
+                            if (this.map.isDefine) {
+                                //If setting exports via 'module' is in play,
+                                //favor that over return value and exports. After that,
+                                //favor a non-undefined return value over exports use.
+                                cjsModule = this.module;
+                                if (cjsModule &&
+                                        cjsModule.exports !== undefined &&
+                                        //Make sure it is not already the exports value
+                                        cjsModule.exports !== this.exports) {
+                                    exports = cjsModule.exports;
+                                } else if (exports === undefined && this.usingExports) {
+                                    //exports already set the defined value.
+                                    exports = this.exports;
+                                }
+                            }
+
+                            if (err) {
+                                err.requireMap = this.map;
+                                err.requireModules = [this.map.id];
+                                err.requireType = 'define';
+                                return onError((this.error = err));
+                            }
+
+                        } else {
+                            //Just a literal value
+                            exports = factory;
+                        }
+
+                        this.exports = exports;
+
+                        if (this.map.isDefine && !this.ignore) {
+                            defined[id] = exports;
+
+                            if (req.onResourceLoad) {
+                                req.onResourceLoad(context, this.map, this.depMaps);
+                            }
+                        }
+
+                        //Clean up
+                        cleanRegistry(id);
+
+                        this.defined = true;
+                    }
+
+                    //Finished the define stage. Allow calling check again
+                    //to allow define notifications below in the case of a
+                    //cycle.
+                    this.defining = false;
+
+                    if (this.defined && !this.defineEmitted) {
+                        this.defineEmitted = true;
+                        this.emit('defined', this.exports);
+                        this.defineEmitComplete = true;
+                    }
+
+                }
+            },
+
+            callPlugin: function () {
+                var map = this.map,
+                    id = map.id,
+                    //Map already normalized the prefix.
+                    pluginMap = makeModuleMap(map.prefix);
+
+                //Mark this as a dependency for this plugin, so it
+                //can be traced for cycles.
+                this.depMaps.push(pluginMap);
+
+                on(pluginMap, 'defined', bind(this, function (plugin) {
+                    var load, normalizedMap, normalizedMod,
+                        name = this.map.name,
+                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
+                        localRequire = context.makeRequire(map.parentMap, {
+                            enableBuildCallback: true
+                        });
+
+                    //If current map is not normalized, wait for that
+                    //normalized name to load instead of continuing.
+                    if (this.map.unnormalized) {
+                        //Normalize the ID if the plugin allows it.
+                        if (plugin.normalize) {
+                            name = plugin.normalize(name, function (name) {
+                                return normalize(name, parentName, true);
+                            }) || '';
+                        }
+
+                        //prefix and name should already be normalized, no need
+                        //for applying map config again either.
+                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
+                                                      this.map.parentMap);
+                        on(normalizedMap,
+                            'defined', bind(this, function (value) {
+                                this.init([], function () { return value; }, null, {
+                                    enabled: true,
+                                    ignore: true
+                                });
+                            }));
+
+                        normalizedMod = getOwn(registry, normalizedMap.id);
+                        if (normalizedMod) {
+                            //Mark this as a dependency for this plugin, so it
+                            //can be traced for cycles.
+                            this.depMaps.push(normalizedMap);
+
+                            if (this.events.error) {
+                                normalizedMod.on('error', bind(this, function (err) {
+                                    this.emit('error', err);
+                                }));
+                            }
+                            normalizedMod.enable();
+                        }
+
+                        return;
+                    }
+
+                    load = bind(this, function (value) {
+                        this.init([], function () { return value; }, null, {
+                            enabled: true
+                        });
+                    });
+
+                    load.error = bind(this, function (err) {
+                        this.inited = true;
+                        this.error = err;
+                        err.requireModules = [id];
+
+                        //Remove temp unnormalized modules for this module,
+                        //since they will never be resolved otherwise now.
+                        eachProp(registry, function (mod) {
+                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
+                                cleanRegistry(mod.map.id);
+                            }
+                        });
+
+                        onError(err);
+                    });
+
+                    //Allow plugins to load other code without having to know the
+                    //context or how to 'complete' the load.
+                    load.fromText = bind(this, function (text, textAlt) {
+                        /*jslint evil: true */
+                        var moduleName = map.name,
+                            moduleMap = makeModuleMap(moduleName),
+                            hasInteractive = useInteractive;
+
+                        //As of 2.1.0, support just passing the text, to reinforce
+                        //fromText only being called once per resource. Still
+                        //support old style of passing moduleName but discard
+                        //that moduleName in favor of the internal ref.
+                        if (textAlt) {
+                            text = textAlt;
+                        }
+
+                        //Turn off interactive script matching for IE for any define
+                        //calls in the text, then turn it back on at the end.
+                        if (hasInteractive) {
+                            useInteractive = false;
+                        }
+
+                        //Prime the system by creating a module instance for
+                        //it.
+                        getModule(moduleMap);
+
+                        //Transfer any config to this other module.
+                        if (hasProp(config.config, id)) {
+                            config.config[moduleName] = config.config[id];
+                        }
+
+                        try {
+                            req.exec(text);
+                        } catch (e) {
+                            return onError(makeError('fromtexteval',
+                                             'fromText eval for ' + id +
+                                            ' failed: ' + e,
+                                             e,
+                                             [id]));
+                        }
+
+                        if (hasInteractive) {
+                            useInteractive = true;
+                        }
+
+                        //Mark this as a dependency for the plugin
+                        //resource
+                        this.depMaps.push(moduleMap);
+
+                        //Support anonymous modules.
+                        context.completeLoad(moduleName);
+
+                        //Bind the value of that module to the value for this
+                        //resource ID.
+                        localRequire([moduleName], load);
+                    });
+
+                    //Use parentName here since the plugin's name is not reliable,
+                    //could be some weird string with no path that actually wants to
+                    //reference the parentName's path.
+                    plugin.load(map.name, localRequire, load, config);
+                }));
+
+                context.enable(pluginMap, this);
+                this.pluginMaps[pluginMap.id] = pluginMap;
+            },
+
+            enable: function () {
+                enabledRegistry[this.map.id] = this;
+                this.enabled = true;
+
+                //Set flag mentioning that the module is enabling,
+                //so that immediate calls to the defined callbacks
+                //for dependencies do not trigger inadvertent load
+                //with the depCount still being zero.
+                this.enabling = true;
+
+                //Enable each dependency
+                each(this.depMaps, bind(this, function (depMap, i) {
+                    var id, mod, handler;
+
+                    if (typeof depMap === 'string') {
+                        //Dependency needs to be converted to a depMap
+                        //and wired up to this module.
+                        depMap = makeModuleMap(depMap,
+                                               (this.map.isDefine ? this.map : this.map.parentMap),
+                                               false,
+                                               !this.skipMap);
+                        this.depMaps[i] = depMap;
+
+                        handler = getOwn(handlers, depMap.id);
+
+                        if (handler) {
+                            this.depExports[i] = handler(this);
+                            return;
+                        }
+
+                        this.depCount += 1;
+
+                        on(depMap, 'defined', bind(this, function (depExports) {
+                            this.defineDep(i, depExports);
+                            this.check();
+                        }));
+
+                        if (this.errback) {
+                            on(depMap, 'error', this.errback);
+                        }
+                    }
+
+                    id = depMap.id;
+                    mod = registry[id];
+
+                    //Skip special modules like 'require', 'exports', 'module'
+                    //Also, don't call enable if it is already enabled,
+                    //important in circular dependency cases.
+                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
+                        context.enable(depMap, this);
+                    }
+                }));
+
+                //Enable each plugin that is used in
+                //a dependency
+                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
+                    var mod = getOwn(registry, pluginMap.id);
+                    if (mod && !mod.enabled) {
+                        context.enable(pluginMap, this);
+                    }
+                }));
+
+                this.enabling = false;
+
+                this.check();
+            },
+
+            on: function (name, cb) {
+                var cbs = this.events[name];
+                if (!cbs) {
+                    cbs = this.events[name] = [];
+                }
+                cbs.push(cb);
+            },
+
+            emit: function (name, evt) {
+                each(this.events[name], function (cb) {
+                    cb(evt);
+                });
+                if (name === 'error') {
+                    //Now that the error handler was triggered, remove
+                    //the listeners, since this broken Module instance
+                    //can stay around for a while in the registry.
+                    delete this.events[name];
+                }
+            }
+        };
+
+        function callGetModule(args) {
+            //Skip modules already defined.
+            if (!hasProp(defined, args[0])) {
+                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
+            }
+        }
+
+        function removeListener(node, func, name, ieName) {
+            //Favor detachEvent because of IE9
+            //issue, see attachEvent/addEventListener comment elsewhere
+            //in this file.
+            if (node.detachEvent && !isOpera) {
+                //Probably IE. If not it will throw an error, which will be
+                //useful to know.
+                if (ieName) {
+                    node.detachEvent(ieName, func);
+                }
+            } else {
+                node.removeEventListener(name, func, false);
+            }
+        }
+
+        /**
+         * Given an event from a script node, get the requirejs info from it,
+         * and then removes the event listeners on the node.
+         * @param {Event} evt
+         * @returns {Object}
+         */
+        function getScriptData(evt) {
+            //Using currentTarget instead of target for Firefox 2.0's sake. Not
+            //all old browsers will be supported, but this one was easy enough
+            //to support and still makes sense.
+            var node = evt.currentTarget || evt.srcElement;
+
+            //Remove the listeners once here.
+            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
+            removeListener(node, context.onScriptError, 'error');
+
+            return {
+                node: node,
+                id: node && node.getAttribute('data-requiremodule')
+            };
+        }
+
+        function intakeDefines() {
+            var args;
+
+            //Any defined modules in the global queue, intake them now.
+            takeGlobalQueue();
+
+            //Make sure any remaining defQueue items get properly processed.
+            while (defQueue.length) {
+                args = defQueue.shift();
+                if (args[0] === null) {
+                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
+                } else {
+                    //args are id, deps, factory. Should be normalized by the
+                    //define() function.
+                    callGetModule(args);
+                }
+            }
+        }
+
+        context = {
+            config: config,
+            contextName: contextName,
+            registry: registry,
+            defined: defined,
+            urlFetched: urlFetched,
+            defQueue: defQueue,
+            Module: Module,
+            makeModuleMap: makeModuleMap,
+            nextTick: req.nextTick,
+            onError: onError,
+
+            /**
+             * Set a configuration for the context.
+             * @param {Object} cfg config object to integrate.
+             */
+            configure: function (cfg) {
+                //Make sure the baseUrl ends in a slash.
+                if (cfg.baseUrl) {
+                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
+                        cfg.baseUrl += '/';
+                    }
+                }
+
+                //Save off the paths and packages since they require special processing,
+                //they are additive.
+                var pkgs = config.pkgs,
+                    shim = config.shim,
+                    objs = {
+                        paths: true,
+                        config: true,
+                        map: true
+                    };
+
+                eachProp(cfg, function (value, prop) {
+                    if (objs[prop]) {
+                        if (prop === 'map') {
+                            if (!config.map) {
+                                config.map = {};
+                            }
+                            mixin(config[prop], value, true, true);
+                        } else {
+                            mixin(config[prop], value, true);
+                        }
+                    } else {
+                        config[prop] = value;
+                    }
+                });
+
+                //Merge shim
+                if (cfg.shim) {
+                    eachProp(cfg.shim, function (value, id) {
+                        //Normalize the structure
+                        if (isArray(value)) {
+                            value = {
+                                deps: value
+                            };
+                        }
+                        if ((value.exports || value.init) && !value.exportsFn) {
+                            value.exportsFn = context.makeShimExports(value);
+                        }
+                        shim[id] = value;
+                    });
+                    config.shim = shim;
+                }
+
+                //Adjust packages if necessary.
+                if (cfg.packages) {
+                    each(cfg.packages, function (pkgObj) {
+                        var location;
+
+                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
+                        location = pkgObj.location;
+
+                        //Create a brand new object on pkgs, since currentPackages can
+                        //be passed in again, and config.pkgs is the internal transformed
+                        //state for all package configs.
+                        pkgs[pkgObj.name] = {
+                            name: pkgObj.name,
+                            location: location || pkgObj.name,
+                            //Remove leading dot in main, so main paths are normalized,
+                            //and remove any trailing .js, since different package
+                            //envs have different conventions: some use a module name,
+                            //some use a file name.
+                            main: (pkgObj.main || 'main')
+                                  .replace(currDirRegExp, '')
+                                  .replace(jsSuffixRegExp, '')
+                        };
+                    });
+
+                    //Done with modifications, assing packages back to context config
+                    config.pkgs = pkgs;
+                }
+
+                //If there are any "waiting to execute" modules in the registry,
+                //update the maps for them, since their info, like URLs to load,
+                //may have changed.
+                eachProp(registry, function (mod, id) {
+                    //If module already has init called, since it is too
+                    //late to modify them, and ignore unnormalized ones
+                    //since they are transient.
+                    if (!mod.inited && !mod.map.unnormalized) {
+                        mod.map = makeModuleMap(id);
+                    }
+                });
+
+                //If a deps array or a config callback is specified, then call
+                //require with those args. This is useful when require is defined as a
+                //config object before require.js is loaded.
+                if (cfg.deps || cfg.callback) {
+                    context.require(cfg.deps || [], cfg.callback);
+                }
+            },
+
+            makeShimExports: function (value) {
+                function fn() {
+                    var ret;
+                    if (value.init) {
+                        ret = value.init.apply(global, arguments);
+                    }
+                    return ret || (value.exports && getGlobal(value.exports));
+                }
+                return fn;
+            },
+
+            makeRequire: function (relMap, options) {
+                options = options || {};
+
+                function localRequire(deps, callback, errback) {
+                    var id, map, requireMod;
+
+                    if (options.enableBuildCallback && callback && isFunction(callback)) {
+                        callback.__requireJsBuild = true;
+                    }
+
+                    if (typeof deps === 'string') {
+                        if (isFunction(callback)) {
+                            //Invalid call
+                            return onError(makeError('requireargs', 'Invalid require call'), errback);
+                        }
+
+                        //If require|exports|module are requested, get the
+                        //value for them from the special handlers. Caveat:
+                        //this only works while module is being defined.
+                        if (relMap && hasProp(handlers, deps)) {
+                            return handlers[deps](registry[relMap.id]);
+                        }
+
+                        //Synchronous access to one module. If require.get is
+                        //available (as in the Node adapter), prefer that.
+                        if (req.get) {
+                            return req.get(context, deps, relMap, localRequire);
+                        }
+
+                        //Normalize module name, if it contains . or ..
+                        map = makeModuleMap(deps, relMap, false, true);
+                        id = map.id;
+
+                        if (!hasProp(defined, id)) {
+                            return onError(makeError('notloaded', 'Module name "' +
+                                        id +
+                                        '" has not been loaded yet for context: ' +
+                                        contextName +
+                                        (relMap ? '' : '. Use require([])')));
+                        }
+                        return defined[id];
+                    }
+
+                    //Grab defines waiting in the global queue.
+                    intakeDefines();
+
+                    //Mark all the dependencies as needing to be loaded.
+                    context.nextTick(function () {
+                        //Some defines could have been added since the
+                        //require call, collect them.
+                        intakeDefines();
+
+                        requireMod = getModule(makeModuleMap(null, relMap));
+
+                        //Store if map config should be applied to this require
+                        //call for dependencies.
+                        requireMod.skipMap = options.skipMap;
+
+                        requireMod.init(deps, callback, errback, {
+                            enabled: true
+                        });
+
+                        checkLoaded();
+                    });
+
+                    return localRequire;
+                }
+
+                mixin(localRequire, {
+                    isBrowser: isBrowser,
+
+                    /**
+                     * Converts a module name + .extension into an URL path.
+                     * *Requires* the use of a module name. It does not support using
+                     * plain URLs like nameToUrl.
+                     */
+                    toUrl: function (moduleNamePlusExt) {
+                        var ext,
+                            index = moduleNamePlusExt.lastIndexOf('.'),
+                            segment = moduleNamePlusExt.split('/')[0],
+                            isRelative = segment === '.' || segment === '..';
+
+                        //Have a file extension alias, and it is not the
+                        //dots from a relative path.
+                        if (index !== -1 && (!isRelative || index > 1)) {
+                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
+                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
+                        }
+
+                        return context.nameToUrl(normalize(moduleNamePlusExt,
+                                                relMap && relMap.id, true), ext,  true);
+                    },
+
+                    defined: function (id) {
+                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
+                    },
+
+                    specified: function (id) {
+                        id = makeModuleMap(id, relMap, false, true).id;
+                        return hasProp(defined, id) || hasProp(registry, id);
+                    }
+                });
+
+                //Only allow undef on top level require calls
+                if (!relMap) {
+                    localRequire.undef = function (id) {
+                        //Bind any waiting define() calls to this context,
+                        //fix for #408
+                        takeGlobalQueue();
+
+                        var map = makeModuleMap(id, relMap, true),
+                            mod = getOwn(registry, id);
+
+                        delete defined[id];
+                        delete urlFetched[map.url];
+                        delete undefEvents[id];
+
+                        if (mod) {
+                            //Hold on to listeners in case the
+                            //module will be attempted to be reloaded
+                            //using a different config.
+                            if (mod.events.defined) {
+                                undefEvents[id] = mod.events;
+                            }
+
+                            cleanRegistry(id);
+                        }
+                    };
+                }
+
+                return localRequire;
+            },
+
+            /**
+             * Called to enable a module if it is still in the registry
+             * awaiting enablement. A second arg, parent, the parent module,
+             * is passed in for context, when this method is overriden by
+             * the optimizer. Not shown here to keep code compact.
+             */
+            enable: function (depMap) {
+                var mod = getOwn(registry, depMap.id);
+                if (mod) {
+                    getModule(depMap).enable();
+                }
+            },
+
+            /**
+             * Internal method used by environment adapters to complete a load event.
+             * A load event could be a script load or just a load pass from a synchronous
+             * load call.
+             * @param {String} moduleName the name of the module to potentially complete.
+             */
+            completeLoad: function (moduleName) {
+                var found, args, mod,
+                    shim = getOwn(config.shim, moduleName) || {},
+                    shExports = shim.exports;
+
+                takeGlobalQueue();
+
+                while (defQueue.length) {
+                    args = defQueue.shift();
+                    if (args[0] === null) {
+                        args[0] = moduleName;
+                        //If already found an anonymous module and bound it
+                        //to this name, then this is some other anon module
+                        //waiting for its completeLoad to fire.
+                        if (found) {
+                            break;
+                        }
+                        found = true;
+                    } else if (args[0] === moduleName) {
+                        //Found matching define call for this script!
+                        found = true;
+                    }
+
+                    callGetModule(args);
+                }
+
+                //Do this after the cycle of callGetModule in case the result
+                //of those calls/init calls changes the registry.
+                mod = getOwn(registry, moduleName);
+
+                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
+                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
+                        if (hasPathFallback(moduleName)) {
+                            return;
+                        } else {
+                            return onError(makeError('nodefine',
+                                             'No define call for ' + moduleName,
+                                             null,
+                                             [moduleName]));
+                        }
+                    } else {
+                        //A script that does not call define(), so just simulate
+                        //the call for it.
+                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
+                    }
+                }
+
+                checkLoaded();
+            },
+
+            /**
+             * Converts a module name to a file path. Supports cases where
+             * moduleName may actually be just an URL.
+             * Note that it **does not** call normalize on the moduleName,
+             * it is assumed to have already been normalized. This is an
+             * internal API, not a public one. Use toUrl for the public API.
+             */
+            nameToUrl: function (moduleName, ext, skipExt) {
+                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
+                    parentPath;
+
+                //If a colon is in the URL, it indicates a protocol is used and it is just
+                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
+                //or ends with .js, then assume the user meant to use an url and not a module id.
+                //The slash is important for protocol-less URLs as well as full paths.
+                if (req.jsExtRegExp.test(moduleName)) {
+                    //Just a plain path, not module name lookup, so just return it.
+                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
+                    //an extension, this method probably needs to be reworked.
+                    url = moduleName + (ext || '');
+                } else {
+                    //A module that needs to be converted to a path.
+                    paths = config.paths;
+                    pkgs = config.pkgs;
+
+                    syms = moduleName.split('/');
+                    //For each module name segment, see if there is a path
+                    //registered for it. Start with most specific name
+                    //and work up from it.
+                    for (i = syms.length; i > 0; i -= 1) {
+                        parentModule = syms.slice(0, i).join('/');
+                        pkg = getOwn(pkgs, parentModule);
+                        parentPath = getOwn(paths, parentModule);
+                        if (parentPath) {
+                            //If an array, it means there are a few choices,
+                            //Choose the one that is desired
+                            if (isArray(parentPath)) {
+                                parentPath = parentPath[0];
+                            }
+                            syms.splice(0, i, parentPath);
+                            break;
+                        } else if (pkg) {
+                            //If module name is just the package name, then looking
+                            //for the main module.
+                            if (moduleName === pkg.name) {
+                                pkgPath = pkg.location + '/' + pkg.main;
+                            } else {
+                                pkgPath = pkg.location;
+                            }
+                            syms.splice(0, i, pkgPath);
+                            break;
+                        }
+                    }
+
+                    //Join the path parts together, then figure out if baseUrl is needed.
+                    url = syms.join('/');
+                    url += (ext || (/\?/.test(url) || skipExt ? '' : '.js'));
+                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
+                }
+
+                return config.urlArgs ? url +
+                                        ((url.indexOf('?') === -1 ? '?' : '&') +
+                                         config.urlArgs) : url;
+            },
+
+            //Delegates to req.load. Broken out as a separate function to
+            //allow overriding in the optimizer.
+            load: function (id, url) {
+                req.load(context, id, url);
+            },
+
+            /**
+             * Executes a module callack function. Broken out as a separate function
+             * solely to allow the build system to sequence the files in the built
+             * layer in the right sequence.
+             *
+             * @private
+             */
+            execCb: function (name, callback, args, exports) {
+                return callback.apply(exports, args);
+            },
+
+            /**
+             * callback for script loads, used to check status of loading.
+             *
+             * @param {Event} evt the event from the browser for the script
+             * that was loaded.
+             */
+            onScriptLoad: function (evt) {
+                //Using currentTarget instead of target for Firefox 2.0's sake. Not
+                //all old browsers will be supported, but this one was easy enough
+                //to support and still makes sense.
+                if (evt.type === 'load' ||
+                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
+                    //Reset interactive script so a script node is not held onto for
+                    //to long.
+                    interactiveScript = null;
+
+                    //Pull out the name of the module and the context.
+                    var data = getScriptData(evt);
+                    context.completeLoad(data.id);
+                }
+            },
+
+            /**
+             * Callback for script errors.
+             */
+            onScriptError: function (evt) {
+                var data = getScriptData(evt);
+                if (!hasPathFallback(data.id)) {
+                    return onError(makeError('scripterror', 'Script error', evt, [data.id]));
+                }
+            }
+        };
+
+        context.require = context.makeRequire();
+        return context;
+    }
+
+    /**
+     * Main entry point.
+     *
+     * If the only argument to require is a string, then the module that
+     * is represented by that string is fetched for the appropriate context.
+     *
+     * If the first argument is an array, then it will be treated as an array
+     * of dependency string names to fetch. An optional function callback can
+     * be specified to execute when all of those dependencies are available.
+     *
+     * Make a local req variable to help Caja compliance (it assumes things
+     * on a require that are not standardized), and to give a short
+     * name for minification/local scope use.
+     */
+    req = requirejs = function (deps, callback, errback, optional) {
+
+        //Find the right context, use default
+        var context, config,
+            contextName = defContextName;
+
+        // Determine if have config object in the call.
+        if (!isArray(deps) && typeof deps !== 'string') {
+            // deps is a config object
+            config = deps;
+            if (isArray(callback)) {
+                // Adjust args if there are dependencies
+                deps = callback;
+                callback = errback;
+                errback = optional;
+            } else {
+                deps = [];
+            }
+        }
+
+        if (config && config.context) {
+            contextName = config.context;
+        }
+
+        context = getOwn(contexts, contextName);
+        if (!context) {
+            context = contexts[contextName] = req.s.newContext(contextName);
+        }
+
+        if (config) {
+            context.configure(config);
+        }
+
+        return context.require(deps, callback, errback);
+    };
+
+    /**
+     * Support require.config() to make it easier to cooperate with other
+     * AMD loaders on globally agreed names.
+     */
+    req.config = function (config) {
+        return req(config);
+    };
+
+    /**
+     * Execute something after the current tick
+     * of the event loop. Override for other envs
+     * that have a better solution than setTimeout.
+     * @param  {Function} fn function to execute later.
+     */
+    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
+        setTimeout(fn, 4);
+    } : function (fn) { fn(); };
+
+    /**
+     * Export require as a global, but only if it does not already exist.
+     */
+    if (!require) {
+        require = req;
+    }
+
+    req.version = version;
+
+    //Used to filter out dependencies that are already paths.
+    req.jsExtRegExp = /^\/|:|\?|\.js$/;
+    req.isBrowser = isBrowser;
+    s = req.s = {
+        contexts: contexts,
+        newContext: newContext
+    };
+
+    //Create default context.
+    req({});
+
+    //Exports some context-sensitive methods on global require.
+    each([
+        'toUrl',
+        'undef',
+        'defined',
+        'specified'
+    ], function (prop) {
+        //Reference from contexts instead of early binding to default context,
+        //so that during builds, the latest instance of the default context
+        //with its config gets used.
+        req[prop] = function () {
+            var ctx = contexts[defContextName];
+            return ctx.require[prop].apply(ctx, arguments);
+        };
+    });
+
+    if (isBrowser) {
+        head = s.head = document.getElementsByTagName('head')[0];
+        //If BASE tag is in play, using appendChild is a problem for IE6.
+        //When that browser dies, this can be removed. Details in this jQuery bug:
+        //http://dev.jquery.com/ticket/2709
+        baseElement = document.getElementsByTagName('base')[0];
+        if (baseElement) {
+            head = s.head = baseElement.parentNode;
+        }
+    }
+
+    /**
+     * Any errors that require explicitly generates will be passed to this
+     * function. Intercept/override it if you want custom error handling.
+     * @param {Error} err the error object.
+     */
+    req.onError = function (err) {
+        throw err;
+    };
+
+    /**
+     * Does the request to load a module for the browser case.
+     * Make this a separate function to allow other environments
+     * to override it.
+     *
+     * @param {Object} context the require context to find state.
+     * @param {String} moduleName the name of the module.
+     * @param {Object} url the URL to the module.
+     */
+    req.load = function (context, moduleName, url) {
+        var config = (context && context.config) || {},
+            node;
+        if (isBrowser) {
+            //In the browser so use a script tag
+            node = config.xhtml ?
+                    document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
+                    document.createElement('script');
+            node.type = config.scriptType || 'text/javascript';
+            node.charset = 'utf-8';
+            node.async = true;
+
+            node.setAttribute('data-requirecontext', context.contextName);
+            node.setAttribute('data-requiremodule', moduleName);
+
+            //Set up load listener. Test attachEvent first because IE9 has
+            //a subtle issue in its addEventListener and script onload firings
+            //that do not match the behavior of all other browsers with
+            //addEventListener support, which fire the onload event for a
+            //script right after the script execution. See:
+            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
+            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
+            //script execution mode.
+            if (node.attachEvent &&
+                    //Check if node.attachEvent is artificially added by custom script or
+                    //natively supported by browser
+                    //read https://github.com/jrburke/requirejs/issues/187
+                    //if we can NOT find [native code] then it must NOT natively supported.
+                    //in IE8, node.attachEvent does not have toString()
+                    //Note the test for "[native code" with no closing brace, see:
+                    //https://github.com/jrburke/requirejs/issues/273
+                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
+                    !isOpera) {
+                //Probably IE. IE (at least 6-8) do not fire
+                //script onload right after executing the script, so
+                //we cannot tie the anonymous define call to a name.
+                //However, IE reports the script as being in 'interactive'
+                //readyState at the time of the define call.
+                useInteractive = true;
+
+                node.attachEvent('onreadystatechange', context.onScriptLoad);
+                //It would be great to add an error handler here to catch
+                //404s in IE9+. However, onreadystatechange will fire before
+                //the error handler, so that does not help. If addEventListener
+                //is used, then IE will fire error before load, but we cannot
+                //use that pathway given the connect.microsoft.com issue
+                //mentioned above about not doing the 'script execute,
+                //then fire the script load event listener before execute
+                //next script' that other browsers do.
+                //Best hope: IE10 fixes the issues,
+                //and then destroys all installs of IE 6-9.
+                //node.attachEvent('onerror', context.onScriptError);
+            } else {
+                node.addEventListener('load', context.onScriptLoad, false);
+                node.addEventListener('error', context.onScriptError, false);
+            }
+            node.src = url;
+
+            //For some cache cases in IE 6-8, the script executes before the end
+            //of the appendChild execution, so to tie an anonymous define
+            //call to the module name (which is stored on the node), hold on
+            //to a reference to this node, but clear after the DOM insertion.
+            currentlyAddingScript = node;
+            if (baseElement) {
+                head.insertBefore(node, baseElement);
+            } else {
+                head.appendChild(node);
+            }
+            currentlyAddingScript = null;
+
+            return node;
+        } else if (isWebWorker) {
+            try {
+                //In a web worker, use importScripts. This is not a very
+                //efficient use of importScripts, importScripts will block until
+                //its script is downloaded and evaluated. However, if web workers
+                //are in play, the expectation that a build has been done so that
+                //only one script needs to be loaded anyway. This may need to be
+                //reevaluated if other use cases become common.
+                importScripts(url);
+
+                //Account for anonymous modules
+                context.completeLoad(moduleName);
+            } catch (e) {
+                context.onError(makeError('importscripts',
+                                'importScripts failed for ' +
+                                    moduleName + ' at ' + url,
+                                e,
+                                [moduleName]));
+            }
+        }
+    };
+
+    function getInteractiveScript() {
+        if (interactiveScript && interactiveScript.readyState === 'interactive') {
+            return interactiveScript;
+        }
+
+        eachReverse(scripts(), function (script) {
+            if (script.readyState === 'interactive') {
+                return (interactiveScript = script);
+            }
+        });
+        return interactiveScript;
+    }
+
+    //Look for a data-main script attribute, which could also adjust the baseUrl.
+    if (isBrowser) {
+        //Figure out baseUrl. Get it from the script tag with require.js in it.
+        eachReverse(scripts(), function (script) {
+            //Set the 'head' where we can append children by
+            //using the script's parent.
+            if (!head) {
+                head = script.parentNode;
+            }
+
+            //Look for a data-main attribute to set main script for the page
+            //to load. If it is there, the path to data main becomes the
+            //baseUrl, if it is not already set.
+            dataMain = script.getAttribute('data-main');
+            if (dataMain) {
+                //Set final baseUrl if there is not already an explicit one.
+                if (!cfg.baseUrl) {
+                    //Pull off the directory of data-main for use as the
+                    //baseUrl.
+                    src = dataMain.split('/');
+                    mainScript = src.pop();
+                    subPath = src.length ? src.join('/')  + '/' : './';
+
+                    cfg.baseUrl = subPath;
+                    dataMain = mainScript;
+                }
+
+                //Strip off any trailing .js since dataMain is now
+                //like a module name.
+                dataMain = dataMain.replace(jsSuffixRegExp, '');
+
+                //Put the data-main script in the files to load.
+                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];
+
+                return true;
+            }
+        });
+    }
+
+    /**
+     * The function that handles definitions of modules. Differs from
+     * require() in that a string for the module should be the first argument,
+     * and the function to execute after dependencies are loaded should
+     * return a value to define the module corresponding to the first argument's
+     * name.
+     */
+    define = function (name, deps, callback) {
+        var node, context;
+
+        //Allow for anonymous modules
+        if (typeof name !== 'string') {
+            //Adjust args appropriately
+            callback = deps;
+            deps = name;
+            name = null;
+        }
+
+        //This module may not have dependencies
+        if (!isArray(deps)) {
+            callback = deps;
+            deps = [];
+        }
+
+        //If no name, and callback is a function, then figure out if it a
+        //CommonJS thing with dependencies.
+        if (!deps.length && isFunction(callback)) {
+            //Remove comments from the callback string,
+            //look for require calls, and pull them into the dependencies,
+            //but only if there are function args.
+            if (callback.length) {
+                callback
+                    .toString()
+                    .replace(commentRegExp, '')
+                    .replace(cjsRequireRegExp, function (match, dep) {
+                        deps.push(dep);
+                    });
+
+                //May be a CommonJS thing even without require calls, but still
+                //could use exports, and module. Avoid doing exports and module
+                //work though if it just needs require.
+                //REQUIRES the function to expect the CommonJS variables in the
+                //order listed below.
+                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
+            }
+        }
+
+        //If in IE 6-8 and hit an anonymous define() call, do the interactive
+        //work.
+        if (useInteractive) {
+            node = currentlyAddingScript || getInteractiveScript();
+            if (node) {
+                if (!name) {
+                    name = node.getAttribute('data-requiremodule');
+                }
+                context = contexts[node.getAttribute('data-requirecontext')];
+            }
+        }
+
+        //Always save off evaluating the def call until the script onload handler.
+        //This allows multiple modules to be in a file without prematurely
+        //tracing dependencies, and allows for anonymous module support,
+        //where the module name is not known until the script onload event
+        //occurs. If no context, use the global queue, and get it processed
+        //in the onscript load callback.
+        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
+    };
+
+    define.amd = {
+        jQuery: true
+    };
+
+
+    /**
+     * Executes the text. Normally just uses eval, but can be modified
+     * to use a better, environment-specific call. Only used for transpiling
+     * loader plugins, not for plain JS modules.
+     * @param {String} text the text to execute/evaluate.
+     */
+    req.exec = function (text) {
+        /*jslint evil: true */
+        return eval(text);
+    };
+
+    //Set up with config info.
+    req(cfg);
+}(this));
diff --git a/public/js_src/run-jshint.sh b/public/js_src/run-jshint.sh
new file mode 100755
index 0000000..391201e
--- /dev/null
+++ b/public/js_src/run-jshint.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+if which -s jshint; then
+	jshint ./
+else
+  echo 'Error: jshint not found. Install Node.js then: npm install -g jshint';
+	exit 1;
+fi
diff --git a/public/js_src/run_jshint.bat b/public/js_src/run_jshint.bat
new file mode 100644
index 0000000..99fd3c8
--- /dev/null
+++ b/public/js_src/run_jshint.bat
@@ -0,0 +1,7 @@
+@echo off
+where /q jshint || (
+	echo jshint node package is not installed. You must install node, npm and then run npm install -g jshint
+	goto :eof
+)
+jshint ./
+:end
\ No newline at end of file
diff --git a/public/js_src/scripts/add_new_event.js b/public/js_src/scripts/add_new_event.js
new file mode 100644
index 0000000..c47afba
--- /dev/null
+++ b/public/js_src/scripts/add_new_event.js
@@ -0,0 +1,264 @@
+define(
+	[
+		"jquery_timely",
+		'domReady',
+		'ai1ec_config',
+		'scripts/add_new_event/event_location/gmaps_helper',
+		'scripts/add_new_event/event_location/input_coordinates_event_handlers',
+		'scripts/add_new_event/event_location/input_coordinates_utility_functions',
+		'scripts/add_new_event/event_date_time/date_time_event_handlers',
+		'scripts/add_new_event/facebook_export',
+		'scripts/add_new_event/event_cost_helper',
+		'external_libs/jquery.calendrical_timespan',
+		'external_libs/jquery.inputdate',
+		'external_libs/jquery.tools',
+		'external_libs/jquery.blockui',
+		'external_libs/ai1ec_datepicker',
+		'external_libs/bootstrap_collapse'
+	],
+	function (
+		$,
+		domReady,
+		ai1ec_config,
+		gmaps_helper,
+		input_coordinates_event_handlers,
+		input_utility_functions,
+		date_time_event_handlers,
+		facebook_export,
+		event_cost,
+		calendrical_functions
+	) {
+	"use strict"; // jshint ;_;
+
+
+	var init_date_time = function() {
+
+		var now = new Date( ai1ec_config.now * 1000 );
+
+		/**
+		* Timespan plugin setup
+		*/
+		// Initialize timespan plugin on our date/time inputs.
+		var data = {
+			allday           : '#ai1ec_all_day_event',
+			start_date_input : '#ai1ec_start-date-input',
+			start_time_input : '#ai1ec_start-time-input',
+			start_time       : '#ai1ec_start-time',
+			end_date_input   : '#ai1ec_end-date-input',
+			end_time_input   : '#ai1ec_end-time-input',
+			end_time         : '#ai1ec_end-time',
+			date_format      : ai1ec_config.date_format,
+			month_names      : ai1ec_config.month_names,
+			day_names        : ai1ec_config.day_names,
+			week_start_day   : ai1ec_config.week_start_day,
+			twentyfour_hour  : ai1ec_config.twentyfour_hour,
+			now              : now
+		};
+		$.timespan( data );
+		// Retrieve the dates saved in the hidden field
+		var exdate  = $( "#ai1ec_exdate" ).val();
+
+		// This variable holds the dates that must be selected in the datepicker.
+		var dp_date = null;
+		var _clear_dp = false;
+		var _day;
+		if( exdate.length >= 8 ) {
+			dp_date = [];
+			var _span_html = [];
+			$.each( exdate.split( ',' ), function( i, v ) {
+				var _date = v.slice( 0, 8 );
+				var _year = _date.substr( 0, 4 );
+				var _month = _date.substr( 4, 2 );
+				_day = _date.substr( 6, 2 );
+
+				_month = _month.charAt(0) === '0' ? ( '0' + ( parseInt( _month.charAt( 1 ), 10 ) - 1 ) ) : ( parseInt( _month, 10 ) - 1 );
+
+				dp_date.push( new Date( _year, _month, _day ) );
+				_span_html.push( 
+					calendrical_functions.formatDate( 
+						new Date( _year, _month, _day ),
+						ai1ec_config.date_format,
+						true
+					)
+				);
+			});
+
+			$( '#widgetField span:first' ).html( _span_html.join( ', ' ) );
+		} else {
+			// Set as default date shown today
+			dp_date = new Date( ai1ec_config.now * 1000 );
+			_clear_dp = true;
+		}
+
+		$( '#widgetCalendar' ).DatePicker({
+			flat: true,
+			calendars: 3,
+			mode: 'multiple',
+			start: 1,
+			date: dp_date,
+			onChange: function( formated ) {
+				formated = formated.toString();
+				if( formated.length >= 8 ) {
+					// save the date in your hidden field
+					var exdate = '';
+					var formatted_date = [];
+					$.each( formated.split( ',' ), function( i, v ) {
+						formatted_date.push( calendrical_functions.formatDate( new Date( v ), ai1ec_config.date_format ) );
+						exdate += v.replace( /-/g, '' ) + 'T000000Z,';
+					});
+					$( '#widgetField span' ).html( formatted_date.join( ', ' ) );
+					exdate = exdate.slice( 0, exdate.length - 1 );
+					$( "#ai1ec_exdate" ).val( exdate );
+				} else {
+					$( "#ai1ec_exdate" ).val( '' );
+				}
+			}
+		});
+		if( _clear_dp ) {
+			$( '#widgetCalendar' ).DatePickerClear();
+		}
+		$( '#widgetCalendar div.datepicker' ).css( 'position', 'absolute' );
+	};
+
+	/**
+	 * Add a hook into Bootstrap collapse for accordions for proper overflow
+	 * behaviour when open.
+	 */
+	var init_collapsibles = function() {
+		$( '.accordion-body' ).on( 'hide', function() {
+			$( this ).removeClass( 'ai1ec-overflow-visible' );
+		} );
+		$( '.accordion-body' ).on( 'shown', function() {
+			var $el = $( this );
+			window.setTimeout(
+				function() { $el.addClass( 'ai1ec-overflow-visible' ); },
+				350
+			);
+		} );
+	};
+
+	/**
+	 * Perform all initialization functions required on the page.
+	 */
+	var init = function() {
+		init_date_time();
+
+		// We load gMaps here so that we can start acting on the DOM as soon as possibe.
+		// All initialization is done in the callback.
+		require( ['libs/gmaps' ], function( gMapsLoader ) {
+			gMapsLoader( gmaps_helper.init_gmaps );
+		} );
+	};
+
+	/**
+	 * Present user with error notice and prevent form submission
+	 */
+	var prevent_form_submission = function( submit_event, notice ) {
+		window.alert( notice );
+		submit_event.preventDefault();
+		// Just in case, hide the ajax spinner and remove the disabled status
+		$( '#publish, #ai1ec_bottom_publish' ).removeClass(
+			'button-primary-disabled'
+		);
+		$( '#publish, #ai1ec_bottom_publish' ).siblings(
+			'#ajax-loading, .spinner'
+		).css( 'visibility', 'hidden' );
+	};
+
+	/**
+	 * Validate the form when clicking Publish/Update.
+	 *
+	 * @param  object e jQuery event object
+	 */
+	var validate_form = function( e ) {
+		// Validate geolocation coordinates.
+		if ( input_utility_functions.ai1ec_check_lat_long_fields_filled_when_publishing_event( e ) === true ) {
+			// Convert commas to dots
+			input_utility_functions.ai1ec_convert_commas_to_dots_for_coordinates();
+			// Check that fields are ok and there are no errors
+			input_utility_functions.ai1ec_check_lat_long_ok_for_search( e );
+		}
+
+		// Validate URL fields.
+		$( '#ai1ec_ticket_url, #ai1ec_contact_url' ).each( function () {
+			var url = this.value;
+			if ( '' !== url ) {
+				var urlPattern = /(http|https):\/\//;
+				if ( ! urlPattern.test( url ) ) {
+					prevent_form_submission( e, ai1ec_config.url_not_valid );
+				}
+			}
+		} );
+	};
+
+	/**
+	 * Attach event handlers to page.
+	 */
+	var attach_event_handlers = function() {
+		// Toggle the visibility of google map on checkbox click
+		$( '#ai1ec_google_map' ).click( input_coordinates_event_handlers.toggle_visibility_of_google_map_on_click );
+		// Hide / Show the coordinates table when clicking the checkbox
+		$( '#ai1ec_input_coordinates' ).change( input_coordinates_event_handlers.toggle_visibility_of_coordinate_fields_on_click );
+		// Validate fields when clicking Publish
+		$( '#post' ).submit( validate_form );
+		// on blur, update the map if both coordinates are set
+		$( 'input.coordinates' ).blur ( input_coordinates_event_handlers.update_map_from_coordinates_on_blur );
+		// ==============================================
+		// = EVENT HANDLERS FOR EVENT DATE AND TIME BOX =
+		// ==============================================
+		// Show different fields for the "ends" clause in the modal
+		$( document ).on( 'change', '#ai1ec_end', date_time_event_handlers.show_end_fields );
+		// If the extra publish button is present handle it's click
+		$( '#ai1ec_bottom_publish' ).on( 'click', date_time_event_handlers.trigger_publish );
+		// Handle clicking on tabs when the modal is open
+		$( document ).on( 'click', '.ai1ec_tab', date_time_event_handlers.handle_click_on_tab_modal );
+		// Handle click on the Apply button of the modal
+		$( document ).on( 'click', '.ai1ec_repeat_apply', date_time_event_handlers.handle_click_on_apply_button );
+		// Handle click on the cancel button of the modal
+		$( document ).on( 'click', 'a.ai1ec_repeat_cancel', date_time_event_handlers.handle_click_on_cancel_modal );
+		// Handle click on the cancel button of the modal
+		$( document ).on( 'click', '#ai1ec_monthly_type_bymonthday, #ai1ec_monthly_type_byday', date_time_event_handlers.handle_checkbox_monthly_tab_modal );
+		// initialize showing / hiding the calendars
+		$( '#widgetField > a, #widgetField > span, #ai1ec_exclude_date_label' ).on( 'click', date_time_event_handlers.handle_animation_of_calendar_widget );
+		$( document ).on( 'click', '#ai1ec_weekly_date_select > li,#ai1ec_montly_date_select > li,#ai1ec_yearly_date_select > li', date_time_event_handlers.handle_click_on_day_month_in_modal );
+		// Attach event on the facebook export checkbox
+		$( '#ai1ec_facebook_export' ).click( facebook_export.open_modal_when_user_chooses_to_unpublish_event );
+		$( '#ai1ec_facebook_export' ).click( facebook_export.show_multi_choices_when_present );
+		$( document ).on( 'click', '#ai1ec_refresh_tokens',  facebook_export.refresh_page_tokens );
+		$( 'body' ).on( 'click', '.remove, .keep', facebook_export.add_hidden_field_when_user_click_remove_in_modal );
+		$( document ).on(
+			'change',
+			'#ai1ec_is_free',
+			event_cost.handle_change_is_free
+		);
+		// Attach pseudo handler function. These functions are kind of wrappers around other functions
+		// i left them as i found them.
+		date_time_event_handlers.execute_pseudo_handlers();
+	};
+
+	/**
+	 * Place Event Details meta box below title, rather than below description.
+	 */
+	var reposition_meta_box = function() {
+		$( '#ai1ec_event' )
+			.insertAfter( '#titlediv' );
+		$( '#post' ).addClass( 'ai1ec-visible' );
+	};
+
+	var start = function() {
+		// Initialize the page. We do this before domReady so we start loading other
+		// dependencies as soon as possible.
+		init();
+		domReady( function() {
+			init_collapsibles();
+			// Reposition event details meta box.
+			reposition_meta_box();
+			// Attach the event handlers
+			attach_event_handlers();
+		} );
+	};
+
+	return {
+		start: start
+	};
+} );
diff --git a/public/js_src/scripts/add_new_event/event_cost_helper.js b/public/js_src/scripts/add_new_event/event_cost_helper.js
new file mode 100644
index 0000000..2d1e980
--- /dev/null
+++ b/public/js_src/scripts/add_new_event/event_cost_helper.js
@@ -0,0 +1,36 @@
+define(
+	[
+		"jquery_timely",
+		"ai1ec_config"
+	],
+	function( $, ai1ec_config ) {
+		"use strict";
+
+		var is_free = function() {
+			return $( '#ai1ec_is_free' ).is( ':checked' );
+		};
+
+		var is_price_entered = function() {
+			return ( $( '#ai1ec_cost' ).val() !== '' );
+		};
+
+		var is_free_click_handler = function( evt ) {
+			var $wrap = $( this ).parents( 'table:eq(0)' );
+			var $cost = $( '#ai1ec_cost', $wrap );
+			var label = ai1ec_config.label_a_buy_tickets_url;
+			if ( is_free() ) {
+				$cost.attr( 'value', '' ).addClass( 'ai1ec-hidden' );
+				label = ai1ec_config.label_a_rsvp_url;
+			} else {
+				$cost.removeClass( 'ai1ec-hidden' );
+			}
+			$( 'label[for=ai1ec_ticket_url]', $wrap ).text( label );
+		};
+
+		return {
+			handle_change_is_free:  is_free_click_handler,
+			check_is_free:          is_free,
+			check_is_price_entered: is_price_entered
+		};
+	}
+);
diff --git a/public/js_src/scripts/add_new_event/event_date_time/date_time_event_handlers.js b/public/js_src/scripts/add_new_event/event_date_time/date_time_event_handlers.js
new file mode 100644
index 0000000..6eed6fe
--- /dev/null
+++ b/public/js_src/scripts/add_new_event/event_date_time/date_time_event_handlers.js
@@ -0,0 +1,277 @@
+define(
+		[
+		 "jquery_timely",
+		 'ai1ec_config',
+		 'scripts/add_new_event/event_date_time/date_time_utility_functions',
+		 'external_libs/jquery.calendrical_timespan',
+		 "libs/utils"
+		 ],
+		 function( $, ai1ec_config, date_time_utility_functions, calendrical_functions, AI1EC_UTILS ) {
+	"use strict"; // jshint ;_;
+	var ajaxurl = AI1EC_UTILS.get_ajax_url();
+	/**
+	 * Show/hide elements that show selectors for ending until/after events
+	 */
+	var show_end_fields = function() {
+		var selected = $( '#ai1ec_end option:selected' ).val();
+		switch( selected ) {
+			// Never selected, hide end fields
+			case '0':
+				date_time_utility_functions.hide_all_end_fields();
+				break;
+			// After selected
+			case '1':
+				if( $( '#ai1ec_count_holder' ).css( 'display' ) === 'none' ) {
+					date_time_utility_functions.hide_all_end_fields();
+					$( '#ai1ec_count_holder' ).fadeIn();
+				}
+				break;
+			// On date selected
+			case '2':
+				if( $( '#ai1ec_until_holder' ).css( 'display' ) === 'none' ) {
+					date_time_utility_functions.hide_all_end_fields();
+					$( '#ai1ec_until_holder' ).fadeIn();
+				}
+				break;
+		}
+	};
+	var trigger_publish = function() {
+		$( '#publish' ).trigger( 'click' );
+	};
+	// Handles clicks on the tabs when the modal is open
+	var handle_click_on_tab_modal = function( e ) {
+		if( ! $( this ).hasClass( 'ai1ec_active' ) ) {
+			var $active_tab = $( '.ai1ec_repeat_tabs > li > a.ai1ec_active' );
+			var $active_content = $( $active_tab.attr( 'href' ) );
+
+			var $becoming_active = $( $( this ).attr( 'href' ) );
+
+			$active_tab.removeClass( 'ai1ec_active' );
+			$active_content.hide();
+
+			$( this ).addClass( 'ai1ec_active' );
+			$becoming_active.append( $( '#ai1ec_repeat_tab_append' ) );
+			$( '#ai1ec_ending_box' ).show();
+			$becoming_active.show();
+		}
+		return false;
+	};
+	// Handle click on the Apply button
+	var handle_click_on_apply_button = function( e ) {
+		var $button = $( this );
+		var rule = '';
+		var $active_tab = $( $( '.ai1ec_active' ).attr( 'href' ) );
+		var frequency = $active_tab.attr( 'title' );
+		switch( frequency ) {
+			case 'daily':
+				rule += 'FREQ=DAILY;';
+				var interval_day = $( '#ai1ec_daily_count' ).val();
+				if( interval_day > 1 ) {
+					rule += 'INTERVAL=' + interval_day + ';';
+				}
+				break;
+			case 'weekly':
+				rule += 'FREQ=WEEKLY;';
+				var interval_week = $( '#ai1ec_weekly_count' ).val();
+				if( interval_week > 1 ) {
+					rule += 'INTERVAL=' + interval_week + ';';
+				}
+				var week_days = $( 'input[name="ai1ec_weekly_date_select"]:first' ).val();
+				var wkst = $( '#ai1ec_weekly_date_select > li:first > input[type="hidden"]:first' ).val();
+				if( week_days.length > 0 ) {
+					rule += 'WKST=' + wkst + ';BYday=' + week_days + ';';
+				}
+				break;
+			case 'monthly':
+				rule += 'FREQ=MONTHLY;';
+				var interval_month  = $( '#ai1ec_monthly_count' ).val();
+				var monthtype = $( 'input[name="ai1ec_monthly_type"]:checked' ).val();
+				if( interval_month > 1 ) {
+					rule += 'INTERVAL=' + interval_month + ';';
+				}
+				var month_days = $( 'input[name="ai1ec_montly_date_select"]:first' ).val();
+				if( month_days.length > 0 && monthtype === 'bymonthday' ) {
+					rule += 'BYMONTHDAY=' + month_days + ';';
+				} else if ( monthtype === 'byday' ) {
+					var byday_num     = $( '#ai1ec_monthly_byday_num' ).val();
+					var byday_weekday = $( '#ai1ec_monthly_byday_weekday' ).val();
+					rule += 'BYday=' + byday_num + byday_weekday + ';';
+				}
+				break;
+			case 'yearly':
+				rule += 'FREQ=YEARLY;';
+				var interval_year = $( '#ai1ec_yearly_count' ).val();
+				if( interval_year > 1 ) {
+					rule += 'INTERVAL=' + interval_year + ';';
+				}
+				var months = $( 'input[name="ai1ec_yearly_date_select"]:first' ).val();
+				if( months.length > 0 ) {
+					rule += 'BYMONTH=' + months + ';';
+				}
+				break;
+		}
+
+		var ending = $( '#ai1ec_end' ).val();
+		// After
+		if( ending === '1' ) {
+			rule += 'COUNT=' + $( '#ai1ec_count' ).val() + ';';
+		}
+		// On Date
+		if( ending === '2' ) {
+			var until = calendrical_functions.parseDate( $( '#ai1ec_until-date-input' ).val(), ai1ec_config.date_format );
+
+
+			// Take the starting date to set hour and minute
+			var start = new Date( calendrical_functions.parseDate( $( '#ai1ec_start-time' ).val(), ai1ec_config.date_format ) );
+			// Get UTC Day and UTC Month, and then add leading zeroes if required
+			var d     = until.getUTCDate();
+			var m     = until.getUTCMonth() + 1;
+			var hh    = start.getUTCHours();
+			var mm    = start.getUTCMinutes();
+
+			// months
+			m         = ( m < 10 )  ? '0' + m  : m;
+			// days
+			d         = ( d < 10 )  ? '0' + d  : d;
+			// hours
+			hh        = ( hh < 10 ) ? '0' + hh : hh;
+			// minutes
+			mm        = ( mm < 10 ) ? '0' + mm : mm;
+			// Now, set the UTC friendly date string
+			until     = until.getUTCFullYear() + '' + m + d + 'T235959Z';
+			rule += 'UNTIL=' + until + ';';
+		}
+
+		var data = {
+			action       : 'ai1ec_rrule_to_text',
+			rrule        :  rule
+		};
+
+		$( this ).attr( 'disabled', true );
+		$.post(
+			ajaxurl,
+			data,
+			function( response ) {
+				if( response.error ) {
+					if( $( '#ai1ec_is_box_repeat' ).val() === '1' ) {
+						date_time_utility_functions.ai1ec_repeat_form_error( '#ai1ec_rrule', '#ai1ec_repeat_label', response, $button );
+					} else {
+						date_time_utility_functions.ai1ec_repeat_form_error( '#ai1ec_exrule', '#ai1ec_exclude_label', response, $button );
+					}
+				} else {
+					if( $( '#ai1ec_is_box_repeat' ).val() === '1' ) {
+						date_time_utility_functions.ai1ec_repeat_form_success( '#ai1ec_rrule', '#ai1ec_repeat_label', '#ai1ec_repeat_text > a', rule, $button, response );
+					} else {
+						date_time_utility_functions.ai1ec_repeat_form_success( '#ai1ec_exrule', '#ai1ec_exclude_label', '#ai1ec_exclude_text > a', rule, $button, response );
+					}
+				}
+			},
+			'json'
+		);
+	};
+	// Handle clicking on cancel button
+	var handle_click_on_cancel_modal = function( e ) {
+		if( $( '#ai1ec_is_box_repeat' ).val() === '1' ) {
+			// handles click on cancel for RRULE
+			date_time_utility_functions.ai1ec_click_on_modal_cancel( '#ai1ec_repeat_text > a', '#ai1ec_repeat', '#ai1ec_repeat_label' );
+		} else {
+			// handles click on cancel for EXRULE
+			date_time_utility_functions.ai1ec_click_on_modal_cancel( '#ai1ec_exclude_text > a', '#ai1ec_exclude', '#ai1ec_exclude_label' );
+		}
+		$.unblockUI();
+		return false;
+	};
+	// Handle clicking on the two checkboxes in the monthly tab
+	var handle_checkbox_monthly_tab_modal = function( e ) {
+		$( '#ai1c_repeat_monthly_bymonthday' ).toggle();
+		$( '#ai1c_repeat_monthly_byday' ).toggle();
+	};
+	var handle_click_on_day_month_in_modal = function( e ) {
+		var $this = $( e.target );
+		if( $this.hasClass( 'ai1ec_selected' ) ) {
+			$this.removeClass( 'ai1ec_selected' );
+		} else {
+			$this.addClass( 'ai1ec_selected' );
+		}
+		var data = [];
+		var $ul = $this.closest( 'ul' );
+		$( 'li', $ul ).each( function( i, el ) {
+			if( $( el ).hasClass( 'ai1ec_selected' ) ) {
+				var value = $( el ).children( 'input[type="hidden"]:first' ).val();
+				data.push( value );
+			}
+		});
+		$ul.next().val( data.join() );
+	};
+	// This are pseudo handlers, they might require a refactoring sooner or later
+	var execute_pseudo_handlers = function() {
+		// handles click on rrule text
+		date_time_utility_functions.ai1ec_click_on_ics_rule_text(
+			'#ai1ec_repeat_text > a',
+			'#ai1ec_repeat',
+			'#ai1ec_repeat_label',
+			{
+				action: 'ai1ec_get_repeat_box',
+				repeat: 1,
+				post_id: $( '#post_ID' ).val()
+			},
+			date_time_utility_functions.ai1ec_apply_js_on_repeat_block
+		);
+		// handles click on exrule text
+		date_time_utility_functions.ai1ec_click_on_ics_rule_text(
+			'#ai1ec_exclude_text > a',
+			'#ai1ec_exclude',
+			'#ai1ec_exclude_label',
+			{
+				action: 'ai1ec_get_repeat_box',
+				repeat: 0,
+				post_id: $( '#post_ID' ).val()
+			},
+			date_time_utility_functions.ai1ec_apply_js_on_repeat_block
+		);
+
+		// handles click on repeat checkbox
+		date_time_utility_functions.ai1ec_click_on_checkbox(
+			'#ai1ec_repeat',
+			'#ai1ec_repeat_text > a',
+			'#ai1ec_repeat_label',
+			{
+				action: 'ai1ec_get_repeat_box',
+				repeat: 1,
+				post_id: $( '#post_ID' ).val()
+			},
+			date_time_utility_functions.ai1ec_apply_js_on_repeat_block
+		);
+
+		// handles click on exclude checkbox
+		date_time_utility_functions.ai1ec_click_on_checkbox(
+			'#ai1ec_exclude',
+			'#ai1ec_exclude_text > a',
+			'#ai1ec_exclude_label',
+			{
+				action: 'ai1ec_get_repeat_box',
+				repeat: 0,
+				post_id: $( '#post_ID' ).val()
+			},
+			date_time_utility_functions.ai1ec_apply_js_on_repeat_block
+		);
+	};
+	var handle_animation_of_calendar_widget = function( e ) {
+		// On the first run it will be undefined, so we set it to false
+		var state = $( this ).data( 'state' ) === undefined ? false : $( this ).data( 'state' );
+		$('#widgetCalendar').stop().animate( { height: state ? 0 : $( '#widgetCalendar div.datepicker' ).get( 0 ).offsetHeight }, 500 );
+		$( this ).data( 'state', ! state );
+		return false;
+	};
+	return {
+		show_end_fields                     : show_end_fields,
+		trigger_publish                     : trigger_publish,
+		handle_click_on_tab_modal           : handle_click_on_tab_modal,
+		handle_click_on_apply_button        : handle_click_on_apply_button,
+		handle_click_on_cancel_modal        : handle_click_on_cancel_modal,
+		handle_checkbox_monthly_tab_modal   : handle_checkbox_monthly_tab_modal,
+		execute_pseudo_handlers             : execute_pseudo_handlers,
+		handle_animation_of_calendar_widget : handle_animation_of_calendar_widget,
+		handle_click_on_day_month_in_modal  : handle_click_on_day_month_in_modal
+	};
+} );
\ No newline at end of file
diff --git a/public/js_src/scripts/add_new_event/event_date_time/date_time_utility_functions.js b/public/js_src/scripts/add_new_event/event_date_time/date_time_utility_functions.js
new file mode 100644
index 0000000..8724dce
--- /dev/null
+++ b/public/js_src/scripts/add_new_event/event_date_time/date_time_utility_functions.js
@@ -0,0 +1,164 @@
+define(
+		[
+		 "jquery_timely",
+		 "ai1ec_config",
+		 "libs/utils"
+		 ],
+		 function( $, ai1ec_config, AI1EC_UTILS ) {
+	"use strict"; // jshint ;_;
+	var ajaxurl = AI1EC_UTILS.get_ajax_url();
+
+	var hide_all_end_fields = function() {
+		$( '#ai1ec_count_holder, #ai1ec_until_holder' ).hide();
+	};
+
+	var ai1ec_repeat_form_success = function( s1, s2, s3, rule, button, response ) {
+		$( s1 ).val( rule );
+		$.unblockUI();
+		var txt = $.trim( $( s2 ).text() );
+		if( txt.lastIndexOf( ':' ) === -1 ) {
+			txt = txt.substring( 0, txt.length - 3 );
+			$( s2 ).text( txt + ':' );
+		}
+		$(button).attr( 'disabled', false );
+		$( s3 ).fadeOut( 'fast', function() {
+			$( this ).text( response.message );
+			$( this ).fadeIn( 'fast' );
+		});
+	};
+
+	var ai1ec_repeat_form_error = function( s1, s2, response, button ) {
+		$.growlUI( 'Error', response.message );
+		$( button ).attr( 'disabled', false );
+		$( s1 ).val( '' );
+		var txt = $.trim( $( s2 ).text() );
+		if( txt.lastIndexOf( '...' ) === -1 ) {
+			txt = txt.substring( 0, txt.length - 1 );
+			$( s2 ).text( txt + '...' );
+		}
+		// If there is no text, uncheck the checkbox, otherwise keep it as the provious rule is still valid.
+		if( $( this ).closest( 'tr' ).find( '.ai1ec_rule_text' ).text() === '' ) {
+			$( s1 ).siblings( 'input:checkbox' ).removeAttr( 'checked' );
+		}
+	};
+
+	var ai1ec_click_on_ics_rule_text = function( s1, s2, s3, data, fn ) {
+		$( document ).on( 'click', s1, function() {
+			if( ! $( s2 ).is( ':checked' ) ) {
+				$( s2 ).attr( 'checked', true );
+				var txt = $.trim( $( s3 ).text() );
+				txt = txt.substring( 0, txt.length - 3 );
+				$( s3 ).text( txt + ':' );
+			}
+			ai1ec_show_repeat_tabs( data, fn );
+			return false;
+		});
+	};
+
+	var ai1ec_click_on_checkbox = function( s1, s2, s3, data, fn ) {
+		$( s1 ).click( function() {
+			if( $(this).is( ':checked' ) ) {
+				if( this.id === 'ai1ec_repeat' ) {
+					$( '#ai1ec_exclude' ).removeAttr( 'disabled' );
+				};
+				ai1ec_show_repeat_tabs( data, fn );
+			} else {
+				if( this.id === 'ai1ec_repeat' ) {
+					$( '#ai1ec_exclude' ).attr( 'disabled', true );
+				};
+				$( s2 ).text( '' );
+				var txt = $.trim( $( s3 ).text() );
+				txt = txt.substring( 0, txt.length - 1 );
+				$( s3 ).text( txt + '...' );
+			}
+		});
+	};
+
+	var ai1ec_click_on_modal_cancel = function( s1, s2, s3 ) {
+		if( $.trim( $( s1 ).text() ) === '' ) {
+			$( s2 ).removeAttr( 'checked' );
+			if( ! $( '#ai1ec_repeat' ).is( ':checked' ) ) {
+				$( '#ai1ec_exclude' ).attr( 'disabled', true );
+			}
+			var txt = $.trim( $( s3 ).text() );
+			if( txt.lastIndexOf( '...' ) === -1 ) {
+				txt = txt.substring( 0, txt.length - 1 );
+				$( s3 ).text( txt + '...' );
+			}
+		}
+	};
+
+	// called after the repeat block is inserted in the DOM
+	var ai1ec_apply_js_on_repeat_block = function() {
+		// Initialize count range slider
+		$( '#ai1ec_count, #ai1ec_daily_count, #ai1ec_weekly_count, #ai1ec_monthly_count, #ai1ec_yearly_count' ).rangeinput( {
+			css: {
+				input: 'ai1ec-range',
+				slider: 'ai1ec-slider',
+				progress: 'ai1ec-progress',
+				handle: 'ai1ec-handle'
+			}
+		} );
+		// Initialize inputdate plugin on our "until" date input.
+		var data = {
+			start_date_input : '#ai1ec_until-date-input',
+			start_time       : '#ai1ec_until-time',
+			date_format      : ai1ec_config.date_format,
+			month_names      : ai1ec_config.month_names,
+			day_names        : ai1ec_config.day_names,
+			week_start_day   : ai1ec_config.week_start_day,
+			twentyfour_hour  : ai1ec_config.twentyfour_hour,
+			now              : new Date( ai1ec_config.now * 1000 )
+		};
+		$.inputdate( data );
+	};
+
+	var ai1ec_show_repeat_tabs = function( data, post_ajax_func ) {
+		$.blockUI( {
+			message: '<div class="ai1ec-repeat-box-loading"></div>',
+			css: {
+				width: '358px',
+				border: '0',
+				background: 'transparent',
+				cursor: 'normal'
+			}
+		} );
+		$.post(
+			ajaxurl,
+			data,
+			function( response ) {
+				if( response.error ) {
+					// tell the user there is an error
+					// TODO: Use other method of notification
+					window.alert( response.message );
+					$.unblockUI();
+				} else {
+					// display the form
+					$.blockUI( {
+						message: response.message,
+						css: {
+							width: '358px',
+							border: '0',
+							background: 'transparent',
+							cursor: 'normal'
+						}
+					});
+					if( typeof post_ajax_func === 'function' ) {
+						post_ajax_func();
+					}
+				}
+			},
+			'json'
+		);
+	};
+	return {
+		ai1ec_show_repeat_tabs         : ai1ec_show_repeat_tabs,
+		ai1ec_apply_js_on_repeat_block : ai1ec_apply_js_on_repeat_block,
+		ai1ec_click_on_modal_cancel    : ai1ec_click_on_modal_cancel,
+		ai1ec_click_on_checkbox        : ai1ec_click_on_checkbox,
+		ai1ec_click_on_ics_rule_text   : ai1ec_click_on_ics_rule_text,
+		ai1ec_repeat_form_error        : ai1ec_repeat_form_error,
+		ai1ec_repeat_form_success      : ai1ec_repeat_form_success,
+		hide_all_end_fields            : hide_all_end_fields
+	};
+		} );
diff --git a/public/js_src/scripts/add_new_event/event_location/gmaps_helper.js b/public/js_src/scripts/add_new_event/event_location/gmaps_helper.js
new file mode 100644
index 0000000..3045d5d
--- /dev/null
+++ b/public/js_src/scripts/add_new_event/event_location/gmaps_helper.js
@@ -0,0 +1,248 @@
+define(
+		[
+		 "jquery_timely",
+		 'domReady',
+		 'ai1ec_config',
+		 'scripts/add_new_event/event_location/input_coordinates_utility_functions',
+		 'external_libs/jquery.autocomplete_geomod',
+		 'external_libs/geo_autocomplete'
+		 ],
+		function( $, domReady, ai1ec_config, input_utility_functions ) {
+	"use strict"; // jshint ;_;
+	// Local Variables (killing those would be even better)
+	var ai1ec_geocoder,
+	    ai1ec_default_location,
+	    ai1ec_myOptions,
+	    ai1ec_map,
+	    ai1ec_marker,
+	    ai1ec_position;
+
+	var gmap_event_listener = function( e ) {
+		$( 'input.longitude' ).val( e.latLng.lng() );
+		$( 'input.latitude' ).val( e.latLng.lat() );
+		// If the checkbox to input coordinates is not checked, trigger the click event on it.
+		if( $( '#ai1ec_input_coordinates:checked' ).length === 0 ) {
+			$( '#ai1ec_input_coordinates' ).trigger( 'click' );
+		}
+	};
+	var set_position_with_geolocator_if_available = function() {
+		// Check if browser supports W3C Geolocation API. Use !! to have a boolean that reflect the truthiness of the original value.
+		if ( !! navigator.geolocation ) {
+			// Ask the user for his position. If the User denies it or if anything else goes wrong, we just fail silently and keep using our default.
+			navigator.geolocation.getCurrentPosition( function( position ) {
+				// The callback takes some time bofore it's called, we need to be sure to set the starting position only when no previous position was set.
+				// So we check if the coordinates or the address have been set.
+				var address_or_coordinates_set = input_utility_functions.check_if_address_or_coordinates_are_set();
+				// If they have not been set, we use geolocation data.
+				if ( address_or_coordinates_set === false ) {
+					var lat = position.coords.latitude;
+					var long = position.coords.longitude;
+					// Update default location.
+					ai1ec_default_location = new google.maps.LatLng( lat, long );
+					// Set the marker position.
+					ai1ec_marker.setPosition( ai1ec_default_location );
+					// Center the Map and adjust the zoom level.
+					ai1ec_map.setCenter( ai1ec_default_location );
+					ai1ec_map.setZoom( 15 );
+					ai1ec_position = position;
+				}
+			} );
+		}
+	};
+	var set_autocomplete_if_needed = function() {
+		if( ! ai1ec_config.disable_autocompletion ) {
+			// This is the only way to stop the autocomplete from firing when the
+			// coordinates checkbox is checked. The new jQuery UI autocomplete
+			// supports the method .autocomplete( "disable" ) but not this version.
+			$( '#ai1ec_address' )
+				.bind( "keypress keyup keydown change", function( e ) {
+					if( $( '#ai1ec_input_coordinates:checked' ).length ) {
+						e.stopImmediatePropagation();
+					}
+				})
+				// Initialize geo_autocomplete plugin
+				.geo_autocomplete(
+					new google.maps.Geocoder(),
+					{
+						selectFirst: false,
+						minChars: 3,
+						cacheLength: 50,
+						width: 300,
+						scroll: true,
+						scrollHeight: 330,
+						region: ai1ec_config.region
+					}
+				)
+				.result(
+					function( _event, _data ) {
+						if( _data ) {
+							ai1ec_update_address( _data );
+						}
+					}
+				)
+				// Each time user changes address field, reformat field and update map.
+				.change(
+					function() {
+						// Position map based on provided address value
+						if( $( this ).val().length > 0 ) {
+							var address = $( this ).val();
+
+							ai1ec_geocoder.geocode(
+								{
+									'address': address,
+									'region': ai1ec_config.region
+								},
+								function( results, status ) {
+									if( status === google.maps.GeocoderStatus.OK ) {
+										ai1ec_update_address( results[0] );
+									}
+								}
+							);
+						}
+					}
+				);
+		}
+	};
+	var init_gmaps = function() {
+		/**
+		 * Google map setup
+		 */
+		// If the user is updating an event, initialize the map to the event
+		// location, otherwise if the user is creating a new event initialize
+		// the map to the whole world
+		ai1ec_geocoder = new google.maps.Geocoder();
+		//world = map.setCenter(new GLatLng(9.965, -83.327), 1);
+		//africa = map.setCenter(new GLatLng(-3, 27), 3);
+		//europe = map.setCenter(new GLatLng(47, 19), 3);
+		//asia = map.setCenter(new GLatLng(32, 130), 3);
+		//south pacific = map.setCenter(new GLatLng(-24, 134), 3);
+		//north america = map.setCenter(new GLatLng(50, -114), 3);
+		//latin america = map.setCenter(new GLatLng(-20, -70), 3);
+		ai1ec_default_location = new google.maps.LatLng( 9.965, -83.327 );
+		ai1ec_myOptions = {
+			zoom: 0,
+			mapTypeId: google.maps.MapTypeId.ROADMAP,
+			center: ai1ec_default_location
+		};
+		domReady( function() {
+			// This is mainly for testing purpose but it makes sense in any case, start the work only if there is a container
+			if( $( '#ai1ec_map_canvas' ).length > 0 ) {
+				// initialize map
+				ai1ec_map = new google.maps.Map( $( '#ai1ec_map_canvas' ).get(0), ai1ec_myOptions );
+				// Initialize Marker
+				ai1ec_marker = new google.maps.Marker({
+					map: ai1ec_map,
+					draggable: true
+				});
+				// When the marker is dropped, update the latitude and longitude fields.
+				google.maps.event.addListener( ai1ec_marker, 'dragend', gmap_event_listener );
+				ai1ec_marker.setPosition( ai1ec_default_location );
+				// If the browser supports geolocation, use it
+				set_position_with_geolocator_if_available();
+				// Start the autocompleter if the user decided to use it
+				set_autocomplete_if_needed();
+				// Set the map location and show / hide the coordinates
+				init_coordinates_visibility();
+			}
+		} );
+
+	};
+	/**
+	 * Given a location, update the address field with a reformatted version,
+	 * update hidden location fields with address data, and center map on
+	 * new location.
+	 *
+	 * @param object result  single result of a Google geocode() call
+	 */
+	var ai1ec_update_address = function( result ) {
+		ai1ec_map.setCenter( result.geometry.location );
+		ai1ec_map.setZoom( 15 );
+		ai1ec_marker.setPosition( result.geometry.location );
+		$( '#ai1ec_address' ).val( result.formatted_address );
+		$( '#ai1ec_latitude' ).val( result.geometry.location.lat() );
+		$( '#ai1ec_longitude' ).val( result.geometry.location.lng() );
+		// check the checkbox if not checked, we want to store the lat/lng data
+		if( ! $( '#ai1ec_input_coordinates' ).is( ':checked' ) ) {
+			$( '#ai1ec_input_coordinates' ).click();
+		}
+		
+
+		var street_number = '',
+					street_name = '',
+					city = '',
+					postal_code = 0,
+					country = 0,
+					province = '';
+
+		for( var i = 0; i < result.address_components.length; i++ ) {
+			switch( result.address_components[i].types[0] ) {
+				case 'street_number':
+					street_number = result.address_components[i].long_name;
+					break;
+				case 'route':
+					street_name = result.address_components[i].long_name;
+					break;
+				case 'locality':
+					city = result.address_components[i].long_name;
+					break;
+				case 'administrative_area_level_1':
+					province = result.address_components[i].long_name;
+					break;
+				case 'postal_code':
+					postal_code = result.address_components[i].long_name;
+					break;
+				case 'country':
+					country = result.address_components[i].long_name;
+					break;
+			}
+		}
+		// Combine street number with street address
+		var address = street_number.length > 0 ? street_number + ' ' : '';
+		address += street_name.length > 0 ? street_name : '';
+		// Clean up postal code if necessary
+		postal_code = postal_code !== 0 ? postal_code : '';
+
+		$( '#ai1ec_city' ).val( city );
+		$( '#ai1ec_province' ).val( province );
+		$( '#ai1ec_postal_code' ).val( postal_code );
+		$( '#ai1ec_country' ).val( country );
+	};
+	/**
+	 * Updates the map taking the coordinates from the input fields
+	 */
+	var ai1ec_update_map_from_coordinates = function() {
+		var lat = parseFloat( $( 'input.latitude' ).val() );
+		var long = parseFloat( $( 'input.longitude' ).val() );
+		var LatLong = new google.maps.LatLng( lat, long );
+
+		ai1ec_map.setCenter( LatLong );
+		ai1ec_map.setZoom( 15 );
+		ai1ec_marker.setPosition( LatLong );
+	};
+	var init_coordinates_visibility = function() {
+		// If the coordinates checkbox is not checked
+		if( $( '#ai1ec_input_coordinates:checked' ).length === 0 ) {
+			// Hide the table (i hide things in js for progressive enhancement reasons)
+			$( '#ai1ec_table_coordinates' ).css( { visibility : 'hidden' } );
+			// Trigger the change event on the address to show the map
+			$( '#ai1ec_address' ).change();
+		} else {
+			// If the checkbox is checked, show the map using the coordinates
+			ai1ec_update_map_from_coordinates();
+		}
+	};
+	// This allows another function to access the marker ( if the marker is set ). I mainly use this for testing.
+	var get_marker = function() {
+		return ai1ec_marker;
+	};
+	// This allows another function to access the position ( if the position is set ). I mainly use this for testing.
+	var get_position = function() {
+		return ai1ec_position;
+	};
+	return {
+		init_gmaps                        : init_gmaps,
+		ai1ec_update_map_from_coordinates : ai1ec_update_map_from_coordinates,
+		get_marker                        : get_marker,
+		get_position                      : get_position
+	};
+} );
diff --git a/public/js_src/scripts/add_new_event/event_location/input_coordinates_event_handlers.js b/public/js_src/scripts/add_new_event/event_location/input_coordinates_event_handlers.js
new file mode 100644
index 0000000..8e3fe8c
--- /dev/null
+++ b/public/js_src/scripts/add_new_event/event_location/input_coordinates_event_handlers.js
@@ -0,0 +1,56 @@
+define(
+	[
+		"jquery_timely",
+		"scripts/add_new_event/event_location/input_coordinates_utility_functions",
+		"scripts/add_new_event/event_location/gmaps_helper",
+		"ai1ec_config"
+	],
+	function( $, input_utility_functions, gmaps_helper, ai1ec_config ) {
+	"use strict"; // jshint ;_;
+
+	// Toggle the visibility of google map on checkbox click
+	var toggle_visibility_of_google_map_on_click = function( e ) {
+		if( $( this ).is( ':checked' ) ) {
+			// show the map
+			$( '.ai1ec_box_map' )
+				.addClass( 'ai1ec_box_map_visible')
+				.hide()
+				.slideDown( 'fast' );
+		} else {
+			// hide the map
+			$( '.ai1ec_box_map' ).slideUp( 'fast' );
+		}
+	};
+
+	// Hide / Show the coordinates table when clicking the checkbox
+	var toggle_visibility_of_coordinate_fields_on_click = function( e ) {
+		// If the checkbox is checked
+		if( this.checked === true ) {
+			$( '#ai1ec_table_coordinates' ).css( { visibility : 'visible' } );
+		} else {
+			// Hide the table
+			$( '#ai1ec_table_coordinates' ).css( { visibility : 'hidden' } );
+			// Erase the input fields
+			$( '#ai1ec_table_coordinates input' ).val( '' );
+			// Clean up error messages
+			$( 'div.ai1ec-error' ).remove();
+		}
+	};
+
+	var update_map_from_coordinates_on_blur = function( e ) {
+		// Convert commas to dots
+		input_utility_functions.ai1ec_convert_commas_to_dots_for_coordinates();
+		// Check if the coordinates are valid.
+		var valid = input_utility_functions.ai1ec_check_lat_long_ok_for_search( e );
+		// If they are valid, update the map.
+		if( valid === true ) {
+			gmaps_helper.ai1ec_update_map_from_coordinates();
+		}
+	};
+
+	return {
+		"toggle_visibility_of_google_map_on_click"        : toggle_visibility_of_google_map_on_click,
+		"toggle_visibility_of_coordinate_fields_on_click" : toggle_visibility_of_coordinate_fields_on_click,
+		"update_map_from_coordinates_on_blur"             : update_map_from_coordinates_on_blur
+	};
+} );
diff --git a/public/js_src/scripts/add_new_event/event_location/input_coordinates_utility_functions.js b/public/js_src/scripts/add_new_event/event_location/input_coordinates_utility_functions.js
new file mode 100644
index 0000000..00b4e24
--- /dev/null
+++ b/public/js_src/scripts/add_new_event/event_location/input_coordinates_utility_functions.js
@@ -0,0 +1,170 @@
+define(
+		[
+		 "jquery_timely",
+		 "ai1ec_config",
+		 "libs/utils"
+		 ],
+		 function( $, ai1ec_config, AI1EC_UTILS ) {
+	"use strict"; // jshint ;_;
+			/**
+			 *
+			 * converts commas to dots as in some regions (Europe for example) floating point numbers are defined with a comma instead of a dot
+			 *
+			 */
+			var ai1ec_convert_commas_to_dots_for_coordinates = function() {
+				if ( $( '#ai1ec_input_coordinates:checked' ).length > 0 ) {
+					$( '#ai1ec_table_coordinates input.coordinates' ).each( function() {
+						this.value = AI1EC_UTILS.convert_comma_to_dot( this.value );
+					} );
+				}
+			};
+			/**
+			 * Shows the error message after the field
+			 *
+			 * @param Object the dom element after which we put the error
+			 *
+			 * @param the error message
+			 *
+			 */
+			var ai1ec_show_error_message_after_element = function( el, error_message ) {
+				// Create the element to append in case of error
+				var error = $( '<div />',
+						{
+							"text" : error_message,
+							"class" : "ai1ec-error"
+						}
+				);
+				// Insert error message
+				$( el ).after( error );
+			};
+			/**
+			 * INTERNAL FUNCTION (not exported)
+			 * prevent default actions and stop immediate propagation if the publish button was clicked and
+			 * gives focus to the passed element
+			 *
+			 * @param Object the event object
+			 *
+			 * @param Object the element to focus
+			 *
+			 */
+			var ai1ec_prevent_actions_and_focus_on_errors = function( e, el ) {
+				// If the validation was triggered  by clicking publish
+				if ( e.target.id === 'post' ) {
+					// Prevent other events from firing
+					e.stopImmediatePropagation();
+					// Prevent the submit
+					e.preventDefault();
+					// Just in case, hide the ajax spinner and remove the disabled status
+					$( '#publish' ).removeClass( 'button-primary-disabled' );
+					$( '#publish' ).siblings( '.spinner' ).css( 'visibility', 'hidden' );
+					
+				}
+				// Focus on the first field that has an error
+				$( el ).focus();
+			};
+			/**
+			 * Check if either the coordinates or the address are set
+			 *
+			 * @returns boolean true if at least one is set between the address and both coordinates
+			 */
+			var check_if_address_or_coordinates_are_set = function() {
+				var address_set = AI1EC_UTILS.field_has_value( 'ai1ec_address' );
+				var lat_long_set = true;
+				$( '.coordinates' ).each( function() {
+					var is_set = AI1EC_UTILS.field_has_value( this.id );
+					if ( ! is_set ) {
+						lat_long_set = false;
+					}
+				} );
+				return address_set || lat_long_set;
+			};
+			/**
+			 * check that both latitude and longitude are not empty when publishing an event if the "Input coordinates" check-box
+			 * is checked
+			 *
+			 * @param Object the event object
+			 *
+			 * @returns boolean true if the check is ok, false otherwise
+			 *
+			 */
+			var ai1ec_check_lat_long_fields_filled_when_publishing_event = function( e ) {
+				var valid = true;
+				// We will save the first non valid field in this variable so whe can focus
+				var first_not_valid = false;
+				if ( $( '#ai1ec_input_coordinates:checked' ).length > 0 ) {
+					// Clean up old error messages
+					$( 'div.ai1ec-error' ).remove();
+					$( '#ai1ec_table_coordinates input.coordinates' ).each( function() {
+						// Check if we are validating latitude or longitude
+						var latitude = $( this ).hasClass( 'latitude' );
+						// Get the correct error message
+						var error_message = latitude ? ai1ec_config.error_message_not_entered_lat : ai1ec_config.error_message_not_entered_long;
+						if ( this.value === '' ) {
+							valid = false;
+							if( first_not_valid === false ) {
+								first_not_valid = this;
+							}
+							ai1ec_show_error_message_after_element( this, error_message );
+						}
+					});
+				}
+				if ( valid === false ) {
+					ai1ec_prevent_actions_and_focus_on_errors( e, first_not_valid );
+				}
+				return valid;
+			};
+			/**
+			 * checks if latitude and longitude fields are valid and a search can be performed
+			 *
+			 * @param Object the event object that is passed to the handler function
+			 *
+			 * @return boolean true if the values are valid and both fields have a value, false otherwise;
+			 */
+			var ai1ec_check_lat_long_ok_for_search = function( e ) {
+				// If the coordinates checkbox is checked
+				if ( $( '#ai1ec_input_coordinates:checked' ).length === 1 ) {
+					// Clean up old error messages
+					$( 'div.ai1ec-error' ).remove();
+					var valid = true;
+					// We will save the first non valid field in this variable so whe can focus
+					var first_not_valid = false;
+					// If a field is empty, we will return false so that the map is not updated.
+					var at_least_one_field_empty = false;
+					// Let's iterate over the coordinates.
+					$( '#ai1ec_table_coordinates input.coordinates' ).each( function() {
+						if ( this.value === '' ) {
+							at_least_one_field_empty = true;
+							return;
+						}
+						// Check if we are validating latitude or longitude
+						var latitude = $( this ).hasClass( 'latitude' );
+						// Get the correct error message
+						var error_message = latitude ? ai1ec_config.error_message_not_valid_lat : ai1ec_config.error_message_not_valid_long;
+						// Check if the coordinate is valid.
+						if( ! AI1EC_UTILS.is_valid_coordinate( this.value, latitude ) ) {
+							valid = false;
+							// Save the elements so that we can focus later
+							if ( first_not_valid === false ) {
+								first_not_valid = this;
+							}
+							ai1ec_show_error_message_after_element( this, error_message );
+						}
+					});
+					// Check if there are errors
+					if ( valid === false ) {
+						ai1ec_prevent_actions_and_focus_on_errors( e, first_not_valid );
+					}
+					if ( at_least_one_field_empty === true ) {
+						valid = false;
+					}
+					return valid;
+				}
+			};
+			return {
+				ai1ec_convert_commas_to_dots_for_coordinates             : ai1ec_convert_commas_to_dots_for_coordinates,
+				ai1ec_show_error_message_after_element                   : ai1ec_show_error_message_after_element,
+				check_if_address_or_coordinates_are_set                  : check_if_address_or_coordinates_are_set,
+				ai1ec_check_lat_long_fields_filled_when_publishing_event : ai1ec_check_lat_long_fields_filled_when_publishing_event,
+				ai1ec_check_lat_long_ok_for_search                       : ai1ec_check_lat_long_ok_for_search
+			};
+} );
\ No newline at end of file
diff --git a/public/js_src/scripts/add_new_event/facebook_export.js b/public/js_src/scripts/add_new_event/facebook_export.js
new file mode 100644
index 0000000..569206b
--- /dev/null
+++ b/public/js_src/scripts/add_new_event/facebook_export.js
@@ -0,0 +1,80 @@
+define(
+	[
+		"jquery_timely",
+		"libs/modal_helper"
+	],
+	function( $ ) {
+	"use strict";
+
+	var open_modal_when_user_chooses_to_unpublish_event = function( e ) {
+		if( ! $( this ).is( ':checked' ) && $( '#ai1ec-facebook-export-modal' ).length ) {
+			$( '#ai1ec-facebook-export-modal' ).modal( {
+				"show": true,
+				"backdrop" : 'static'
+			} );
+		} else {
+			// Remove th hidden input if present
+			$( '#ai1ec-remove-event-hidden' ).remove();
+		}
+	};
+	var add_hidden_field_when_user_click_remove_in_modal = function() {
+		$( '#ai1ec-facebook-export-modal' ).modal( 'hide' );
+		if( $( this ).hasClass( 'remove' ) ) {
+			var $input = $( '<input />', {
+				type  : "hidden",
+				name  : "ai1ec-remove-event",
+				value : 1,
+				id    : "ai1ec-remove-event-hidden"
+			} );
+			$( '#ai1ec-facebook-publish' ).append( $input );
+		}
+	};
+	var refresh_page_tokens = function( e ) {
+		e.preventDefault();
+		var data = {
+				"action"     : 'ai1ec_refresh_tokens'
+			};
+		$.post(
+			ajaxurl,
+			data,
+			function( data ) {
+				var $facebook = $( e.target ).closest( '#ai1ec-facebook-publish' );
+				var $radios = $facebook.find( '.ai1ec_export_radios' );
+				var $multi = $radios.find( '.ai1ec_multi_choiches' );
+				// are the radios hidden or not?
+				var hidden = true;
+				if( $multi.length > 0 ) {
+					hidden = $multi.hasClass( 'hide' );
+				}
+				
+				// if the radio buttons exist, replace them
+				if( $radios.length > 0 ) {
+					$radios.replaceWith( data );
+				} else {
+					$facebook.find( '.ai1ec_refresh_tokens' ).before( data );
+				}
+				if( false === hidden ) {
+					$( '#ai1ec-facebook-publish' ).find( '.ai1ec_multi_choiches' ).removeClass( 'hide' );
+				}
+			},
+			'json'
+		);
+	};
+	var show_multi_choices_when_present = function( e ) {
+		var $multi = $( '.ai1ec_multi_choiches' ), $this = $( this );
+
+		if( 0 !== $multi.length ) {
+			if( this.checked ) {
+				$multi.removeClass( 'hide' );
+			} else {
+				$multi.addClass( 'hide' );
+			}
+		}
+	};
+	return {
+		open_modal_when_user_chooses_to_unpublish_event  : open_modal_when_user_chooses_to_unpublish_event,
+		add_hidden_field_when_user_click_remove_in_modal : add_hidden_field_when_user_click_remove_in_modal,
+		show_multi_choices_when_present                  : show_multi_choices_when_present,
+		refresh_page_tokens                              : refresh_page_tokens
+	};
+} );
diff --git a/public/js_src/scripts/admin_settings.js b/public/js_src/scripts/admin_settings.js
new file mode 100644
index 0000000..2892b62
--- /dev/null
+++ b/public/js_src/scripts/admin_settings.js
@@ -0,0 +1,214 @@
+define(
+	[
+		"jquery_timely",
+		"domReady",
+		"ai1ec_config",
+		"libs/utils",
+		"libs/collapse_helper",
+		"external_libs/bootstrap_tab",
+		"external_libs/bootstrap_dropdown",
+		"external_libs/bootstrap_datepicker",
+		"external_libs/bootstrap_tooltip",
+		"external_libs/jquery_cookie"
+	],
+	function( $, domReady, ai1ec_config, utils ) {
+	"use strict";
+
+	var remove_feeds_postbox_if_all_values_are_empty = function() {
+		var remove = true;
+		$( '#ai1ec-plugins-settings input:text' ).each( function() {
+			if ( this.value !== '' ) {
+				remove = false;
+			}
+		} );
+		if ( remove === true ) {
+			$( '#ai1ec-plugins-settings' ).remove();
+		}
+	};
+
+	/**
+	 * Destroys and reinitializes the datepicker on the given element with the
+	 * given data map to assign to the element before initializing the new
+	 * datepicker. The previous date value is preserved.
+	 *
+	 * @param  {object} $el  jQuery object of element datepicker is attached to
+	 * @param  {array}  data Data map to assign to $el before calling .datepicker()
+	 */
+	var reset_datepicker = function( $el, data ) {
+		// Save the old date from the datepicker.
+		var cur_date = false;
+		if ( $el.val() !== '' ) {
+			cur_date = $el.data( 'datepicker' ).date;
+		}
+		// Destroy the datepicker.
+		var dp = $el.data( 'datepicker' );
+		if( dp !== undefined ) {
+			dp.hide();
+			dp.picker.remove();
+			$el.removeData( 'datepicker' );
+		}
+		// Reinitialize datepicker to use the new pattern, and restore the date.
+		$el.data( data ).datepicker();
+		dp = $el.data( 'datepicker' );
+		if ( cur_date !== false ) {
+			dp.date = cur_date;
+			dp.setValue();
+		}
+	};
+
+	/**
+	 * Event handler when tab is clicked; saves chosen tab to cookie.
+	 *
+	 * @param  {string} active_tab Value of tab's href attribute
+	 */
+	var handle_set_tab_cookie = function( e ) {
+		var active = $( this ).attr( 'href' );
+		$.cookie( 'ai1ec_general_settings_active_tab', active );
+	};
+
+	/**
+	 * Toggle disabled states on certain settings depending on value of other
+	 * settings.
+	 */
+	var set_disabled_states = function() {
+		var show_create_button = $( '#show_create_event_button' )[0].checked,
+		    $show_front_end_form = $( '#show_front_end_create_form' ),
+		    show_front_end_form = $show_front_end_form[0].checked,
+		    $allow_anonymous = $( '#allow_anonymous_submissions' ),
+		    allow_anonymous = $allow_anonymous[0].checked;
+
+		$show_front_end_form.attr( 'disabled',
+			! show_create_button
+		);
+		$allow_anonymous.attr( 'disabled',
+			! ( show_create_button && show_front_end_form )
+		);
+		$( '#allow_anonymous_uploads' ).attr( 'disabled',
+			! ( show_create_button && show_front_end_form && allow_anonymous )
+		);
+	}
+
+	var validate_week_start_end = function() {
+		var $start = $( '#week_view_starts_at' )
+		  , $end = $( '#week_view_ends_at' )
+		  , start = parseInt( $start.val(), 10 )
+		  , end = parseInt( $end.val(), 10 );
+		if ( end < start ) {
+			window.alert( ai1ec_config.end_must_be_after_start );
+			$end.focus();
+			return false;
+		}
+		var diff = end - start;
+		if ( diff < 6 ) {
+			window.alert( ai1ec_config.show_at_least_six_hours );
+			$end.focus();
+			return false;
+		}
+	};
+	/**
+	 * Initialize the license status indicator with API call.
+	 */
+	var init_license_status = function() {
+	};
+
+	var remove_gzip_button = function() {
+		$( '.ai1ec-gzip-causes-js-failure' ).remove();
+	};
+
+	var setup_disclaimer = function() {
+		$( '#ai1ec_save_settings' ).on( 'click', function( e ) {
+			var checked = $( '#require_disclaimer' ).is( ':checked' );
+			var discl = $( '#disclaimer' ).val();
+
+
+			if( true === checked && '' === discl ) {
+				alert( ai1ec_config.require_desclaimer );
+				// Activate the correct tab
+				$( '#ai1ec-general-settings ul.nav-tabs a[href="#ai1ec-advanced"]' )
+					.tab( 'show' );
+				$( '#disclaimer' ).focus();
+				e.preventDefault();
+			}
+		} );
+	};
+	var start = function() {
+		// Perform DOM ready tasks.
+		domReady( function() {
+			init_license_status();
+			setup_disclaimer();
+			remove_gzip_button();
+
+			// Handle saving/loading of active tab.
+			utils.activate_saved_tab_on_page_load( $.cookie( 'ai1ec_general_settings_active_tab' ) );
+			$( document ).on(
+				'click',
+				'#ai1ec-general-settings .nav-tabs a[data-toggle="tab"]',
+				handle_set_tab_cookie
+			);
+
+			// Prevent `label` action
+			$( document ).on(
+				'click',
+				'#disable_standard_filter_menu_toggler',
+				function( evt ) {
+					evt.preventDefault();
+				}
+			);
+
+			// Initialize datepicker and have it respond to changes in format settings.
+			var $exact_date = $('#exact_date');
+			$exact_date.datepicker();
+			// Apply the new date pattern when "Calendar default start date" is changed.
+			$( document ).on( 'change', '#input_date_format', function() {
+				var pattern = $( 'option:selected', this ).data( 'pattern' );
+				reset_datepicker( $exact_date, { dateFormat: pattern } );
+			});
+			// Change the week start day in the picker.
+			$( document ).on( 'change', '#week_start_day', function() {
+				var week_start_day = $( this ).val();
+				reset_datepicker( $exact_date, { dateWeekstart: week_start_day } );
+			});
+
+			remove_feeds_postbox_if_all_values_are_empty();
+
+			// When a view is enabled, affect form state.
+			$( document ).on(
+				"click", '.ai1ec-admin-view-settings .ai1ec-toggle-view', function() {
+				var $this = $( this )
+				  , $tr = $this.closest( 'tr' );
+
+				// Check to see if there are any siblings that are checked.
+				var is_one_box_checked = $( '.ai1ec-admin-view-settings .ai1ec-toggle-view:checked' ).length === 0;
+				// Check if this view is selected as the default via radio button
+				var is_selected_default = $tr.find( '.ai1ec-toggle-default-view:checked' ).length === 1;
+				// If either is true, prevent :checked state change (only for the
+				// Enabled column).
+				if ( ( is_one_box_checked === true || is_selected_default === true ) ) {
+					return false;
+				}
+			} );
+
+			// When clicking a radio button to select a default view
+			$( document ).on( "click", '.ai1ec-admin-view-settings .ai1ec-toggle-default-view', function () {
+				// Automatically set the associated checkbox property to :checked
+				$( this ).closest( 'tr' ).find( '.ai1ec-toggle-view:first' )
+					.prop( 'checked', true );
+			} );
+
+			// Enable/disable show_front_end_create_form checkbox based on status of
+			// show_create_event_button checkbox.
+			$( document ).on(
+				'click ready',
+				'#show_create_event_button, #show_front_end_create_form, #allow_anonymous_submissions',
+				set_disabled_states
+			);
+
+			$( '#ai1ec_save_settings' ).on( 'click', validate_week_start_end );
+			$( '#show_create_event_button' ).trigger( 'ready' );
+		} );
+	};
+	return {
+		start : start,
+		reset_datepicker : reset_datepicker
+	};
+} );
diff --git a/public/js_src/scripts/calendar.js b/public/js_src/scripts/calendar.js
new file mode 100644
index 0000000..3bfb206
--- /dev/null
+++ b/public/js_src/scripts/calendar.js
@@ -0,0 +1,341 @@
+define(
+	[
+		"jquery_timely",
+		"domReady",
+		"scripts/calendar/load_views",
+		"scripts/calendar/print",
+		"scripts/calendar/agenda_view",
+		"scripts/calendar/posterboard_view",
+		"scripts/calendar/month_view",
+		"scripts/calendar/submit_ics_modal",
+		"ai1ec_calendar",
+		"ai1ec_config",
+		"scripts/common_scripts/frontend/common_frontend",
+		"libs/utils",
+		"libs/select2_multiselect_helper",
+		"external_libs/jquery.debouncedresize",
+		"external_libs/bootstrap_transition",
+		"libs/modal_helper",
+		"external_libs/jquery.scrollTo"
+	],
+	function( $, domReady, load_views, print, agenda_view, posterboard_view,
+		month_view, submit_ics_modal, ai1ec_calendar, ai1ec_config, common_frontend,
+		AI1EC_UTILS, select2_multiselect_helper ) {
+	"use strict"; // jshint ;_;
+
+	var create_event_form;
+	/**
+	 * Moves calendar into CSS selector defined by advanced settings.
+	 */
+	var css_selector_replacement = function() {
+		if( ai1ec_calendar.selector !== undefined && ai1ec_calendar.selector !== '' &&
+			$( ai1ec_calendar.selector ).length === 1 ) {
+			// Try to find an <h#> element containing the title
+			var $title = $( ":header:contains(" + ai1ec_calendar.title + "):first" );
+			// If none found, create one
+			if( ! $title.length ) {
+				$title = $( '<h1 class="page-title"></h1>' );
+				$title.text( ai1ec_calendar.title ); // Do it this way to automatically generate HTML entities
+			}
+			var $calendar = $( '#ai1ec-container' )
+				.detach()
+				.before( $title );
+
+			$( ai1ec_calendar.selector )
+				.empty()
+				.append( $calendar )
+				.hide()
+				.css( 'visibility', 'visible' )
+				.fadeIn( 'fast' );
+		}
+	};
+
+	/**
+	 * Initialize Create Your Event modal dialog.
+	 */
+	var init_create_event_modal = function() {
+		var $modal = $( '#ai1ec-create-event-modal' );
+		// move the modal to be a child of the body
+		$timely = $( '<div class="timely" />' );
+		$modal.appendTo( $timely );
+		$timely.appendTo( 'body' );
+		$modal
+			.modal( { show: false } )
+			// Execute initialization only once.
+			.one( 'show', function() {
+				// Load the form body via AJAX.
+				$( '.ai1ec-ajax-placeholder', this ).load(
+					ai1ec_config.ajax_url + '?action=ai1ec_front_end_create_event_form',
+					function() {
+						// Hide spinner.
+						$( '> .ai1ec-loading', $modal ).removeClass( 'show' );
+						// Start up requirejs when form body is loaded.
+						require( [ 'scripts/front_end_create_event_form' ],
+							function( page ) {
+								create_event_form = page;
+								page.start();
+						} );
+				} );
+			} )
+			.on( 'show', function() {
+				// the first time the object is not present.
+				if( typeof create_event_form !== 'undefined' ) {
+					create_event_form.init_recaptcha();
+				}
+			} )
+			.on( 'hidden', function( e ) {
+				// Take off classes so that it reinitializes correctly.
+				$( '.ai1ec-recaptcha', this ).removeClass(
+					'ai1ec-initializing ai1ec-initialized'
+				);
+				// remove the backdrop since firefox has problems with transitionend
+				$( '.ai1ec-modal-backdrop' ).remove();
+				Recaptcha.destroy();
+			} );
+
+		// Stop bubbling of collapsibles within modal, else they interfere with
+		// above events.
+		$modal.on( 'show hidden', '.collapse', function( e ) {
+			e.stopPropagation();
+		} );
+	};
+
+	/**
+	 * Initialize Add Your Calendar modal.
+	 */
+	var init_submit_ics_modal = function() {
+		var $modal = $( '#ai1ec-submit-ics-modal' );
+		// move the modal to be a child of the body
+		$timely = $( '<div class="timely" />' );
+		$modal.appendTo( $timely );
+		$timely.appendTo( 'body' );
+		$modal
+			.modal( { show: false } )
+			.one( 'show', function() {
+				submit_ics_modal.init_form();
+			} )
+			.on( 'show', function() {
+				submit_ics_modal.init_recaptcha();
+			} )
+			.on( 'hidden', function() {
+				// Take off classes so that it reinitializes correctly.
+				$( '.ai1ec-recaptcha', this ).removeClass(
+					'ai1ec-initializing ai1ec-initialized'
+				);
+				// remove the backdrop since firefox has problems with transitionend
+				$( '.ai1ec-modal-backdrop' ).remove();
+				Recaptcha.destroy();
+			} );
+
+		// Stop bubbling of collapsibles within modal, else they interfere with
+		// above events.
+		$modal.on( 'show hidden', '.collapse', function( e ) {
+			e.stopPropagation();
+		} );
+	};
+
+	/**
+	 * Event handler for multiday events. When being hovered, add hover class
+	 * to its clones.
+	 */
+	var handle_multiday_enter = function() {
+		var id = $( this ).data( 'instanceId' );
+		$( '.ai1ec-event-instance-id-' + id ).addClass( 'ai1ec-hover' );
+	};
+
+	/**
+	 * Event handler for multiday events. When leaving hover, remove hover class
+	 * from its clones.
+	 */
+	var handle_multiday_leave = function() {
+		var id = $( this ).data( 'instanceId' );
+		$( '.ai1ec-event-instance-id-' + id ).removeClass( 'ai1ec-hover' );
+	};
+
+	/**
+	 * Event handler for events in week/day view. Issue a delayed raising effect
+	 * on this event and all its multiday clones.
+	 */
+	var handle_raise_enter = function() {
+		var $this = $( this ),
+				id = $this.data( 'instanceId' );
+		$this.delay( 500 ).queue( function() {
+			$( '.ai1ec-event-instance-id-' + id ).addClass( 'ai1ec-raised' );
+		} );
+	};
+
+	/**
+	 * Event handler for events in week/day view. Cancel raising effect on this
+	 * event and all its multiday clones.
+	 */
+	var handle_raise_leave = function( e ) {
+		var $this = $( this ),
+				id = $this.data( 'instanceId' ),
+				$target = $( e.toElement || e.relatedTarget );
+		// Don't cancel the effect if moving onto a clone of the same instance.
+		if ( $target.is( '.ai1ec-event-instance-id-' + id ) ||
+				 $target.parent().is( '.ai1ec-event-instance-id-' + id ) ) {
+			return;
+		}
+		$( '.ai1ec-event-instance-id-' + id )
+			.clearQueue()
+			.removeClass( 'ai1ec-raised' );
+	};
+
+	/**
+	 * General calendar page initialization.
+	 */
+	var init = function() {
+		// Do the replacement of the calendar and create title if not present
+		css_selector_replacement();
+
+		// Initialize Post Your Event modal.
+		init_create_event_modal();
+		// Initialize Add Your Calendar modal.
+		init_submit_ics_modal();
+	};
+
+
+	/**
+	 * Attach event handlers for calendar page.
+	 */
+	var attach_event_handlers = function() {
+		// ======================================
+		// = Month/week/day view multiday hover =
+		// ======================================
+		$( document ).on(
+			{
+				mouseenter: handle_multiday_enter,
+				mouseleave: handle_multiday_leave
+			},
+			'.ai1ec-event-container.ai1ec-multiday'
+		);
+
+		// ====================================
+		// = Week/day view hover-raise effect =
+		// ====================================
+		$( document ).on(
+			{
+				mouseenter: handle_raise_enter,
+				mouseleave: handle_raise_leave
+			},
+			'.ai1ec-oneday-view .ai1ec-oneday .ai1ec-event-container, ' +
+				'.ai1ec-week-view .ai1ec-week .ai1ec-event-container'
+		 );
+
+		// ===============
+		// = Agenda view =
+		// ===============
+		// Register click handlers for Agenda View event title
+		$( document ).on( 'click', '.ai1ec-agenda-view .ai1ec-event-header', agenda_view.toggle_event );
+
+		// Register click handlers for expand/collapse all buttons
+		$( document ).on( 'click', '#ai1ec-agenda-expand-all', agenda_view.expand_all );
+		$( document ).on( 'click', '#ai1ec-agenda-collapse-all', agenda_view.collapse_all );
+
+		// =======================================
+		// = Posterboard view masonry.js events  =
+		// =======================================
+		// Trigger resize events no faster than 250 ms.
+		$.event.special.debouncedresize.threshold = 400;
+		// Trigger masonry update on window resize
+		$( window ).on( 'debouncedresize', posterboard_view.resize_masonry );
+
+		// =============
+		// = All views =
+		// =============
+
+		// Register navigation click handlers
+		$( document ).on( 'click',      'a.ai1ec-load-view',
+			load_views.handle_click_on_link_to_load_view
+		);
+
+		// Register minical datepicker events.
+		$( document ).on( 'click',      '.ai1ec-minical-trigger',
+			load_views.handle_minical_trigger );
+		$( document ).on( 'changeDate', '.ai1ec-minical-trigger',
+			load_views.handle_minical_change_date
+		);
+
+		// Handle clearing filters.
+		$( document ).on( 'click',      '.ai1ec-clear-filter',
+			load_views.clear_filters
+		);
+
+		// Handle click on print button.
+		$( document ).on( 'click',      '#ai1ec-print-button',
+			print.handle_click_on_print_button
+		);
+
+		// Handle click on reveal full day button.
+		$( document ).on( 'click',      '.ai1ec-reveal-full-day button',
+			function() {
+				// Hide the button (no longer serves a purpose).
+				$( this ).fadeOut();
+				// check if it's oneday or week view
+				var $oneday_original = $( '.ai1ec-oneday-view-original' );
+				var $actual_table   = $( '.ai1ec-week-view-original' );
+				if ( $actual_table.length === 0 ) {
+					$actual_table = $oneday_original;
+				}
+				// Scroll window down the same amount that the upper portion of the
+				// table is being revealed.
+				var vertical_offset =
+					$( '.tablescroll_wrapper' ).offset().top -
+					$actual_table.offset().top;
+				$( window ).scrollTo( '+=' + vertical_offset + 'px', 400 );
+				// At the same time, expand height to reveal 1 full day (24 hours).
+				var height = 24 * 60;
+				$( '.tablescroll_wrapper' ).animate( { height: height + 'px' } );
+			}
+
+		);
+
+		$( document ).on( 'submit',     '.ai1ec-submit-ics-form',
+			submit_ics_modal.handle_form_submission
+		);
+
+
+		// Handle click on save view
+		$( document ).on( 'click', '#save_filtered_views:not(.active)',
+			load_views.save_current_filter
+		);
+
+		// Handle click on remove saved view
+		$( document ).on( 'click', '#save_filtered_views.active',
+			load_views.remove_current_filter
+		);
+
+		// Bind to statechange event.
+		History.Adapter.bind( window, 'statechange', load_views.handle_state_change );
+
+	};
+
+	var initialize_select2 = function() {
+		select2_multiselect_helper.init( $( '.ai1ec-select2-filters' ) );
+		$( document ).on( 
+			'change', 
+			'.ai1ec-select2-multiselect-selector',
+			load_views.load_view_from_select2_filter
+		);
+	};
+
+	/**
+	 * Start calendar page.
+	 */
+	var start = function() {
+		domReady( function() {
+			init();
+			if( ai1ec_config.use_select2 ) {
+				initialize_select2();
+			}
+
+			attach_event_handlers();
+			// Initialize the calendar view for the first time.
+			load_views.initialize_view();
+		} );
+	};
+	return {
+		start : start
+	};
+} );
diff --git a/public/js_src/scripts/calendar/agenda_view.js b/public/js_src/scripts/calendar/agenda_view.js
new file mode 100644
index 0000000..918b741
--- /dev/null
+++ b/public/js_src/scripts/calendar/agenda_view.js
@@ -0,0 +1,35 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+	"use strict"; // jshint ;_;
+	// *** Agenda view ***
+
+	/**
+	 * Callbacks for event expansion, collapse.
+	 */
+	var toggle_event = function() {
+		$( this )
+			// Find the parent li.ai1ec-event, toggle its class.
+			.closest( '.ai1ec-event' )
+				.toggleClass( 'ai1ec-expanded' )
+				// Find the event summary and slideToggle it
+				.find( '.ai1ec-event-summary' )
+					.slideToggle( 300 );
+	};
+	var collapse_all = function() {
+		$( '.ai1ec-expanded .ai1ec-event-toggle')
+			.click();
+	};
+
+	var expand_all = function() {
+		$( '.ai1ec-event:not(.ai1ec-expanded) .ai1ec-event-toggle')
+			.click();
+	};
+	return {
+		toggle_event   : toggle_event,
+		collapse_all   : collapse_all,
+		expand_all     : expand_all
+	};
+} );
diff --git a/public/js_src/scripts/calendar/event.js b/public/js_src/scripts/calendar/event.js
new file mode 100644
index 0000000..7ec6ebd
--- /dev/null
+++ b/public/js_src/scripts/calendar/event.js
@@ -0,0 +1,98 @@
+define(
+		[
+		 "jquery_timely",
+		 "external_libs/jquery.scrollTo"
+		 ],
+		 function( $ ) {
+	"use strict"; // jshint ;_;
+
+	var load_event_through_jsonp = function( e ) {
+		e.preventDefault();
+		// Remove popovers
+		$( 'div.popover' ).remove();
+		var type = 'jsonp';
+		var timely_div = $( this ).closest( '.timely-calendar' );
+		var query = {
+				request_type: type,
+				ai1ec_doing_ajax : true,
+				ai1ec : create_ai1ec_to_send( timely_div )
+		};
+
+		// Fetch AJAX result
+		$.ajax( {
+			url : $( this ).attr( 'href' ) ,
+			dataType: type,
+			data: query,
+			method : 'get',
+			success: function( data ) {
+				// Use the closest container relative to the target
+				$( e.target ).closest( '#ai1ec-calendar-view' ).html( data.html );
+				// Update the back to calendar button with the
+				var href = $( '.ai1ec-calendar-link' ).attr( 'href' );
+				var timely_action = $( e.target ).closest( '.timely-calendar' ).data( 'action' );
+				if( timely_action ) {
+					href = href + 'action~' + timely_action + '/';
+				}
+				// Scroll to the relative div top to bring the event details into focus.
+				$.scrollTo( timely_div, 1000,
+					{
+						offset: {
+							left: 0,
+							top: -100
+						}
+					}
+				);
+
+				// Start up requirejs
+				require(
+						[
+						 'pages/event'
+						 ] );
+			}
+		} );
+	};
+	var add_value_to_array_if_present_on_el = function( key, params, $el, skip_key ) {
+		var camel_key = dashToCamel( key );
+		var value = $el.data( camel_key );
+		if ( value === undefined ) {
+			return params;
+		} else {
+			if( skip_key ) {
+				params.push( value );
+			} else {
+				params.push( key + '~' + value );
+			}
+			return params;
+		}
+
+	};
+
+	/**
+	 * Convert a string to camelcase
+	 *
+	 */
+	var dashToCamel = function( str ) {
+		return str.replace(/\W+(.)/g, function (x, chr) {
+			return chr.toUpperCase();
+		});
+	};
+	/**
+	 * Creates the ai1ec variable to send to the server to filter the calendar
+	 *
+	 */
+	var create_ai1ec_to_send = function( el ) {
+		var $el = $( el );
+		var params = [];
+		params = add_value_to_array_if_present_on_el( 'action', params, $el );
+		params = add_value_to_array_if_present_on_el( 'cat_ids', params, $el );
+		params = add_value_to_array_if_present_on_el( 'auth_ids', params, $el );
+		params = add_value_to_array_if_present_on_el( 'tag_ids', params, $el );
+		params = add_value_to_array_if_present_on_el( 'exact_date', params, $el );
+		params = add_value_to_array_if_present_on_el( 'no_navigation', params, $el );
+		return params.join( '|' );
+	};
+	return {
+		load_event_through_jsonp : load_event_through_jsonp,
+		create_ai1ec_to_send     : create_ai1ec_to_send
+	};
+} );
diff --git a/public/js_src/scripts/calendar/load_views.js b/public/js_src/scripts/calendar/load_views.js
new file mode 100644
index 0000000..a8943c2
--- /dev/null
+++ b/public/js_src/scripts/calendar/load_views.js
@@ -0,0 +1,401 @@
+/*global History: true */
+define(
+	[
+		"jquery_timely",
+		"scripts/calendar/print",
+		"scripts/calendar/posterboard_view",
+		"scripts/calendar/agenda_view",
+		"scripts/calendar/month_view",
+		"libs/frontend_utils",
+		"libs/utils",
+		"ai1ec_calendar",
+		"ai1ec_config",
+		"scripts/common_scripts/frontend/common_frontend",
+		"libs/select2_multiselect_helper",
+		"external_libs/jquery_history",
+		"external_libs/jquery.tablescroller",
+		"external_libs/jquery.scrollTo",
+		"external_libs/bootstrap_datepicker",
+		"external_libs/bootstrap_alert",
+		"external_libs/jquery_cookie"
+	],
+	function(
+		$,
+		print_functions,
+		posterboard_view,
+		agenda_view,
+		month_view,
+		frontend_utils,
+		utils,
+		ai1ec_calendar,
+		ai1ec_config,
+		common_frontend,
+		select2_multiselect_helper
+	) {
+	"use strict"; // jshint ;_;
+	$.cookie.json = true;
+	var save_filter_view_cookie = 'ai1ec_saved_filter';
+	// the initial value is determined by the visibility of the save view button
+	var are_filters_set = ! $( '#save_filtered_views' ).hasClass( 'hide' );
+
+	/**
+	 * function initialize_view
+	 *
+	 * General initialization function to execute whenever any view is loaded
+	 * (this is also called at the end of load_view()).
+	 */
+	var initialize_view = function() {
+
+		// Get the dropdown menu link of the active view.
+		var $selected_view = $('#ai1ec-view-dropdown .dropdown-menu .active a');
+
+		var hours =
+			ai1ec_config.week_view_ends_at - ai1ec_config.week_view_starts_at;
+		var height = hours * 60;
+		// Make week view table limitable.
+		$( 'table.ai1ec-week-view-original' ).tableScroll( {
+			height: height,
+			containerClass: 'ai1ec-week-view ai1ec-popover-boundary',
+			scroll : false
+		} );
+		$( 'table.ai1ec-oneday-view-original' ).tableScroll( {
+			height: height,
+			containerClass: 'ai1ec-oneday-view ai1ec-popover-boundary',
+			scroll : false
+		} );
+
+		if( $( '.ai1ec-week-view' ).length || $( '.ai1ec-oneday-view' ).length ) {
+			// If no active event, then in week view, scroll down to 6am.
+			$( '.ai1ec-oneday-view .tablescroll_wrapper, .ai1ec-week-view .tablescroll_wrapper' )
+				.scrollTo( '.ai1ec-hour-marker:eq(' + ai1ec_config.week_view_starts_at + ')' );
+			$( '.ai1ec-hour-marker:eq(' + ai1ec_config.week_view_starts_at + ')' ).addClass( 'ai1ec-first-visible' );
+		}
+
+		// If in month view, extend multiday events.
+		if ( $( '.ai1ec-month-view .ai1ec-multiday' ).length ) {
+			month_view.extend_multiday_events();
+		}
+
+		// If in posterboard view, initialize masonry.
+		if ( $( '.ai1ec-posterboard-view' ).length ) {
+			posterboard_view.resize_masonry();
+		}
+	};
+
+	/**
+	 * Do any cleanup required before currently displayed view is replaced with
+	 * a newly retrieved view.
+	 */
+	var destroy_view = function() {
+		// Destroy any datepicker before loading new view.
+		var dp = $( '.ai1ec-minical-trigger' ).data( 'datepicker' );
+		if ( typeof dp !== 'undefined' ) {
+			dp.picker.parent( '.timely' ).remove();
+		}
+		// Destroy any visible tooltips or popovers.
+		$( '.tooltip.in, .ai1ec-popup' ).remove();
+	};
+
+	var get_cal_state = function() {
+		// Otherwise we need to get the state from the dropdowns.
+		var cat_ids = [], tag_ids = [], auth_ids = [], action;
+		$( '.ai1ec-category-filter .dropdown-menu .active' ).each( function() {
+			cat_ids.push( $( this ).data( 'term' ) );
+		} );
+		$( '.ai1ec-tag-filter .dropdown-menu .active' ).each( function() {
+			tag_ids.push( $( this ).data( 'term' ) );
+		} );
+		$( '.ai1ec-author-filter .dropdown-menu .active' ).each( function() {
+			auth_ids.push( $( this ).data( 'term' ) );
+		} );
+		var cal_state = {};
+		cal_state.cat_ids  = cat_ids;
+		cal_state.tag_ids  = tag_ids;
+		cal_state.auth_ids = auth_ids;
+		action =
+			$( '.ai1ec-views-dropdown .dropdown-menu .active' ).data( 'action' );
+		cal_state.action = action;
+		return cal_state;
+	};
+
+	/**
+	 * Save the current url in a cookie so that the user is redirected here
+	 * When he visit the calendar home page
+	 *
+	 */
+	var save_current_filter = function() {
+		var state = History.getState();
+		var cookie = $.cookie( save_filter_view_cookie );
+		// If the cookie is not present, create it.
+		if ( null === cookie || undefined === cookie ) {
+			cookie = {};
+		}
+		var cal_state = get_cal_state();
+		// If we are on the calendar page, we just save the URL.
+		if ( ai1ec_config.is_calendar_page ) {
+			cookie['calendar_page'] = cal_state;
+		} else {
+			
+			cookie[state.url] = cal_state;
+		}
+		$.cookie( save_filter_view_cookie, cookie, { path: '/', expires: 365 } );
+		$( '#save_filtered_views' )
+			.addClass( 'active' )
+			.attr( 'data-original-title', ai1ec_config.clear_saved_filter_text );
+		var $alert =
+			utils.make_alert( ai1ec_config.save_filter_text_ok, 'success' );
+		$( '#ai1ec-calendar' ).prepend( $alert );
+	};
+
+	/**
+	 * Remove the cookie with the saved url.
+	 *
+	 * @param {object} e jQuery event object
+	 */
+	var remove_current_filter = function( e ) {
+		e.stopImmediatePropagation();
+		var cookie = $.cookie( save_filter_view_cookie );
+		if( ai1ec_config.is_calendar_page ) {
+			delete cookie['calendar_page'];
+		} else {
+			var state = History.getState();
+			delete cookie[state.url];
+		}
+		$.cookie( save_filter_view_cookie, cookie, { path : '/', expires : 365 } );
+		$( '#save_filtered_views' )
+			.removeClass( 'active' )
+			.attr( 'data-original-title', ai1ec_config.reset_saved_filter_text );
+		// we keep the variable that tells us if some filters are set updated on every call.
+		// so if no filters are applied, just hide the button
+		if( ! are_filters_set ) {
+			$( '#save_filtered_views' ).addClass( 'hide' );
+		}
+		var $alert =
+			utils.make_alert( ai1ec_config.remove_filter_text_ok, 'success' );
+		$( '#ai1ec-calendar' ).prepend( $alert );
+	};
+
+	/**
+	 * Load a calendar view represented by the given hash value.
+	 *
+	 * @param {string} hash The hash string requesting a calendar view
+	 */
+	var load_view = function( hash, type ) {
+		// Reveal loader behind view
+		$('#ai1ec-calendar-view-loading').fadeIn( 'fast' );
+		$('#ai1ec-calendar-view').fadeTo( 'fast', 0.3,
+			// After loader is visible, fetch new content
+			function() {
+				var query = {
+						request_type: type,
+						ai1ec_doing_ajax : true
+				};
+				// Fetch AJAX result
+				$.ajax( {
+					url : hash,
+					dataType: type,
+					data: query,
+					method : 'get',
+					success: function( data ) {
+						// Do required cleanup of existing view.
+						destroy_view();
+
+						// Views Dropdown
+						if( typeof data.views_dropdown === 'string' ) {
+							$( '.ai1ec-views-dropdown' ).replaceWith( data.views_dropdown );
+						}
+						// Update categories
+						if( typeof data.categories === 'string' ) {
+							$( '.ai1ec-category-filter' ).replaceWith( data.categories );
+							if( ai1ec_config.use_select2 ) {
+								select2_multiselect_helper.init( $( '.ai1ec-category-filter' ) );
+							}
+						}
+						// Update authors
+						if( typeof data.authors === 'string' ) {
+							$( '.ai1ec-author-filter' ).replaceWith( data.authors );
+							if( ai1ec_config.use_select2 ) {
+								select2_multiselect_helper.init( $( '.ai1ec-author-filter' ) );
+							}
+						}
+						// Tags
+						if( typeof data.tags === 'string' ) {
+							$( '.ai1ec-tag-filter' ).replaceWith( data.tags );
+							if( ai1ec_config.use_select2 ) {
+								select2_multiselect_helper.init( $( '.ai1ec-tag-filter' ) );
+							}
+						}
+						// And the "Subscribe buttons"
+						if( typeof data.subscribe_buttons === 'string' ) {
+							$( '.ai1ec-subscribe-container' ).replaceWith( data.subscribe_buttons );
+						}
+						// And the "Save filtered view"
+						if( typeof data.save_view_btngroup === 'string' ) {
+							$( '#save_filtered_views' ).closest( '.btn-group' ).replaceWith( data.save_view_btngroup );
+						}
+						are_filters_set = data.are_filters_set;
+
+
+						// Animate vertical height of container between HTML replacement
+						var $container = $('#ai1ec-calendar-view-container');
+						$container.height( $container.height() );
+						var new_height =
+							$('#ai1ec-calendar-view')
+								.html( data.html )
+								.height();
+						$container.animate( { height: new_height }, { complete: function() {
+							// Restore height to automatic upon animation completion for
+							// proper page layout.
+							$container.height( 'auto' );
+						} } );
+
+						// Hide loader
+						$('#ai1ec-calendar-view-loading').fadeOut( 'fast' );
+						$('#ai1ec-calendar-view').fadeTo( 'fast', 1.0 );
+						// Do any general view initialization after loading
+						initialize_view();
+					}
+				}
+				);
+			}
+		);
+	};
+
+	// When the state changes, load the corresponding view
+	var handle_state_change = function( e ) {
+		var state = History.getState();
+		if( state.data.ai1ec !== undefined && true === state.data.ai1ec ) {
+			load_view( state.url, 'json' );
+		}
+	};
+
+	/**
+	 * Load the correct view according to the datatypet
+	 *
+	 */
+	var load_view_according_to_datatype = function( type, url ) {
+		if( type === 'json' ) {
+			var data = {
+				ai1ec : true
+			};
+			History.pushState( data, null, url );
+		} else {
+			load_view( url, 'jsonp' );
+		}
+	};
+	// Handle loading the correct view when clicking on a link
+	var handle_click_on_link_to_load_view = function( e ) {
+
+		var $el = $( this );
+		e.preventDefault();
+
+		load_view_according_to_datatype( $el.data( 'type' ), $el.attr( 'href' ) );
+	};
+
+	/**
+	 * Click of minical trigger button. If not initialized, initialize datepicker.
+	 * Then show datepicker.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_minical_trigger = function( e ) {
+		var $el = $( this );
+
+		e.preventDefault();
+
+		if ( typeof $el.data( 'datepicker' ) === 'undefined' ) {
+			// Initialize this view's minical datepicker.
+			$el.datepicker( {
+					todayBtn: 'linked',
+					todayHighlight: true,
+					templateOverrides: 'headTemplate contTemplate',
+					headTemplate:
+						'<thead><tr class="datepicker-btn-group">' +
+							'<th class="prev"><div class="dp-btn"><i class="icon-arrow-left"/></div></th>' +
+							'<th colspan="5" class="switch"><div class="dp-btn"></div></th>' +
+							'<th class="next"><div class="dp-btn"><i class="icon-arrow-right"/></div></th>' +
+						'</tr></thead>',
+					contTemplate: '<tbody><tr><td colspan="7" class="grid-picker"></td></tr></tbody>'
+				} );
+
+			// Extend Datepicker behaviour without modifying the plugin.
+			var dp = $el.data( 'datepicker' );
+			// Wrap datepicker in div.timely to avoid polluting global namespace, and
+			// flag as right-aligned.
+			dp.picker
+				.wrapAll( '<div class="timely" />' )
+				.addClass( 'ai1ec-right-aligned' );
+			// Replace the place() method so that it is right-aligned to trigger.
+			var place_orig = dp.place;
+			dp.place = function() {
+				place_orig.call( this );
+				var $el = this.component ? this.component : this.element;
+				var offset = $el.offset();
+				this.picker.css( {
+					left: 'auto',
+					right: $( document ).width() - offset.left - $el.outerWidth()
+				} );
+			};
+		}
+
+		$el.datepicker( 'show' );
+	};
+
+	/**
+	 * Handle loading the correct view when selecting date from the datepicker.
+	 * Destroy datepicker first.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_minical_change_date = function( e ) {
+		var url,
+		    $el = $( this ),
+		    date;
+
+		$el.datepicker( 'hide' );
+
+		// Get URL template, and date, replacing '/' with '-' to be URL-friendly.
+		url = $el.data( 'href' );
+		date = $el.data( 'date' ).replace( /\//g, '-' );
+		url = url.replace( '__DATE__', date );
+		load_view_according_to_datatype( $el.data( 'type' ), url );
+	};
+
+	/**
+	 * Load the correct view from a select2 filter.
+	 * 
+	 */
+	var load_view_from_select2_filter = function( e ) {
+		var new_state;
+		if( typeof e.added !== 'undefined' ) {
+			new_state = $( e.added.element ).data( 'href' );
+		} else {
+			new_state = $( 'option[value=' + e.removed.id + ']', e.target ).data( 'href' );
+		}
+		data = {
+			ai1ec : true
+		};
+		History.pushState( data, null, new_state );
+	};
+
+	// Handle clearing filter
+	var clear_filters = function() {
+		load_view_according_to_datatype(
+				$( this ).data( 'type' ),
+				$( this ).data( 'href' )
+		);
+	};
+
+	return {
+		initialize_view                    : initialize_view,
+		handle_click_on_link_to_load_view  : handle_click_on_link_to_load_view,
+		handle_minical_trigger             : handle_minical_trigger,
+		handle_minical_change_date         : handle_minical_change_date,
+		clear_filters                      : clear_filters,
+		handle_state_change                : handle_state_change,
+		load_view                          : load_view,
+		save_current_filter                : save_current_filter,
+		remove_current_filter              : remove_current_filter,
+		load_view_from_select2_filter      : load_view_from_select2_filter
+	};
+});
diff --git a/public/js_src/scripts/calendar/month_view.js b/public/js_src/scripts/calendar/month_view.js
new file mode 100644
index 0000000..5faaea9
--- /dev/null
+++ b/public/js_src/scripts/calendar/month_view.js
@@ -0,0 +1,284 @@
+define(
+		[
+		 "jquery_timely",
+		 "external_libs/modernizr"
+		 ],
+		function( $, Modernizr ) {
+	"use strict"; // jshint ;_;
+	// *** Month view ***
+
+	var isOpera = navigator.userAgent.match(/opera/i);
+	var isWebkit = navigator.userAgent.match(/webkit/i);
+	/**
+	 * Extends day bars for multiday events.
+	 */
+	var extend_multiday_events = function() {
+		var $days = $('.ai1ec-day');
+		var daysFirstWeek = $( '.ai1ec-week:first .ai1ec-day' ).length;
+
+		$('.ai1ec-month-view .ai1ec-multiday').each( function() {
+			var container = this.parentNode;
+			var elHeight = $(this).outerHeight( true );
+			var endDay = parseInt( $(this).data( 'endDay' ), 10 );
+			var $startEl = $( '.ai1ec-date', container );
+			var startDay = parseInt( $startEl.text(), 10 );
+
+			var nextMonthBar = $( this ).data( 'endTruncated' );
+			if ( nextMonthBar ) {
+				endDay = parseInt( $($days[$days.length - 1]).text(), 10 ) ;
+			}
+
+			var $evtContainer = $(this);
+			var bgColor = $( '.ai1ec-event', $evtContainer )[0].style.backgroundColor;
+			var curLine = 0;
+			var deltaDays = endDay - startDay + 1;
+			var daysLeft = deltaDays;
+			var marginSize;
+
+			// this is the variable used to count the number of days for the event
+			var days = 0;
+
+			$days.each( function( i ) {
+				var $dayEl = $( '.ai1ec-date', this );
+				var $td = $( this.parentNode );
+				var cellNum = $td.index();
+				var day = parseInt( $dayEl.text(), 10 );
+				if ( day >= startDay && day <= endDay ) {
+					if ( day === startDay ) {
+						marginSize = parseInt( $dayEl.css( 'marginBottom' ), 10 ) + 16;
+					}
+
+					if ( curLine === 0 ) {
+						// Extend initial event bar to the end of first (!) week.
+						days++;
+					}
+
+					if ( cellNum === 0 && day > startDay && daysLeft !== 0 ) {
+						// Clone the event as well as its associated popup
+						var $clone = $evtContainer
+							.next( '.ai1ec-popup' )
+							.andSelf()
+							.clone( false );
+						$dayEl.parent().append( $clone );
+
+						var $block = $clone.first();
+
+						// Create a new spanning multiday bar. "ai1ec-multiday-bar" is used
+						// for proper styling, while "ai1ec-multiday-clone" identifies the
+						// clones so they can be removed when required.
+						$block.addClass( 'ai1ec-multiday-bar ai1ec-multiday-clone' );
+
+						$block
+							.css({
+								position: "absolute",
+								left: '1px',
+								top: parseInt( $dayEl.css( 'marginBottom' ), 10 ) + 13, // line height is 16px - 3px of initial margin
+								backgroundColor: bgColor
+							});
+
+						// Check the days left, if they are more than 7 a new block is needed and we draw 7 days only
+						var daysForThisBlock = ( daysLeft > 7 ) ? 7 : daysLeft;
+
+						$block.css( 'width', create_percentual_width_from_days( daysForThisBlock ) );
+
+						if ( daysLeft > 7 ) {
+							$block.append( create_multiday_arrow( 1, bgColor ));
+						}
+
+						$block.append( create_multiday_arrow( 2, bgColor ));
+					}
+
+					// Keep constant margin (number of bars) during the first row.
+					if ( curLine === 0 ) {
+						$dayEl.css({ 'marginBottom': marginSize + 'px' });
+					}
+					// But need to reset it and append margins from the begining for
+					// subsequent weeks.
+					else {
+						$dayEl.css({ 'marginBottom': '+=16px' });
+					}
+
+					daysLeft--;
+
+					// If in the last column of the table and there are more days left,
+					// increment curLine.
+					if ( daysLeft > 0 && cellNum === 6 ) {
+						curLine++;
+					}
+				}
+			});
+			// Adding "start arrow" to the end of multi-month bars.
+			if ( nextMonthBar ) {
+				var $lastBarPiece = $( '.' + $evtContainer[0].className.replace( /\s+/igm, '.' ) ).last();
+				$lastBarPiece.append( create_multiday_arrow( 1, bgColor ));
+			}
+
+			$(this).css({
+				position: 'absolute',
+				top: $startEl.outerHeight( true ) - elHeight - 1 + 'px',
+				left: '1px',
+				width: create_percentual_width_from_days( days )
+			});
+
+			// Add an ending arrow to the initial event bar for multi-week events.
+			if ( curLine > 0 ) {
+				$(this).append( create_multiday_arrow( 1, bgColor ) );
+			}
+			// Add a starting arrow to the initial event bar for events starting in
+			// previous month.
+			if ( $(this).data( 'startTruncated' ) ) {
+				$(this)
+					.append( create_multiday_arrow( 2, bgColor ) )
+					.addClass( 'ai1ec-multiday-bar' );
+			}
+		});
+	};
+
+	/**
+	 * returns a string with the percentage to use as width for the specified number of days
+	 *
+	 * @param int days the number of days
+	 *
+	 */
+	var create_percentual_width_from_days = function( days ) {
+		var percent;
+		switch ( days ) {
+			case 1:
+				percent = 97.5;
+				break;
+			case 2:
+				percent = 198.7;
+				break;
+			case 3:
+				percent = 300;
+				break;
+			case 4:
+				percent = 401;
+				break;
+			case 5:
+				if( isWebkit || isOpera ) {
+					percent = 507;
+				} else {
+					percent = 503.4;
+				}
+				break;
+			case 6:
+				if( isWebkit || isOpera ) {
+					percent = 608;
+				} else {
+					percent = 603.5;
+				}
+				break;
+			case 7:
+				if( isWebkit || isOpera ) {
+					percent = 709;
+				} else {
+					percent = 705;
+				}
+				break;
+		}
+		return percent + '%';
+	};
+
+	/**
+	 * Creates arrow for multiday bars.
+	 *
+	 * @param {int}    type  1 for ending arrow, 2 for starting arrow
+	 * @param {string} color Color of the multiday event
+	 */
+	var create_multiday_arrow = function( type, color ) {
+		var $arrow = $( '<div class="ai1ec-multiday-arrow' + type + '"></div>' );
+		if ( type === 1 ) {
+			$arrow.css({ borderLeftColor: color });
+		} else {
+			$arrow.css({ borderTopColor: color, borderRightColor: color, borderBottomColor: color });
+		}
+		return $arrow;
+	};
+
+	/**
+	 * Trims date boxes for which there are too many listed events.
+	 */
+	/* NOT USED
+	var truncate_month_view = function()
+	{
+		if( $( '.ai1ec-month-view' ).length )
+		{
+			// First undo any previous truncation
+			revert_dropdowns();
+
+			// Now set up truncation on any days with max visible events.
+			$( '.ai1ec-month-view .ai1ec-day' ).each( function()
+			{
+				var max_visible = 5;
+				var maxVisibleHeight = 5 * 16;
+				var addDropdownContainer = -1;
+				var $events = $( '.ai1ec-event-container', this );
+
+				$events.each( function( i ) {
+					if ( this.offsetTop >= maxVisibleHeight && addDropdownContainer === -1 ) {
+						addDropdownContainer = ( i > 1 ? i - 1 : 0 );
+					 }
+
+				});
+
+				if ( addDropdownContainer !== -1 ) {
+					var container = document.createElement("div");
+					container.className = "ai1ec-event-dropdown";
+
+					$( container ).css({
+						top: $events[addDropdownContainer].offsetTop,
+						display: "none"
+					});
+					for ( var i = addDropdownContainer; i < $events.length; i++ ) {
+						// Need to reset styles for events in dropdown.
+						revert_multiday_bar( $events[i] );
+
+						// Add an arrow for multiday events.
+						if ( $( $events[i] ).hasClass( "ai1ec-multiday" ) ) {
+							$( $events[i] ).append( create_multiday_arrow( 1, $events[i].style.backgroundColor ) );
+						}
+						$( container ).append( $events[i] );
+					}
+
+					// Scroll down button, and register mousedown.
+					var $scroll_down = $( '<a href="#" class="ai1ec-scroll-down"></a>' );
+					$scroll_down.bind( 'hover click', function () {
+						$( container ).fadeIn( 100 );
+						return false;
+					});
+
+					var $date = $( this ).find( ".ai1ec-date" );
+					if ( parseInt( $date.css( "marginBottom" ), 10 ) > maxVisibleHeight ) {
+						$date.css({ marginBottom: maxVisibleHeight - 15 + "px" });
+						$( container ).css({
+							top: maxVisibleHeight + "px"
+						});
+					}
+					$( this ).append(container);
+					$( this ).append($scroll_down);
+
+					// Need additional button to close dropdown on touch devices
+					if ( Modernizr.touch ) {
+						// Scroll down button, and register mousedown
+						var $scroll_up = $( '<a href="#" class="ai1ec-scroll-up"></a>' );
+						$scroll_up.bind("click", function () {
+							$( container ).fadeOut( 100 );
+							return false;
+						});
+						$( container ).append($scroll_up);
+					} else {
+						$( container ).bind( 'mouseleave' ,function() {
+							$( this ).fadeOut( 100 );
+						});
+					}
+				}
+			});
+		}
+	};*/
+
+	return {
+		extend_multiday_events: extend_multiday_events
+	};
+
+} );
diff --git a/public/js_src/scripts/calendar/posterboard_view.js b/public/js_src/scripts/calendar/posterboard_view.js
new file mode 100644
index 0000000..47f74d2
--- /dev/null
+++ b/public/js_src/scripts/calendar/posterboard_view.js
@@ -0,0 +1,76 @@
+define(
+	[
+	 "jquery_timely",
+	 "external_libs/jquery.masonry",
+	],
+	function( $, masonry ) {
+	"use strict";
+
+	// *** Posterboard view layout ***
+
+	/**
+	 * Initializes and/or reflows masonry on the active posterboard view (usually
+	 * when the window has been resized, or after web fonts have been loaded).
+	 */
+	var resize_masonry = function() {
+		var $container = $( '.ai1ec-posterboard-view' ),
+		    $tiles = $( '> .ai1ec-event', $container ),
+		    container_width,
+		    col_width,
+		    num_columns;
+
+		// Don't reflow masonry if no posterboard view is available.
+		if ( $container.length === 0 ) {
+			return;
+		}
+
+		// Get new width of container & columns.
+		container_width = $container.parent().width();
+		// Min column width locally is col_width (a variable set in the ai1ec
+		// settings by the global var $ai1ec_settings->posterboard_tile_min_width).
+		col_width = $container.data( 'ai1ecTileMinWidth' );
+		// We then stretch until the container width is filled.
+		num_columns = Math.floor( container_width / col_width );
+		// Don't create more columns than there are tiles.
+		num_columns = Math.min( num_columns, $tiles.length );
+		col_width = Math.floor( container_width / num_columns );
+
+		// Reset width to auto to bypass masonry inline CSS.
+		$container.css( 'width', 'auto' );
+
+		// Size event tiles to desired column width.
+		$tiles.width( col_width );
+
+		// Configure masonry on the view.
+		$container.imagesLoaded( function() {
+			var $loading = $( '#ai1ec-calendar-view-loading' );
+			$container
+				.masonry({
+					itemSelector: '.ai1ec-event',
+					isFitWidth: true,
+					isResizable: false, // We are handling resize events ourselves
+					isAnimated: true,
+					columnWidth: col_width,
+					animationOptions: { easing: 'swing' }
+				});
+		});
+
+		// Reload masonry; needed if it has already been initialized (most cases).
+		$container.imagesLoaded( function() {
+			$container.masonry( 'reload' );
+		});
+	};
+
+	/**
+	 * Reloads masonry on the active posterboard view, in case its contents have
+	 * changed.
+	 */
+	var reload_masonry = function() {
+		$( '.ai1ec-posterboard-view' ).masonry( 'reload' );
+	};
+
+	return {
+		resize_masonry: resize_masonry,
+		reload_masonry: reload_masonry
+	};
+} );
diff --git a/public/js_src/scripts/calendar/print.js b/public/js_src/scripts/calendar/print.js
new file mode 100644
index 0000000..9041b74
--- /dev/null
+++ b/public/js_src/scripts/calendar/print.js
@@ -0,0 +1,50 @@
+/**
+ * This module handles the print button behaviour.
+ */
+define(
+	[
+		"jquery_timely"
+	],
+	function( $ ) {
+	"use strict"; // jshint ;_;
+
+	/**
+	 * Handle clicks on the print button.
+	 *
+	 * @param {object} e jQuery Event object
+	 */
+	var handle_click_on_print_button = function( e ) {
+		e.preventDefault();
+		// get the calendar html
+		var $body = $( 'body' )
+		  , $html = $( 'html' )
+		  , view = $( '#ai1ec-container' ).html()
+		  , body = $body.html();
+		// Remove all scripts tag otherwise they are reapplied when the
+		// html is used.
+		body = body.replace( /<script.*?>([\s\S]*?)<\/script>/gmi, '' );
+		// Empty the page
+		$body.empty();
+		// Add the namespace to the body
+		$body.addClass( 'timely' );
+		// add the print class to the document
+		$html.addClass( 'ai1ec-print' );
+		// Attacch our calendar
+		$body.html( view );
+		// Disable clicking on title
+		$( 'span' ).click( function() {
+			return false;
+		} );
+		// Open the print screen
+		window.print();
+		// remove classes we added
+		$body.removeClass( 'timely' );
+		$html.removeClass( 'ai1ec-print' );
+		// Attach back the body
+		$body.html( body );
+	};
+
+	return {
+		handle_click_on_print_button     : handle_click_on_print_button
+	};
+} );
diff --git a/public/js_src/scripts/calendar/submit_ics_modal.js b/public/js_src/scripts/calendar/submit_ics_modal.js
new file mode 100644
index 0000000..ad430fa
--- /dev/null
+++ b/public/js_src/scripts/calendar/submit_ics_modal.js
@@ -0,0 +1,85 @@
+define(
+	[
+		"jquery_timely",
+		"ai1ec_config",
+		"libs/utils",
+		"libs/recaptcha",
+		"libs/select2_multiselect_helper",
+		"libs/collapse_helper",
+		"external_libs/Placeholders"
+	],
+	function( $, ai1ec_config, utils, recaptcha, select2_multiselect_helper ) {
+	"use strict"; // jshint ;_;
+
+	var $form = $( '.ai1ec-submit-ics-form' )
+	 ,  $spinner = $( '#ai1ec-submit-ics-modal .ai1ec-loading' );
+
+	/**
+	 * Initialize the iCalendar feed submission form.
+	 */
+	var init_form = function() {
+		recaptcha.init_recaptcha( $form );
+		select2_multiselect_helper.init( $form );
+	};
+
+	var init_recaptcha = function() {
+		recaptcha.init_recaptcha( $form );
+	};
+
+	var handle_form_submission = function( e ) {
+		e.preventDefault();
+		$( '.ai1ec-alerts', $form ).html( '' );
+		var ics = $( '#ai1ec_calendar_url', $form ).val();
+		var email = $( '#ai1ec_submitter_email', $form ).val();
+		if( ics === '' || email === '' ) {
+			var $alert = utils.make_alert( ai1ec_config.mail_url_required, 'error', true );
+			$( '.ai1ec-alerts', $form ).append( $alert );
+		}
+		else {
+			if( ! utils.isUrl( ics ) ) {
+				var $alert = utils.make_alert( ai1ec_config.invalid_url_message, 'error', true );
+				$( '.ai1ec-alerts', $form ).append( $alert );
+				$( '#ai1ec_calendar_url', $form ).focus();
+				return;
+			}
+			if( ! utils.isValidEmail( email ) ) {
+				var $alert = utils.make_alert( ai1ec_config.invalid_email_message, 'error', true );
+				$( '.ai1ec-alerts', $form ).append( $alert );
+				$( '#ai1ec_submitter_email', $form ).focus();
+				return;
+			}
+
+			var form_data = $form.serialize();
+			$spinner.addClass( 'show' );
+			$.ajax( {
+				data: form_data + "&action=ai1ec_add_ics_frontend",
+				type: 'POST',
+				dataType: 'json',
+				url: ai1ec_config.ajax_url,
+				success: function( data ) {
+					$spinner.removeClass( 'show' );
+					if ( $( '#recaptcha_response_field', $form ).length &&
+					     typeof Recaptcha !== 'undefined' ) {
+						// Fetch new CAPTCHA challenge.
+						Recaptcha.reload();
+					}
+					var outcome = data.success ? 'success' : 'error';
+					var $alert = utils.make_alert( data.message, outcome, true );
+					$( '.ai1ec-alerts', $form ).append( $alert );
+					$( '.ai1ec-nonce-fields', $form ).html( data.nonce );
+					if ( 'success' === outcome ) {
+						$( '#ai1ec_calendar_url, #ai1ec_submitter_email', $form ).val( '' );
+						$( '#ai1ec_categories', $form ).select2( "val", "" );
+					}
+				}
+			} );
+		}
+	};
+
+	return {
+		handle_form_submission : handle_form_submission,
+		init_form              : init_form,
+		init_recaptcha         : init_recaptcha
+	};
+
+} );
diff --git a/public/js_src/scripts/common_scripts/backend/common_ajax_handlers.js b/public/js_src/scripts/common_scripts/backend/common_ajax_handlers.js
new file mode 100644
index 0000000..dd8ec35
--- /dev/null
+++ b/public/js_src/scripts/common_scripts/backend/common_ajax_handlers.js
@@ -0,0 +1,58 @@
+define(
+	[
+		"jquery_timely"
+	],
+	function( $ ) {
+	"use strict"; // jshint ;_;
+
+	var handle_dismiss_plugins = function( response ) {
+		if ( response ) {
+			if( typeof response.message !== 'undefined' ) {
+				window.alert( response.message );
+			} else {
+				$( '.ai1ec-facebook-cron-dismiss-notification' ).closest( '.message' ).fadeOut();
+			}
+		}
+	};
+
+	var handle_dismiss_notification = function( response ) {
+		if( response.error ) {
+			// tell the user that there is an error
+			window.alert( response.message );
+		} else {
+			// hide notification message
+			$( '.ai1ec-dismiss-notification' ).closest( '.message' ).fadeOut();
+		}
+	};
+
+	var handle_dismiss_intro_video = function( response ) {
+		if( response.error ) {
+			// Tell the user that there is an error.
+			window.alert( response.message );
+		} else {
+			// Hide notification message.
+			$( '.ai1ec-dismiss-intro-video' ).closest( '.message' ).fadeOut();
+		}
+	};
+
+	/**
+	 * AJAX result after clicking Dismiss in license warning.
+	 * @param  {object} response Data returned by HTTP response
+	 */
+	var handle_dismiss_license_warning = function( response ) {
+		if( response.error ) {
+			// Tell the user that there is an error.
+			window.alert( response.message );
+		} else {
+			// Hide notification message.
+			$( '.ai1ec-dismiss-license-warning' ).closest( '.message' ).fadeOut();
+		}
+	};
+
+	return {
+		handle_dismiss_plugins        : handle_dismiss_plugins,
+		handle_dismiss_notification   : handle_dismiss_notification,
+		handle_dismiss_intro_video    : handle_dismiss_intro_video,
+		handle_dismiss_license_warning: handle_dismiss_license_warning
+	};
+} );
diff --git a/public/js_src/scripts/common_scripts/backend/common_backend.js b/public/js_src/scripts/common_scripts/backend/common_backend.js
new file mode 100644
index 0000000..7916f1b
--- /dev/null
+++ b/public/js_src/scripts/common_scripts/backend/common_backend.js
@@ -0,0 +1,162 @@
+/*global YT:true*/
+define(
+	[
+		"jquery_timely",
+		"domReady",
+		"ai1ec_config",
+		"scripts/common_scripts/backend/common_event_handlers",
+		"external_libs/Placeholders",
+		"external_libs/bootstrap_tooltip",
+		"external_libs/bootstrap_popover",
+		"libs/modal_helper"
+	],
+	function( $, domReady, ai1ec_config, event_handlers ) {
+	"use strict"; // jshint ;_;
+
+	var add_export_to_facebook = function() {
+		// When we have select the "Show only events that can be exported to facebook" filter and when there are rows in the table
+		if( $( '#ai1ec-facebook-filter option[value=exportable]:selected' ).length > 0 && $( 'table.wp-list-table tr.no-items' ).length === 0 && ai1ec_config.facebook_logged_in === "1" ) {
+			// Add the bulk action to the selects
+			$( '<option>' ).val( 'export-facebook' ).text( "Export to facebook" ).appendTo( "select[name='action']" );
+			$( '<option>' ).val( 'export-facebook' ).text( "Export to facebook" ).appendTo( "select[name='action2']" );
+		}
+	};
+
+	var handle_platform_mode = function() {
+		if( ai1ec_config.platform_active === "1" ) {
+			// Hide certain menu links from Events menu (Settings, Themes,
+			// Theme Options). If any of them are active, activate their duplicate
+			// ones in the other locations.
+			$( '#menu-posts-ai1ec_event li' ).each( function() {
+				var $li = $( this );
+				if ( $li.has( 'a[href$="all-in-one-event-calendar-themes"], ' +
+				              'a[href$="all-in-one-event-calendar-edit-css"], ' +
+				              'a[href$="all-in-one-event-calendar-settings"]' ).length ) {
+					if ( $li.is( '.current' ) ) {
+						var url = $( 'a', $li ).attr( 'href' );
+						// Find this menu item's duplicate menu item and activate it.
+						$( '#adminmenu a:not(.current)[href="' + url + '"]' ) // <a>
+							.parent()                                           // <li>
+								.andSelf()                                        // <li> + <a>
+									.addClass( 'current' )
+								.end()                                            // <li>
+								.closest( 'li.menu-top' )             // parent menu <li>
+								  .find( '> a.menu-top' )             // parent menu <li>'s <a>
+								    .andSelf()                        // parent menu <li> + its <a>
+								  .addClass( 'wp-has-current-submenu wp-menu-open' )
+								  .removeClass( 'wp-not-current-submenu' );
+						// Deactivate this menu item's parent menu.
+						$li.closest( 'li.menu-top' )
+							.find( '> a.menu-top' )
+							.andSelf()
+							.removeClass( 'wp-has-current-submenu wp-menu-open' )
+							.addClass( 'wp-not-current-submenu' );
+					}
+					// Finally, hide this menu item altogether.
+					$li.hide();
+				}
+			});
+			// Make changes to the WordPress Settings > Reading page.
+			if( $( 'body.options-reading-php' ).length ) {
+				var disable_front_page_option = function() {
+					$( '#page_on_front' ).attr( 'disabled', 'disabled' );
+				};
+				disable_front_page_option();
+				$( '#front-static-pages input:radio' ).change( disable_front_page_option );
+				$( '#page_on_front' ).after( '<span class="description">' + ai1ec_config.page_on_front_description + '</span>' );
+			}
+			// In strict mode, aggressively remove elements from the admin interface.
+			if( ai1ec_config.strict_mode === "1" ) {
+				$( '#dashboard-widgets .postbox' )
+					.not( '#ai1ec-calendar-tasks, #dashboard_right_now' )
+					.remove();
+				$( '#adminmenu > li' )
+					.not( '.wp-menu-separator, #menu-dashboard, #menu-posts-ai1ec_event, #menu-media, #menu-appearance, #menu-users, #menu-settings' )
+					.remove();
+				$( '#menu-appearance > .wp-submenu li, #menu-settings > .wp-submenu li' )
+					.not( ':has(a[href*="all-in-one-event-calendar"])' )
+					.remove();
+			}
+		}
+	};
+
+	var initialize_modal_video = function() {
+
+		if ( $( '#ai1ec-video' ).length ) {
+			// TODO: Load YouTube IFrame Player API async using requirejs (right?)
+			// TODO: Separate event handlers into common_event_handlers.js. Tried this
+			// already and had difficulties; maybe the Bootstrap modal code wasn't
+			// initialized yet? Weird error messages.
+
+			// Load the YouTube IFrame Player API code asynchronously.
+			$.ajax({
+				cache : true,
+				async : true,
+				dataType : 'script',
+				url : '//www.youtube.com/iframe_api'
+			});
+
+
+			// Create an <iframe> (and YouTube player) after the API code downloads.
+			window.onYouTubeIframeAPIReady = function() {
+
+				var player = new YT.Player( 'ai1ec-video', {
+					height: '368',
+					width: '600',
+					videoId: window.ai1ecVideo.youtubeId
+				});
+				$( '#ai1ec-video' ).css( 'display', 'block' );
+
+				$( '#ai1ec-video-modal' ).on( 'hide', function() {
+					player.stopVideo();
+				} );
+			};
+		}
+	};
+
+	var attach_event_handlers_backend = function() {
+		$( document )
+			.on( 'click', '.ai1ec-facebook-cron-dismiss-notification',  event_handlers.dismiss_plugins_messages_handler )
+			.on( 'click', '.ai1ec-dismiss-notification', event_handlers.dismiss_notification_handler )
+			.on( 'click', '.ai1ec-dismiss-intro-video', event_handlers.dismiss_intro_video_handler )
+			.on( 'click', '.ai1ec-dismiss-license-warning', event_handlers.dismiss_license_warning_handler )
+			.on( 'click', '.ai1ec-limit-by-cat, .ai1ec-limit-by-tag, .ai1ec-limit-by-event', event_handlers.handle_multiselect_containers_widget_page );
+	};
+
+	/**
+	 * Initialize any popovers & tooltips required on the page.
+	 */
+	var initialize_popovers = function() {
+		// Popovers in Support box (if present) need to be initialized specially.
+		$( '#ai1ec-support .ai1ec-download a[title]' ).popover( {
+			placement: 'left'
+		} );
+		// Initialize any tooltips.
+		$( '.ai1ec-tooltip-toggle' ).tooltip();
+	};
+
+	// If it was set in the backend, run the script
+	if( ai1ec_config.page !== '' ) {
+		$( '.if-js-closed' ).removeClass( 'if-js-closed' ).addClass( 'closed' );
+		postboxes.add_postbox_toggles( ai1ec_config.page  );
+	}
+
+	var start = function() {
+		domReady( function() {
+			// Attach the export to Facebook functionality.
+			add_export_to_facebook();
+			// Initialize modal video if present.
+			initialize_modal_video();
+			// Attach the event handlers.
+			attach_event_handlers_backend();
+			// Handle event platform mode.
+			handle_platform_mode();
+			// Initialize any popovers.
+			initialize_popovers();
+		} );
+	};
+
+	return {
+		start : start
+	};
+} );
diff --git a/public/js_src/scripts/common_scripts/backend/common_event_handlers.js b/public/js_src/scripts/common_scripts/backend/common_event_handlers.js
new file mode 100644
index 0000000..ff781df
--- /dev/null
+++ b/public/js_src/scripts/common_scripts/backend/common_event_handlers.js
@@ -0,0 +1,80 @@
+define(
+	[
+		"jquery_timely",
+		"scripts/common_scripts/backend/common_ajax_handlers"
+	],
+	function( $, ajax_handlers ) {
+	"use strict"; // jshint ;_;
+
+	var dismiss_plugins_messages_handler = function( e ) {
+		var data = {
+			"action" : 'ai1ec_facebook_cron_dismiss'
+		};
+		$.post(
+				ajaxurl,
+				data,
+				ajax_handlers.handle_dismiss_plugins,
+				'json'
+			);
+	};
+
+	var dismiss_notification_handler = function( e ) {
+		var $button = $( this );
+		// disable the update button
+		$button.attr( 'disabled', true );
+
+		// create the data to send
+		var data = {
+			action: 'ai1ec_disable_notification',
+			note  : false
+		};
+
+		$.post( ajaxurl, data, ajax_handlers.handle_dismiss_notification ) ;
+	};
+
+	var dismiss_intro_video_handler = function( e ) {
+		var $button = $( this );
+		// Disable the update button.
+		$button.attr( 'disabled', true );
+
+		// Create the data to send.
+		var data = {
+			action: 'ai1ec_disable_intro_video',
+			note  : false
+		};
+
+		$.post( ajaxurl, data, ajax_handlers.handle_dismiss_intro_video ) ;
+	};
+
+	/**
+	 * Dismiss button clicked in invalid license warning.
+	 *
+	 * @param  {Event} e jQuery event object
+	 */
+	var dismiss_license_warning_handler = function( e ) {
+		var $button = $( this );
+		// Disable the update button.
+		$button.attr( 'disabled', true );
+
+		// Create the data to send.
+		var data = {
+			action: 'ai1ec_set_license_warning',
+			value: 'dismissed'
+		};
+
+		$.post( ajaxurl, data, ajax_handlers.handle_dismiss_license_warning ) ;
+	};
+
+	// Show/hide the multiselect containers when user clicks on "limit by" widget options
+	var handle_multiselect_containers_widget_page = function( e ) {
+		$( this ).parent().next( '.ai1ec-limit-by-options-container' ).toggle();
+	};
+
+	return {
+		dismiss_plugins_messages_handler          : dismiss_plugins_messages_handler,
+		dismiss_notification_handler              : dismiss_notification_handler,
+		dismiss_intro_video_handler               : dismiss_intro_video_handler,
+		dismiss_license_warning_handler           : dismiss_license_warning_handler,
+		handle_multiselect_containers_widget_page : handle_multiselect_containers_widget_page
+	};
+} );
diff --git a/public/js_src/scripts/common_scripts/frontend/common_event_handlers.js b/public/js_src/scripts/common_scripts/frontend/common_event_handlers.js
new file mode 100644
index 0000000..06fa51f
--- /dev/null
+++ b/public/js_src/scripts/common_scripts/frontend/common_event_handlers.js
@@ -0,0 +1,160 @@
+define(
+	[
+		"jquery_timely",
+		"scripts/calendar/posterboard_view"
+	],
+	function( $, posterboard_view ) {
+	"use strict"; // jshint ;_;
+
+	/**
+	 * Handler for popover trigger: mouseenter.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_popover_over = function( e ) {
+		var $this = $( this ),
+				$pop_content = $this.next( '.ai1ec-popup' ),
+				el_content_data, el_classes_data, popover_placement;
+
+		// If no popover found, quit.
+		if ( $pop_content.length === 0 ) {
+			return;
+		}
+
+		el_content_data = $pop_content.html();
+		el_classes_data = $pop_content.attr( 'class' );
+
+		// Position popover to the left only if there's room for it within the
+		// bounds of the view (popovers are 182 pixels wide, a product of padding
+		// and inner width as defined in style.less).
+		var $bounds = $this.closest( '#ai1ec-calendar-view' );
+		if ( $bounds.length === 0 ) {
+			$bounds = $( 'body' );
+		}
+		if ( $this.offset().left - $bounds.offset().left > 182 ) {
+			popover_placement = 'left';
+		} else {
+			popover_placement = 'right';
+		}
+
+		$this.constrained_popover( {
+			content: el_content_data,
+			title: '',
+			placement: popover_placement,
+			trigger: 'manual',
+			html: true,
+			template: '<div class="timely popover ' + el_classes_data +
+				'"><div class="arrow"></div><div class="popover-inner">' +
+				'<div class="popover-content"><div></div></div></div></div></div>',
+			container: $this.closest( '.ai1ec-popover-boundary' )
+		}).constrained_popover( 'show' );
+	};
+
+	/**
+	 * Handler for popover trigger: mouseleave. Remove popup if entering an
+	 * element that is not the popup.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_popover_out = function( e ) {
+		var $el = $( e.toElement || e.relatedTarget );
+		// If an ancestor of element being entered is not a popup, hide popover.
+		if ( $el.closest( '.ai1ec-popup' ).length === 0 ) {
+			$( this ).constrained_popover( 'hide' );
+		}
+	};
+
+	/**
+	 * Handler for popover; remove the popover on mouseleave of itself. Hide popup
+	 * if entering an element that is not a tooltip.
+	 * Also remove any visible tooltip if removing popup.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_popover_self_out = function( e ) {
+		var $el = $( e.toElement || e.relatedTarget );
+		// If an ancestor of element being entered is not a tooltip, hide popover.
+		if ( $el.closest( '.tooltip' ).length === 0 ) {
+			$( this ).remove();
+			$( 'body > .tooltip' ).remove();
+		}
+	};
+
+	/**
+	 * Manually handle tooltip mouseenter. Need to apply .timely namespace.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_tooltip_over = function( e ) {
+		var $this = $( this ),
+		    params = {
+					template: '<div class="timely tooltip">' +
+						'<div class="tooltip-arrow"></div><div class="tooltip-inner">' +
+						'</div></div>',
+					trigger: 'manual'
+				};
+
+		// Don't add tooltips to category colour squares already contained in
+		// descriptive category labels.
+		if ( $this.is( '.ai1ec-category .ai1ec-color-swatch' ) ) {
+			return;
+		}
+
+		$this.tooltip( params );
+		$this.tooltip( 'show' );
+	};
+
+	/**
+	 * Manually handle tooltip mouseleave. Do not hide if entering tooltip or
+	 * tooltip triggering action.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_tooltip_out = function( e ) {
+		var $el = $( e.toElement || e.relatedTarget );
+		if ( $el.closest( '.tooltip' ).length === 0 ) {
+			$( this ).tooltip( 'hide' );
+		}
+	};
+
+	/**
+	 * Handler for tooltip; remove the tooltip on mouseleave of itself, unless
+	 * moving onto the tooltip trigger action. If moving onto an element that is
+	 * not in a popup, hide any visible popup.
+	 *
+	 * @param  {object} e JS event object
+	 */
+	var handle_tooltip_self_out = function( e ) {
+		var $el = $( e.toElement || e.relatedTarget );
+		// If an ancestor of element being entered is not a tooltip trigger action,
+		// hide tooltip.
+		if ( $el.closest( '.ai1ec-tooltip-trigger' ).length === 0 ) {
+			$( this ).remove();
+		}
+		// If an ancestor of element being entered is not a popup, hide any popup.
+		if ( $el.closest( '.ai1ec-popup' ).length === 0 ) {
+			$( 'body > .ai1ec-popup' ).remove();
+		}
+	};
+
+	/**
+	 * Handler for web font loader. Do any required actions when web fonts are
+	 * loaded.
+	 */
+	var handle_fonts_loaded = function( e ) {
+		posterboard_view.resize_masonry();
+		if ( $( 'html' ).is( '#ie8' ) ) {
+			//$( '[class^="icon-"]' ).css( 'zoom', '1' );
+		}
+	};
+
+	return {
+		handle_popover_over        : handle_popover_over,
+		handle_popover_out         : handle_popover_out,
+		handle_popover_self_out    : handle_popover_self_out,
+		handle_tooltip_over        : handle_tooltip_over,
+		handle_tooltip_out         : handle_tooltip_out,
+		handle_tooltip_self_out    : handle_tooltip_self_out,
+		handle_fonts_loaded        : handle_fonts_loaded
+	};
+} );
diff --git a/public/js_src/scripts/common_scripts/frontend/common_frontend.js b/public/js_src/scripts/common_scripts/frontend/common_frontend.js
new file mode 100644
index 0000000..357262e
--- /dev/null
+++ b/public/js_src/scripts/common_scripts/frontend/common_frontend.js
@@ -0,0 +1,74 @@
+define(
+	[
+		"jquery_timely",
+		"domReady",
+		"scripts/common_scripts/frontend/common_event_handlers",
+		"ai1ec_calendar",
+		"external_libs/modernizr",
+		"external_libs/bootstrap_tooltip",
+		"external_libs/bootstrap_popover",
+		"external_libs/bootstrap_dropdown"
+	],
+	function( $, domReady, event_handlers, ai1ec_calendar, Modernizr ) {
+	"use strict"; // jshint ;_;
+
+	var event_listeners_attached = false;
+
+	var attach_event_handlers_frontend = function() {
+		event_listeners_attached = true;
+		$( document ).on( 'mouseenter', '.ai1ec-popup-trigger', event_handlers.handle_popover_over );
+		$( document ).on( 'mouseleave', '.ai1ec-popup-trigger', event_handlers.handle_popover_out );
+		$( document ).on( 'mouseleave', '.ai1ec-popup', event_handlers.handle_popover_self_out );
+		$( document ).on( 'mouseenter', '.ai1ec-tooltip-trigger', event_handlers.handle_tooltip_over );
+		$( document ).on( 'mouseleave', '.ai1ec-tooltip-trigger', event_handlers.handle_tooltip_out );
+		$( document ).on( 'mouseleave', '.tooltip', event_handlers.handle_tooltip_self_out );
+	};
+
+	/**
+	 * Load the fonts and trigger actions to happen when fonts have loaded.
+	 */
+	var load_fonts = function() {
+		var families = [];
+		var url = [];
+		$.each( ai1ec_calendar.fonts, function() {
+			families.push( this.name );
+			url.push( this.url );
+		} );
+		var data = {
+			active: event_handlers.handle_fonts_loaded,
+			custom : {
+				families : families,
+				urls : url
+			}
+		};
+		require(
+			[ 'external_libs/webfont' ],
+			function() {
+				WebFont.load(data);
+			} );
+	};
+
+	/**
+	 * Initialize page.
+	 */
+	var start = function() {
+		load_fonts();
+		domReady( function() {
+			attach_event_handlers_frontend();
+		} );
+	};
+
+	/**
+	 * Returns whether event listeners have been attached.
+	 *
+	 * @return {boolean}
+	 */
+	var are_event_listeners_attached = function() {
+		return event_listeners_attached;
+	};
+
+	return {
+		start                        : start,
+		are_event_listeners_attached : are_event_listeners_attached
+	};
+} );
diff --git a/public/js_src/scripts/event.js b/public/js_src/scripts/event.js
new file mode 100644
index 0000000..1d5afe1
--- /dev/null
+++ b/public/js_src/scripts/event.js
@@ -0,0 +1,93 @@
+define(
+		[
+		 "jquery_timely",
+		 'domReady',
+		 'ai1ec_config',
+		 'scripts/event/gmaps_helper',
+		 'libs/utils',
+		 'external_libs/jquery_cookie',
+		 'external_libs/bootstrap_modal',
+		 'external_libs/bootstrap_transition',
+		 'external_libs/bootstrap_alert',
+		 'libs/modal_helper'
+		 ],
+		 function( $, domReady, ai1ec_config, gmaps_helper, utils ) {
+	"use strict"; // jshint ;_;
+	var cookie_name = 'ai1ec_event_subscribed';
+	$.cookie.json = true;
+	// Perform all initialization functions required on the page.
+	var init = function() {
+		if( $( '#ai1ec-gmap-canvas' ).length > 0 ) {
+			require( ['libs/gmaps' ], function( gMapsLoader ) {
+				gMapsLoader( gmaps_helper.init_gmaps );
+			} );
+		}
+	};
+	var subscribe_to_event = function( e ) {
+		e.preventDefault();
+		var mail = $( '#ai1ec_email_subscribe' ).val();
+		if( ! utils.isValidEmail( mail ) ) {
+			window.alert( ai1ec_config.invalid_email_message );
+			$( '#ai1ec_email_subscribe' ).focus();
+			return;
+		}
+		var event = $( '.ai1ec_email_container' ).data( 'event_id' );
+		var event_instance = $( '.ai1ec_email_container' ).data( 'event_instance' );
+		var data = {
+			action : 'ai1ec_subscribe_to_event',
+			mail : mail,
+			event : event,
+			event_instance : event_instance
+		};
+		$.post(
+			ai1ec_config.ajax_url,
+			data,
+			function( data ) {
+				var alert = utils.make_alert( data.message, data.type );
+				$modal = $( '#ai1ec_subscribe_email_modal' );
+				$( '.alerts', $modal ).append( alert );
+				if( data.type === 'success' ) {
+					var saved_cookie = $.cookie( cookie_name );
+					if( undefined === saved_cookie ) {
+						saved_cookie = [];
+					}
+					saved_cookie.push( event_instance );
+					// if the user has subscribed, set a cookie to avoid showing the button again
+					$.cookie( cookie_name, saved_cookie, { expires : 365 } );
+					// remove the button
+					$( '.ai1ec-subscribe-mail' ).remove();
+				}
+				$( '.btn-danger', $modal ).show();
+				$( '.btn-primary', $modal ).hide();
+				$( '.ai1ec_email_container', $modal ).hide();
+			},
+			'json'
+		);
+	};
+	var attach_event_handlers = function() {
+		$modal = $( '#ai1ec_subscribe_email_modal' );
+		// handle showing the maps when clicking on the placeholder
+		$( '.ai1ec-gmap-placeholder:first' ).click( gmaps_helper.handle_show_map_when_clicking_on_placeholder );
+		$modal
+			.modal( { show: false } )
+			.on( 'hidden', function() {
+				// remove the backdrop since firefox has problems with transitionend
+				$( '.ai1ec-modal-backdrop' ).remove();
+			} );
+		$modal.on( 'click', '.btn-primary', subscribe_to_event );
+		$modal.on( 'click', '.btn-danger', function() {
+			$modal.modal( 'hide' );
+		} );
+	};
+	var start = function() {
+		domReady( function() {
+			// Initialize the page.
+			// We wait for the DOM to be loaded so we load gMaps only when needed
+			init();
+			attach_event_handlers();
+		} );
+	};
+	return {
+		start: start
+	};
+} );
diff --git a/public/js_src/scripts/event/gmaps_helper.js b/public/js_src/scripts/event/gmaps_helper.js
new file mode 100644
index 0000000..55082c2
--- /dev/null
+++ b/public/js_src/scripts/event/gmaps_helper.js
@@ -0,0 +1,41 @@
+define(
+		[
+		 "jquery_timely"
+		 ],
+		 function( $ ) {
+	"use strict"; // jshint ;_;
+	var init_gmaps = function() {
+		var options = {
+				zoom      : 14,
+				mapTypeId : google.maps.MapTypeId.ROADMAP
+			};
+			var map = new google.maps.Map( document.getElementById( 'ai1ec-gmap-canvas' ), options );
+			var marker = new google.maps.Marker( { map: map } );
+			var geocoder = new google.maps.Geocoder();
+
+			geocoder.geocode(
+				{
+					'address': document.getElementById( 'ai1ec-gmap-address' ).value
+				},
+				function( results, status ) {
+					if( status === google.maps.GeocoderStatus.OK ) {
+						map.setCenter( results[0].geometry.location );
+						marker.setPosition( results[0].geometry.location );
+					}
+				}
+			);
+	};
+	var handle_show_map_when_clicking_on_placeholder = function() {
+		var map_el = $( '.ai1ec-gmap-container-hidden:first');
+		// delete placeholder
+		$( this ).remove();
+		// hide map
+		map_el.hide();
+		map_el.removeClass( 'ai1ec-gmap-container-hidden' );
+		map_el.fadeIn();
+	};
+	return {
+		handle_show_map_when_clicking_on_placeholder : handle_show_map_when_clicking_on_placeholder,
+		init_gmaps                                   : init_gmaps
+	};
+} );
\ No newline at end of file
diff --git a/public/js_src/scripts/event_category.js b/public/js_src/scripts/event_category.js
new file mode 100644
index 0000000..07a408e
--- /dev/null
+++ b/public/js_src/scripts/event_category.js
@@ -0,0 +1,131 @@
+define(
+		[
+		 "jquery_timely",
+		 "external_libs/colorpicker",
+		 "external_libs/tax_meta_class"
+		 ],
+		 function( $ ) {
+	"use strict"; // jshint ;_;
+$( '#tag-color' ).click( function() {
+	var fs_offset = $( '#tag-color' ).offset();
+	var top = fs_offset.top + $( '#tag-color' ).height() ;
+	var left = fs_offset.left + 1;
+	var ul_el = $( '<ul></ul>');
+	var li_els = $(
+		'<li style="color: #60a;" class="color-1"></li>' + // 1
+		'<li style="color: #807;" class="color-2"></li>' + // 2
+		'<li style="color: #920;" class="color-3"></li>' + // 3
+		'<li style="color: #a60;" class="color-4"></li>' + // 4
+		'<li style="color: #990;" class="color-5"></li>' + // 5
+		'<li style="color: #080;" class="color-6"></li>' + // 6
+		'<li style="color: #077;" class="color-7"></li>' + // 7
+		'<li style="color: #00a;" class="color-8"></li>' + // 8
+		'<li style="color: #000;" class="color-9"></li>' + // 9
+		'<li style="color: #444;" class="color-10"></li>' + // 10
+		'<li style="color: #85e;" class="color-11"></li>' + // 11
+		'<li style="color: #d5d;" class="color-12"></li>' + // 12
+		'<li style="color: #d43;" class="color-13"></li>' + // 13
+		'<li style="color: #d90;" class="color-14"></li>' + // 14
+		'<li style="color: #bb0;" class="color-15"></li>' + // 15
+		'<li style="color: #2b0;" class="color-16"></li>' + // 16
+		'<li style="color: #0ba;" class="color-17"></li>' + // 17
+		'<li style="color: #26d;" class="color-18"></li>' + // 18
+		'<li style="color: #777;" class="color-19"></li>' + // 19
+		'<li style="color: #aaa;" class="color-20"></li>' + // 20
+		'<li style="color: #aab;" class="color-21"></li>'   // 21
+	);
+	var more_color = $( '<li class="select-more-colors">More colors</li>' );
+	$( more_color ).ColorPicker({
+		onSubmit: function( hsb, hex, rgb, el ) {
+			$( '#tag-color-background' ).css( 'background-color', '#' + hex );
+			$( '#tag-color-value' ).val( '#' + hex );
+			$(el).ColorPickerHide();
+			ul_el.remove();
+		},
+		onBeforeShow: function () {
+			ul_el.hide();
+			$( document ).unbind( 'mousedown', hide_color_selector );
+			var color = $( '#tag-color-value' ).val();
+			color = color.length > 0 ? color : '#ffffff';
+			$( this ).ColorPickerSetColor( color );
+		}
+	});
+	// Add click event for each font style
+	li_els.click( function() {
+		if( rgb2hex( $(this).css( 'color' ) ) !== "#aaaabb" ){
+			$( '#tag-color-background' ).css( 'background-color', $(this).css( 'color' ) );
+			$( '#tag-color-value' ).val( rgb2hex( $(this).css( 'color' ) )  );
+			ul_el.remove();
+		}
+		else{
+			$( '#tag-color-background' ).css( 'background-color', "" );
+			$( '#tag-color-value' ).val( "" );
+			ul_el.remove();
+		}
+	});
+
+	// append li elements to the ul holder
+	ul_el.append( li_els ).append( more_color );
+
+	// append ul holder to the body
+	ul_el
+	.appendTo( 'body' )
+	.css( {
+		position: 'absolute',
+		top: top + 'px',
+		left: left + 'px',
+		width: '105px',
+		height: '70px',
+		'z-index': 1,
+		background: '#fff',
+		border: '1px solid #ccc'
+	})
+	.addClass( 'colorpicker-list' );
+	$( document ).bind( 'mousedown', {ls: ul_el}, hide_color_selector );
+});
+
+// remove category color click
+$( "#tag-color-value-remove" ).click(function(){
+	$( "#tag-color-background" ).css( "background-color","" );
+	$( "#tag-color-value" ).val("");
+});
+
+var rgb2hex = function( rgb ) {
+	rgb = rgb.match( /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/ );
+	return "#" + hex( rgb[1] ) + hex( rgb[2] ) + hex( rgb[3] );
+};
+
+var hex = function( x ) {
+	return ( "0" + parseInt( x, 10 ).toString( 16 ) ).slice( -2 );
+};
+
+var hide_color_selector = function( ev ) {
+	if( ! is_child_of( ev.data.ls.get( 0 ), ev.target, ev.data.ls.get( 0 ) ) ) {
+		$( ev.data.ls.get(0) ).remove();
+		$( document ).unbind( 'mousedown', hide_color_selector );
+	}
+};
+var is_child_of = function( parentEl, el, container ) {
+	/*jshint bitwise: false */
+	if( parentEl === el ){
+		return true;
+	}
+
+	if( parentEl.contains ) {
+		return parentEl.contains( el );
+	}
+
+	if( parentEl.compareDocumentPosition ) {
+		return !!(parentEl.compareDocumentPosition(el) & 16);
+	}
+
+	var prEl = el.parentNode;
+	while( prEl && prEl !== container ) {
+		if( prEl === parentEl ) {
+			return true;
+		}
+		prEl = prEl.parentNode;
+	}
+	return false;
+};
+} );
diff --git a/vendor/minify-2.1.7/.gitignore b/vendor/minify-2.1.7/.gitignore
new file mode 100755
index 0000000..f4558c7
--- /dev/null
+++ b/vendor/minify-2.1.7/.gitignore
@@ -0,0 +1,7 @@
+
+# /
+/test
+/docs
+.idea/
+.DS_Store
+vendor
diff --git a/vendor/minify-2.1.7/HISTORY.txt b/vendor/minify-2.1.7/HISTORY.txt
new file mode 100755
index 0000000..785b8ee
--- /dev/null
+++ b/vendor/minify-2.1.7/HISTORY.txt
@@ -0,0 +1,116 @@
+Minify Release History
+
+Version 2.1.7
+    * Fixes arbitrary file inclusion vulnerability on some systems.
+      * Thanks to Matt Mecham for reporting this.
+
+Version 2.1.6
+    * JSMin fixes
+    * Prevents some Closure Compiler API failures
+    * Uses autoloading for all class loading
+    * Multiple group support in HTML Helper
+    * Cache adaptor for XCache
+    * Allow setting stack-size in YUI Compressor wrapper
+    * Adds jsCleanComments option to HTML minifier
+    * Upgrades CSSmin
+    * CLI script more portable
+    * Adds composer.json
+
+Version 2.1.5
+    * Removed XSS vulnerability
+    * Disabled builder bby default
+    * command line tools to minify and rewrite URIs in CSS
+    * upgrade (optional) JSMin+ library
+    * more efficient JS minification when using CC/YUIC
+    * Closure Compiler uses cURL when allow_url_fopen is off
+    * Missing file notices when using groups
+
+Version 2.1.4
+    * Option to minify JS with Closure Compiler API w/ JSMin failover
+    * Cookie/bookmarklet-based debug mode. No HTML editing!
+    * Allows 1 file to be missing w/o complete failure
+    * Combine multiple groups and files in single URI
+    * More useful HTML helpers for writing versioned URIs
+    * More detailed error logging, including minifier exceptions
+    * Builder offers more helpful messages/PHP environment warnings
+    * Bypass minification based on filename pattern. e.g. foo.min.js / foo-min.css
+    * JSMin won't choke on common Closure compiler syntaxes (i+ ++j)
+    * Better caching in IE6
+    * Cache ids are influenced by group/file names
+    * Debug mode for Javascript doesn't break on common XPath strings (Prototype 1.6)
+    * Removed annoying maxFiles limit
+    * mbstring.func_overload usage is safer
+
+Version 2.1.3
+    * HTTP fixes
+      * ETag generation now valid (different when gzipped)
+      * Vary header always sent when Accept-Encoding is sniffed
+      * Cache-Control no longer has "must-revalidate" due to webkit bug
+        See: http://mrclay.org/index.php/2009/02/24/safari-4-beta-cache-controlmust-revalidate-bug/
+      * Dropped deflate encoding. Browser and proxy support could be buggy.
+        See: http://stackoverflow.com/questions/883841/
+    * File cache now works w/o setting $min_cachePath
+    * Allow setting contentType in Minify_Source objects
+    * No more 5.3 deprecation warnings: split() removed
+
+Version 2.1.2
+    * Javascript fixes
+      * Debug mode no longer confused by "*/*" in strings/RegExps (jQuery)
+      * quote characters inside RegExp literals no longer cause exception
+      * files ending in single-line comments no longer cause code loss
+    * CSS: data: URLs no longer mangled
+    * Optional error logging to Firefox's FirePHP extension
+    * Unit tests to check for common DOCUMENT_ROOT problems
+      * DOCUMENT_ROOT no longer overwritten on IIS servers
+    * Builder app doesn't fail on systems without gzdeflate()
+    * APC caching class included
+
+Version 2.1.1
+    * Bug fix release
+    * Detection and workarounds for zlib.output_compression and non-PHP encoding modules
+    * Zlib not required (mod_rewrite, et.al., can still be used for encoding)
+    * HTML : More IE conditional comments preserved
+    * Minify_groupUri() utility fixed
+
+Version 2.1.0
+    * "min" default application for quick deployment
+    * Minify URI Builder app & bookmarklet for quickly creating minify URIs
+    * Relative URIs in CSS file are fixed automatically by default
+    * "debug" mode for revealing original line #s in combined files
+    * Better IIS support
+    * Improved minifier classes:
+      * JS: preserves IE conditional comments
+      * CSS: smaller output, preserves more hacks and valid CSS syntax, 
+             shorter line lengths, other bug fixes
+      * HTML: smaller output, shorter line lengths, other bug fixes
+    * Default Cache-Control: max-age of 30 minutes
+    * Conditional GETs supported even when max-age sent
+    * Experimental memcache cache class (default is files)
+    * Minify_Cache_File has flock()s (by default)
+    * Workaround for Windows mtime reporting bug
+
+Version 2.0.2 beta (2008-06-24)
+    * Fast new cache system. Cached files served almost 3x as fast.
+    * Dropped support of compress encoding (though HTTP_Encoder still supports it)
+
+Version 2.0.1 (2008-05-31)
+    * E_STRICT compliance (Cache_Lite_File).
+
+Version 2.0.0 (2008-05-22)
+    * Complete code overhaul. Minify is now a PEAR-style class and toolkit 
+      for building customized minifying file servers.
+    * Content-Encoding: deflate/gzip/compress, based on request headers
+    * Expanded CSS and HTML minifiers with test cases
+    * Easily plug-in 3rd-party minifiers (like Packer)
+    * Plug-able front end controller allows changing the way files are chosen
+    * Compression & encoding modules lazy-loaded as needed (304 responses use 
+      use minimal code)
+    * Separate utility classes for HTTP encoding and cache control 
+
+Version 1.0.1 (2007-05-05)
+    * Fixed various problems resolving pathnames when hosted on an NFS mount.
+    * Fixed 'undefined constant' notice.
+    * Replaced old JSMin library with a much faster custom implementation.
+
+Version 1.0.0 (2007-05-02)
+    * First release.
\ No newline at end of file
diff --git a/vendor/minify-2.1.7/HTTP/ConditionalGet.php b/vendor/minify-2.1.7/HTTP/ConditionalGet.php
new file mode 100755
index 0000000..66ae36f
--- /dev/null
+++ b/vendor/minify-2.1.7/HTTP/ConditionalGet.php
@@ -0,0 +1,366 @@
+<?php
+/**
+ * Class Ai1ec_HTTP_ConditionalGet  
+ * @package Minify
+ * @subpackage HTTP
+ */
+
+/**
+ * Implement conditional GET via a timestamp or hash of content
+ *
+ * E.g. Content from DB with update time:
+ * <code>
+ * list($updateTime, $content) = getDbUpdateAndContent();
+ * $cg = new Ai1ec_HTTP_ConditionalGet(array(
+ *     'lastModifiedTime' => $updateTime
+ *     ,'isPublic' => true
+ * ));
+ * $cg->sendHeaders();
+ * if ($cg->cacheIsValid) {
+ *     exit();
+ * }
+ * echo $content;
+ * </code>
+ * 
+ * E.g. Shortcut for the above
+ * <code>
+ * Ai1ec_HTTP_ConditionalGet::check($updateTime, true); // exits if client has cache
+ * echo $content;
+ * </code>
+ *
+ * E.g. Content from DB with no update time:
+ * <code>
+ * $content = getContentFromDB();
+ * $cg = new Ai1ec_HTTP_ConditionalGet(array(
+ *     'contentHash' => md5($content)
+ * ));
+ * $cg->sendHeaders();
+ * if ($cg->cacheIsValid) {
+ *     exit();
+ * }
+ * echo $content;
+ * </code>
+ * 
+ * E.g. Static content with some static includes:
+ * <code>
+ * // before content
+ * $cg = new Ai1ec_HTTP_ConditionalGet(array(
+ *     'lastUpdateTime' => max(
+ *         filemtime(__FILE__)
+ *         ,filemtime('/path/to/header.inc')
+ *         ,filemtime('/path/to/footer.inc')
+ *     )
+ * ));
+ * $cg->sendHeaders();
+ * if ($cg->cacheIsValid) {
+ *     exit();
+ * }
+ * </code>
+ * @package Minify
+ * @subpackage HTTP
+ * @author Stephen Clay <steve@mrclay.org>
+ */
+class Ai1ec_HTTP_ConditionalGet {
+
+    /**
+     * Does the client have a valid copy of the requested resource?
+     * 
+     * You'll want to check this after instantiating the object. If true, do
+     * not send content, just call sendHeaders() if you haven't already.
+     *
+     * @var bool
+     */
+    public $cacheIsValid = null;
+
+    /**
+     * @param array $spec options
+     * 
+     * 'isPublic': (bool) if false, the Cache-Control header will contain
+     * "private", allowing only browser caching. (default false)
+     * 
+     * 'lastModifiedTime': (int) if given, both ETag AND Last-Modified headers
+     * will be sent with content. This is recommended.
+     *
+     * 'encoding': (string) if set, the header "Vary: Accept-Encoding" will
+     * always be sent and a truncated version of the encoding will be appended
+     * to the ETag. E.g. "pub123456;gz". This will also trigger a more lenient 
+     * checking of the client's If-None-Match header, as the encoding portion of
+     * the ETag will be stripped before comparison.
+     * 
+     * 'contentHash': (string) if given, only the ETag header can be sent with
+     * content (only HTTP1.1 clients can conditionally GET). The given string 
+     * should be short with no quote characters and always change when the 
+     * resource changes (recommend md5()). This is not needed/used if 
+     * lastModifiedTime is given.
+     * 
+     * 'eTag': (string) if given, this will be used as the ETag header rather
+     * than values based on lastModifiedTime or contentHash. Also the encoding
+     * string will not be appended to the given value as described above.
+     * 
+     * 'invalidate': (bool) if true, the client cache will be considered invalid
+     * without testing. Effectively this disables conditional GET. 
+     * (default false)
+     * 
+     * 'maxAge': (int) if given, this will set the Cache-Control max-age in 
+     * seconds, and also set the Expires header to the equivalent GMT date. 
+     * After the max-age period has passed, the browser will again send a 
+     * conditional GET to revalidate its cache.
+     */
+    public function __construct($spec)
+    {
+        $scope = (isset($spec['isPublic']) && $spec['isPublic'])
+            ? 'public'
+            : 'private';
+        $maxAge = 0;
+        // backwards compatibility (can be removed later)
+        if (isset($spec['setExpires']) 
+            && is_numeric($spec['setExpires'])
+            && ! isset($spec['maxAge'])) {
+            $spec['maxAge'] = $spec['setExpires'] - $_SERVER['REQUEST_TIME'];
+        }
+        if (isset($spec['maxAge'])) {
+            $maxAge = $spec['maxAge'];
+            $this->_headers['Expires'] = self::gmtDate(
+                $_SERVER['REQUEST_TIME'] + $spec['maxAge'] 
+            );
+        }
+        $etagAppend = '';
+        if (isset($spec['encoding'])) {
+            $this->_stripEtag = true;
+            $this->_headers['Vary'] = 'Accept-Encoding';
+            if ('' !== $spec['encoding']) {
+                if (0 === strpos($spec['encoding'], 'x-')) {
+                    $spec['encoding'] = substr($spec['encoding'], 2);
+                }
+                $etagAppend = ';' . substr($spec['encoding'], 0, 2);
+            }
+        }
+        if (isset($spec['lastModifiedTime'])) {
+            $this->_setLastModified($spec['lastModifiedTime']);
+            if (isset($spec['eTag'])) { // Use it
+                $this->_setEtag($spec['eTag'], $scope);
+            } else { // base both headers on time
+                $this->_setEtag($spec['lastModifiedTime'] . $etagAppend, $scope);
+            }
+        } elseif (isset($spec['eTag'])) { // Use it
+            $this->_setEtag($spec['eTag'], $scope);
+        } elseif (isset($spec['contentHash'])) { // Use the hash as the ETag
+            $this->_setEtag($spec['contentHash'] . $etagAppend, $scope);
+        }
+        $privacy = ($scope === 'private')
+            ? ', private'
+            : '';
+        $this->_headers['Cache-Control'] = "max-age={$maxAge}{$privacy}";
+        // invalidate cache if disabled, otherwise check
+        $this->cacheIsValid = (isset($spec['invalidate']) && $spec['invalidate'])
+            ? false
+            : $this->_isCacheValid();
+    }
+    
+    /**
+     * Get array of output headers to be sent
+     * 
+     * In the case of 304 responses, this array will only contain the response
+     * code header: array('_responseCode' => 'HTTP/1.0 304 Not Modified')
+     * 
+     * Otherwise something like: 
+     * <code>
+     * array(
+     *     'Cache-Control' => 'max-age=0, public'
+     *     ,'ETag' => '"foobar"'
+     * )
+     * </code>
+     *
+     * @return array 
+     */
+    public function getHeaders()
+    {
+        return $this->_headers;
+    }
+
+    /**
+     * Set the Content-Length header in bytes
+     * 
+     * With most PHP configs, as long as you don't flush() output, this method
+     * is not needed and PHP will buffer all output and set Content-Length for 
+     * you. Otherwise you'll want to call this to let the client know up front.
+     * 
+     * @param int $bytes
+     * 
+     * @return int copy of input $bytes
+     */
+    public function setContentLength($bytes)
+    {
+        return $this->_headers['Content-Length'] = $bytes;
+    }
+
+    /**
+     * Send headers
+     * 
+     * @see getHeaders()
+     * 
+     * Note this doesn't "clear" the headers. Calling sendHeaders() will
+     * call header() again (but probably have not effect) and getHeaders() will
+     * still return the headers.
+     *
+     * @return null
+     */
+    public function sendHeaders()
+    {
+        $headers = $this->_headers;
+        if (array_key_exists('_responseCode', $headers)) {
+            // FastCGI environments require 3rd arg to header() to be set
+            list(, $code) = explode(' ', $headers['_responseCode'], 3);
+            header($headers['_responseCode'], true, $code);
+            unset($headers['_responseCode']);
+        }
+        foreach ($headers as $name => $val) {
+            header($name . ': ' . $val);
+        }
+    }
+    
+    /**
+     * Exit if the client's cache is valid for this resource
+     *
+     * This is a convenience method for common use of the class
+     *
+     * @param int $lastModifiedTime if given, both ETag AND Last-Modified headers
+     * will be sent with content. This is recommended.
+     *
+     * @param bool $isPublic (default false) if true, the Cache-Control header 
+     * will contain "public", allowing proxies to cache the content. Otherwise 
+     * "private" will be sent, allowing only browser caching.
+     *
+     * @param array $options (default empty) additional options for constructor
+     */
+    public static function check($lastModifiedTime = null, $isPublic = false, $options = array())
+    {
+        if (null !== $lastModifiedTime) {
+            $options['lastModifiedTime'] = (int)$lastModifiedTime;
+        }
+        $options['isPublic'] = (bool)$isPublic;
+        $cg = new Ai1ec_HTTP_ConditionalGet($options);
+        $cg->sendHeaders();
+        if ($cg->cacheIsValid) {
+            exit();
+        }
+    }
+    
+    
+    /**
+     * Get a GMT formatted date for use in HTTP headers
+     * 
+     * <code>
+     * header('Expires: ' . Ai1ec_HTTP_ConditionalGet::gmtdate($time));
+     * </code>  
+     *
+     * @param int $time unix timestamp
+     * 
+     * @return string
+     */
+    public static function gmtDate($time)
+    {
+        return gmdate('D, d M Y H:i:s \G\M\T', $time);
+    }
+    
+    protected $_headers = array();
+    protected $_lmTime = null;
+    protected $_etag = null;
+    protected $_stripEtag = false;
+
+    /**
+     * @param string $hash
+     *
+     * @param string $scope
+     */
+    protected function _setEtag($hash, $scope)
+    {
+        $this->_etag = '"' . substr($scope, 0, 3) . $hash . '"';
+        $this->_headers['ETag'] = $this->_etag;
+    }
+
+    /**
+     * @param int $time
+     */
+    protected function _setLastModified($time)
+    {
+        $this->_lmTime = (int)$time;
+        $this->_headers['Last-Modified'] = self::gmtDate($time);
+    }
+
+    /**
+     * Determine validity of client cache and queue 304 header if valid
+     *
+     * @return bool
+     */
+    protected function _isCacheValid()
+    {
+        if (null === $this->_etag) {
+            // lmTime is copied to ETag, so this condition implies that the
+            // server sent neither ETag nor Last-Modified, so the client can't 
+            // possibly has a valid cache.
+            return false;
+        }
+        $isValid = ($this->resourceMatchedEtag() || $this->resourceNotModified());
+        if ($isValid) {
+            $this->_headers['_responseCode'] = 'HTTP/1.0 304 Not Modified';
+        }
+        return $isValid;
+    }
+
+    /**
+     * @return bool
+     */
+    protected function resourceMatchedEtag()
+    {
+        if (!isset($_SERVER['HTTP_IF_NONE_MATCH'])) {
+            return false;
+        }
+        $clientEtagList = get_magic_quotes_gpc()
+            ? stripslashes($_SERVER['HTTP_IF_NONE_MATCH'])
+            : $_SERVER['HTTP_IF_NONE_MATCH'];
+        $clientEtags = explode(',', $clientEtagList);
+        
+        $compareTo = $this->normalizeEtag($this->_etag);
+        foreach ($clientEtags as $clientEtag) {
+            if ($this->normalizeEtag($clientEtag) === $compareTo) {
+                // respond with the client's matched ETag, even if it's not what
+                // we would've sent by default
+                $this->_headers['ETag'] = trim($clientEtag);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * @param string $etag
+     *
+     * @return string
+     */
+    protected function normalizeEtag($etag) {
+        $etag = trim($etag);
+        return $this->_stripEtag
+            ? preg_replace('/;\\w\\w"$/', '"', $etag)
+            : $etag;
+    }
+
+    /**
+     * @return bool
+     */
+    protected function resourceNotModified()
+    {
+        if (!isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {
+            return false;
+        }
+        // strip off IE's extra data (semicolon)
+        list($ifModifiedSince) = explode(';', $_SERVER['HTTP_IF_MODIFIED_SINCE'], 2);
+        if (strtotime($ifModifiedSince) >= $this->_lmTime) {
+            // Apache 2.2's behavior. If there was no ETag match, send the 
+            // non-encoded version of the ETag value.
+            $this->_headers['ETag'] = $this->normalizeEtag($this->_etag);
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/vendor/minify-2.1.7/HTTP/Encoder.php b/vendor/minify-2.1.7/HTTP/Encoder.php
new file mode 100755
index 0000000..22f8c20
--- /dev/null
+++ b/vendor/minify-2.1.7/HTTP/Encoder.php
@@ -0,0 +1,335 @@
+<?php
+/**
+ * Class Ai1ec_HTTP_Encoder  
+ * @package Minify
+ * @subpackage HTTP
+ */
+ 
+/**
+ * Encode and send gzipped/deflated content
+ *
+ * The "Vary: Accept-Encoding" header is sent. If the client allows encoding, 
+ * Content-Encoding and Content-Length are added.
+ *
+ * <code>
+ * // Send a CSS file, compressed if possible
+ * $he = new Ai1ec_HTTP_Encoder(array(
+ *     'content' => file_get_contents($cssFile)
+ *     ,'type' => 'text/css'
+ * ));
+ * $he->encode();
+ * $he->sendAll();
+ * </code>
+ *
+ * <code>
+ * // Shortcut to encoding output
+ * header('Content-Type: text/css'); // needed if not HTML
+ * Ai1ec_HTTP_Encoder::output($css);
+ * </code>
+ * 
+ * <code>
+ * // Just sniff for the accepted encoding
+ * $encoding = Ai1ec_HTTP_Encoder::getAcceptedEncoding();
+ * </code>
+ *
+ * For more control over headers, use getHeaders() and getData() and send your
+ * own output.
+ * 
+ * Note: If you don't need header mgmt, use PHP's native gzencode, gzdeflate, 
+ * and gzcompress functions for gzip, deflate, and compress-encoding
+ * respectively.
+ * 
+ * @package Minify
+ * @subpackage HTTP
+ * @author Stephen Clay <steve@mrclay.org>
+ */
+class Ai1ec_HTTP_Encoder {
+
+    /**
+     * Should the encoder allow HTTP encoding to IE6? 
+     * 
+     * If you have many IE6 users and the bandwidth savings is worth troubling 
+     * some of them, set this to true.
+     * 
+     * By default, encoding is only offered to IE7+. When this is true,
+     * getAcceptedEncoding() will return an encoding for IE6 if its user agent
+     * string contains "SV1". This has been documented in many places as "safe",
+     * but there seem to be remaining, intermittent encoding bugs in patched 
+     * IE6 on the wild web.
+     * 
+     * @var bool
+     */
+    public static $encodeToIe6 = true;
+    
+    
+    /**
+     * Default compression level for zlib operations
+     * 
+     * This level is used if encode() is not given a $compressionLevel
+     * 
+     * @var int
+     */
+    public static $compressionLevel = 6;
+    
+
+    /**
+     * Get an HTTP Encoder object
+     * 
+     * @param array $spec options
+     * 
+     * 'content': (string required) content to be encoded
+     * 
+     * 'type': (string) if set, the Content-Type header will have this value.
+     * 
+     * 'method: (string) only set this if you are forcing a particular encoding
+     * method. If not set, the best method will be chosen by getAcceptedEncoding()
+     * The available methods are 'gzip', 'deflate', 'compress', and '' (no
+     * encoding)
+     */
+    public function __construct($spec) 
+    {
+        $this->_useMbStrlen = (function_exists('mb_strlen')
+                               && (ini_get('mbstring.func_overload') !== '')
+                               && ((int)ini_get('mbstring.func_overload') & 2));
+        $this->_content = $spec['content'];
+        $this->_headers['Content-Length'] = $this->_useMbStrlen
+            ? (string)mb_strlen($this->_content, '8bit')
+            : (string)strlen($this->_content);
+        if (isset($spec['type'])) {
+            $this->_headers['Content-Type'] = $spec['type'];
+        }
+        if (isset($spec['method'])
+            && in_array($spec['method'], array('gzip', 'deflate', 'compress', '')))
+        {
+            $this->_encodeMethod = array($spec['method'], $spec['method']);
+        } else {
+            $this->_encodeMethod = self::getAcceptedEncoding();
+        }
+    }
+
+    /**
+     * Get content in current form
+     * 
+     * Call after encode() for encoded content.
+     * 
+     * @return string
+     */
+    public function getContent() 
+    {
+        return $this->_content;
+    }
+    
+    /**
+     * Get array of output headers to be sent
+     * 
+     * E.g.
+     * <code>
+     * array(
+     *     'Content-Length' => '615'
+     *     ,'Content-Encoding' => 'x-gzip'
+     *     ,'Vary' => 'Accept-Encoding'
+     * )
+     * </code>
+     *
+     * @return array 
+     */
+    public function getHeaders()
+    {
+        return $this->_headers;
+    }
+
+    /**
+     * Send output headers
+     * 
+     * You must call this before headers are sent and it probably cannot be
+     * used in conjunction with zlib output buffering / mod_gzip. Errors are
+     * not handled purposefully.
+     * 
+     * @see getHeaders()
+     */
+    public function sendHeaders()
+    {
+        foreach ($this->_headers as $name => $val) {
+            header($name . ': ' . $val);
+        }
+    }
+    
+    /**
+     * Send output headers and content
+     * 
+     * A shortcut for sendHeaders() and echo getContent()
+     *
+     * You must call this before headers are sent and it probably cannot be
+     * used in conjunction with zlib output buffering / mod_gzip. Errors are
+     * not handled purposefully.
+     */
+    public function sendAll()
+    {
+        $this->sendHeaders();
+        echo $this->_content;
+    }
+
+    /**
+     * Determine the client's best encoding method from the HTTP Accept-Encoding 
+     * header.
+     * 
+     * If no Accept-Encoding header is set, or the browser is IE before v6 SP2,
+     * this will return ('', ''), the "identity" encoding.
+     * 
+     * A syntax-aware scan is done of the Accept-Encoding, so the method must
+     * be non 0. The methods are favored in order of gzip, deflate, then 
+     * compress. Deflate is always smallest and generally faster, but is 
+     * rarely sent by servers, so client support could be buggier.
+     * 
+     * @param bool $allowCompress allow the older compress encoding
+     * 
+     * @param bool $allowDeflate allow the more recent deflate encoding
+     * 
+     * @return array two values, 1st is the actual encoding method, 2nd is the
+     * alias of that method to use in the Content-Encoding header (some browsers
+     * call gzip "x-gzip" etc.)
+     */
+    public static function getAcceptedEncoding($allowCompress = true, $allowDeflate = true)
+    {
+        // @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
+        
+        if (! isset($_SERVER['HTTP_ACCEPT_ENCODING'])
+            || self::isBuggyIe())
+        {
+            return array('', '');
+        }
+        $ae = $_SERVER['HTTP_ACCEPT_ENCODING'];
+        // gzip checks (quick)
+        if (0 === strpos($ae, 'gzip,')             // most browsers
+            || 0 === strpos($ae, 'deflate, gzip,') // opera
+        ) {
+            return array('gzip', 'gzip');
+        }
+        // gzip checks (slow)
+        if (preg_match(
+                '@(?:^|,)\\s*((?:x-)?gzip)\\s*(?:$|,|;\\s*q=(?:0\\.|1))@'
+                ,$ae
+                ,$m)) {
+            return array('gzip', $m[1]);
+        }
+        if ($allowDeflate) {
+            // deflate checks    
+            $aeRev = strrev($ae);
+            if (0 === strpos($aeRev, 'etalfed ,') // ie, webkit
+                || 0 === strpos($aeRev, 'etalfed,') // gecko
+                || 0 === strpos($ae, 'deflate,') // opera
+                // slow parsing
+                || preg_match(
+                    '@(?:^|,)\\s*deflate\\s*(?:$|,|;\\s*q=(?:0\\.|1))@', $ae)) {
+                return array('deflate', 'deflate');
+            }
+        }
+        if ($allowCompress && preg_match(
+                '@(?:^|,)\\s*((?:x-)?compress)\\s*(?:$|,|;\\s*q=(?:0\\.|1))@'
+                ,$ae
+                ,$m)) {
+            return array('compress', $m[1]);
+        }
+        return array('', '');
+    }
+
+    /**
+     * Encode (compress) the content
+     * 
+     * If the encode method is '' (none) or compression level is 0, or the 'zlib'
+     * extension isn't loaded, we return false.
+     * 
+     * Then the appropriate gz_* function is called to compress the content. If
+     * this fails, false is returned.
+     * 
+     * The header "Vary: Accept-Encoding" is added. If encoding is successful, 
+     * the Content-Length header is updated, and Content-Encoding is also added.
+     * 
+     * @param int $compressionLevel given to zlib functions. If not given, the
+     * class default will be used.
+     * 
+     * @return bool success true if the content was actually compressed
+     */
+    public function encode($compressionLevel = null)
+    {
+        if (! self::isBuggyIe()) {
+            $this->_headers['Vary'] = 'Accept-Encoding';
+        }
+        if (null === $compressionLevel) {
+            $compressionLevel = self::$compressionLevel;
+        }
+        if ('' === $this->_encodeMethod[0]
+            || ($compressionLevel == 0)
+            || !extension_loaded('zlib'))
+        {
+            return false;
+        }
+        if ($this->_encodeMethod[0] === 'deflate') {
+            $encoded = gzdeflate($this->_content, $compressionLevel);
+        } elseif ($this->_encodeMethod[0] === 'gzip') {
+            $encoded = gzencode($this->_content, $compressionLevel);
+        } else {
+            $encoded = gzcompress($this->_content, $compressionLevel);
+        }
+        if (false === $encoded) {
+            return false;
+        }
+        $this->_headers['Content-Length'] = $this->_useMbStrlen
+            ? (string)mb_strlen($encoded, '8bit')
+            : (string)strlen($encoded);
+        $this->_headers['Content-Encoding'] = $this->_encodeMethod[1];
+        $this->_content = $encoded;
+        return true;
+    }
+    
+    /**
+     * Encode and send appropriate headers and content
+     *
+     * This is a convenience method for common use of the class
+     * 
+     * @param string $content
+     * 
+     * @param int $compressionLevel given to zlib functions. If not given, the
+     * class default will be used.
+     * 
+     * @return bool success true if the content was actually compressed
+     */
+    public static function output($content, $compressionLevel = null)
+    {
+        if (null === $compressionLevel) {
+            $compressionLevel = self::$compressionLevel;
+        }
+        $he = new Ai1ec_HTTP_Encoder(array('content' => $content));
+        $ret = $he->encode($compressionLevel);
+        $he->sendAll();
+        return $ret;
+    }
+
+    /**
+     * Is the browser an IE version earlier than 6 SP2?
+     *
+     * @return bool
+     */
+    public static function isBuggyIe()
+    {
+        if (empty($_SERVER['HTTP_USER_AGENT'])) {
+            return false;
+        }
+        $ua = $_SERVER['HTTP_USER_AGENT'];
+        // quick escape for non-IEs
+        if (0 !== strpos($ua, 'Mozilla/4.0 (compatible; MSIE ')
+            || false !== strpos($ua, 'Opera')) {
+            return false;
+        }
+        // no regex = faaast
+        $version = (float)substr($ua, 30);
+        return self::$encodeToIe6
+            ? ($version < 6 || ($version == 6 && false === strpos($ua, 'SV1')))
+            : ($version < 7);
+    }
+    
+    protected $_content = '';
+    protected $_headers = array();
+    protected $_encodeMethod = array('', '');
+    protected $_useMbStrlen = false;
+}
diff --git a/vendor/minify-2.1.7/LICENSE.txt b/vendor/minify-2.1.7/LICENSE.txt
new file mode 100755
index 0000000..8f008ad
--- /dev/null
+++ b/vendor/minify-2.1.7/LICENSE.txt
@@ -0,0 +1,26 @@
+Copyright (c) 2008 Ryan Grove <ryan@wonko.com>
+Copyright (c) 2008 Steve Clay <steve@mrclay.org>
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+  * Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+  * Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+  * Neither the name of this project nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/vendor/minify-2.1.7/MIN.txt b/vendor/minify-2.1.7/MIN.txt
new file mode 100755
index 0000000..dbeff0f
--- /dev/null
+++ b/vendor/minify-2.1.7/MIN.txt
@@ -0,0 +1,145 @@
+The files in the /min/ directory represent the default Minify setup designed to ease
+integration with your site. This app will combine and minify your Javascript or
+CSS files and serve them with HTTP compression and cache headers.
+
+
+RECOMMENDED
+
+It's recommended to edit /min/config.php to set $min_cachePath to a writeable
+(by PHP) directory on your system. This will improve performance.
+
+
+GETTING STARTED
+
+The quickest way to get started is to use the Minify URI Builder application
+on your website: http://example.com/min/builder/
+
+
+MINIFYING A SINGLE FILE
+
+Let's say you want to serve this file:
+  http://example.com/wp-content/themes/default/default.css
+
+Here's the "Minify URL" for this file:
+  http://example.com/min/?f=wp-content/themes/default/default.css
+
+In other words, the "f" argument is set to the file path from root without the
+initial "/". As CSS files may contain relative URIs, Minify will automatically
+"fix" these by rewriting them as root relative.
+
+
+COMBINING MULTIPLE FILES IN ONE DOWNLOAD
+
+Separate the paths given to "f" with commas.
+
+Let's say you have CSS files at these URLs:
+  http://example.com/scripts/jquery-1.2.6.js
+  http://example.com/scripts/site.js
+
+You can combine these files through Minify by requesting this URL:
+  http://example.com/min/?f=scripts/jquery-1.2.6.js,scripts/site.js
+
+
+SIMPLIFYING URLS WITH A BASE PATH
+
+If you're combining files that share the same ancestor directory, you can use
+the "b" argument to set the base directory for the "f" argument. Do not include
+the leading or trailing "/" characters.
+
+E.g., the following URLs will serve the exact same content:
+  http://example.com/min/?f=scripts/jquery-1.2.6.js,scripts/site.js,scripts/home.js
+  http://example.com/min/?b=scripts&f=jquery-1.2.6.js,site.js,home.js
+
+
+MINIFY URLS IN HTML
+
+In HTML files, don't forget to replace any "&" characters with "&amp;".
+
+
+SPECIFYING ALLOWED DIRECTORIES
+
+By default, Minify will serve any *.css/*.js files within the DOCUMENT_ROOT. If
+you'd prefer to limit Minify's access to certain directories, set the
+$min_serveOptions['minApp']['allowDirs'] array in config.php. E.g. to limit
+to the /js and /themes/default directories, use:
+
+$min_serveOptions['minApp']['allowDirs'] = array('//js', '//themes/default');
+
+
+GROUPS: NICER URLS
+
+For nicer URLs, edit groupsConfig.php to pre-specify groups of files
+to be combined under preset keys. E.g., here's an example configuration in
+groupsConfig.php:
+
+return array(
+    'js' => array('//js/Class.js', '//js/email.js')
+);
+
+This pre-selects the following files to be combined under the key "js":
+  http://example.com/js/Class.js
+  http://example.com/js/email.js
+
+You can now serve these files with this simple URL:
+  http://example.com/min/?g=js
+
+
+GROUPS: SPECIFYING FILES OUTSIDE THE DOC_ROOT
+
+In the groupsConfig.php array, the "//" in the file paths is a shortcut for
+the DOCUMENT_ROOT, but you can also specify paths from the root of the filesystem
+or relative to the DOC_ROOT:
+
+return array(
+    'js' => array(
+        '//js/file.js'            // file within DOC_ROOT
+        ,'//../file.js'           // file in parent directory of DOC_ROOT
+        ,'C:/Users/Steve/file.js' // file anywhere on filesystem
+    )
+);
+
+
+COMBINE MULTIPLE GROUPS AND FILES IN ONE URL
+
+E.g.: http://example.com/min/?g=js&f=more/scripts.js
+
+Separate group keys with commas:
+  http://example.com/min/?g=baseCss,css1&f=moreStyles.css
+
+
+FAR-FUTURE EXPIRES HEADERS
+
+Minify can send far-future (one year) Expires headers. To enable this you must
+add a number to the querystring (e.g. /min/?g=js&1234 or /min/f=file.js&1234)
+and alter it whenever a source file is changed. If you have a build process you
+can use a build/source control revision number.
+
+You can alternately use the utility function Minify_getUri() to get a "versioned"
+Minify URI for use in your HTML. E.g.:
+
+<?php
+require $_SERVER['DOCUMENT_ROOT'] . '/min/utils.php';
+
+$jsUri = Minify_getUri('js'); // a key in groupsConfig.php
+echo "<script src='{$jsUri}'></script>";
+
+$cssUri = Minify_getUri(array(
+     '//css/styles1.css'
+    ,'//css/styles2.css'
+)); // a list of files
+echo "<link rel=stylesheet href='{$cssUri}'>";
+
+
+DEBUG MODE
+
+In debug mode, instead of compressing files, Minify sends combined files with
+comments prepended to each line to show the line number in the original source
+file. To enable this, set $min_allowDebugFlag to true in config.php and append
+"&debug=1" to your URIs. E.g. /min/?f=script1.js,script2.js&debug=1
+
+Known issue: files with comment-like strings/regexps can cause problems in this mode.
+
+
+QUESTIONS?
+
+http://groups.google.com/group/minify
\ No newline at end of file
diff --git a/vendor/minify-2.1.7/README.txt b/vendor/minify-2.1.7/README.txt
new file mode 100755
index 0000000..54b0690
--- /dev/null
+++ b/vendor/minify-2.1.7/README.txt
@@ -0,0 +1,68 @@
+WELCOME TO MINIFY!
+
+Minify is an HTTP content server. It compresses sources of content 
+(usually files), combines the result and serves it with appropriate 
+HTTP headers. These headers can allow clients to perform conditional 
+GETs (serving content only when clients do not have a valid cache) 
+and tell clients to cache the file for a period of time. 
+More info: http://code.google.com/p/minify/
+
+
+WORDPRESS USER?
+
+These WP plugins integrate Minify into WordPress's style and script hooks to
+get you set up faster.
+  http://wordpress.org/extend/plugins/bwp-minify/
+  http://wordpress.org/extend/plugins/w3-total-cache/
+
+
+INSTALLATION
+
+Place the /min/ directory as a child of your DOCUMENT_ROOT
+directory: i.e. you will have: /home/example/www/min
+
+You can see verify that it is working by visiting these two URLs:
+  http://example.org/min/?f=min/quick-test.js
+  http://example.org/min/?f=min/quick-test.css
+
+If your server supports mod_rewrite, this URL should also work:
+  http://example.org/min/f=min/quick-test.js
+
+CONFIGURATION & USAGE
+
+See the MIN.txt file and http://code.google.com/p/minify/wiki/UserGuide
+
+Minify also comes with a URI Builder application that can help you write URLs
+for use with Minify or configure groups of files. See here for details:
+  http://code.google.com/p/minify/wiki/BuilderApp
+
+The cookbook also provides some more advanced options for minification:
+  http://code.google.com/p/minify/wiki/CookBook
+
+UPGRADING
+
+See UPGRADING.txt for instructions.
+
+
+UNIT TESTING:
+
+1. Place the /min_unit_tests/ directory as a child of your DOCUMENT_ROOT 
+directory: i.e. you will have: /home/example/www/min_unit_tests
+
+2. To run unit tests, access: http://example.org/min_unit_tests/test_all.php
+
+(If you wish, the other test_*.php files can be run to test individual
+components with more verbose output.)
+
+3. Remove /min_unit_tests/ from your DOCUMENT_ROOT when you are done.
+
+
+FILE ENCODINGS
+
+Minify *should* work fine with files encoded in UTF-8 or other 8-bit 
+encodings like ISO 8859/Windows-1252. By default Minify appends
+";charset=utf-8" to the Content-Type headers it sends. 
+
+Leading UTF-8 BOMs are stripped from all sources to prevent 
+duplication in output files, and files are converted to Unix newlines.
+
diff --git a/vendor/minify-2.1.7/UPGRADING.txt b/vendor/minify-2.1.7/UPGRADING.txt
new file mode 100755
index 0000000..647b9cc
--- /dev/null
+++ b/vendor/minify-2.1.7/UPGRADING.txt
@@ -0,0 +1,28 @@
+Minify Upgrade Guide
+
+UPGRADING FROM 2.1.*
+
+1. Rename the following files:
+
+    /min/config.php       --> /min/old_config.php
+    /min/groupsConfig.php --> /min/old_groupsConfig.php
+
+2. Overwrite all files in /min (and /min_unit_tests) with those from this zip.
+
+3. Delete /min/groupsConfig.php
+
+4. Rename /min/old_groupsConfig.php --> /min/groupsConfig.php
+
+5. Merge your settings in old_config.php into config.php.
+
+6. (optional) Delete /min/old_config.php.
+
+
+INSTALLING FRESH
+
+See README.txt for instructions on installing this app for the first time.
+   
+
+SUPPORT
+
+Send a message to http://groups.google.com/group/minify
\ No newline at end of file